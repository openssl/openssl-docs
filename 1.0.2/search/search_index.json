{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"OpenSSL300Design/","title":"OpenSSL 3.0.0 Design (Draft)","text":""},{"location":"OpenSSL300Design/#introduction","title":"Introduction","text":"<p>This document outlines the design of OpenSSL 3.0, the next version of OpenSSL after 1.1.1. It assumes familiarity with the document entitled OpenSSL Strategic Architecture and a working knowledge of OpenSSL 1.1.x.</p> <p>The OpenSSL 3.0 release will have minimal impact to the vast majority of existing applications; almost all well-behaved applications will just need to be recompiled.</p> <p>The majority of the changes in OpenSSL 3.0 are internal architectural restructuring to facilitate a long-term supportable cryptographic framework that enables better separation of algorithm implementations from algorithm APIs. These structural changes also support a more maintainable OpenSSL FIPS Cryptographic Module 3.0.</p> <p>No currently marked deprecated APIs will be removed in OpenSSL 3.0.</p> <p>Many additional low-level functions will be marked as deprecated APIs in OpenSSL 3.0.</p> <p>OpenSSL 3.0 will support an application having TLS connections that are in FIPS mode (using the OpenSSL FIPS Cryptographic Module 3.0) and TLS connections that are in non-FIPS mode simultaneously.</p>"},{"location":"OpenSSL300Design/#terms-used-in-this-document","title":"Terms Used in This Document","text":"<p>The following terms, in alphabetical order,  are used in this document.  A brief (summary) definition is provided.</p> <ul> <li>Algorithm, or sometimes cryptographic algorithm, is a     method to perform a set of operations (such as encryption or     decryption).  Our use of the term is abstract, and usually     represents an algorithm by its name, such as \"aes-128-cbc\".</li> <li>Algorithm implementation, or sometimes just     implementation, is a concrete implementation of an algorithm.     This is mainly represented in code in the form of a set of     functions.</li> <li>CAVS is the Cryptographic Algorithm Validation System. A tool     used to test that a cryptographic implementation conforms to FIPS     standards.</li> <li>CMVP is the Cryptographic Module Validation Program. A process     that validates that cryptographic implementations conform to FIPS     standards.</li> <li>EVP is a family of APIs implemented by libcrypto that enables     applications to perform cryptographic operations. The     implementation of the EVP API uses the Core and Provider     components.</li> <li>The Core is a component in libcrypto that enables applications     to access the algorithm implementations offered by providers.</li> <li>CSP is Critical Security Parameters. This includes any information (e.g.     private keys, passwords, pin numbers etc) that might compromise the security     of a module in the event of their unauthorised disclosure or modification.</li> <li>Explicit Fetch is a method for finding an algorithm     implementation where the application makes an explicit call to     locate the implementation and supplies search criteria.</li> <li>FIPS is the Federal Information Processing Standards. This is     a set of standards defined by the US government. In particular,     FIPS standard 140-2 is applicable to cryptographic software.</li> <li>A FIPS module is an implementation of cryptographic algorithms     that has been validated by the CMVP as conforming to FIPS     standards. In OpenSSL the FIPS module is implemented as a provider     and is available in dynamically loadable module form.</li> <li>Implicit Fetch is a method for finding an algorithm     implementation where the application does not explicitly make a     call to locate the implementation and therefore default search     criteria are used.</li> <li>The Integrity Check is a test that is automatically run when     the FIPS module is loaded. The module checksums itself and     verifies that it hasn't been inadvertently altered.</li> <li>KAS is Key Agreement Scheme. A method by which two communicating parties     can agree a shared key between them.</li> <li>KATs are Known Answer Tests. A set of tests used to perform a     health-check of a FIPS module.</li> <li>libcrypto is a shared library implemented by OpenSSL that     provides applications with access to various cryptography related     capabilities.</li> <li>libssl is a shared library implemented by OpenSSL that     provides applications with the ability to create SSL/TLS     connections either as a client or as a server.</li> <li>A Library Context is an opaque structure that holds library     \"global\" data.</li> <li>Operation is a class of functions to be performed on data,     such as calculating a digest, encrypting, decrypting, etc. An     algorithm may offer one or more operations. For example RSA     provides asymmetric encryption, asymmetric decryption, signing,     verifying, etc</li> <li>Parameters are an implementation agnostic set of key-value     pairs that are used to communicate object data between the Core     and providers. For example they could be used to transfer private     key data.</li> <li>POST refers to the FIPS module Power-Up Self-Tests     (a.k.a. Power-On Self-Tests) that are run at installation time, at     power up (i.e. each time the FIPS module is loaded for an     application) or on demand. These tests include the Integrity Check     and the KATs. If the KATs were run successfully at installation     time then they don't need to be run again at power up, however the     Integrity Check is always performed.</li> <li>Properties are used by providers to describe the features of     their algorithm implementations. They are also used in application     queries to find specific implementations.</li> <li>Provider is a unit that provides one or more algorithm     implementations.</li> <li>Provider module is a provider in dynamically loadable module     form.</li> </ul>"},{"location":"OpenSSL300Design/#architecture","title":"Architecture","text":"<p>The architecture shall have the following features:</p> <ul> <li>Common Services form the building blocks usable by applications     and providers. (e.g. BIO, X509, SECMEM, ASN.1, etc).</li> <li>Providers implement cryptographic algorithms and supporting     services. An algorithm may consist of multiple operations (for     example RSA may have \"encrypt\", \"decrypt\", \"sign\", \"verify\"     etc). Similarly an operation (for example \"sign\") can be     implemented by multiple algorithms such as RSA and ECDSA. A     provider has implementations of the cryptographic primitives for     an algorithm. This release will include the following providers:     a.  Default, which contains the current non-legacy OpenSSL         cryptographic algorithms; this will be built-in (i.e., part of         libcrypto)     b.  Legacy, with implementations of older algorithms (e.g, DES,         MDC2, MD2, Blowfish, CAST)     c.  FIPS, which implements the OpenSSL FIPS Cryptographic Module         3.0; this can be loaded dynamically at runtime.</li> <li>The Core enables access to the operations offered by providers to     applications (and other providers). The Core is the mechanism via     which concrete implementations of operations are located.</li> <li>Protocol implementations. E.g. TLS, DTLS.</li> </ul> <p>This document has many references to the \"EVP API.\" This refers to \"application-level\" operations, such as public-key signing, generating a digest and so on. These functions include <code>EVP_DigestSign</code>, <code>EVP_Digest</code>, <code>EVP_MAC_init</code> and the like. The EVP API also encapsulates the cryptographic objects used to perform those services, such as <code>EVP_PKEY</code>, <code>EVP_CIPHER</code>, <code>EVP_MD</code>, <code>EVP_MAC</code> and so forth. Providers implement the backend functionality for the latter set. Instances of these objects can be bound to providers implicitly or explicitly, depending on the application's needs. This is discussed in more detail in the Provider Design, below.</p> <p>The architecture has the following characteristics:</p> <ul> <li>The EVP layer is a thin wrapper for operations implemented in the     providers. Most calls are passed straight through with little/no     pre- or post-processing.</li> <li>New EVP APIs will be provided to affect how the Core selects (or     finds) the implementation of an operation to be used for any given     EVP call.</li> <li>Information will be passed between libcrypto and the providers in     an implementation agnostic manner.</li> <li>Legacy APIs (e.g. low level cryptographic APIs that do not go via     the EVP layer) will be deprecated. Note that there are legacy APIs     to non legacy algorithms (e.g. AES is not a legacy algorithm but     <code>AES_encrypt</code> is a legacy API).</li> <li>The OpenSSL FIPS Cryptographic Module will be implemented as a     dynamically loaded provider. It will be self-contained (i.e. can     only depend on system runtime libraries and services provided by     the Core).</li> </ul>"},{"location":"OpenSSL300Design/#conceptual-component-view","title":"Conceptual Component View","text":"<p>An overview of the conceptual components in the OpenSSL architecture is as shown in the diagram below. Note that the existence of a component in the diagram does not indicate that the component is a public API or intended for end-user direct access or usage.</p> <p></p> <p>The new components (not present in the previous architecture) shown here are as follows:</p> <ul> <li>Core: This is a fundamental component that connects requests for     an operation (such as encryption) to a provider of that     operation. It provides the ability to locate an implementation of     an algorithm offering specified operations given a set of     properties that the implementation must fulfil. For example,     properties of an encryption algorithm may include at a minimum     \"fips\".</li> <li>Default Provider: Implements a set of default algorithms.</li> <li>FIPS Provider: Implements a set of algorithms that are FIPS     validated and are made available via the Core. This includes the     following supporting services:<ul> <li>POST: Power On Self Test that perform:<ul> <li>KAT: Known Answer Tests</li> <li>Integrity Check</li> </ul> </li> <li>Low Level Implementations: This is the set of components that     actually implement the cryptographic primitives (to meet the     FIPS-mandated self-contained requirement).</li> </ul> </li> <li>Legacy Provider: Provides implementations of older algorithms that     will be exposed via EVP-level APIs.</li> <li>3rd Party Providers: Eventually, third-parties may provide their     own providers. A third-party provider, like any other provider,     implements a set of algorithms that will be accessible to     applications and other providers via the Core.</li> <li>Null Provider: A provider that does nothing. This can be useful     for testing that the correct library context is used.</li> <li>Base Provider: A provider for serialization of keys. The FIPS     provider requires this since it does not contain methods to     load keys. The Base provider is also embedded in the default     provider.</li> </ul>"},{"location":"OpenSSL300Design/#packaging-view","title":"Packaging View","text":"<p>The various components described in the conceptual component view above are physically packaged into:</p> <ul> <li>Executable application(s) for use by users</li> <li>Libraries for use by application(s)</li> <li>Dynamically loadable module(s) for use by the Core.</li> </ul> <p>There will be multiple different packaging options provided with OpenSSL 3.0 (for example a single library libcrypto containing everything except the FIPS Provider, and all providers as separate dynamically loadable modules).</p> <p>Which dynamically loadable modules are registered, used, or available will be able to be configured at runtime.</p> <p>The following figure describes the architecture in terms of physical packages.</p> <p></p> <p>The physical packages new to this release are:</p> <ul> <li> <p>FIPS module. This contains the FIPS Provider that implements a set     of algorithms that are FIPS validated and are available via the     Core. The FIPS Provider is the OpenSSL FIPS Cryptographic Module     3.0.</p> <p>We will not attempt to preclude users from making errors, however we will keep in mind the typical user usage and \"safety\". By default the FIPS provider will be built and installed.</p> <p>We will be able to perform a safety check that detects if the user has modified the source in a FIPS-impactful manner from the release distribution and block building the FIPS provider (on best effort basis) unless an override option is provided.</p> <p>We need to ensure there is a mechanism that enables the end user to determine whether or not their usage of the FIPS module is within the allowed uses under a formal validation.</p> <p>Versioning of the FIPS module will be aligned with the base OpenSSL version  number at the point in time of the validation. Not all OpenSSL releases will need an update to the FIPS module. Therefore when a new FIPS module version is released there may be gaps/jumps in its version number since the previous release.</p> </li> <li> <p>Legacy module. This contains implementations of legacy     algorithms.</p> </li> </ul> <p>It was originally intended that Engines would be built with a provider shim, to allow them to work as usual for cases when an ENGINE pointer is passed to some functions, and as providers when acting as default implementations. Investigations during development, showed that this approach had problematic edge cases. The workaround for now is that there are two code paths currently when EVP calls are made. For engines support, the legacy code is used for 'legacy keys'. The long term plan is to remove engines and the legacy code paths from the code base. Anything written as an engine will need to be rewritten as a provider once engines are removed.</p>"},{"location":"OpenSSL300Design/#core-and-provider-design","title":"Core and Provider Design","text":"<p>The interactions relevant for the Core and provider design are shown in the diagram below. There are four major components: User Application, EVP component, the Core, and a cryptographic Provider. (There may be multiple providers, but that is not relevant here).</p> <p></p> <p>The Core has the following characteristics:</p> <ul> <li>It enables Provider discovery, loading, initialisation and     unloading</li> <li>It enables property-based algorithm queries</li> <li>It implements caching of algorithm queries and implementation     details</li> <li>It operates within a library context that contains data such as     global properties, search cache and dispatch tables.</li> </ul> <p>Providers have the following characteristics:</p> <ul> <li>They provide for access to specific algorithm implementations</li> <li>They associate algorithm implementations with a set of well     defined properties</li> <li>They support parameter passing in an implementation agnostic     manner</li> <li>They can be loaded at any point in time</li> <li>They have a well-known module entry point</li> </ul> <p>The subsections that follow describe the flow an application uses to load a provider, fetch an algorithm implementation, and use it.  In addition, this section describes in detail how algorithms, properties, and parameters are named; how algorithm queries are handled; how algorithms are registered and initialized; and how providers are loaded.</p> <p>In order for an application to be able to use an algorithm it must first \"fetch\" an implementation of it through an algorithm query. Our design objective is to be able to support both explicit (up front) fetching of algorithms and fetching of algorithms on use. By default we expect to do fetching on use (e.g. using <code>EVP_sha256()</code>) so that algorithms are typically fetched during an \"init\" function and bound to a context  object (often named <code>ctx</code>). The explicit fetching option will be implemented via new API calls (e.g. <code>EVP_MD_fetch()</code>).</p> <p>The diagram above shows the explicit fetch approach. The steps are as follows:</p> <ol> <li>Every provider needs to be loaded. This will happen implicitly     (default provider or specified via configuration) and may also be     explicitly requested by the application. Load encompases both     dynamic shared object loading (as needed) and initialisation.<ol> <li>The Core physically loads the module into memory (not required     if default provider is already in memory).</li> <li>The Core calls the provider's entry point for the provider to     initialise itself.<ol> <li>Within the entry point function, the provider initialises     some provider variables using values passed in from the     Core. A provider algorithm implementation query callback     is returned to the Core if initialization succeeds.</li> </ol> </li> </ol> </li> <li>User application requests algorithm by calling a fetch routine.<ol> <li>The search by EVP will combine global properties with     call-specific ones and an algorithm identity to find the     corresponding algorithm implementation, and then create and     return a library handle (e.g. <code>EVP_MD</code>, <code>EVP_CIPHER</code>) to the     application.<ol> <li>The first search of the implementation dispatch table is     made in an internal cache.</li> <li>Should the first search fail, a second search is made by     asking the providers if they have an implementation of     said algorithm with the queried properties. When this     search is done, the resulting data is cached unless the     provider opts out of caching, to be used in the first     search (2.1.1). For example a PKCS#11 provider may opt out     of caching because its algorithms may become available and     unavailable over time.</li> </ol> </li> </ol> </li> <li>The user application then uses the algorithm via EVP APIs (e.g.,     <code>EVP_DigestInit()</code>, <code>EVP_DigestUpdate()</code>, <code>EVP_DigestFinal()</code>,     etc).<ol> <li>The function pointer is invoked and ends up in the provider     for the implementation to perform the requested cryptographic     algorithm.</li> </ol> </li> </ol> <p>For the existing <code>EVP_{algorithm}()</code> functions (e.g. <code>EVP_sha256()</code>, etc) things remain mostly unchanged. In particular, the fetch call is not performed when the <code>EVP_{algorithm}()</code> call returns, but rather it happens implicitly when the context object (e.g. <code>EVP_MD_CTX</code>) is bound within the respective EVP init function. Specifically, step 2.1 happens just before step 3.1. This is known as \"implicit fetch\". Implicit fetch always operates within a default library context (see Library Context below).</p> <p>The method dispatch table is a list of <code>&lt;function-id, function-pointer&gt;</code> pairs \u2014 where the <code>function-id</code>s are publically defined and known by OpenSSL \u2014 put together with a set of properties that can be used to identify each particular implementation.  The Core can take a property query and find the corresponding dispatch table, to be used for applicable operations. This approach allows providers to flexibly pass references to functions that the OpenSSL code can use to create its method structures dynamically.</p> <p>Providers can be loaded at any point in time. Unload at any point in time can be requested.  It is up to the application to ensure that a provider is not currently being used or referenced when it is unloaded. If an attempt is made to use an implementation that is no longer available then an error will be returned.</p> <p>The assumptions an application can currently make about the return from <code>EVP_{algorithm}()</code> and not the new fetch approach are:</p> <ul> <li>const pointer</li> <li>does not need to be freed by the application</li> <li>can safely be compared for checking algorithms are the same     (i.e. specifically comparing pointers to <code>EVP_CIPHER</code>, <code>EVP_MD</code>,     etc)</li> </ul> <p>For a direct use of explicit fetch by the application (rather than using the existing <code>EVP_{algorithm}()</code> functions) the semantics will be different:</p> <ul> <li>non-const pointer</li> <li>needs to be freed by the application</li> <li>pointers can't be safely compared with each other (more on that in     the next paragraph)</li> </ul> <p>There will be new APIs to test the equality of objects that can be used for both explicitly fetched objects and static variant ones These APIs will enable comparison of just the algorithm identity, or of specific algorithm implementations.</p>"},{"location":"OpenSSL300Design/#library-context","title":"Library Context","text":"<p>A library context is an opaque structure that holds library \"global\" data.  OpenSSL will provide such a structure, limited to the global data that the Core has to keep. Future expansion may come to include other existing global data. An application will be able to create and destroy one or more library context(s) within which all subsequent interactions with the Core operate within. If the application does not create and provide its own library context, an internal default one will be used.</p> <pre><code>OPENSSL_CTX *OPENSSL_CTX_new();\nvoid OPENSSL_CTX_free(OPENSSL_CTX *ctx);\n</code></pre> <p>A library context can be passed to the explicit fetch functions.  If <code>NULL</code> is passed to them, the internal default context will be used.</p> <p>More than one library context may be allocated, which implies that any provider module may be initialized more than once.  This permits an application to both be directly linked with libcrypto and loading providers it's interested in, as well as being linked with other libraries that use their own provider modules, independently.</p>"},{"location":"OpenSSL300Design/#naming","title":"Naming","text":"<p>Names are required for algorithms, parameters, and properties. In order to ensure consistency and to enable external Provider implementers to define new names in a consistent way there will be a registry of recommended or used names. It will be maintained separately from the sources.</p> <p>The ability to define aliases for names is required because there are contexts where there are more than one name for the same thing (e.g. EC curves with general names and NIST names for the same thing).</p>"},{"location":"OpenSSL300Design/#properties-for-algorithm-implementation-selection","title":"Properties for Algorithm Implementation Selection","text":"<p>Algorithm implementations (cryptographic and non-cryptographic) will have some properties which will be used to select an implementation from amongst those available. For 3.0, two properties are defined:</p> <ul> <li>is this implementation the default implementation?</li> <li>is this implementation FIPS validated?</li> </ul> <p>The valid input and their meaning are:</p> Property String Meaning in a definition Meaning in a query <code>default</code> This is the default implementation Request the default implementation <code>default=yes</code> This is the default implementation Request the default implementation <code>default=no</code> This is not the default implementation Request a non-default implementation <code>fips</code> This implementation is FIPS validated Request an implementation that is FIPS validated <code>fips=yes</code> This implementation is FIPS validated Request an implementation that is FIPS validated <code>fips=no</code> This implementation is not FIPS validated Request an implementation that is not FIPS validated <p>In all cases property names will be defined as printable ASCII characters and are case insensitive. Property values may be quoted or unquoted. Unquoted values will also always be printable ASCII characters and are case insensitive. Quoted values are tested for equality on a raw byte comparison basis only.</p> <p>Providers will be able to provide their own names or values. The full syntax of property definitions and queries appear in Appendix 1 - Property Syntax.</p> <p>OpenSSL reserves all property names that do not have a period; vendor-provided property names must have a period in the name. It is expected (but not enforced) that the part of the property name before the first period is or relates to the provider's name, to provide some level of conflict avoidance via namespacing.</p> <p>It is likely that additional properties will be defined during the development of this release.  A likely candidate is <code>provider</code> being the name of the provider that is supplying the implementation. Another possibility is <code>engine</code>, meaning that this algorithm is implemented by an OpenSSL 1.1.1 dynamically loaded engine masquerading as a provider.</p> <p>There will be a built in global property query string, which will be \"default\".</p>"},{"location":"OpenSSL300Design/#property-based-algorithm-selection","title":"Property-based Algorithm Selection","text":"<p>Algorithm implementation selection is based on properties.</p> <p>The provider sets properties on the algorithms it offers. The application sets which properties that it wants to see used as a filter during algorithm selection - the query.</p> <p>The desired properties for fetching algorithm implementations can be specified in the following places:</p> <ol> <li>globally, based on configuration files.</li> <li>globally, based on API calls.</li> <li>on a per-object basis for specific objects. E.g. SSL_CTX, SSL.</li> </ol> <p>Properties will be used during algorithm lookup (parameter specification of property values).</p> <p>The sets of properties will be evaluated in a manner that resolves to a single value of a property for each specified property (keyword). The precedence order for keyword evaluation is:</p> <ol> <li>The per-object or directly specified API parameter to fetch</li> <li>The global (default) properties set by API calls</li> <li>The global (default) properties set in configuration files</li> </ol> <p>It is possible that additional property setting methods and evaluation approaches will be defined during the development of this release.</p> <p>By default, OpenSSL 3.0 will load a configuration file (which contains global properties and other settings) automatically without explicit application API calls. This will occur in libcrypto. Note that in OpenSSL 1.1.1 the configuration file is automatically loaded only by the default (automatic) initialisation of libssl.</p>"},{"location":"OpenSSL300Design/#parameter-definition","title":"Parameter Definition","text":"<p>The OpenSSL Core and providers have to exchange data while keeping OpenSSL and provider structures opaque.  All composite values will be passed as an array of items, using the public data structure defined in Appendix 2 - OpenSSL parameter passing. Parameters will be identified using their name (as a string) and each contains its own type and size information.</p> <p>The Core will define an API to pass an array of parameter values or requests for values to a provider or a specific algorithm implementation, and for the latter, an associated object handled by that implementation.  In the cases of the basic machine types, macros could be developed to assist in the construction and extraction of values.</p>"},{"location":"OpenSSL300Design/#operation-and-operation-function-definitions","title":"Operation and Operation Function Definitions","text":"<p>While algorithm and parameter names are essentially controlled and allocated by the providers, the operations and associated functions that are going to be called by libcrypto are essentially controlled and allocated by the Core.</p> <p>For things that are only controlled by the Core, we will use macros to name them, with numbers as values to be used as indexes.  Allocation will be incremental, i.e. for any new operation or function, the next number available will be picked.</p>"},{"location":"OpenSSL300Design/#algorithm-query","title":"Algorithm Query","text":"<p>Each algorithm type (e.g. <code>EVP_MD</code>, <code>EVP_CIPHER</code> etc) with have a \"fetch\" function available (e.g. <code>EVP_MD_fetch()</code>, <code>EVP_CIPHER_fetch()</code>).  Algorithm implementations are identified using their name and properties</p> <p>Each fetch function will use services provided by the Core to find an appropriate implementation as described in the introduction of Core and Provider Design. If an appropriate implementation has been found then it is constructed into a suitable algorithm structure (e.g. <code>EVP_MD</code>, <code>EVP_CIPHER</code>) and returned to the calling application.</p> <p>If multiple implementations are equally good matches for the passed name and properties, one of these will be returned on retrieval but exactly which one is not defined. Furthermore, there is no guarantee that the same match would be returned every time.</p>"},{"location":"OpenSSL300Design/#algorithm-query-caching","title":"Algorithm Query Caching","text":"<p>Algorithm queries will be cached together with their result.</p> <p>The algorithm query cache can be flushed to remove:</p> <ul> <li>All queries returning a specific algorithm implementation</li> <li>All algorithm implementations from a specific provider</li> <li>All algorithm implementations</li> </ul>"},{"location":"OpenSSL300Design/#multilevel-queries","title":"Multilevel Queries","text":"<p>In order to handle both global properties and properties passed to specific calls (such as fetch calls), the global property query settings will be merged with the passed property settings except where there is a conflict, specifically:</p> Global Setting Passed Settings Resulting Query <code>fips=yes</code> <code>fips=yes</code> <code>fips=yes</code> <code>fips=yes</code> <code>fips=no</code> <code>fips=no</code> <code>fips=yes</code> <code>-fips</code> fips is not specified <code>fips=yes</code> fips is not specified <code>fips=yes</code> <code>fips=no</code> <code>fips=yes</code> <code>fips=yes</code> <code>fips=no</code> <code>fips=no</code> <code>fips=no</code> <code>fips=no</code> <code>-fips</code> fips is not specified <code>fips=no</code> fips is not specified <code>fips=no</code> fips is not specified <code>fips=yes</code> <code>fips=yes</code> fips is not specified <code>fips=no</code> <code>fips=no</code> fips is not specified <code>-fips</code> fips stays not specified fips is not specified fips is not specified fips stays not specified"},{"location":"OpenSSL300Design/#provider-module-loading","title":"Provider Module Loading","text":"<p>Providers can either be built-in or dynamically loadable modules.</p> <p>All algorithms are implemented by providers. The OpenSSL Core will initially have no providers loaded, and therefore will have no algorithms available. Providers will need to be discovered and loaded. The algorithm implementations contained within them can then be queried by the Core at a later time, with those queries possibly becoming cached.</p> <p>If no provider has been loaded at the time of the first fetch (implicit as well as explicit), the built in default provider will be automatically loaded.</p> <p>Note that a provider may be written against an older version of the Core API than the current version in libcrypto. For example, it will have to be possible for users to run a different FIPS provider module version than the main OpenSSL version. This means the Core API will have to remain stable and backwards compatible (just like any other public API).</p> <p>All of the command line applications supplied as part of the OpenSSL build will gain a <code>-provider xxx</code> option which loads a provider.  This option can be specified multiple times on the command line (as multiple providers can always be loaded) and it isn't an error if the provider remains unused for any specific operation (e.g. loading a provider that only supplies AES when doing a SHA256 digest).</p>"},{"location":"OpenSSL300Design/#finding-and-loading-dynamic-provider-modules","title":"Finding and loading dynamic provider modules","text":"<p>Dynamic provider modules are <code>.so</code> files on UNIX type operating systems, or a <code>.dll</code> file on Windows type operating systems, or whatever corresponds on other operating systems.  By default, they will be installed in a well known directory.</p> <p>Provider module loading can occur several ways:</p> <ul> <li>On demand, the application will have to specify exactly what     provider modules should be loaded.</li> <li>By configuration, the set of provider modules to load would be     specified in a configuration file.</li> </ul> <p>Some of these methods may be combined.</p> <p>A provider module can be specified by full path, and can therefore be loaded even if it isn't located in the well known directory.</p> <p>After the Core loads a  provider module, it calls the provider module entry point.</p>"},{"location":"OpenSSL300Design/#provider-module-entry-point","title":"Provider Module Entry Point","text":"<p>A provider module must have the following  well known entry point:</p> <pre><code>int OSSL_provider_init(const OSSL_PROVIDER *provider,\n                       const OSSL_DISPATCH *in,\n                       const OSSL_DISPATCH **out\n                       void **provider_ctx);\n</code></pre> <p>If the entry point does not exist in the dynamically loaded object, then it is not a valid module and loading it will fail.</p> <p><code>in</code> is an array of functions that the Core passes to the provider.</p> <p><code>out</code> is an array of provider functions that the provider passes back to the Core.</p> <p><code>provider_ctx</code> (may be shortened to <code>provctx</code> elsewhere in this document) is an object optionally created by the provider for its own use (storing data it needs to keep around safely).  This pointer will be passed back to appropriate provider functions.</p> <p><code>provider</code> is a handle to a provider object belonging to the Core. This can serve as a unique provider identity which may be required in some API calls.  This object will also be populated with diverse data, such as module path, NCONF configuration structure for the provider (see CONF / NCONF values as parameters below for an idea on how that would be implemented), and these diverse values can then be retrieved by the provider using a params getter callback that the Core provides.  The type <code>OSSL_PROVIDER</code> is opaque.</p> <p><code>OSSL_DISPATCH</code> is an open structure that implements the <code>&lt; function-id, function-pointer &gt;</code> tuple mentioned in the introduction of Core and Provider Design:</p> <pre><code>typedef struct ossl_dispatch_st {\n    int function_id;\n    void *(*function)();\n} OSSL_DISPATCH;\n</code></pre> <p>The <code>funcion_id</code> identifies a specific function, and <code>function</code> is the pointer to that function. An array of these is terminated with <code>function_id</code> set to zero.</p> <p>The provider module may or may not be linked against libcrypto. If it is not then it will have no direct access to any libcrypto functions. All essential communication back to libcrypto will be via callback functions provided by the Core. It is important that memory allocated by specific providers is freed by the same providers. Similarly memory allocated in libcrypto should be freed by libcrypto.</p> <p>The API will specify a well known set of callback function numbers. More function numbers can be added in later releases as required without breaking backwards compatibility.</p> <pre><code>/* Functions provided by the Core to the provider */\n#define OSSL_FUNC_ERR_PUT_ERROR                        1\n#define OSSL_FUNC_GET_PARAMS                           2\n/* Functions provided by the provider to the Core */\n#define OSSL_FUNC_PROVIDER_QUERY_OPERATION             3\n#define OSSL_FUNC_PROVIDER_TEARDOWN                    4\n</code></pre> <p>The Core will set up an array of the well known callback functions:</p> <pre><code>static OSSL_DISPATCH core_callbacks[] = {\n    { OSSL_FUNC_ERR_PUT_ERROR, ERR_put_error },\n    /* int ossl_get_params(OSSL_PROVIDER *prov, OSSL_PARAM params[]); */\n    { OSSL_FUNC_GET_PARAMS, ossl_get_params, }\n    /* ... and more */\n};\n</code></pre> <p>This is only a few of the functions that the Core may see fit to pass to a provider.  We may also pass functions to help with logging, testing, instrumentation etc as the need comes up.</p> <p>Once the module is loaded and the well known entry point located, the init entry point can be invoked by the Core:</p> <pre><code>/*\n * NOTE: this code is meant as a simple demonstration of what could happen\n * in the core.  This is an area where the OSSL_PROVIDER type is not opaque.\n */\nOSSL_PROVIDER *provider = OSSL_PROVIDER_new();\nconst OSSL_DISPATCH *provider_callbacks;\n/*\n * The following are diverse parameters that the provider can get the values\n * of with ossl_get_params.\n */\n/* reference to the loaded module, or NULL if built in */\nprovider-&gt;module = dso;\n/* reference to the path of the loaded module */\nprovider-&gt;module_path = dso_path;\n/* reference to the NCONF structure used for this provider */\nprovider-&gt;conf_module = conf_module;\n\nif (!OSSL_provider_init(provider, core_callbacks, &amp;provider_callbacks))\n    goto err;\n\n/* populate |provider| with functions passed by the provider */\nwhile (provider_callbacks-&gt;func_num &gt; 0) {\n    switch (provider_callbacks-&gt;func_num) {\n    case OSSL_FUNC_PROVIDER_QUERY_OPERATION:\n        provider-&gt;query_operation = provider_callbacks-&gt;func;\n        break;\n    case OSSL_FUNC_PROVIDER_TEARDOWN:\n        provider-&gt;teardown = provider_callbacks-&gt;func;\n        break;\n    }\n    provider_callbacks++;\n}\n</code></pre> <p>The <code>OSSL_provider_init</code> entry point does not register any algorithms that will be needed, but it will return at least these two callbacks to enable this process:</p> <ol> <li><code>OSSL_FUNC_QUERY_OPERATION</code>, which is used to find out what     implementations of an operation are available.  This must return     an array of <code>OSSL_ALGORITHM</code> (see further down), which maps     algorithm names and property definition strings to implementation     dispatch tables.  This function must also be able to indicate if     the resulting array may be cached by the Core or not. This is     explained in further detail below.</li> <li><code>OSSL_FUNC_TEARDOWN</code>, which is used when the provider is unloaded.</li> </ol> <p>The provider register callback can only be run after the <code>OSSL_provider_init()</code> call succeeds.</p>"},{"location":"OpenSSL300Design/#provider-initialisation-and-algorithm-registration","title":"Provider Initialisation and Algorithm Registration","text":"<p>An algorithm offers a set of operations (capabilities, features, etc). The operations are invoked via functions. For example, the RSA algorithm offers signing and encryption (two operations) which are invoked via the init, update, final functions for signing and init, update, _final _ functions for encryption. The set of functions is determined by the implementation of the upper-level EVP code.</p> <p>Operations are identified by a unique number. For example:</p> <pre><code>#define OSSL_OP_DIGEST                     1\n#define OSSL_OP_SYM_ENCRYPT                2\n#define OSSL_OP_SEAL                       3\n#define OSSL_OP_DIGEST_SIGN                4\n#define OSSL_OP_SIGN                       5\n#define OSSL_OP_ASYM_KEYGEN                6\n#define OSSL_OP_ASYM_PARAMGEN              7\n#define OSSL_OP_ASYM_ENCRYPT               8\n#define OSSL_OP_ASYM_SIGN                  9\n#define OSSL_OP_ASYM_DERIVE               10\n</code></pre> <p>For a provider to make an algorithm usable by libcrypto, it must register an operation querying callback, which returns an array of implementation descriptors, given an operation identity:</p> <pre><code>&lt; algorithm name, property definition string, implementation `OSSL_DISPATCH*` &gt;\n</code></pre> <p>So for example, this query callback will return the list of all its digests if the given operation is <code>OSSL_OP_DIGEST</code>.</p> <p>Algorithms are identified by a string.</p> <p>The Core provides a set of services for the provider to use in the form of a function table.</p> <p>A provider will also offer a service for returning information (in the form of parameters as specified in Appendix 2 - Parameter Passing) via a callback provided by the provider, such as:</p> <ul> <li>version number</li> <li>Build strings - as per the current OpenSSL related build     information (only at the provider level)</li> <li>Provider name</li> </ul> <p>An individual operation may require multiple function callbacks to be defined in order to implement the operation. Each function will be identified by a numeric function identity. Each of the identities are unique for the combination of operation and function, i.e. the number assigned to the init function of the digest operation cannot be reused for init functions for other operations, those will have their own unique numbers. For example, for the digest operation, these functions are required:</p> <pre><code>#define OSSL_OP_DIGEST_NEWCTX_FUNC         1\n#define OSSL_OP_DIGEST_INIT_FUNC           2\n#define OSSL_OP_DIGEST_UPDATE_FUNC         3\n#define OSSL_OP_DIGEST_FINAL_FUNC          4\n#define OSSL_OP_DIGEST_FREECTX_FUNC        5\ntypedef void *(*OSSL_OP_digest_newctx_fn)(void *provctx);\ntypedef int (*OSSL_OP_digest_init_fn)(void *ctx);\ntypedef int (*OSSL_OP_digest_update_fn)(void *ctx, void *data, size_t len);\ntypedef int (*OSSL_OP_digest_final_fn)(void *ctx, void *md, size_t mdsize,\n                                       size_t *outlen);\ntypedef void (*OSSL_OP_digest_freectx_fn)(void *ctx);\n</code></pre> <p>An all in one version is also advisable for devices that cannot handle multi-part operations:</p> <pre><code>#define OSSL_OP_DIGEST_FUNC                6\ntypedef int (*OSSL_OP_digest)(void *provctx,\n                              const void *data, size_t len,\n                              unsigned char *md, size_t mdsize,\n                              size_t *outlen);\n</code></pre> <p>A provider then defines arrays containing the set of functions for each algorithm implementation and one array of algorithm descriptors for each operation.  The algorithm descriptor was mentioned higher up, and would be publically defined like this:</p> <pre><code>typedef struct ossl_algorithm_st {\n    const char *name;\n    const char *properties;\n    OSSL_DISPATCH *impl;\n} OSSL_ALGORITHM;\n</code></pre> <p>For example (and it is only an example, providers may arrange these things any way they want, the important thing is what the algorithm querying function such as <code>fips_query_operation</code> below returns) the FIPS module may define arrays like this for the SHA1 algorithm:</p> <pre><code>static OSSL_DISPATCH fips_sha1_callbacks[] = {\n    { OSSL_OP_DIGEST_NEWCTX_FUNC, fips_sha1_newctx },\n    { OSSL_OP_DIGEST_INIT_FUNC, fips_sha1_init },\n    { OSSL_OP_DIGEST_UPDATE_FUNC, fips_sha1_update },\n    { OSSL_OP_DIGEST_FINAL_FUNC, fips_sha1_final },\n    { OSSL_OP_DIGEST_FUNC, fips_sha1_digest },\n    { OSSL_OP_DIGEST_FREECTX_FUNC, fips_sha1_freectx },\n    { 0, NULL }\n};\nstatic const char prop_fips[] = \"fips\";\nstatic const OSSL_ALGORITHM fips_digests[] = {\n    { \"sha1\", prop_fips, fips_sha1_callbacks },\n    { \"SHA-1\", prop_fips, fips_sha1_callbacks }, /* alias for \"sha1\" */\n    { NULL, NULL, NULL }\n};\n</code></pre> <p>The FIPS provider init module entry point function might look like this:</p> <pre><code>static int fips_query_operation(void *provctx, int op_id,\n                                const OSSL_ALGORITHM **map)\n{\n    *map = NULL;\n    switch (op_id) {\n    case OSSL_OP_DIGEST:\n        *map = fips_digests;\n        break;\n    }\n    return *map != NULL;\n}\n\n#define param_set_string(o,s) do {                                  \\\n    (o)-&gt;buffer = (s);                                              \\\n    (o)-&gt;data_type = OSSL_PARAM_UTF8_STRING_PTR;                    \\\n    if ((o)-&gt;result_size != NULL) *(o)-&gt;result_size = sizeof(s);    \\\n} while(0)\nstatic int fips_get_params(void *provctx, OSSL_PARAM *outparams)\n{\n    while (outparams-&gt;key != NULL) {\n        if (strcmp(outparams-&gt;key, \"provider.name\") == 0) {\n            param_set_string(outparams, \"OPENSSL_FIPS\");\n        } else if if (strcmp(outparams-&gt;key, \"provider.build\") == 0) {\n            param_set_string(outparams, OSSL_FIPS_PROV_BUILD_STRING);\n        }\n    }\n    return 1;\n}\n\nOSSL_DISPATCH provider_dispatch[] = {\n    { OSSL_FUNC_PROVIDER_QUERY_OPERATION, fips_query_operation },\n    { OSSL_FUNC_PROVIDER_GET_PARAMS, fips_get_params },\n    { OSSL_FUNC_PROVIDER_STATUS, fips_get_status },\n    { OSSL_FUNC_PROVIDER_TEARDOWN, fips_teardown },\n    { 0, NULL }\n};\nstatic core_put_error_fn *core_put_error = NULL;\nstatic core_get_params_fn *core_get_params = NULL;\n\nint OSSL_provider_init(const OSSL_PROVIDER *provider,\n                       const OSSL_DISPATCH *in,\n                       const OSSL_DISPATCH **out\n                       void **provider_ctx)\n{\n    int ret = 0;\n\n    /*\n     * Start with collecting the functions provided by the core\n     * (we could write it more elegantly, but ...)\n     */\n    while (in-&gt;func_num &gt; 0) {\n        switch (in-&gt;func_num) {\n        case OSSL_FUNC_ERR_PUT_ERROR:\n            core_put_error = in-&gt;func;\n            break;\n        case OSSL_FUNC_GET_PARAMS:\n            core_get_params = in-&gt;func;\n            Break;\n        }\n        in++;\n    }\n\n    /* Get all parameters required for self tests */\n    {\n        /*\n         * All these parameters come from a configuration saying this:\n         *\n         * [provider]\n         * selftest_i = 4\n         * selftest_path = \"foo\"\n         * selftest_bool = true\n         * selftest_name = \"bar\"\n         */\n        OSSL_PARAM selftest_params[] = {\n            { \"provider.selftest_i\", OSSL_PARAM_NUMBER,\n              &amp;selftest_i, sizeof(selftest_i), NULL },\n            { \"provider.selftest_path\", OSSL_PARAM_STRING,\n              &amp;selftest_path, sizeof(selftest_path), &amp;selftest_path_ln },\n            { \"provider.selftest_bool\", OSSL_PARAM_BOOLEAN,\n              &amp;selftest_bool, sizeof(selftest_bool), NULL },\n            { \"provider.selftest_name\", OSSL_PARAM_STRING,\n              &amp;selftest_name, sizeof(selftest_name), &amp;selftest_name_ln },\n            { NULL, 0, NULL, 0, NULL }\n        }\n        core_get_params(provider, selftest_params);\n    }\n\n    /* Perform the FIPS self test - only return params if it succeeds. */\n    if (OSSL_FIPS_self_test()) {\n        *out = provider_dispatch;\n        return 1;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"OpenSSL300Design/#algorithm-selection","title":"Algorithm Selection","text":"<p>Multiple providers may be available at any one time. Existing application code re-compiled for this version should continue to work. At the same time it should be possible with minor code adjustments to be able to find and use algorithms using the new property based algorithm lookup capability.</p> <p>To illustrate how this might work, the code below is an example of how a simple AES-CBC-128 encryption might be done using OpenSSL 1.1.1. All error handling has been stripped out for simplicity.</p> <pre><code>EVP_CIPHER_CTX *ctx;\nEVP_CIPHER *ciph;\n\nctx = EVP_CIPHER_CTX_new();\nciph = EVP_aes_128_cbc();\nEVP_EncryptInit_ex(ctx, ciph, NULL, key, iv);\nEVP_EncryptUpdate(ctx, ciphertext, &amp;clen, plaintext, plen);\nEVP_EncryptFinal_ex(ctx, ciphertext + clen, &amp;clentmp);\nclen += clentmp;\n\nEVP_CIPHER_CTX_free(ctx);\n</code></pre> <p>In OpenSSL 3.0, such code would continue to work and would use algorithms from a provider (assuming nothing else has been configured, it will be the default provider). It could also be rewritten using explicit fetching as follows. Explicit fetching also enables the application to specify a non-default library context if required (<code>osslctx</code> in this example):</p> <pre><code>EVP_CIPHER_CTX *ctx;\nEVP_CIPHER *ciph;\n\nctx = EVP_CIPHER_CTX_new();\nciph = EVP_CIPHER_fetch(osslctx, \"aes-128-cbc\", NULL);                /* &lt;=== */\nEVP_EncryptInit_ex(ctx, ciph, NULL, key, iv);\nEVP_EncryptUpdate(ctx, ciphertext, &amp;clen, plaintext, plen);\nEVP_EncryptFinal_ex(ctx, ciphertext + clen, &amp;clentmp);\nclen += clentmp;\n\nEVP_CIPHER_CTX_free(ctx);\nEVP_CIPHER_free(ciph);                                                /* &lt;=== */\n</code></pre> <p>An application may wish to use algorithms from a different provider.</p> <p>For example, consider the scenario where an application wishes to use some algorithms from the FIPS provider, but still use the default algorithms in certain cases. This could be implemented in different ways, e.g.</p> <ol> <li>Only use FIPS algorithms.</li> <li>Default to using FIPS algorithms. Be able to override it on an \"as     needed\" basis to get access to a non FIPS algorithm.</li> <li>Default to not caring about FIPS algorithms. Be able to override     it on an \"as needed\" basis to get a FIPS algorithm.</li> </ol>"},{"location":"OpenSSL300Design/#only-fips","title":"Only FIPS","text":"<p>Compared to code written for pre-3.0.0 OpenSSL, all you need to do to only get FIPS implementations is something like this:</p> <pre><code>int main(void)\n{\n    EVP_set_default_alg_properties(NULL, \"fips=yes\");                 /* &lt;=== */\n    ...\n}\n</code></pre> <p>Then the above encryption code that uses <code>EVP_aes_128_cbc()</code>would continue to work as before. The <code>EVP_EncryptInit_ex()</code> call would use those default algorithm properties, and then look it up via the Core in order to get a handle to the FIPS implementation. This implementation would then be associated with the <code>EVP_CIPHER_CTX</code> object. If there isn't a suitable algorithm implementation available then the the <code>EVP_Encrypt_init_ex()</code> call will fail.</p> <p>The first parameter to <code>EVP_set_default_alg_properties</code> is the library context, NULL being the default internal one.</p>"},{"location":"OpenSSL300Design/#default-to-fips-but-allow-an-override","title":"Default to FIPS but allow an override","text":"<p>To default to using FIPS algorithms but override it on an as needed basis to non-FIPS algorithms, the application might instead do this, compared to code written for pre-3.0.0 OpenSSL:</p> <pre><code>int main(void)\n{\n    EVP_set_default_alg_properties(osslctx, \"fips=yes\");              /* &lt;=== */\n    ...\n}\n\nEVP_CIPHER_CTX *ctx;\nEVP_CIPHER *ciph;\n\nctx = EVP_CIPHER_CTX_new();\nciph = EVP_CIPHER_fetch(osslctx, \"aes-128-cbc\", \"fips!=yes\");         /* &lt;=== */\nEVP_EncryptInit_ex(ctx, ciph, NULL, key, iv);\nEVP_EncryptUpdate(ctx, ciphertext, &amp;clen, plaintext, plen);\nEVP_EncryptFinal_ex(ctx, ciphertext + clen, &amp;clentmp);\nclen += clentmp;\n\nEVP_CIPHER_CTX_free(ctx);\nEVP_CIPHER_free(ciph);                                                /* &lt;=== */\n</code></pre> <p>Here the <code>EVP_CIPHER_fetch()</code> call would combine properties from:</p> <ol> <li>The default algorithm properties</li> <li>The properties passed in as a parameter (with the passed in     properties taking precedence).</li> </ol> <p>Because the <code>EVP_CIPHER_fetch()</code> call overrides the default \"fips\" property it will look for an implementation of AES-CBC-128 that is not \"fips\".</p> <p>In this example, we see a non-default library context being used. This is only possible with explicitly fetched implementations.</p> <p>(note for the attentive: <code>\"fips!=yes\"</code> could as well be <code>\"fips=no\"</code>, but is provided here as an example of the \"not equal to\" operator)</p>"},{"location":"OpenSSL300Design/#default-to-not-caring-and-allow-override-for-fips","title":"Default to not caring and allow override for FIPS","text":"<p>To default to not using FIPS algorithms but override it on an as needed basis to use FIPS, the application code might look like this, compared to code written for pre-3.0.0 OpenSSL:</p> <pre><code>EVP_CIPHER_CTX *ctx;\nEVP_CIPHER *ciph;\n\nctx = EVP_CIPHER_CTX_new();\nciph = EVP_CIPHER_fetch(osslctx, \"aes-128-cbc\", \"fips=yes\");          /* &lt;=== */\nEVP_EncryptInit_ex(ctx, ciph, NULL, key, iv);\nEVP_EncryptUpdate(ctx, ciphertext, &amp;clen, plaintext, plen);\nEVP_EncryptFinal_ex(ctx, ciphertext + clen, &amp;clentmp);\nclen += clentmp;\n\nEVP_CIPHER_CTX_free(ctx);\nEVP_CIPHER_free(ciph);                                                /* &lt;=== */\n</code></pre> <p>In this version we have not overridden the default algorithm properties in \"main\", and therefore you get the standard out-of-the-box defaults which are to not mandate the use of FIPS. However we've explicitly set the \"fips\" property at the <code>EVP_CIPHER_fetch()</code> level, and so that overrides the default. When <code>EVP_CIPHER_fetch()</code> looks up the algorithm using the Core it will get a reference to the FIPS one (or fail if no such algorithm is available).</p>"},{"location":"OpenSSL300Design/#asymmetric-algorithm-selection","title":"Asymmetric algorithm selection","text":"<p>Note that for symmetric encryption/decryption and for message digests there are existing OpenSSL objects that can be used to represent an algorithm, i.e. <code>EVP_CIPHER</code> and <code>EVP_MD</code>. For asymmetric algorithms there is no equivalent object. The algorithm in use is inferred implicitly from the type of the <code>EVP_PKEY</code>.</p> <p>In order to solve this problem a new asymmetric algorithm object will be introduced. In the example below an ECDH key derivation is performed. We lookup a FIPS ECDH implementation (assuming we know that the given private key is an ECC one, of course) using a new algorithm object, <code>EVP_ASYM</code>:</p> <pre><code>EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(privkey, NULL);\nEVP_ASYM *asym = EVP_ASYM_fetch(osslctx, EVP_PKEY_EC, \"fips=yes\");\nEVP_PKEY_CTX_set_alg(pctx, asym));\nEVP_PKEY_derive_init(pctx);\nEVP_PKEY_derive_set_peer(pctx, pubkey);\nEVP_PKEY_derive(pctx, out, &amp;outlen);\nEVP_PKEY_CTX_free(pctx);\n</code></pre>"},{"location":"OpenSSL300Design/#example-dynamic-views-of-algorithm-selection","title":"Example dynamic views of algorithm selection","text":"<p>The sequence diagram below shows an example of how the SHA256 algorithm might be selected and invoked from the default provider.</p> <p></p> <p>Note that each EVP layer call is implemented by thin wrappers in the EVP layer, which invoke similarly named functions within the provider on an algorithm by algorithm basis. The specific provider functions to be used will be looked up in the Core Dispatcher tables via an explicit <code>EVP_MD_fetch()</code> call that specifies the message digest name as a string and any other relevant properties. The returned \"md\" object contains function pointers to the implementation of the algorithm in the selected provider.</p> <p>The <code>EVP_MD_CTX</code> object is not passed through to the provider since we do not know whether any specific provider module is linked against libcrypto. Instead we simply pass through a black box handle (<code>void *</code> pointer), which the provider will associate with whatever structure it requires. This is allocated during an explicit <code>digestNewCtx()</code> call to the provider at the beginning of the operation, and freed at the end with a <code>digestFreeCtx()</code> call.</p> <p>The next diagram shows a slightly more complex scenario, i.e. an <code>EVP_DigestSign*</code> operation using RSA and SHA256. This diagram is drawn from the perspective of libcrypto with algorithms being provided by the FIPS module. A later section will examine this scenario from the perspective of the FIPS module.</p> <p></p> <p>An <code>EVP_DigestSign*</code> operation is more complicated because it involves two algorithms: a signing algorithm, and a digest algorithm. In general those two algorithms may come from different providers or the same one. In the case of the FIPS module the algorithms must both come from the same FIPS module provider. The operation will fail if an attempt is made to do otherwise.</p> <p>In spite of the added complexity of having two algorithms the same concepts apply as for the simpler <code>EVP_Digest*</code> operation shown in the earlier diagram. There are two contexts produced: an <code>EVP_MD_CTX</code> and an <code>EVP_PKEY_CTX</code>. Neither of these are passed through to the provider. Instead black box (<code>void *</code>) handles are created via explicit \"newCtx\" provider calls, and then those handles are passed through during subsequent \"init\", \"update\" and \"final\" operations.</p> <p>The algorithms are looked up in the Core dispatch tables using explicit <code>EVP_MD_fetch()</code> and <code>EVP_ASYM_fetch()</code> calls in advance.</p>"},{"location":"OpenSSL300Design/#fips-module","title":"FIPS Module","text":"<p>This is a FIPS 140-2 validated cryptographic module. It is a provider that contains FIPS validated/approved cryptographic algorithms only. Non FIPS algorithms will be supplied by the default provider  (not the FIPS module).</p> <p>The module is dynamically loadable - static linking is not supported.</p> <p>The FIPS Module will itself not have a \"FIPS mode\". The OpenSSL that can use the FIPS provider will have a \"mode\" concept that is compatible with the FIPS Module 2.0.0.</p>"},{"location":"OpenSSL300Design/#fips-module-version-numbering","title":"FIPS Module Version Numbering","text":"<p>The version will be FIPS module 3.0</p> <p>Any subsequent revisions will be labelled in a similar manner to previous releases i.e 3.0.x.</p> <p>For change letters or revalidations the version number of the FIPS Module will be updated to match the current version of the OpenSSL library.</p>"},{"location":"OpenSSL300Design/#detection-of-changes-inside-the-fips-boundary","title":"Detection of Changes inside the FIPS Boundary","text":"<p>For the sake of validation, we need to detect if any relevant source has changed.</p> <p>This can be done with a script that tokenizes the C sources the same way a C preprocessor does, but that is also taught to ignore certain parts of the source:</p> <ul> <li>System <code>#include</code> directives.</li> <li>Code that is conditioned away in FIPS mode (as described in     Conditional Code below).</li> </ul> <p>(reminder: a C preprocessor can, but doesn't not have to, collapse all non-newline whitespace and leave a standard single space between every token, and comments are considered to be whitespace for this purpose)</p> <p>The result of the tokenization process can then go through a checksum, which is stored in a file parallel to the source file and ultimately version controlled.</p> <p>The process will be something like this (not exactly, this is a code example to show the overall process):</p> <pre><code>    for f in $(FIPS_SOURCES); do\n        perl ./util/fips-tokenize $f | openssl sha256 -r\n    done | openssl sha256 -hex -out fips.checksum\n</code></pre> <p>There will also be some mechanism that alerts us of changes so we can take appropriate action.  For example:</p> <pre><code>    git diff --quiet fips.checksum || \\\n        (git rev-parse HEAD &gt; fips.commit; scream)\n</code></pre> <p>What <code>scream</code> should actually do is still to be determined.</p> <p>Updating <code>fips.checksum</code> should happen as part of a normal <code>make update</code>, which is the usual method to change and check changes on files that are version controlled.  OpenSSL's CIs already run this to see that nothing was forgotten, and breaks the build if something was changed by this command.  Running <code>make update</code> is also part of the normal OpenSSL release process.</p>"},{"location":"OpenSSL300Design/#how-to-react-to-a-change-of-the-signed-checksum","title":"How to react to a change of the signed checksum","text":"<p>In spite of <code>scream</code>, a changed checksum in our repo isn't very dramatic per se, it simply notifies us that we need to pay some extra attention to the FIPS source.</p> <p>Two possibilities:</p> <ol> <li>When it's soon time for a release and <code>fips.checksum</code> no longer     contains the checksum from the last validated source, send the     FIPS source to the lab and get the update validation process     started.</li> <li>At the same time as a release is made <code>fips.checksum</code> no longer     contains the checksum from the last validated source, send the     FIPS source to the lab (including diff files and a change list)     and get the appropriate update validation process started.</li> </ol> <p>The list of validated checksums will be listed somewhere else (to be specified later)</p>"},{"location":"OpenSSL300Design/#compiling","title":"Compiling","text":"<p>For each FIPS provider source file, we calculate that file's checksum and check it against the collected checksum in <code>fips.checksum</code>, and refuse to compile if there's a mismatch.</p>"},{"location":"OpenSSL300Design/#fips-mode","title":"FIPS Mode","text":"<p>The FIPS module only contains FIPS validated cryptographic algorithms. Any FIPS mode 'switching logic' will be outside the FIPS module boundary - this will be handled by the \"fips\" property.</p> <p>Conditional code related to FIPS mode is discussed in a separate section.</p> <p>The following FIPS API's will continue to be available for application use (for consistency the same names present in 1.1.1 are used):</p> <ul> <li> <p><code>int FIPS_mode_set(int on)</code></p> <p>Ensures that \"fips=yes\" is set (for <code>on != 0</code>) or \"fips\" is unset (for <code>on == 0</code>) in the current global property setting. This will also attempt to fetch the <code>HMAC-SHA256</code> algorithm with the property \"fips=yes\" and ensure that it successfully returns.</p> </li> <li> <p><code>int FIPS_mode(void)</code></p> <p>Returns 1 if the current global property string contains the property \"fips=yes\" (or \"fips\"), 0 otherwise.</p> <p>We could check if there is any provider available that offers a FIPS algorithm currently and handle this a little differently.</p> </li> <li> <p><code>int FIPS_self_test(void)</code></p> <p>If the <code>FIPS_mode()</code> returns true then this runs the KATs.</p> <p>The integrity test will not be covered. That will be a separate function if we decide to provide it.</p> <p>Returns 1 on success; 0 on failure or there being no OpenSSL FIPS provider.</p> </li> </ul> <p>Note: these functions will only operate in the context of the OpenSSL FIPS provider - not in the context of any other FIPS provider. These are legacy, deprecated interfaces. The <code>EVP_set_default_alg_properties()</code> function(s) should be used for non-legacy configuration.</p>"},{"location":"OpenSSL300Design/#roles-and-authentication","title":"Roles and Authentication","text":"<p>There are two implied roles - Cryptographic Officer (CO) and User. Both roles support all the same services. The only difference is that the CO installs the software. The module should not support user authentication (it is not required for level 1). This can all be explained in the security policy without any specific code.</p>"},{"location":"OpenSSL300Design/#finite-state-model-fips-140-2-section-44","title":"Finite State Model (FIPS 140-2 section 4.4)","text":"<p>A state machine needs to be defined.</p> <p>We will require the following:</p> <ul> <li>Self test states - initialisation, running, self test, error,     shutdown, (and potentially post_triggered)</li> <li> <p>Error States - If a self test fails the module should return an     error for that operation. It is permissible to try to clear the     error and repeat the operation.  If failure persists, the module     should enter an error state.  This can either be a hard error     state where all cryptographic operations fail or a reduced     functionality state where the failing components only return error     when used.</p> <p>Failing a self test can be triggered by:</p> <ol> <li>Continuous tests (key pair gen pairwise test (sign/verify) and     random number compare test from entropy source to verify     random number inputs into the DRBG are not the same).</li> <li>DRBG health tests - this can be made to cause an error always     just in the RNG (rather than setting a global error     state)<sup>1</sup>.</li> <li>POST Integrity test failure either at install, startup, or on     demand.</li> <li>POST KAT failure at startup, or on demand.</li> </ol> <p>An internal API will be supplied to set the failure state for the above cases.</p> </li> </ul>"},{"location":"OpenSSL300Design/#state-machine","title":"State Machine","text":"<p>States which are not present in the state machine are shown dotted. The edges into and out of the error state are dashed  to indicate that they are not expected to be traversed.</p> <p></p> <p>The state model consists of these states:</p> <ol> <li>Power Off: the FIPS module is not loaded into an application     and the shared library is not in memory.</li> <li>Power On: the FIPS module has been loaded by an application     and the shared library is in memory.  Default Entry Point     Constructors will be initiated.</li> <li>Initialisation: <code>OSSL_provider_init</code> is called.</li> <li> <p>Integrity Check (POST Integrity): the module checksums itself     and verifies that it hasn't been inadvertently altered.</p> <p>(This is run during the FIPS providers <code>OSSL_provider_init()</code>).</p> </li> <li> <p>Self Test (POST KAT): the FIPS module is performing its POST     during installation or the POST on demand from an API call.</p> </li> <li>Running: the FIPS module is in its normal operating state.     All APIs can be used and continuous testing is in force.</li> <li>Error: the FIPS module has entered an error state.  All     cryptographic APIs will return an error when called.</li> <li>Shutdown: the FIPS module is being terminated and unloaded     from the using application.</li> </ol> <p>The edges between states are:</p> <ol> <li>Power Off to Power On: this transition is performed by the     operating system when loading the shared library into an     application.</li> <li>Power On to Initialisation: this transition occurs when     the shared library constructor is called.</li> <li>Power On to Shutdown: this transition is triggered if the     constructor cannot be called or if it fails.</li> <li>Initialisation to Integrity Check: this transition occurs     when the initialisation code has completed.  The module integrity     checksum is computed and compared to the expected value.</li> <li>Initialisation to Error: this transition is triggered if     the initialisation code encounters an error before the self tests     are initiated.</li> <li>Integrity Check to Running: this transition occurs for all     startup where the integrity checks succeed after initial     installation.</li> <li>Integrity Check to Self Test: this transition occurs     during installation when the integrity checks succeed.</li> <li>Integrity Check to Error: this transition is triggered if     the integrity check fails.</li> <li>Running to Shutdown: this transition occurs when the FIPS     module is being finalised.</li> <li>Running to Error: this transition is triggered if one of      the continuous tests fail.</li> <li>Running to Self Test: this transition is triggered by the      application when it initiates the self tests manually.  The      integrity checks are not rerun.</li> <li>Self Test to Running: this transition occurs when the      self tests pass.</li> <li>Self Test to Error: this transition is triggered if the      self tests fail.</li> <li>Shutdown to Power Off: this transition occurs when the      FIPS module is unloaded from the memory of the application.</li> <li>Error to Shutdown: this transition occurs when the FIPS      module is being finalised.</li> </ol> <p>If possible, we should aim to have algorithms registered only in the running state.  Any transition into the running state should allow registration / caching of cryptographic algorithms and any transition into the error or shutdown states should flush all cached algorithms from libcrypto.  By taking this approach, we obviate the need to check the state in all the cryptographic factory functions.  This avoids special case access for the self tests (when started manually) while denying access to external callers.</p>"},{"location":"OpenSSL300Design/#services","title":"Services","text":"<p>The FIPS module provides the following services.</p> <ul> <li>Show status. This returns 1 if the 'Running' state is active     otherwise it returns 0.</li> <li>Cryptographic services such as HMAC, SHS, Encryption. See     Algorithms.</li> <li>Self Test (POST On Demand) - A public API FIPS_self_test() in     libcrypto will be used to access this method. The method used must     be the same one that is triggered during initialization. The     Security Policy will state that this may only be accessed while no     other cryptographic services are running.</li> <li>Key Zeroization. See CSP/Key Zeroization.</li> </ul> <p>Services are only operational in the running state. Any attempts to access services in any other state will result in an error being returned. If the POST fails then any attempt to access any service should result in an error being returned.</p>"},{"location":"OpenSSL300Design/#self-testing","title":"Self Testing","text":"<p>Self-testing consists of power-on self-tests (POST) and run-time tests (such as ensuring entropy isn't repeated as input to the RNG).</p> <p>The POST consists of a module integrity check (which runs each time a FIPS-using application runs) as well as algorithm KATs (which can be run once at installation time).</p> <p>The POST tests run during the call to the FIPS modules <code>OSSL_provider_init()</code> entry point.</p> <p>In order to implement the Integrity Test and KAT in the proper order, the module needs access to the following data items:</p> <ol> <li>Path to the library;</li> <li>HMAC-SHA256 of the library contents (or path to the file with     that);</li> <li>An indication that the library has been installed and the KAT has     passed; and</li> <li>HMAC-SHA256 of that indicator.</li> </ol> <p>These values will be part of the parameters that can be retrieved through the <code>OSSL_PROVIDER</code> object and associated <code>OSSL_PARAM</code> getter. A \"safer\" get-value function that doesn't expand environment variables, etc. will be used to fetch the values. In addition, functions to access and return the library contents (probably BIO-based by having the Core pass a select number of BIO functions in its dispatch table) will also have to be passed into the module so that it can generate its own digest of the library.</p> <p>A new OpenSSL \"fips\" application will provide install (run the KAT and output data for the config file) and check (see if the values in the config file are valid) capabilities.</p> <p>The module's Default Entry Point (DEP), the \".init\" function in Linux libraries, will set a module variable (probably the state variable). This variable will be checked in the OSSL_provider_init() and, if set (which it always will be), will verify the values in the file. This two-step process meets the FIPS requirement of having the DEP ensure the tests are run, but allows us to implement the tests when the rest of the module is being initialized during normal operation.</p> <p>As part of the build process the integrity checksum of the FIPS module must be saved to a file. This could be done as a script.  It is just a HMAC_SHA256  of the entire FIPS module file with a known fixed key. If the library is signed then the checksum would have to be calculated after the signature is applied.</p> <p>A fixed key of at least 112 bits will be embedded in the FIPS module for all HMAC integrity operation(s), this key will also be made available to the external build script.</p> <p>For testing purposes all active POST tests run even if one or more of them fail.</p>"},{"location":"OpenSSL300Design/#integrity-checksum-location","title":"Integrity Checksum Location","text":"<p>The integrity checksum will be saved into a seperate file during installation. This file will be in the same location as the FIPS module itself by default, but may be configured to be in a different location.</p>"},{"location":"OpenSSL300Design/#known-answer-tests","title":"Known Answer Tests","text":"<p>The purpose of a KAT is to perform a health-check of the cryptographic module to identify catastrophic failures or alterations of the module between power cycles and not that the implementation is correct.</p> <p>There are FIPS 140-2 IG's rules that specify that each supported algorithm (not each mode) need to be tested, and that if an algorithm is tested as a component of another test then it does not need separate tests. Here is the list of algorithms that 'need' to be tested.</p> <ul> <li>Cipher encrypt/decrypt<ul> <li>AES_128_GCM<sup>2</sup></li> <li>TDES_CBC</li> </ul> </li> <li>Digests<ul> <li>SHA1</li> <li>SHA256 is required but tested elsewhere</li> <li>SHA512</li> <li>SHA3-256</li> </ul> </li> <li>Sign/Verify tests<ul> <li>DSA_2048</li> <li>RSA_SHA256 (with PKCS #1 v1.5 padding)</li> <li>ECDSA P256</li> </ul> </li> <li>DRBG Health Tests for any supported DRBG mechanisms<ul> <li>CTR (AES_128_CTR)</li> <li>HASH - SHA256<sup>3</sup></li> <li>HMAC - SHA256</li> </ul> </li> <li>Derived Tests (Compute Z)<ul> <li>ECDSA P256</li> <li>ECDH</li> </ul> </li> <li>KDF's<ul> <li>KBKDF (HKDF for TLS)</li> </ul> </li> </ul> <p>Note: HMAC-SHA-256 is used by the integrity test, so there is no need for a seperate HMAC test.</p>"},{"location":"OpenSSL300Design/#api-access","title":"API access","text":"<p>In order to easily modify and change the self tests that are run - the self tests should be data driven. The POST tests are run before any methods are registered but the method tables can still be used indirectly. Lower level API's will still be required to set up keys (params, public/private)  - the key loading code should be isolated in a separate function.</p> <p>An init method  that sets up any required dependencies for the high level functions will be required i.e. <code>set_cpuid</code> may need to be called before doing primitive calls.</p> <p>API's for different types of self tests should be provided for digests, ciphers, signatures, DRBGs, KDFs, HMACs.</p> <p>The parameter passed into each of these tests is KAT data.</p>"},{"location":"OpenSSL300Design/#security-strength","title":"Security Strength","text":"<p>SP 800-131A rev2 disallows certain algorithms and key lengths after certain dates. Security strengths are associated with these items.</p> <p>Algorithms with at least 112 bits of security strength are allowed.</p> <p>For signature verification, security strengths of at least 80 and below 112 are allowed for legacy purposes.</p> <p>These two values could be defined and enforced in the FIPS module for keys, or it can be handled more simply in the Security Policy Document.</p> <p>They could be defined by public API's that allow setting of these minimum values.</p> <p>A concept of target security strength should also be added, this value would be used during key generation algorithms, which have an input target security strength parameter specified by their standards.</p>"},{"location":"OpenSSL300Design/#sp800-56a-56b","title":"SP800-56A &amp; 56B","text":"<p>These standards contain Key Agreement protocols. In order to test the protocols the following low level primitives would need to be in the cryptographic module.</p> <ul> <li>Compute key methods - These already exist. (e.g <code>DH_compute_key()</code>).</li> <li>Key Generation - (RSA     FIPS 186-4     Keygen is currently missing).</li> <li>Key Validation - (Mostly implemented).</li> </ul>"},{"location":"OpenSSL300Design/#fips-186-4-rsa-key-generation","title":"FIPS 186-4 RSA Key Generation","text":"<ul> <li> <p>Initial Code for RSA key generation has been written     (https://github.com/openssl/openssl/pull/6652)</p> <p>Outstanding work is to plumb this into the FIPS module. The OpenSSL FIPs provider will have the logic that enforces the key size limits. *   A pairwise consistency test (Conditional Self Test) is required for RSA, DSA &amp; ECDSA key pair generation. As the purpose of keys is not known during key generation, FIPS 140-2 IG states that the same pairwise tests can be used for both modes i.e Signatures and Encryption. *   1024 bit keys are not allowed for RSA key generation. *   The Key generation algorithms have the concept of a target_security_strength. i.e- the code in key generation needs the following check for RSA for example</p> <pre><code>if (target_strength &lt; 112\n    || target_strength &gt; 256\n    || BN_security_bits(nbits) &lt; target_strength)\n    return 0;\n</code></pre> </li> </ul>"},{"location":"OpenSSL300Design/#dh-key-generation","title":"DH Key Generation","text":"<ul> <li>DH Key generation - This could possibly be broken up so that it     matches the standard steps. It is currently a fairly complex     monolithic function that is also used for validation.</li> </ul>"},{"location":"OpenSSL300Design/#key-validation","title":"Key Validation","text":"<ul> <li>RSA     SP 800-56B     Key validation - public key, private key and key-pair checks that     conform to the standard have been added to     PR #6652.</li> <li>DH key validation checks need to be checked that they match the     standard.</li> <li>EC key validation matches the standards checks.</li> <li>AES-XTS mode requires a tweak key check.</li> </ul> <p>For KAS DH Params - two types are supported:</p> <ol> <li> <p>Approved Safe Prime groups given by the following:</p> <p>(where g=2, q=(p-1)/2, priv=[1, q-1], pub=[2, p-2])</p> <p>TLS:  (ffdhe2048, ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192)</p> <p>IKE: (modp-2048, modp-3072, modp-4096, modp-6144, modp-8192)</p> <p>Only the above safe primes can be validated - any others should fail.</p> <p>Safe primes can be used for security strengths of at least 112 bits. FIPS specific checks to validate the group may be required.</p> </li> <li> <p>FIPS 186-4     param sets can be used for backwards compatibility with security     strength of 112 bits only. The groups are</p> <p>FB (2048, 224) &amp;</p> <p>FC (2048, 256).</p> <p>This requires the seed and counter to be saved for validation purposes.</p> </li> </ol> <p>If both types need to be supported then different key validation code will be required.</p> <p>The existing <code>DH_Check()</code> will require FIPS specific checks for the approved types.</p> <p>Keygen is the same for both (the security strength and max bitlen of private key are inputs).</p> <p>DSA = 'FFC' in FIPS 186-4. The DSA key generation/key validation could be reworked so that it matches the standard steps better. The key validation would benefit from this and can possibly be reused for the DH case if required.</p>"},{"location":"OpenSSL300Design/#gcm-iv-generation","title":"GCM IV Generation","text":"<p>For the FIPS module AES GCM has requirements related to unique key/IV pairs i.e.</p> <ul> <li>Key/IV pair's must be unique for encryption.</li> <li>The IV's must be generated inside the FIPS boundary.</li> <li>For TLS the counter portion of the IV must be set by the     module. The module must ensure that when the counter is exhausted     an error is returned.</li> <li>For a given key (for any IV length) the total number of     invocations of the authenticated encryption function must be less     than 2^32^.</li> <li>A loss of power to the module should not cause the repetition of IVs.</li> </ul> <p>The Random Construction method for IV generation (from SP 800-38D) will be used (except for TLS which will behave the same way it currently does). The Random Construction consists of a free field (which will be NULL) and a random field which will use a DRBG that can return at least 96 bits of entropy strength. This DRBG needs to be seeded by the module.</p> <p>The existing code needs to be modified so that an IV is generated if it is not set during the init() phase. The do_cipher() method can then be used to generate an iv if required..</p> <pre><code>int aes_gcm_cipher()\n{\n    ....\n    /* old code just returned -1 if iv_set was zero */\n    if (!gctx-&gt;iv_set) {\n        if (ctx-&gt;encrypt) {\n           if (!aes_gcm_iv_generate(gctx, 0))\n               return -1;\n           } else {\n               return -1;\n           }\n        }\n    }\n}\n</code></pre> <p>The generate code would look like the following:</p> <pre><code>#define AES_GCM_IV_GENERATE(gctx, offset)                   \\\n    if (!gctx-&gt;iv_set) {                                    \\\n        int sz = gctx-&gt;ivlen - offset;                      \\\n        if (sz &lt;= 0)                                        \\\n            return -1;                                      \\\n        /* Must be at least 96 bits */                      \\\n        if (gctx-&gt;ivlen &lt; 12)                               \\\n            return -1;                                      \\\n        /* Use DRBG to generate random iv */                \\\n        if (RAND_bytes(gctx-&gt;iv + offset, sz) &lt;= 0)         \\\n            return -1;                                      \\\n        gctx-&gt;iv_set = 1;                                   \\\n    }\n</code></pre> <p>The generated IV can be retrieved via <code>EVP_CIPHER_CTX_iv()</code> so a ctrl id should not be  needed.</p> <p>Ideally in FIPS mode trying to set the GCM IV parameter would result in an error. In practice there may be some applications that still require setting of the IV, so it is recommended  that this is specified as a security policy item.</p> <p>The security policy would also need to state the following: (See FIPS 140-2 IG A.5)</p> <ul> <li>When the power is lost and then restored, a new key for use with     AES GCM encryption shall be established.</li> <li>The total number of invocations using the same key must be less     than 2^32^.</li> <li>Scenario 1: IV gen is in compliance with the TLS protocol.</li> <li>Scenario 2: IV gen using     NIST SP 800-38D     (Section 8.2.2).</li> </ul>"},{"location":"OpenSSL300Design/#cspkey-zeroization","title":"CSP/Key Zeroization","text":"<p>We must set all Critical Security Parameters (CSPs) to zero when they are no longer needed. This might happen at different times dependent on the context:</p> <ul> <li>Temporary copies of CSPs may be stack or heap allocated, and will     be zeroized within the relevant function for the scope within     which they are used.</li> <li>Some CSPs will have a lifetime associated with an OpenSSL object     such as an <code>EVP_PKEY</code>, or an <code>EVP_CIPHER_CTX</code>. In this case the     CSPs will be zeroized at the point that these objects are     freed. In some cases objects may be reused (e.g. an     <code>EVP_CIPHER_CTX</code> can be reused for multiple encryption     operations), in which case any CSPs still present in the object     will be zeroized at the point that it is reinitialized for the new     operation.</li> <li>Some CSPs (e.g. internal DRBG state) may live for the entire time     that the OpenSSL FIPS Module is loaded. In this case the state     will be encapsulated within OpenSSL objects. All OpenSSL Providers     (including the FIPS Module Provider) will have the ability to     register an \"unload\" function which is to be called when OpenSSL     is closed down (or the module is unloaded for any other     reason). The objects containing CSPs will be freed (and hence     zeroized) by this unload function.</li> <li>According to     FIPS 140-2 IG     4.7: Cryptographic keys used by a cryptographic module ONLY to perform     FIPS 140-2     Section 4.9.1 Power-Up Tests are not considered CSPs and therefore     do not need to meet the     FIPS 140-2     Section 4.7.6 zeroization requirements.</li> </ul> <p>The OpenSSL FIPS Module will contain its own copy of the standard <code>OPENSSL_cleanse()</code> function to perform the zeroization. This is implemented using platform specific assembler.</p>"},{"location":"OpenSSL300Design/#drbg","title":"DRBG","text":"<p>The following API's existed in the old FIPS module and may need to be re-added:</p> <ul> <li>FIPS_drbg_health_check: runs the DRBG KAT tests on demand.  We     will need this available.</li> <li>FIPS_drbg_set_check_interval: sets the interval (number of     generate calls) between running the DRBG KATs.  This doesn't seem     like it is necessary, these tests are run at power up but are not     required to be run later, however this call is useful for failure     testing.</li> </ul>"},{"location":"OpenSSL300Design/#derivation-function","title":"Derivation Function","text":"<p>As per #2 in FIPS 140-2 IG 14.5, CTR DRBG will need to support the derivation function unconditionally. With the derivation function disabled, the current code has issues reseeding.  Moreover, without a derivation function, additional justification is required from the lab.</p>"},{"location":"OpenSSL300Design/#test-requirements","title":"Test Requirements","text":"<ul> <li>The <code>uninstantiate()</code> needs to demonstrate that the internal state     has been zeroized.</li> <li>Failure testing requires a function for DRBG's to always produce the same     output.</li> </ul>"},{"location":"OpenSSL300Design/#other-items-to-consider","title":"Other Items to Consider","text":"<p>In addition to entropy, described below, the following items need to be considered:</p> <ul> <li>The entropy expansion in     NIST SP 800-90C     10.1.2 should be considered for implementation.</li> <li>A better DRBG selection mechanism to choose between the available     DRBGs.</li> <li>Support for prediction resistance.  I.e. attempt to collect more     entropy from our sources when requested.</li> <li>We need to figure out what the DRBG layer is going to look like. A     fair portion of the code will need to sit inside the FIPS     module. This code currently accesses EVP functionality which might     not be exposed inside the module. e.g. <code>drbg_ctr_init()</code> resolves     the <code>EVP_CIPHER</code> from a NID, and then sets up an <code>EVP_CIPHER_CTX</code>.</li> </ul>"},{"location":"OpenSSL300Design/#entropy","title":"Entropy","text":"<p>For all platforms, the operating system will provide entropy.  For some platforms, built in hardware random number generators can also be used, although this introduces additional justification needs.</p> <p>For UNIX-like systems, one of the system calls <code>getrandom</code> or <code>getentropy</code> or the random device, <code>/dev/random</code>, will be used as entropy sources.  Preference to be given to the system calls.  Other strong random devices that can be used instead of <code>/dev/random</code> include: <code>/dev/srandom</code> and <code>/dev/hwrng</code>.  Note, <code>/dev/urandom</code>, <code>/dev/prandom</code>, <code>/dev/wrandom</code> and <code>/dev/arandom</code> are not useable for FIPS operations without additional justification.</p> <p>On Windows, <code>BCryptGenRandom</code> or <code>CryptGenRandom</code> will be used as entropy sources.</p> <p>On VMS, various pieces of system status information will be used as entropy sources.  Note, this will require justification and analysis to attest to the quality of the sources.</p> <p>For iOS, SecRandomCopyBytes which produces cryptographically secure random bytes.</p> <p>FIPS only allows one entropy source to be credited so the FIPS module will rely solely on the aforementioned operating system sources. Other sources, e.g. egd, hardware devices and the like, will not be used.</p>"},{"location":"OpenSSL300Design/#work-to-do-to-complete-the-entropy-solution","title":"Work to do to Complete the Entropy Solution","text":"<p>The DRBG health tests need to be added to the random framework so that the seed material being fed into the DRBGs is checked.  The check is for no two sequential blocks of seed material being identical.  The check is made after all entropy sources are coalesced together and if it fails, reseeding the DRBGs fails forever more.  We get to define the block size used: 64 bits.  This is a balance between the probability of accidentally receiving a duplicate block (2^-64^) and grabbing too much entropy from the operating system (since the first block is discarded).  Other obvious block sizes that could be used are 128 and 256 bits.</p> <p>The initial block of data must be zeroed and discarded after it is used.</p>"},{"location":"OpenSSL300Design/#gcm-iv","title":"GCM IV","text":"<p>A recent update to FIPS 140-2 IG A.5 states that justification is required if the module claims to generate a random IV for GCM.  We would need to substantiate that the module can obtain the required 96 bits of entropy from the operating system.  This should not be an insurmountable problem if the blocking calls to the operating system's randomness source are used and at least this amount is used as seed material for the DRBGs.</p>"},{"location":"OpenSSL300Design/#fips-module-boundary","title":"FIPS Module Boundary","text":"<p>Once in a FIPS module provided algorithm, we must remain within the FIPS module for any other cryptographic operations. It would be allowed by the FIPS rules for one FIPS module to use another FIPS module. However, for the purposes of the 3.0 design we are making the simplifying assumption that we will not allow this. For example an <code>EVP_DigestSign*</code> implementation uses both a signing algorithm and digest algorithm. We will not allow one of those algorithms to come from the FIPS module, and one to come from some other provider.</p> <p>All providers are assigned a unique <code>OSSL_PROVIDER</code> object when they are initialised. When the FIPS module is asked to use an algorithm it will verify that the implementation <code>OSSL_PROVIDER</code> object for that algorithm is the same as its own <code>OSSL_PROVIDER</code> object (i.e. the one that was passed to <code>OSSL_provider_init</code>). For example consider the case of an <code>EVP_DigestSign*</code> using RSA and SHA256. Both algorithms will be looked up externally to the FIPS module using the Core. The RSA signing algorithm is the first entry point and the \"init\" call will be passed references to the SHA256 algorithm to be used. The FIPS module implementation will check that the <code>OSSL_PROVIDER</code> object associated that the SHA256 implementation that it has been asked to use is also within the FIPS module boundary. If it is not then the \"init\" operation will fail. This is illustrated in the diagram below, which shows this operation from the perspective of the FIPS module.</p> <p></p> <p>Note that within the FIPS module we are using EVP concepts (EVP_MD_CTX, EVP_PKEY_CTX, etc) in order to implement this. These are copies of the EVP implementation found in libcrypto. The FIPS module is not linked against libcrypto. This is to ensure that the complete operation stays within the boundary of the FIPS module without calling code that is external to it.</p>"},{"location":"OpenSSL300Design/#asn1-code","title":"ASN.1 code","text":"<p>ASN.1 DER (distinguished encoding rules) is used to:</p> <ul> <li>serialize keys and parameters</li> <li>serialize DSA and ECDSA signatures, which consist of two     values, r and s</li> <li>encode the signature digest OBJECT IDENTIFIER (OID) that is placed     in RSA PKCS #1 padding</li> <li>serialize X.509 certificates and CRLs</li> <li>other PDUs, such as PKCS #7/CMS, OCSP, PKCS #12, etc.</li> </ul> <p>The FIPS module will not have a copy of the ASN.1 DER encoder/parser and there will be no requirement for any provider to perform ASN.1 serialization/deserialization for algorithms implemented by OpenSSL.</p> <p>All ASN.1 serialization/deserialization will be performed in libcrypto, with composite-value key, parameter and signature structures crossing the Core/provider boundary as an array of items, using the public data structure defined in Appendix 2 - OpenSSL parameter passing.</p> <p>The encoded digest OIDs used for RSA PKCS #1 padding will either be pre-generated (as was done in the old FIPS module using the SHA_DATA macro) or generated on demand using a simple function that only generates encoded OIDs for the small set of digests supported by PKCS #1 padding. These digest OIDs occur in the \"OID tree\" under a common node. Verifying the padding will include getting the encoded OID for the expected digest and comparing the bytes with what occurs in the padding; no DER parsing/decoding is required.</p>"},{"location":"OpenSSL300Design/#code-maintenance","title":"Code Maintenance","text":""},{"location":"OpenSSL300Design/#source-code-structuretree-clean-up","title":"Source code structure/tree clean-up","text":"<p>Cryptographic implementations (<code>crypto/evp/e_*.c</code> and most of <code>crypto/evp/m_*.c</code>; essentially any code that defines an <code>EVP_CIPHER</code>, <code>EVP_MD</code>, <code>EVP_PKEY_METHOD</code>, <code>EVP_MAC</code>, or <code>EVP_KDF</code>) must move out of the evp directory.  They will all end up being part of one or two providers, so they should end up in a provider specific sub-tree.</p> <p>There will be a new directory <code>providers/</code>, where provider specific code is moved. <code>providers/build.info</code> defines exactly what source is used in what provider module(s).</p>"},{"location":"OpenSSL300Design/#shared-source-code","title":"Shared source code","text":"<p>The FIPS provider module and the default provider will share the same source, under different conditions, such as different include paths or different macros being defined (the latter requires added support in the build system). An example <code>build.info</code> that does this:</p> <pre><code>PROVIDERS=p_fips p_default\n\nSOURCE[p_fips]=foo.c\nINCLUDE[p_fips]=include/fips\n\nSOURCE[p_default]=foo.c\nINCLUDE[p_default]=include/default\n</code></pre> <p>Or, using macros:</p> <pre><code>PROVIDERS=p_fips p_default\n\nSOURCE[p_fips]=foo.c\nDEFINE[p_fips]=FIPS_MODE\n\nSOURCE[p_default]=foo.c\n</code></pre> <p>Note: some keywords aren't yet part of the <code>build.info</code> language.</p>"},{"location":"OpenSSL300Design/#conditional-code","title":"Conditional Code","text":"<p>We need a consistent approach to the compile-time inclusion of FIPS-specific code, and in some cases the exclusion of code that FIPS does not permit.</p> <p>Compile-time controls will be done via <code>#ifdef FIPS_MODE</code>. This ensures that all relevant files are compiled explicitly for non-FIPS or for use within the FIPS module. Since every file will be compiled twice (in the default provider, and in the FIPS module), once with each setting, there is no benefit to using a run-time if statement with constant value. (Further, a runtime setting will not always work (such as when expanding macros like BLOCK_CIPHER_custom, which create a global variable of function pointers.)</p> <p>The build system will support this by building FIPS provider object files with <code>-DFIPS_MODE</code> and default provider object files, which come from the same source, without the command line define.</p> <p>For runtime checks, a test for a TLS connection being in FIPS mode will be required.  This can be done in a generic way by checking the property query string that is associated with a specific <code>SSL_CTX</code> or <code>SSL</code> object, to see if the \"fips\" property was set.</p>"},{"location":"OpenSSL300Design/#fips-testing","title":"FIPS Testing","text":"<p>The following types of tests are required:</p> <ul> <li>CAVS testing for CMVP validated algorithms</li> <li>FIPS Test Suite that can run all FIPS module algorithms.</li> <li>POST failure testing.</li> </ul> <p>Acumen will write applications that use libcrypto to gain access to the FIPS provider via the EVP layer.</p> <p>Any special case code needed to return intermediate values (say for CAVS key generation), to display info (self test states), or change the normal flow of FIPS module code (e.g - self test failure or failing a keygen loop that supplies fixed rand values) will be controlled by embedding callbacks into the FIPS module code.</p> <p>It is recommended that this callback code would be conditionally compiled into the module, since some of the values should not be returned (e.g- intermediate values in keygen are not supposed to be output by the FIPS module).</p> <p>rand_bytes() will be overridden for tests that require fixed rand_bytes to be used.</p>"},{"location":"OpenSSL300Design/#fips-test-callbacks","title":"FIPS Test callbacks","text":"<p>The application can optionally supply a single callback function that can be used to process values received from the FIPS module. (Multiple callbacks could be registered if this is required).</p> <p>The optional application callback would be of the form:</p> <pre><code>static int fips_test_callback(const char *type, void *arg)\n{\n    return 1;\n}\n</code></pre> <p>The return value can be used to control flow in special cases inside the FIPS module code.</p> <p>The type is passed in from the FIPS module hook. Each different hook in the FIPS module should have  a unique type. The type determines what the arg param contains (either a struct (e.g- intermediate values), a name, or int.</p> <p>The callback in the FIPS module will be of the form</p> <pre><code>MY_STRUCT  data;   /* values that need to be returned to the application */\ndata.i = 1;\n.....\nif (FIPS_test_cb != NULL)\n    FIPS_test_cb(FIPS_TEST_CB_RSA_KEYGEN_GET, (void *)&amp;data);\n</code></pre>"},{"location":"OpenSSL300Design/#post-failure-testing-and-logging","title":"POST Failure Testing and Logging.","text":"<p>In order to support the failure of multiple tests all tests will always be run without early exiting (the failure is just flagged).  A failure status will be returned after all the tests have completed.</p> <p>For logging or failure, the args would be:</p> <pre><code>struct {\n    const char *desc;\n    const char *state;\n    const char *fail_reason;\n};\n</code></pre> <p>Where:</p> <ul> <li>type is one of \"post_integrity\", \"post_cipher\", \"post_digest\",     \"post_signature\", \"post_drbg\", ..</li> <li>desc is the identifying name: e.g AES_128_CBC</li> <li>state is one of</li> <li>\"start\"  - indicates the test is starting</li> <li>\"corrupt\" - if this returns 0 then the test will fail</li> <li>\"pass\" - indicates the test passed</li> <li>\"fail\" - indicates the test failed</li> <li>fail_reason - is the specific reason for failure (e.g- unable to     read the integrity module file, or integrity checksum file.)</li> </ul>"},{"location":"OpenSSL300Design/#cavs-testing","title":"CAVS Testing","text":"<p>CAVS testing will be performed by the lab.</p> <p>However each CAVS tests file could also be sampled and added to the unit tests. This would mean converting the file data of a single test into binary data inside a unit test.</p> <p>(DRBG_ctr is an example that does this already).</p> <p>This will ensure the following:</p> <ul> <li>The required interfaces will be available to the CAVS tests (some     CAVS tests require access to internals, that are not normally     needed).</li> <li>That the algorithm works.</li> <li>Coverage.</li> </ul> <p>We could skip doing this if there is good communication with the lab, but there may be some extra callback hooks required in the code if the labs finds missing accessors for internals.</p>"},{"location":"OpenSSL300Design/#legacy","title":"Legacy","text":""},{"location":"OpenSSL300Design/#evp-to-low-level-api-bridges","title":"EVP to low level API bridges","text":"<p>There are places where low level API structures are assigned to an <code>EVP_PKEY</code> object. The impact on the public <code>EVP_PKEY</code> is that it will have to keep a pointer to a possible low level structure and the type of that low level structure must be known internally in <code>libcrypto</code>.  Any time the <code>EVP_PKEY</code> with such a pointer is used for any computation, it must check if the low level structure has changed and convert its data to parameters that can be used with the new providers.</p> <p>The exact mechanism to check if the contents of a low level structure has changed is to be determined.  One possibility would be to have a dirty counter in the low level structure and a copy in the <code>EVP_PKEY</code> structure.  The dirty counter gets incremented any time the low level structure is changed (functions such as <code>RSA_set0_key</code> would have to do the increment), and any time the <code>EVP_PKEY</code> is used for computations, its copy of the counter get checked against the low level dirty counter, and if they differ, the <code>EVP_PKEY</code> provider parameters get modified with data from the low level structure.</p> <p>(yet another idea is to have a callback function placed in the <code>EVP_PKEY</code> by the legacy functions, which does the update of parameters if it detects that low level changes have been made)</p>"},{"location":"OpenSSL300Design/#evp-method-creators","title":"EVP method creators","text":"<p>There is functionality to create diverse EVP method structures in OpenSSL 1.1.x, easily found like this:</p> <pre><code>grep EVP_CIPHER_meth util/libcrypto.num\ngrep EVP_MD_meth util/libcrypto.num\ngrep EVP_PKEY_meth util/libcrypto.num\n</code></pre>"},{"location":"OpenSSL300Design/#associated-types","title":"Associated types","text":"<p>The low level APIs are fairly standalone, so all low level API types will remain unchanged apart from an added dirty flag in some of the types.  Associated <code>EVP_CIPHER</code>, <code>EVP_MD</code>, <code>EVP_PKEY_METHOD</code>, <code>EVP_MAC</code>, or <code>EVP_KDF</code> instances are handled separately through the implementation of dispatch tables in the Legacy provider module (see below).</p>"},{"location":"OpenSSL300Design/#legacy-provider-module","title":"Legacy Provider Module","text":"<p>Some algorithms that are considered \"legacy\" (an example could be IDEA) and that have current <code>EVP_CIPHER</code>, <code>EVP_MD</code>, <code>EVP_PKEY_METHOD</code>, <code>EVP_MAC</code>, or <code>EVP_KDF</code> implementations will move to a Legacy provider module rather than our default provider module.</p> <p>The methods for the following algorithms will become dispatch tables in the Legacy provider module:</p> <ol> <li>Blowfish</li> <li>CAST</li> <li>DES (but not 3DES)</li> <li>DSA</li> <li>IDEA</li> <li>MD2</li> <li>MD4</li> <li>MDC2</li> <li>RC2</li> <li>RC4</li> <li>RC5</li> <li>RIPEMD160</li> <li>SEED</li> <li>Whirlpool</li> </ol> <p>(note: this is not meant to be an exhaustive list, even though fairly complete for the moment)</p>"},{"location":"OpenSSL300Design/#the-engine-api","title":"The ENGINE API","text":"<p>The whole ENGINE API will be deprecated and removed in the major release after this one.  By then, people will have to have learned how to create provider modules instead. In the meantime, it will be transformed into a tool to help implementers to transition from an ENGINE module implementation to a provider module implementation.</p> <p>Because algorithm constructors will be changed to construct dispatch tables, the ENGINE type will change into a collection of dispatch tables, and the ENGINE constructor functionality will change to collect the dispatch tables they get into the given ENGINE.</p> <p>Dispatch tables registered this way will get the added property engine with the ENGINE identity as provider name property.  That will make it possible for <code>ENGINE_by_id</code> and similar functionality to find the correct provider.</p> <p>The ENGINE module entry point <code>bind_engine</code> will be replaced with the provider module entry point, and the macro <code>IMPLEMENT_DYNAMIC_BIND_FN</code> will be changed to construct such an entry point.  This entry point will create a provider style ENGINE structure, call the binding function which will fill it up with dispatch tables using the same method creation functions it has always used, then register all those dispatch tables collected in the ENGINE structure just like any provider module would, using the same method setting functions as before.</p> <p>As with the rest of this release, our goal is source-level compatibility.</p> <p>With OpenSSL 1.1.x and older, it's possible to hook in ENGINE provided methods to be used instead of the functions built into <code>libcrypto</code>, using functions like <code>ENGINE_get_default_RSA</code> and <code>ENGINE_get_RSA</code>. The first of the two needs no modification, while the latter will be changed to create the old-style methods (such as <code>RSA_METHOD</code>) from the corresponding dispatch table attached to the engine.</p>"},{"location":"OpenSSL300Design/#appendix-1-property-syntax","title":"Appendix 1 - Property Syntax","text":"<p>Property definitions and queries have a well defined syntax.  This section presents this in both eBNF and as railroad diagrams.  Okay, almost eBNF but using regular expression extensions in places.</p> <p>Definition</p> <p></p> <pre><code>Definition\n      ::= SingleDefinition ( ',' SingleDefinition )*\n\nSingleDefinition\n      ::= PropertyName ( '=' Value )?\n</code></pre> <p>Query</p> <p></p> <pre><code>Query ::= SingleQuery ( ',' SingleQuery )*\n\nSingleQuery\n      ::= '-'? PropertyName\n        | PropertyName ( '=' | '!=' ) Value )\n</code></pre> <p>Value</p> <p></p> <pre><code>Value ::= NumberLiteral\n        | StringLiteral\n</code></pre> <p>StringLiteral</p> <p></p> <pre><code>StringLiteral\n      ::= QuotedString\n        | UnquotedString\n</code></pre> <p>QuotedString<sup>4</sup></p> <p></p> <pre><code>QuotedString\n      ::= '\"' [^\"]* '\"'\n        | \"'\" [^']* \"'\"\n</code></pre> <p>UnquotedString<sup>5</sup></p> <p></p> <pre><code>UnquotedString\n      ::= [^{space},]+\n</code></pre> <p>NumberLiteral</p> <p></p> <pre><code>NumberLiteral\n      ::= '0' ( [0-7]+ | 'x' [0-9A-Fa-f]+ )\n        | '-'? [1-9] [0-9]+\n</code></pre> <p>PropertyName<sup>6</sup></p> <p></p> <pre><code>PropertyName\n      ::= [A-Z] [A-Z0-9_]* ( '.' [A-Z] [A-Z0-9_]* )*\n</code></pre>"},{"location":"OpenSSL300Design/#appendix-2-parameter-passing","title":"Appendix 2 - Parameter Passing","text":"<p>Core or provider objects are supposed to be opaque to everything outside, and yet, we will need to be able to get parameters from them, or to pass parameters to them in a uniform way.  We therefore need an intermediary non-opaque structure to support this.</p> <p>The types of data passed need to remain simple:</p> <ul> <li>Numbers (integers of arbitrary size)</li> <li>Character strings (assume UTF-8 encoding)</li> <li>Octet strings (byte arrays of arbitrary size)</li> </ul> <p>Any parameter that's passing values to a module will need the following items:</p> <ul> <li>An identifier, to indicate what parameter is being passed</li> <li>The type of the value (from the list above)</li> <li>The size of the value</li> <li>The value itself</li> </ul> <p>Any parameters that are used to request values from a module will need the following items:</p> <ul> <li>An identifier to indicate what is being requested</li> <li>The type of the value (from the list above)</li> <li>The size of the buffer</li> <li>A buffer where the values get filled in</li> <li>The resultant output size, to be filled in by the function we ask     for parameters from</li> </ul> <p>These two structure are similar enough to be expressed as one and the same:</p> <pre><code>typedef struct ossl_param_st {\n    const char *key;\n    unsigned char data_type;    /* declare what kind of content is sent or\n                                   expected */\n    void *buffer;               /* value being passed in\n                                   or out */\n    size_t buffer_size;         /* buffer size */\n    size_t *return_size;        /* OPTIONAL: address to\n                                   content size */\n} OSSL_PARAM;\n</code></pre> <p>Usage examples:</p> <pre><code>    /* passing parameters to a module */\n    unsigned char *rsa_n = /* memory allocation */\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n    size_t rsa_n_size = BN_bn2lebinpad(N, rsa_n, BN_num_bytes(rsa_n));\n#else\n    size_t rsa_n_size = BN_bn2bin(N, rsa_n);\n#endif\n    struct OSSL_PARAM rsa_params[] = {\n        { RSA_N, OSSL_PARAM_INTEGER, rsa_n, rsa_n_size, NULL },\n        { 0, 0, 0, 0, 0 },\n    };\n\n    EVP_set_params(pkey, rsa_params);\n\n    /* requesting parameters from a module */\n    size_t rsa_n_buffer_size = BITS / 2 / 8 + 1;\n    unsigned char *rsa_n_buffer =\n       OPENSSL_malloc(rsa_n_size);\n    size_t rsa_n_size = 0;\n    OSSL_PARAM rsa_params[] = {\n        { RSA_N, OSSL_PARAM_INTEGER, rsa_n_buffer, rsa_n_buffer_size,\n          &amp;rsa_n_size },\n        { 0, 0, 0, 0, 0 },\n    };\n\n    EVP_get_params(pkey, rsa_params);\n\n    /*\n     * Note: we could also have a ctrl functionality:\n     * EVP_ctrl(pkey, EVP_CTRL_SET_PARAMS, rsa_params);\n     * EVP_ctrl(pkey, EVP_CTRL_GET_PARAMS, rsa_params);\n     *\n     * This would allow other controls using the same API.\n     * For added flexibility, the signature could be something like:\n     *\n     * int EVP_ctrl(EVP_CTX *ctx, int cmd, ...);\n     */\n</code></pre>"},{"location":"OpenSSL300Design/#data-types","title":"Data types","text":"<p>This specification supports the following parameter types:</p> <ul> <li><code>INTEGER</code></li> <li><code>UNSIGNED_INTEGER</code><ul> <li>These are arbitrary length and may therefore require an     arbitrarily sized buffer.</li> <li>The number is stored in native form, i.e. MSB first on big     endian systems and LSB first on little endian systems.  This     means that arbitrary native integers can be stored in the     buffer, just make sure that the buffer size is correct and     properly aligned.</li> </ul> </li> <li><code>REAL</code><ul> <li>These store C binary floating point values in their native     format and alignment.</li> </ul> </li> <li><code>UTF8_STRING</code><ul> <li>This type of string is expected to be printable as is.</li> </ul> </li> <li><code>OCTET_STRING</code><ul> <li>When printed, this is expected to become a hexdump.</li> </ul> </li> </ul> <p>We also support pointer variants of the same types (which means that the <code>OSSL_PARAM</code> <code>buffer</code> only has to have space for a <code>void *</code>). This use is fragile unless the pointed at values are constant over time.</p> <p>We have macros to declare the type of content in <code>data_type</code>:</p> <pre><code>#define OSSL_PARAM_INTEGER              1\n#define OSSL_PARAM_UNSIGNED_INTEGER     2\n#define OSSL_PARAM_UTF8_STRING          3\n#define OSSL_PARAM_OCTET_STRING         4\n/*\n * This one is combined with one of the above, i.e. to get a string pointer:\n * OSSL_PARAM_POINTER | OSSL_PARAM_UTF8_STRING\n */\n#define OSSL_PARAM_POINTER           0x80\n</code></pre>"},{"location":"OpenSSL300Design/#implementation-details","title":"Implementation details","text":""},{"location":"OpenSSL300Design/#determining-the-size-of-the-buffer","title":"Determining the size of the buffer","text":"<p>When requesting parameter values, the caller may choose to assign <code>NULL</code> to <code>buffer</code> in one or more parameter structures.  The called getter should answer such a request by filling in the size pointed at by <code>return_size</code> and return, at which point the caller can allocate appropriately sized buffers and make a second call, at which point the getter can fill in the buffer with no problem.</p> <p>If the programmer wants,  <code>return_size</code> could be made to point at <code>buffer_size</code> in the same <code>OSSL_PARAM</code>.</p>"},{"location":"OpenSSL300Design/#uses-beyond-the-immediately-obvious","title":"Uses beyond the immediately obvious","text":""},{"location":"OpenSSL300Design/#conf-nconf-values-as-parameters","title":"CONF / NCONF values as parameters","text":"<p>Configuration values are interesting to providers!  And yet, just passing a CONF pointer between the Core and the provider may not be feasible, even though it's currently a non-opaque structure.</p> <p>Another method could be to make the CONF / NCONF values into parameters, with a bit of inspiration from git config value names.</p> <p>Let's start with imagining a provider configuration along the same lines as the what the current ENGINE configuration module supports:</p> <pre><code>[provider_section]\n# Configure provider named \"foo\"\nfoo = foo_section\n# Configure provider named \"bar\"\nbar = bar_section\n\n[foo_section]\nprovider_id = myfoo\nmodule_path = /usr/lib/openssl/providers/foo.so\nselftests = foo_selftest_section\nalgorithms = RSA, DSA, DH\n\n[foo_selftest_section]\ndoodah = 1\ncookie = 0\n</code></pre> <p>The Core side provider structure for the provider \"foo\" could then answer to these requested parameter keys:</p> <ul> <li><code>\"provider_id\"</code> (value is <code>\"myfoo\"</code>)</li> <li><code>\"module_path\"</code> (value is <code>\"/usr/lib/openssl/providers/foo.so\"</code>)</li> <li><code>\"selftests.doodah\"</code> (value is <code>1</code>)</li> <li><code>\"selftests.cookie\"</code> (value is <code>0</code>)</li> <li><code>\"algorithms\"</code> (value is <code>\"RSA, DSA, DH\"</code>)</li> </ul> <p>Note that the section names themselves never appear in the parameter key, but that the key that lead to the section does instead.  This is suggested because OpenSSL allows arbitrarily named section names.</p>"},{"location":"OpenSSL300Design/#the-tooth-of-time","title":"The tooth of time","text":"<p>The parameter structure defined above isn't something that's been invented on the spot.  It's highly inspired from OpenVMS programming paradigms that have proven stable over time.  The actual inspiring structure is called \"item_list_3\", which is documented here: OpenVMS Programming Concepts Manual, Volume I</p>"},{"location":"OpenSSL300Design/#appendix-3-algorithms","title":"Appendix 3 - Algorithms","text":"<p>The algorithms which are to be included in the FIPS module are:</p> Requirement Standard Notes TDES CBC FIPS 81          Refer also to SP 800-67rev2.         TDES support being decryption only (from 2020) and banned (from 2025).      ECB FIPS 81        Limits to data length imposed. Security Policy statement regarding the       SP 800-67rev1       transition and limitations will be required.      AES CBC SP 800-38A All AES cipher modes supporting 128, 192 and 256 bits. CBC CTS CCM SP 800-38C CFB SP 800-38A CTR SP 800-38A ECB SP 800-38A GCM SP 800-38D GMAC SP 800-38D OFB SP 800-38A XTS SP 800-38E        See FIPS 140-2 I.G.       A.9. Needs key check added. This mode does not support 192 bits. Check added by #7120.      KW SP 800-38F Differences from standard but within it. KWP SP 800-38F Hash SHA-1 FIPS 180-4 SHA-2 FIPS 180-4 224, 256, 384, 512, 512/224, 512/256. SHA-3 FIPS 202 224, 256, 384, 512. HMAC SHA-1 FIPS 198-1 SHA-2 FIPS 198-1 224, 256, 384, 512. SHA-3 FIPS 198-1 CMAC GMAC KMAC DRBG AES CTR SP 800-90A        Issues with SP 800-90C.       All comply with SP 800-90A.      Hash SP 800-90A HMAC SP 800-90A RSA FIPS 186-4        Refer also to SP 800-56B.       PKCS#1.5, PSS, Key pair generation. Modulus size changes.      Key wrap (transport) SP 800-56B OAEP.  Update to SP 800-56B rev-1 standard. DH KAS SP 800-56A Update to SP 800-56A rev-3 standard. KAS KASVS Additional testing to meet ZZonly. CVL/KAS. DSA FIPS 186-4 PQG generation &amp; verification, signature generation &amp; verification, key pair generation. ECDSA FIPS 186-4 Key pair generation, public key generation, signature generation &amp; verification. ECC KAS SP 800-56A        B-233, 283, 409, 571; K-233, 283, 409, 571; P-224, 256, 384, 521.       Update to SP 800-56A rev-3 standard.      KAS KASVS Additional testing to meet ZZonly. CVL/KAS. KDF PBKDF2 SP 800-132 Verify conformance with standards.  See #6674. HKDF SSKDF SSHKDF X9.42 KDF X9.63 KDF KBKDF TLS PRF TLS PRF For TLS 1.2 and 1.3."},{"location":"OpenSSL300Design/#notes","title":"Notes","text":"<ol> <li> <p>The output of the DRBGs are not required to be tested because of FIPS 140-2 IG 9.8.  However, the seed material being fed into the master DRBG still requires the RCT or stuck bit testing.\u00a0\u21a9</p> </li> <li> <p>The draft guidance has changed. The alternatives are: AES_GMAC, AES_128_CCM, AES_256_GCM and AES_256_CCM.  GMAC is arguably the simplest of the three and thus might be preferable.\u00a0\u21a9</p> </li> <li> <p>Using a different digest algorithm for HASH and HMAC DRBGs would obviate the need to test the digest independently.\u00a0\u21a9</p> </li> <li> <p>Quoted strings can contain UTF-8 characters.\u00a0\u21a9</p> </li> <li> <p>Unquoted strings are passed through a lower case conversion and can only contain ASCII characters.\u00a0\u21a9</p> </li> <li> <p>Property names are case insensitive even though only upper case is depicted here.\u00a0\u21a9</p> </li> </ol>"},{"location":"OpenSSLStrategicArchitecture/","title":"OpenSSL Strategic Architecture","text":""},{"location":"OpenSSLStrategicArchitecture/#introduction","title":"Introduction","text":"<p>This document outlines the OpenSSL strategic architecture. It will take multiple releases, starting from 3.0.0, to move the architecture from the current \"as-is\" (1.1.1), to the future \"to-be\" architecture.</p> <p>Numerous changes are anticipated in the to-be architecture. A migration path for handling the eventual transition will be provided. The OpenSSL 3.0.0 release will have minimal impact to the vast majority of existing applications, almost all well-behaved applications will just need to be recompiled.</p> <p>The current functionality provided by the engine interface will be replaced over time via a provider interface. OpenSSL 3.0.0 will continue to support engines. The to-be architecture will not be fully realised until OpenSSL 4.0.0 at the earliest.</p>"},{"location":"OpenSSLStrategicArchitecture/#as-is-architecture","title":"As-is architecture","text":"<p>Currently, OpenSSL is split into four principal components:</p> <ol> <li> <p>libcrypto. This is the core library for providing implementations of     numerous cryptographic primitives. In addition it provides a set of     supporting services which are used by libssl and libcrypto, as well     as implementations of protocols such as CMS and OCSP.</p> </li> <li> <p>Engine. The functionality of libcrypto can be extended through the     Engine API.</p> <p>Typically engines are dynamically loadable modules that are registered with libcrypto and use the available hooks to provide cryptographic algorithm implementations. Usually these are alternative implementations of algorithms already provided by libcrypto (e.g. to enable hardware acceleration of the algorithm), but they may also include algorithms not implemented in default OpenSSL (e.g. the GOST engine implements the GOST algorithm family). Some engines are provided as part of the OpenSSL distribution, and some are provided by external third parties (again, GOST).</p> </li> <li> <p>libssl. This library depends on libcrypto and implements the TLS and     DTLS protocols.</p> </li> <li> <p>Applications. The applications are a set of command line tools that     use the underlying libssl and libcrypto components to provide a set     of cryptographic and other features such as:     a.  Key and parameter generation and inspection     b.  Certificate generation and inspection     c.  SSL/TLS test tools     d.  ASN.1 inspection     e.  Etc</p> </li> </ol> <p>Currently, OpenSSL has the following characteristics:</p> <ol> <li> <p>EVP. The EVP (envelope) API level provides the high-level abstract     interface to cryptographic functionality separate from the concrete     implementation binding. Direct use of concrete cryptographic     algorithm implementations via interfaces other than the EVP layer is     discouraged. The EVP layer also provides composite operations, such     as signing and verifying. Certain composite operations are also     provided as an EVP-level operation (such as HMAC-SHA256). EVP also     allow use of cryptographic algorithms in an algorithm-agnostic     manner (e.g. EVP_DigestSign works for both RSA and ECDSA     algorithms).</p> </li> <li> <p>FIPS140 is not supported. FIPS140 it is only available in     OpenSSL-1.0.2 which predates the as-is architecture and is not API     or ABI compatible.</p> </li> </ol>"},{"location":"OpenSSLStrategicArchitecture/#conceptual-component-view","title":"Conceptual Component View","text":"<p>The existing architecture is a simple 4 level layering with the crypto layer at the bottom. The TLS layer depends on the crypto layer, and the applications depend on both the TLS and crypto layers.</p> <p>Note: the existence of a component in the diagram does not indicate that the component is a public API or intended for end-user direct access or usage.</p> <p></p>"},{"location":"OpenSSLStrategicArchitecture/#packaging-view","title":"Packaging View","text":"<p>The components described above are packaged into libraries (libcrypto and libssl) and associated engine interfaces as well as an \"openssl\" command line executable for running the various applications. This is illustrated in the diagram below.</p> <p></p>"},{"location":"OpenSSLStrategicArchitecture/#to-be-architecture","title":"To-be Architecture","text":"<p>The to-be architecture has the following features:</p> <ul> <li> <p>Core Services form the building blocks usable by applications and     providers. (e.g. BIO, X509, SECMEM, ASN1, etc).</p> </li> <li> <p>Providers implement cryptographic algorithms and supporting     services. A provider has implementations of one or more of the     following:</p> <ul> <li>The cryptographic primitives for an algorithm, e.g. how to     encrypt/decrypt/sign/hash etc.</li> <li>Serialisation for an algorithm, e.g. how to convert a private     key into a PEM file. Serialisation could be to or from formats     that are not currently supported.</li> <li>Store loader back ends. OpenSSL currently has a store loader     that reads keys, parameters and other items from files.     Providers could have a loader to load from another location     (e.g. LDAP directory).</li> </ul> <p>A Provider may be entirely self-contained or it may use services that are provided by different providers or the Core Services. For example, an application may use the cryptographic primitives for an algorithm implemented by a hardware accelerated provider, but use the serialisation services of a different provider in order to export keys into PKCS#12 format.</p> <p>A default provider (which contains the core of the current OpenSSL cryptographic algorithm implementations) will be \"built-in\" but other providers will be able to be dynamically loadable at runtime.</p> <p>Legacy provider module(s) will provide cryptographic implementations for older algorithms (e.g., DES, MDC2, MD2, Blowfish, CAST). The OMC will publish a policy for how and when algorithms are transitioned from the default provider to the legacy provider.</p> <p>A FIPS provider that embodies the OpenSSL FIPS Cryptographic Module will be able to be dynamically loaded at runtime.</p> </li> <li> <p>The Core enables access to the services offered by providers to     applications (and other providers). Providers make methods available     to the Core. The Core is the mechanism via which concrete     implementations of where things such as algorithms are located.</p> <p>The Core will implement a property based look-up feature for finding algorithms, e.g. it might allow you find an algorithm where \"fips=true\", or \"keysize=128, constant_time=true\". The details of this will be determined in later design documents.</p> </li> <li> <p>Protocol implementations. E.g. TLS, DTLS.</p> </li> </ul> <p>The to-be architecture has the following characteristics:</p> <ul> <li> <p>The EVP layer becomes a thin wrapper for services implemented in the     providers. Most calls are passed straight through with little/no     pre- or post-processing.</p> </li> <li> <p>New EVP APIs will be provided to find the implementation of an     algorithm in the Core to be used for any given EVP call.</p> </li> <li> <p>Information will be passed between the core library and the     providers in an implementation agnostic way.</p> </li> <li> <p>Legacy APIs (e.g. low level cryptographic APIs that do not go via     the EVP layer) will be deprecated. Note that there are legacy APIs     to non legacy algorithms (e.g. AES is a non-legacy algorithm but     AES_encrypt is a legacy API).</p> </li> <li> <p>The OpenSSL FIPS Cryptographic Module will be implemented as a     dynamically loaded provider. It will be self-contained (i.e. can     only depend on system runtime libraries and services provided by the     Core).</p> </li> <li> <p>Other interfaces may also be transitioned to use the Core over time     (for example OSSL_STORE might be considered for this).</p> </li> <li> <p>Engine usage will evolve to providers. \"Bye-bye-Engines,     Hello-Providers\".</p> </li> </ul>"},{"location":"OpenSSLStrategicArchitecture/#conceptual-component-view_1","title":"Conceptual Component View","text":"<p>An overview of the conceptual components in the OpenSSL to-be architecture is as shown in the (pink nirvana) diagram below.</p> <p>Note: the existence of a component in the diagram does not indicate that the component is a public API or intended for end-user direct access or usage.</p> <p></p> <p>The components shown here are as follows:</p> <ul> <li> <p>Applications: Command line applications, e.g. ca, ciphers, cms, dgst     etc</p> </li> <li> <p>Protocols: Provides capabilities for communicating between endpoints     according to standard protocols</p> <ul> <li>TLS Protocols: An implementation of all supported TLS/DTLS     protocols and supporting infrastructure such as:<ul> <li>SSL BIO: A BIO for communication using TLS</li> <li>Statem: The TLS state machine</li> <li>Record: The TLS record layer</li> </ul> </li> <li>Other Protocols<ul> <li>CMS: An implementation of the Cryptographic Message Syntax     standard</li> <li>OCSP: An implementation of Online Certificate Status     Protocol</li> <li>TS: An implementation of the Timestamp Protocol</li> </ul> </li> <li>Supporting Services: Components specifically designed to support     the implementation of protocol code<ul> <li>Packet: Internal component for reading protocol messages</li> <li>Wpacket: Internal component for writing protocol messages</li> </ul> </li> </ul> </li> <li> <p>Core: This is a fundamental component that connects requests for a     service (such as encryption) to a provider of that service. It     implements the ability for providers to register their services     along with the properties of those services. It also provides the     ability to locate a service given a set of properties that the     service must fulfil. For example, properties of an encryption     service might include \"aead\", \"aes-gcm\", \"fips\",     \"security-bits=128\", etc.</p> </li> <li> <p>Default Provider: Implements a set of default services that are     registered with the Core.</p> <ul> <li>Supporting Services<ul> <li>Low Level Implementations: This is the set of components     that actually implement the cryptographic primitives.</li> </ul> </li> </ul> </li> <li> <p>FIPS Provider: Implements a set of services that are FIPS validated     and made available to the Core. This includes the following     supporting services:</p> <ul> <li>POST: Power On Self Test</li> <li>KAT: Known Answer Tests</li> <li>Integrity Check</li> <li>Low Level Implementations: This is the set of components that     actually implement the cryptographic primitives (to meet the     FIPS-mandated self-contained requirement).</li> </ul> </li> <li> <p>Legacy Provider: Provides implementations of older algorithms that     will be exposed via EVP-level APIs.</p> </li> <li> <p>Third-Party Provider: Not part of the OpenSSL distribution. Third     Parties may implement their own providers.</p> </li> <li> <p>Common Services: these form the building blocks usable by     applications and providers. (e.g. BIO, X509, SECMEM, ASN1, etc).</p> </li> <li> <p>Legacy APIs. The \"low-level\" APIs. The \"legacy\" here refers to the     API, not the algorithm itself. For example, AES is not a legacy     algorithm but it has a legacy API (e.g. AES_encrypt).</p> </li> </ul>"},{"location":"OpenSSLStrategicArchitecture/#packaging-view_1","title":"Packaging View","text":"<p>The various components described in the conceptual component view above are physically packaged into:</p> <ul> <li> <p>Executable application(s) for use by users</p> </li> <li> <p>Libraries for use by application(s)</p> </li> <li> <p>Dynamically loadable module(s) for use by the Core.</p> </li> </ul> <p></p> <p>The physical packages shown here are:</p> <ul> <li> <p>Openssl executable. The command line application.</p> </li> <li> <p>Libssl. This contains everything directly related to TLS and DTLS.     Its contents will be largely the same as libssl in the as-is     architecture. Note that some supporting services will be moved to     libcrypto.</p> </li> <li> <p>Libcrypto. This library contains the following components:</p> <ul> <li>Implementations of the core services such as: X509, ASN1, EVP,     OSSL_STORE etc</li> <li>The Core</li> <li>Protocols not related to TLS or DTLS</li> <li>Protocol supporting services (e.g. Packet and Wpacket)</li> <li>The default provider containing implementations of all the     default algorithms</li> </ul> </li> <li> <p>Libcrypto-legacy. Provides the legacy \"low-level\" APIs.     Implementations of the algorithms for these APIS may come from any     provider.</p> </li> <li> <p>FIPS module. This contains the FIPS Provider that implements a set     of services that are FIPS validated and are registered with the     Core.</p> </li> <li> <p>Legacy module. This contains the legacy provider.</p> </li> </ul>"},{"location":"man1/CA.pl/","title":"CA.pl","text":""},{"location":"man1/CA.pl/#name","title":"NAME","text":"<p>CA.pl - friendlier interface for OpenSSL certificate programs</p>"},{"location":"man1/CA.pl/#synopsis","title":"SYNOPSIS","text":"<p>CA.pl [-?] [-h] [-help] [-newcert] [-newreq] [-newreq-nodes] [-newca] [-xsign] [-sign] [-signreq] [-signcert] [-verify] [files]</p>"},{"location":"man1/CA.pl/#description","title":"DESCRIPTION","text":"<p>The CA.pl script is a perl script that supplies the relevant command line arguments to the openssl command for some common certificate operations. It is intended to simplify the process of certificate creation and management by the use of some simple options.</p>"},{"location":"man1/CA.pl/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>?, -h, -help</p> <p>prints a usage message.</p> </li> <li> <p>-newcert</p> <p>creates a new self signed certificate. The private key is written to the file \"newkey.pem\" and the request written to the file \"newreq.pem\".</p> </li> <li> <p>-newreq</p> <p>creates a new certificate request. The private key is written to the file \"newkey.pem\" and the request written to the file \"newreq.pem\".</p> </li> <li> <p>-newreq-nodes</p> <p>is like -newreq except that the private key will not be encrypted.</p> </li> <li> <p>-newca</p> <p>creates a new CA hierarchy for use with the ca program (or the -signcert and -xsign options). The user is prompted to enter the filename of the CA certificates (which should also contain the private key) or by hitting ENTER details of the CA will be prompted for. The relevant files and directories are created in a directory called \"demoCA\" in the current directory.</p> </li> <li> <p>-pkcs12</p> <p>create a PKCS#12 file containing the user certificate, private key and CA certificate. It expects the user certificate and private key to be in the file \"newcert.pem\" and the CA certificate to be in the file demoCA/cacert.pem, it creates a file \"newcert.p12\". This command can thus be called after the -sign option. The PKCS#12 file can be imported directly into a browser. If there is an additional argument on the command line it will be used as the \"friendly name\" for the certificate (which is typically displayed in the browser list box), otherwise the name \"My Certificate\" is used.</p> </li> <li> <p>-sign, -signreq, -xsign</p> <p>calls the ca program to sign a certificate request. It expects the request to be in the file \"newreq.pem\". The new certificate is written to the file \"newcert.pem\" except in the case of the -xsign option when it is written to standard output.</p> </li> <li> <p>-signCA</p> <p>this option is the same as the -signreq option except it uses the configuration file section v3_ca and so makes the signed request a valid CA certificate. This is useful when creating intermediate CA from a root CA.</p> </li> <li> <p>-signcert</p> <p>this option is the same as -sign except it expects a self signed certificate to be present in the file \"newreq.pem\".</p> </li> <li> <p>-verify</p> <p>verifies certificates against the CA certificate for \"demoCA\". If no certificates are specified on the command line it tries to verify the file \"newcert.pem\". </p> </li> <li> <p>files</p> <p>one or more optional certificate file names for use with the -verify command.</p> </li> </ul>"},{"location":"man1/CA.pl/#examples","title":"EXAMPLES","text":"<p>Create a CA hierarchy:</p> <pre><code>CA.pl -newca\n</code></pre> <p>Complete certificate creation example: create a CA, create a request, sign the request and finally create a PKCS#12 file containing it.</p> <pre><code>CA.pl -newca\nCA.pl -newreq\nCA.pl -signreq\nCA.pl -pkcs12 \"My Test Certificate\"\n</code></pre>"},{"location":"man1/CA.pl/#dsa-certificates","title":"DSA CERTIFICATES","text":"<p>Although the CA.pl creates RSA CAs and requests it is still possible to use it with DSA certificates and requests using the req(1) command directly. The following example shows the steps that would typically be taken.</p> <p>Create some DSA parameters:</p> <pre><code>openssl dsaparam -out dsap.pem 1024\n</code></pre> <p>Create a DSA CA certificate and private key:</p> <pre><code>openssl req -x509 -newkey dsa:dsap.pem -keyout cacert.pem -out cacert.pem\n</code></pre> <p>Create the CA directories and files:</p> <pre><code>CA.pl -newca\n</code></pre> <p>enter cacert.pem when prompted for the CA file name.</p> <p>Create a DSA certificate request and private key (a different set of parameters can optionally be created first):</p> <pre><code>openssl req -out newreq.pem -newkey dsa:dsap.pem\n</code></pre> <p>Sign the request:</p> <pre><code>CA.pl -signreq\n</code></pre>"},{"location":"man1/CA.pl/#notes","title":"NOTES","text":"<p>Most of the filenames mentioned can be modified by editing the CA.pl script.</p> <p>If the demoCA directory already exists then the -newca command will not overwrite it and will do nothing. This can happen if a previous call using the -newca option terminated abnormally. To get the correct behaviour delete the demoCA directory if it already exists.</p> <p>Under some environments it may not be possible to run the CA.pl script directly (for example Win32) and the default configuration file location may be wrong. In this case the command:</p> <pre><code>perl -S CA.pl\n</code></pre> <p>can be used and the OPENSSL_CONF environment variable changed to point to  the correct path of the configuration file \"openssl.cnf\".</p> <p>The script is intended as a simple front end for the openssl program for use by a beginner. Its behaviour isn't always what is wanted. For more control over the behaviour of the certificate commands call the openssl command directly.</p>"},{"location":"man1/CA.pl/#environment-variables","title":"ENVIRONMENT VARIABLES","text":"<p>The variable OPENSSL_CONF if defined allows an alternative configuration file location to be specified, it should contain the full path to the configuration file, not just its directory.</p>"},{"location":"man1/CA.pl/#see-also","title":"SEE ALSO","text":"<p>x509(1), ca(1), req(1), pkcs12(1), config(5)</p>"},{"location":"man1/asn1parse/","title":"asn1parse","text":""},{"location":"man1/asn1parse/#name","title":"NAME","text":"<p>openssl-asn1parse, asn1parse - ASN.1 parsing tool</p>"},{"location":"man1/asn1parse/#synopsis","title":"SYNOPSIS","text":"<p>openssl asn1parse [-inform PEM|DER] [-in filename] [-out filename] [-noout] [-offset number] [-length number] [-i] [-oid filename] [-dump] [-dlimit num] [-strparse offset] [-genstr string] [-genconf file]</p>"},{"location":"man1/asn1parse/#description","title":"DESCRIPTION","text":"<p>The asn1parse command is a diagnostic utility that can parse ASN.1 structures. It can also be used to extract data from ASN.1 formatted data.</p>"},{"location":"man1/asn1parse/#options","title":"OPTIONS","text":"<ul> <li> <p>-inform DER|PEM</p> <p>the input format. DER is binary format and PEM (the default) is base64 encoded.</p> </li> <li> <p>-in filename</p> <p>the input file, default is standard input</p> </li> <li> <p>-out filename</p> <p>output file to place the DER encoded data into. If this option is not present then no data will be output. This is most useful when combined with the -strparse option.</p> </li> <li> <p>-noout</p> <p>don't output the parsed version of the input file.</p> </li> <li> <p>-offset number</p> <p>starting offset to begin parsing, default is start of file.</p> </li> <li> <p>-length number</p> <p>number of bytes to parse, default is until end of file.</p> </li> <li> <p>-i</p> <p>indents the output according to the \"depth\" of the structures.</p> </li> <li> <p>-oid filename</p> <p>a file containing additional OBJECT IDENTIFIERs (OIDs). The format of this file is described in the NOTES section below.</p> </li> <li> <p>-dump</p> <p>dump unknown data in hex format.</p> </li> <li> <p>-dlimit num</p> <p>like -dump, but only the first num bytes are output.</p> </li> <li> <p>-strparse offset</p> <p>parse the contents octets of the ASN.1 object starting at offset. This option can be used multiple times to \"drill down\" into a nested structure.</p> </li> <li> <p>-genstr string, -genconf file</p> <p>generate encoded data based on string, file or both using ASN1_generate_nconf(3) format. If file only is present then the string is obtained from the default section using the name asn1. The encoded data is passed through the ASN1 parser and printed out as though it came from a file, the contents can thus be examined and written to a file using the out option. </p> </li> </ul>"},{"location":"man1/asn1parse/#output","title":"OUTPUT","text":"<p>The output will typically contain lines like this:</p> <pre><code>0:d=0  hl=4 l= 681 cons: SEQUENCE\n</code></pre> <p>.....</p> <pre><code>229:d=3  hl=3 l= 141 prim: BIT STRING        \n373:d=2  hl=3 l= 162 cons: cont [ 3 ]        \n376:d=3  hl=3 l= 159 cons: SEQUENCE          \n379:d=4  hl=2 l=  29 cons: SEQUENCE          \n381:d=5  hl=2 l=   3 prim: OBJECT            :X509v3 Subject Key Identifier\n386:d=5  hl=2 l=  22 prim: OCTET STRING      \n410:d=4  hl=2 l= 112 cons: SEQUENCE          \n412:d=5  hl=2 l=   3 prim: OBJECT            :X509v3 Authority Key Identifier\n417:d=5  hl=2 l= 105 prim: OCTET STRING      \n524:d=4  hl=2 l=  12 cons: SEQUENCE\n</code></pre> <p>.....</p> <p>This example is part of a self signed certificate. Each line starts with the offset in decimal. d=XX specifies the current depth. The depth is increased within the scope of any SET or SEQUENCE. hl=XX gives the header length (tag and length octets) of the current type. l=XX gives the length of the contents octets.</p> <p>The -i option can be used to make the output more readable.</p> <p>Some knowledge of the ASN.1 structure is needed to interpret the output. </p> <p>In this example the BIT STRING at offset 229 is the certificate public key. The contents octets of this will contain the public key information. This can be examined using the option -strparse 229 to yield:</p> <pre><code>  0:d=0  hl=3 l= 137 cons: SEQUENCE          \n  3:d=1  hl=3 l= 129 prim: INTEGER           :E5D21E1F5C8D208EA7A2166C7FAF9F6BDF2059669C60876DDB70840F1A5AAFA59699FE471F379F1DD6A487E7D5409AB6A88D4A9746E24B91D8CF55DB3521015460C8EDE44EE8A4189F7A7BE77D6CD3A9AF2696F486855CF58BF0EDF2B4068058C7A947F52548DDF7E15E96B385F86422BEA9064A3EE9E1158A56E4A6F47E5897\n135:d=1  hl=2 l=   3 prim: INTEGER           :010001\n</code></pre>"},{"location":"man1/asn1parse/#notes","title":"NOTES","text":"<p>If an OID is not part of OpenSSL's internal table it will be represented in numerical form (for example 1.2.3.4). The file passed to the -oid option  allows additional OIDs to be included. Each line consists of three columns, the first column is the OID in numerical format and should be followed by white space. The second column is the \"short name\" which is a single word followed by white space. The final column is the rest of the line and is the \"long name\". asn1parse displays the long name. Example:</p> <p><code>1.2.3.4    shortName   A long name</code></p>"},{"location":"man1/asn1parse/#examples","title":"EXAMPLES","text":"<p>Parse a file:</p> <pre><code>openssl asn1parse -in file.pem\n</code></pre> <p>Parse a DER file:</p> <pre><code>openssl asn1parse -inform DER -in file.der\n</code></pre> <p>Generate a simple UTF8String:</p> <pre><code>openssl asn1parse -genstr 'UTF8:Hello World'\n</code></pre> <p>Generate and write out a UTF8String, don't print parsed output:</p> <pre><code>openssl asn1parse -genstr 'UTF8:Hello World' -noout -out utf8.der\n</code></pre> <p>Generate using a config file:</p> <pre><code>openssl asn1parse -genconf asn1.cnf -noout -out asn1.der\n</code></pre> <p>Example config file:</p> <pre><code>asn1=SEQUENCE:seq_sect\n\n[seq_sect]\n\nfield1=BOOL:TRUE\nfield2=EXP:0, UTF8:some random string\n</code></pre>"},{"location":"man1/asn1parse/#bugs","title":"BUGS","text":"<p>There should be options to change the format of output lines. The output of some ASN.1 types is not well handled (if at all).</p>"},{"location":"man1/asn1parse/#see-also","title":"SEE ALSO","text":"<p>ASN1_generate_nconf(3)</p>"},{"location":"man1/c_rehash/","title":"c_rehash","text":""},{"location":"man1/c_rehash/#name","title":"NAME","text":"<p>c_rehash - Create symbolic links to files named by the hash values</p>"},{"location":"man1/c_rehash/#synopsis","title":"SYNOPSIS","text":"<p>c_rehash [-old] [-h] [-n] [-v] [ directory...]</p>"},{"location":"man1/c_rehash/#description","title":"DESCRIPTION","text":"<p>c_rehash scans directories and calculates a hash value of each <code>.pem</code>, <code>.crt</code>, <code>.cer</code>, or <code>.crl</code> file in the specified directory list and creates symbolic links for each file, where the name of the link is the hash value. (If the platform does not support symbolic links, a copy is made.) This utility is useful as many programs that use OpenSSL require directories to be set up like this in order to find certificates.</p> <p>If any directories are named on the command line, then those are processed in turn. If not, then the SSL_CERT_DIR environment variable is consulted; this shold be a colon-separated list of directories, like the Unix PATH variable. If that is not set then the default directory (installation-specific but often /usr/local/ssl/certs) is processed.</p> <p>In order for a directory to be processed, the user must have write permissions on that directory, otherwise it will be skipped. The links created are of the form <code>HHHHHHHH.D</code>, where each H is a hexadecimal character and D is a single decimal digit. When processing a directory, c_rehash will first remove all links that have a name in that syntax. If you have links in that format used for other purposes, they will be removed. To skip the removal step, use the -n flag. Hashes for CRL's look similar except the letter r appears after the period, like this: <code>HHHHHHHH.rD</code>.</p> <p>Multiple objects may have the same hash; they will be indicated by incrementing the D value. Duplicates are found by comparing the full SHA-1 fingerprint. A warning will be displayed if a duplicate is found.</p> <p>A warning will also be displayed if there are files that cannot be parsed as either a certificate or a CRL.</p> <p>The program uses the openssl program to compute the hashes and fingerprints. If not found in the user's PATH, then set the OPENSSL environment variable to the full pathname. Any program can be used, it will be invoked as follows for either a certificate or CRL:</p> <pre><code>$OPENSSL x509 -hash -fingerprint -noout -in FILENAME\n$OPENSSL crl -hash -fingerprint -noout -in FILENAME\n</code></pre> <p>where FILENAME is the filename. It must output the hash of the file on the first line, and the fingerprint on the second, optionally prefixed with some text and an equals sign.</p>"},{"location":"man1/c_rehash/#options","title":"OPTIONS","text":"<ul> <li> <p>-old</p> <p>Use old-style hashing (MD5, as opposed to SHA-1) for generating links for releases before 1.0.0.  Note that current versions will not use the old style.</p> </li> <li> <p>-h</p> <p>Display a brief usage message.</p> </li> <li> <p>-n</p> <p>Do not remove existing links. This is needed when keeping new and old-style links in the same directory.</p> </li> <li> <p>-v</p> <p>Print messages about old links removed and new links created. By default, c_rehash only lists each directory as it is processed.</p> </li> </ul>"},{"location":"man1/c_rehash/#environment","title":"ENVIRONMENT","text":"<ul> <li> <p>OPENSSL</p> <p>The path to an executable to use to generate hashes and fingerprints (see above).</p> </li> <li> <p>SSL_CERT_DIR</p> <p>Colon separated list of directories to operate on. Ignored if directories are listed on the command line.</p> </li> </ul>"},{"location":"man1/c_rehash/#see-also","title":"SEE ALSO","text":"<p>openssl(1), crl(1). x509(1).</p>"},{"location":"man1/ca/","title":"ca","text":""},{"location":"man1/ca/#name","title":"NAME","text":"<p>openssl-ca, ca - sample minimal CA application</p>"},{"location":"man1/ca/#synopsis","title":"SYNOPSIS","text":"<p>openssl ca [-verbose] [-config filename] [-name section] [-gencrl] [-revoke file] [-status serial] [-updatedb] [-crl_reason reason] [-crl_hold instruction] [-crl_compromise time] [-crl_CA_compromise time] [-crldays days] [-crlhours hours] [-crlexts section] [-startdate date] [-enddate date] [-days arg] [-md arg] [-policy arg] [-keyfile arg] [-keyform PEM|DER] [-key arg] [-passin arg] [-cert file] [-selfsign] [-in file] [-out file] [-notext] [-outdir dir] [-infiles] [-spkac file] [-ss_cert file] [-preserveDN] [-noemailDN] [-batch] [-msie_hack] [-extensions section] [-extfile section] [-engine id] [-subj arg] [-utf8] [-multivalue-rdn]</p>"},{"location":"man1/ca/#description","title":"DESCRIPTION","text":"<p>The ca command is a minimal CA application. It can be used to sign certificate requests in a variety of forms and generate CRLs it also maintains a text database of issued certificates and their status.</p> <p>The options descriptions will be divided into each purpose.</p>"},{"location":"man1/ca/#ca-options","title":"CA OPTIONS","text":"<ul> <li> <p>-config filename</p> <p>specifies the configuration file to use.</p> </li> <li> <p>-name section</p> <p>specifies the configuration file section to use (overrides default_ca in the ca section).</p> </li> <li> <p>-in filename</p> <p>an input filename containing a single certificate request to be signed by the CA.</p> </li> <li> <p>-ss_cert filename</p> <p>a single self signed certificate to be signed by the CA.</p> </li> <li> <p>-spkac filename</p> <p>a file containing a single Netscape signed public key and challenge and additional field values to be signed by the CA. See the SPKAC FORMAT section for information on the required input and output format.</p> </li> <li> <p>-infiles</p> <p>if present this should be the last option, all subsequent arguments are assumed to the the names of files containing certificate requests. </p> </li> <li> <p>-out filename</p> <p>the output file to output certificates to. The default is standard output. The certificate details will also be printed out to this file in PEM format (except that -spkac outputs DER format).</p> </li> <li> <p>-outdir directory</p> <p>the directory to output certificates to. The certificate will be written to a filename consisting of the serial number in hex with \".pem\" appended.</p> </li> <li> <p>-cert</p> <p>the CA certificate file.</p> </li> <li> <p>-keyfile filename</p> <p>the private key to sign requests with.</p> </li> <li> <p>-keyform PEM|DER</p> <p>the format of the data in the private key file. The default is PEM.</p> </li> <li> <p>-key password</p> <p>the password used to encrypt the private key. Since on some systems the command line arguments are visible (e.g. Unix with the 'ps' utility) this option should be used with caution.</p> </li> <li> <p>-selfsign</p> <p>indicates the issued certificates are to be signed with the key the certificate requests were signed with (given with -keyfile). Cerificate requests signed with a different key are ignored.  If -spkac, -ss_cert or -gencrl are given, -selfsign is ignored.</p> <p>A consequence of using -selfsign is that the self-signed certificate appears among the entries in the certificate database (see the configuration option database), and uses the same serial number counter as all other certificates sign with the self-signed certificate.</p> </li> <li> <p>-passin arg</p> <p>the key password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-verbose</p> <p>this prints extra details about the operations being performed.</p> </li> <li> <p>-notext</p> <p>don't output the text form of a certificate to the output file.</p> </li> <li> <p>-startdate date</p> <p>this allows the start date to be explicitly set. The format of the date is YYMMDDHHMMSSZ (the same as an ASN1 UTCTime structure).</p> </li> <li> <p>-enddate date</p> <p>this allows the expiry date to be explicitly set. The format of the date is YYMMDDHHMMSSZ (the same as an ASN1 UTCTime structure).</p> </li> <li> <p>-days arg</p> <p>the number of days to certify the certificate for.</p> </li> <li> <p>-md alg</p> <p>the message digest to use. Possible values include md5, sha1 and mdc2. This option also applies to CRLs.</p> </li> <li> <p>-policy arg</p> <p>this option defines the CA \"policy\" to use. This is a section in the configuration file which decides which fields should be mandatory or match the CA certificate. Check out the POLICY FORMAT section for more information.</p> </li> <li> <p>-msie_hack</p> <p>this is a legacy option to make ca work with very old versions of the IE certificate enrollment control \"certenr3\". It used UniversalStrings for almost everything. Since the old control has various security bugs its use is strongly discouraged. The newer control \"Xenroll\" does not need this option.</p> </li> <li> <p>-preserveDN</p> <p>Normally the DN order of a certificate is the same as the order of the fields in the relevant policy section. When this option is set the order  is the same as the request. This is largely for compatibility with the older IE enrollment control which would only accept certificates if their DNs match the order of the request. This is not needed for Xenroll.</p> </li> <li> <p>-noemailDN</p> <p>The DN of a certificate can contain the EMAIL field if present in the request DN, however it is good policy just having the e-mail set into the altName extension of the certificate. When this option is set the EMAIL field is removed from the certificate' subject and set only in the, eventually present, extensions. The email_in_dn keyword can be used in the configuration file to enable this behaviour.</p> </li> <li> <p>-batch</p> <p>this sets the batch mode. In this mode no questions will be asked and all certificates will be certified automatically.</p> </li> <li> <p>-extensions section</p> <p>the section of the configuration file containing certificate extensions to be added when a certificate is issued (defaults to x509_extensions unless the -extfile option is used). If no extension section is present then, a V1 certificate is created. If the extension section is present (even if it is empty), then a V3 certificate is created. See the x509v3_config(5) manual page for details of the extension section format.</p> </li> <li> <p>-extfile file</p> <p>an additional configuration file to read certificate extensions from (using the default section unless the -extensions option is also used).</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause ca to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> <li> <p>-subj arg</p> <p>supersedes subject name given in the request. The arg must be formatted as /type0=value0/type1=value1/type2=..., characters may be escaped by \\ (backslash), no spaces are skipped.</p> </li> <li> <p>-utf8</p> <p>this option causes field values to be interpreted as UTF8 strings, by  default they are interpreted as ASCII. This means that the field values, whether prompted from a terminal or obtained from a configuration file, must be valid UTF8 strings.</p> </li> <li> <p>-multivalue-rdn</p> <p>this option causes the -subj argument to be interpretedt with full support for multivalued RDNs. Example:</p> <p>/DC=org/DC=OpenSSL/DC=users/UID=123456+CN=John Doe</p> <p>If -multi-rdn is not used then the UID value is 123456+CN=John Doe.</p> </li> </ul>"},{"location":"man1/ca/#crl-options","title":"CRL OPTIONS","text":"<ul> <li> <p>-gencrl</p> <p>this option generates a CRL based on information in the index file.</p> </li> <li> <p>-crldays num</p> <p>the number of days before the next CRL is due. That is the days from now to place in the CRL nextUpdate field.</p> </li> <li> <p>-crlhours num</p> <p>the number of hours before the next CRL is due.</p> </li> <li> <p>-revoke filename</p> <p>a filename containing a certificate to revoke.</p> </li> <li> <p>-status serial</p> <p>displays the revocation status of the certificate with the specified serial number and exits.</p> </li> <li> <p>-updatedb</p> <p>Updates the database index to purge expired certificates.</p> </li> <li> <p>-crl_reason reason</p> <p>revocation reason, where reason is one of: unspecified, keyCompromise, CACompromise, affiliationChanged, superseded, cessationOfOperation, certificateHold or removeFromCRL. The matching of reason is case insensitive. Setting any revocation reason will make the CRL v2.</p> <p>In practive removeFromCRL is not particularly useful because it is only used in delta CRLs which are not currently implemented.</p> </li> <li> <p>-crl_hold instruction</p> <p>This sets the CRL revocation reason code to certificateHold and the hold instruction to instruction which must be an OID. Although any OID can be used only holdInstructionNone (the use of which is discouraged by RFC2459) holdInstructionCallIssuer or holdInstructionReject will normally be used.</p> </li> <li> <p>-crl_compromise time</p> <p>This sets the revocation reason to keyCompromise and the compromise time to time. time should be in GeneralizedTime format that is YYYYMMDDHHMMSSZ.</p> </li> <li> <p>-crl_CA_compromise time</p> <p>This is the same as crl_compromise except the revocation reason is set to CACompromise.</p> </li> <li> <p>-crlexts section</p> <p>the section of the configuration file containing CRL extensions to include. If no CRL extension section is present then a V1 CRL is created, if the CRL extension section is present (even if it is empty) then a V2 CRL is created. The CRL extensions specified are CRL extensions and not CRL entry extensions.  It should be noted that some software (for example Netscape) can't handle V2 CRLs. See x509v3_config(5) manual page for details of the extension section format.</p> </li> </ul>"},{"location":"man1/ca/#configuration-file-options","title":"CONFIGURATION FILE OPTIONS","text":"<p>The section of the configuration file containing options for ca is found as follows: If the -name command line option is used, then it names the section to be used. Otherwise the section to be used must be named in the default_ca option of the ca section of the configuration file (or in the default section of the configuration file). Besides default_ca, the following options are read directly from the ca section:  RANDFILE  preserve  msie_hack With the exception of RANDFILE, this is probably a bug and may change in future releases.</p> <p>Many of the configuration file options are identical to command line options. Where the option is present in the configuration file and the command line the command line value is used. Where an option is described as mandatory then it must be present in the configuration file or the command line equivalent (if any) used.</p> <ul> <li> <p>oid_file</p> <p>This specifies a file containing additional OBJECT IDENTIFIERS. Each line of the file should consist of the numerical form of the object identifier followed by white space then the short name followed by white space and finally the long name. </p> </li> <li> <p>oid_section</p> <p>This specifies a section in the configuration file containing extra object identifiers. Each line should consist of the short name of the object identifier followed by = and the numerical form. The short and long names are the same when this option is used.</p> </li> <li> <p>new_certs_dir</p> <p>the same as the -outdir command line option. It specifies the directory where new certificates will be placed. Mandatory.</p> </li> <li> <p>certificate</p> <p>the same as -cert. It gives the file containing the CA certificate. Mandatory.</p> </li> <li> <p>private_key</p> <p>same as the -keyfile option. The file containing the CA private key. Mandatory.</p> </li> <li> <p>RANDFILE</p> <p>a file used to read and write random number seed information, or an EGD socket (see RAND_egd(3)).</p> </li> <li> <p>default_days</p> <p>the same as the -days option. The number of days to certify a certificate for. </p> </li> <li> <p>default_startdate</p> <p>the same as the -startdate option. The start date to certify a certificate for. If not set the current time is used.</p> </li> <li> <p>default_enddate</p> <p>the same as the -enddate option. Either this option or default_days (or the command line equivalents) must be present.</p> </li> <li> <p>default_crl_hours default_crl_days</p> <p>the same as the -crlhours and the -crldays options. These will only be used if neither command line option is present. At least one of these must be present to generate a CRL.</p> </li> <li> <p>default_md</p> <p>the same as the -md option. The message digest to use. Mandatory.</p> </li> <li> <p>database</p> <p>the text database file to use. Mandatory. This file must be present though initially it will be empty.</p> </li> <li> <p>unique_subject</p> <p>if the value yes is given, the valid certificate entries in the database must have unique subjects.  if the value no is given, several valid certificate entries may have the exact same subject. The default value is yes, to be compatible with older (pre 0.9.8) versions of OpenSSL.  However, to make CA certificate roll-over easier, it's recommended to use the value no, especially if combined with the -selfsign command line option.</p> <p>Note that it is valid in some circumstances for certificates to be created without any subject. In the case where there are multiple certificates without subjects this does not count as a duplicate.</p> </li> <li> <p>serial</p> <p>a text file containing the next serial number to use in hex. Mandatory. This file must be present and contain a valid serial number.</p> </li> <li> <p>crlnumber</p> <p>a text file containing the next CRL number to use in hex. The crl number will be inserted in the CRLs only if this file exists. If this file is present, it must contain a valid CRL number.</p> </li> <li> <p>x509_extensions</p> <p>the same as -extensions.</p> </li> <li> <p>crl_extensions</p> <p>the same as -crlexts.</p> </li> <li> <p>preserve</p> <p>the same as -preserveDN</p> </li> <li> <p>email_in_dn</p> <p>the same as -noemailDN. If you want the EMAIL field to be removed from the DN of the certificate simply set this to 'no'. If not present the default is to allow for the EMAIL filed in the certificate's DN.</p> </li> <li> <p>msie_hack</p> <p>the same as -msie_hack</p> </li> <li> <p>policy</p> <p>the same as -policy. Mandatory. See the POLICY FORMAT section for more information.</p> </li> <li> <p>name_opt, cert_opt</p> <p>these options allow the format used to display the certificate details when asking the user to confirm signing. All the options supported by the x509 utilities -nameopt and -certopt switches can be used here, except the no_signame and no_sigdump are permanently set and cannot be disabled (this is because the certificate signature cannot be displayed because the certificate has not been signed at this point).</p> <p>For convenience the values ca_default are accepted by both to produce a reasonable output.</p> <p>If neither option is present the format used in earlier versions of OpenSSL is used. Use of the old format is strongly discouraged because it only displays fields mentioned in the policy section, mishandles multicharacter string types and does not display extensions.</p> </li> <li> <p>copy_extensions</p> <p>determines how extensions in certificate requests should be handled. If set to none or this option is not present then extensions are ignored and not copied to the certificate. If set to copy then any extensions present in the request that are not already present are copied to the certificate. If set to copyall then all extensions in the request are copied to the certificate: if the extension is already present in the certificate it is deleted first. See the WARNINGS section before using this option.</p> <p>The main use of this option is to allow a certificate request to supply values for certain extensions such as subjectAltName.</p> </li> </ul>"},{"location":"man1/ca/#policy-format","title":"POLICY FORMAT","text":"<p>The policy section consists of a set of variables corresponding to certificate DN fields. If the value is \"match\" then the field value must match the same field in the CA certificate. If the value is \"supplied\" then it must be present. If the value is \"optional\" then it may be present. Any fields not mentioned in the policy section are silently deleted, unless the -preserveDN option is set but this can be regarded more of a quirk than intended behaviour.</p>"},{"location":"man1/ca/#spkac-format","title":"SPKAC FORMAT","text":"<p>The input to the -spkac command line option is a Netscape signed public key and challenge. This will usually come from the KEYGEN tag in an HTML form to create a new private key.  It is however possible to create SPKACs using the spkac utility.</p> <p>The file should contain the variable SPKAC set to the value of the SPKAC and also the required DN components as name value pairs. If you need to include the same component twice then it can be preceded by a number and a '.'.</p> <p>When processing SPKAC format, the output is DER if the -out flag is used, but PEM format if sending to stdout or the -outdir flag is used.</p>"},{"location":"man1/ca/#examples","title":"EXAMPLES","text":"<p>Note: these examples assume that the ca directory structure is already set up and the relevant files already exist. This usually involves creating a CA certificate and private key with req, a serial number file and an empty index file and placing them in the relevant directories.</p> <p>To use the sample configuration file below the directories demoCA, demoCA/private and demoCA/newcerts would be created. The CA certificate would be copied to demoCA/cacert.pem and its private key to demoCA/private/cakey.pem. A file demoCA/serial would be created containing for example \"01\" and the empty index file demoCA/index.txt.</p> <p>Sign a certificate request:</p> <pre><code>openssl ca -in req.pem -out newcert.pem\n</code></pre> <p>Sign a certificate request, using CA extensions:</p> <pre><code>openssl ca -in req.pem -extensions v3_ca -out newcert.pem\n</code></pre> <p>Generate a CRL</p> <pre><code>openssl ca -gencrl -out crl.pem\n</code></pre> <p>Sign several requests:</p> <pre><code>openssl ca -infiles req1.pem req2.pem req3.pem\n</code></pre> <p>Certify a Netscape SPKAC:</p> <pre><code>openssl ca -spkac spkac.txt\n</code></pre> <p>A sample SPKAC file (the SPKAC line has been truncated for clarity):</p> <pre><code>SPKAC=MIG0MGAwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAn7PDhCeV/xIxUg8V70YRxK2A5\nCN=Steve Test\nemailAddress=steve@openssl.org\n0.OU=OpenSSL Group\n1.OU=Another Group\n</code></pre> <p>A sample configuration file with the relevant sections for ca:</p> <pre><code>[ ca ]\ndefault_ca      = CA_default            # The default ca section\n\n[ CA_default ]\n\ndir            = ./demoCA              # top dir\ndatabase       = $dir/index.txt        # index file.\nnew_certs_dir  = $dir/newcerts         # new certs dir\n\ncertificate    = $dir/cacert.pem       # The CA cert\nserial         = $dir/serial           # serial no file\nprivate_key    = $dir/private/cakey.pem# CA private key\nRANDFILE       = $dir/private/.rand    # random number file\n\ndefault_days   = 365                   # how long to certify for\ndefault_crl_days= 30                   # how long before next CRL\ndefault_md     = md5                   # md to use\n\npolicy         = policy_any            # default policy\nemail_in_dn    = no                    # Don't add the email into cert DN\n\nname_opt       = ca_default            # Subject name display option\ncert_opt       = ca_default            # Certificate display option\ncopy_extensions = none                 # Don't copy extensions from request\n\n[ policy_any ]\ncountryName            = supplied\nstateOrProvinceName    = optional\norganizationName       = optional\norganizationalUnitName = optional\ncommonName             = supplied\nemailAddress           = optional\n</code></pre>"},{"location":"man1/ca/#files","title":"FILES","text":"<p>Note: the location of all files can change either by compile time options, configuration file entries, environment variables or command line options. The values below reflect the default values.</p> <pre><code>/usr/local/ssl/lib/openssl.cnf - master configuration file\n./demoCA                       - main CA directory\n./demoCA/cacert.pem            - CA certificate\n./demoCA/private/cakey.pem     - CA private key\n./demoCA/serial                - CA serial number file\n./demoCA/serial.old            - CA serial number backup file\n./demoCA/index.txt             - CA text database file\n./demoCA/index.txt.old         - CA text database backup file\n./demoCA/certs                 - certificate output file\n./demoCA/.rnd                  - CA random seed information\n</code></pre>"},{"location":"man1/ca/#environment-variables","title":"ENVIRONMENT VARIABLES","text":"<p>OPENSSL_CONF reflects the location of master configuration file it can be overridden by the -config command line option.</p>"},{"location":"man1/ca/#restrictions","title":"RESTRICTIONS","text":"<p>The text database index file is a critical part of the process and  if corrupted it can be difficult to fix. It is theoretically possible to rebuild the index file from all the issued certificates and a current CRL: however there is no option to do this.</p> <p>V2 CRL features like delta CRLs are not currently supported.</p> <p>Although several requests can be input and handled at once it is only possible to include one SPKAC or self signed certificate.</p>"},{"location":"man1/ca/#bugs","title":"BUGS","text":"<p>The use of an in memory text database can cause problems when large numbers of certificates are present because, as the name implies the database has to be kept in memory.</p> <p>The ca command really needs rewriting or the required functionality exposed at either a command or interface level so a more friendly utility (perl script or GUI) can handle things properly. The scripts CA.sh and CA.pl help a little but not very much.</p> <p>Any fields in a request that are not present in a policy are silently deleted. This does not happen if the -preserveDN option is used. To enforce the absence of the EMAIL field within the DN, as suggested by RFCs, regardless the contents of the request' subject the -noemailDN option can be used. The behaviour should be more friendly and configurable.</p> <p>Cancelling some commands by refusing to certify a certificate can create an empty file.</p>"},{"location":"man1/ca/#warnings","title":"WARNINGS","text":"<p>The ca command is quirky and at times downright unfriendly.</p> <p>The ca utility was originally meant as an example of how to do things in a CA. It was not supposed to be used as a full blown CA itself: nevertheless some people are using it for this purpose.</p> <p>The ca command is effectively a single user command: no locking is done on the various files and attempts to run more than one ca command on the same database can have unpredictable results.</p> <p>The copy_extensions option should be used with caution. If care is not taken then it can be a security risk. For example if a certificate request contains a basicConstraints extension with CA:TRUE and the copy_extensions value is set to copyall and the user does not spot this when the certificate is displayed then this will hand the requestor a valid CA certificate.</p> <p>This situation can be avoided by setting copy_extensions to copy and including basicConstraints with CA:FALSE in the configuration file. Then if the request contains a basicConstraints extension it will be ignored.</p> <p>It is advisable to also include values for other extensions such as keyUsage to prevent a request supplying its own values.</p> <p>Additional restrictions can be placed on the CA certificate itself. For example if the CA certificate has:</p> <pre><code>basicConstraints = CA:TRUE, pathlen:0\n</code></pre> <p>then even if a certificate is issued with CA:TRUE it will not be valid.</p>"},{"location":"man1/ca/#see-also","title":"SEE ALSO","text":"<p>req(1), spkac(1), x509(1), CA.pl(1), config(5), x509v3_config(5) </p>"},{"location":"man1/ciphers/","title":"ciphers","text":""},{"location":"man1/ciphers/#name","title":"NAME","text":"<p>openssl-ciphers, ciphers - SSL cipher display and cipher list tool.</p>"},{"location":"man1/ciphers/#synopsis","title":"SYNOPSIS","text":"<p>openssl ciphers [-v] [-V] [-ssl2] [-ssl3] [-tls1] [cipherlist]</p>"},{"location":"man1/ciphers/#description","title":"DESCRIPTION","text":"<p>The ciphers command converts textual OpenSSL cipher lists into ordered SSL cipher preference lists. It can be used as a test tool to determine the appropriate cipherlist.</p>"},{"location":"man1/ciphers/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-v</p> <p>Verbose option. List ciphers with a complete description of protocol version (SSLv2 or SSLv3; the latter includes TLS), key exchange, authentication, encryption and mac algorithms used along with any key size restrictions and whether the algorithm is classed as an \"export\" cipher. Note that without the -v option, ciphers may seem to appear twice in a cipher list; this is when similar ciphers are available for SSL v2 and for SSL v3/TLS v1.</p> </li> <li> <p>-V</p> <p>Like -v, but include cipher suite codes in output (hex format).</p> </li> <li> <p>-ssl3, -tls1</p> <p>This lists ciphers compatible with any of SSLv3, TLSv1, TLSv1.1 or TLSv1.2.</p> </li> <li> <p>-ssl2</p> <p>Only include SSLv2 ciphers.</p> </li> <li> <p>-h, -?</p> <p>Print a brief usage message.</p> </li> <li> <p>cipherlist</p> <p>A cipher list to convert to a cipher preference list. If it is not included then the default cipher list will be used. The format is described below.</p> </li> </ul>"},{"location":"man1/ciphers/#cipher-list-format","title":"CIPHER LIST FORMAT","text":"<p>The cipher list consists of one or more cipher strings separated by colons. Commas or spaces are also acceptable separators but colons are normally used.</p> <p>The actual cipher string can take several different forms.</p> <p>It can consist of a single cipher suite such as RC4-SHA.</p> <p>It can represent a list of cipher suites containing a certain algorithm, or cipher suites of a certain type. For example SHA1 represents all ciphers suites using the digest algorithm SHA1 and SSLv3 represents all SSL v3 algorithms.</p> <p>Lists of cipher suites can be combined in a single cipher string using the + character. This is used as a logical and operation. For example SHA1+DES represents all cipher suites containing the SHA1 and the DES algorithms.</p> <p>Each cipher string can be optionally preceded by the characters !, - or +.</p> <p>If ! is used then the ciphers are permanently deleted from the list. The ciphers deleted can never reappear in the list even if they are explicitly stated.</p> <p>If - is used then the ciphers are deleted from the list, but some or all of the ciphers can be added again by later options.</p> <p>If + is used then the ciphers are moved to the end of the list. This option doesn't add any new ciphers it just moves matching existing ones.</p> <p>If none of these characters is present then the string is just interpreted as a list of ciphers to be appended to the current preference list. If the list includes any ciphers already present they will be ignored: that is they will not moved to the end of the list.</p> <p>Additionally the cipher string @STRENGTH can be used at any point to sort the current cipher list in order of encryption algorithm key length.</p>"},{"location":"man1/ciphers/#cipher-strings","title":"CIPHER STRINGS","text":"<p>The following is a list of all permitted cipher strings and their meanings.</p> <ul> <li> <p>DEFAULT</p> <p>The default cipher list. This is determined at compile time and is normally ALL:!EXPORT:!LOW:!aNULL:!eNULL:!SSLv2. When used, this must be the first cipherstring specified.</p> </li> <li> <p>COMPLEMENTOFDEFAULT</p> <p>the ciphers included in ALL, but not enabled by default. Currently this is ADH and AECDH. Note that this rule does not cover eNULL, which is not included by ALL (use COMPLEMENTOFALL if necessary).</p> </li> <li> <p>ALL</p> <p>all cipher suites except the eNULL ciphers which must be explicitly enabled; as of OpenSSL, the ALL cipher suites are reasonably ordered by default</p> </li> <li> <p>COMPLEMENTOFALL</p> <p>the cipher suites not enabled by ALL, currently being eNULL.</p> </li> <li> <p>HIGH</p> <p>\"high\" encryption cipher suites. This currently means those with key lengths larger than 128 bits, and some cipher suites with 128-bit keys.</p> </li> <li> <p>MEDIUM</p> <p>\"medium\" encryption cipher suites, currently some of those using 128 bit encryption.</p> </li> <li> <p>LOW</p> <p>Low strength encryption cipher suites, currently those using 64 or 56 bit encryption algorithms but excluding export cipher suites. As of OpenSSL 1.0.2g, these are disabled in default builds.</p> </li> <li> <p>EXP, EXPORT</p> <p>Export strength encryption algorithms. Including 40 and 56 bits algorithms. As of OpenSSL 1.0.2g, these are disabled in default builds.</p> </li> <li> <p>EXPORT40</p> <p>40-bit export encryption algorithms As of OpenSSL 1.0.2g, these are disabled in default builds.</p> </li> <li> <p>EXPORT56</p> <p>56-bit export encryption algorithms. In OpenSSL 0.9.8c and later the set of 56 bit export ciphers is empty unless OpenSSL has been explicitly configured with support for experimental ciphers. As of OpenSSL 1.0.2g, these are disabled in default builds.</p> </li> <li> <p>eNULL, NULL</p> <p>The \"NULL\" ciphers that is those offering no encryption. Because these offer no encryption at all and are a security risk they are not enabled via either the DEFAULT or ALL cipher strings. Be careful when building cipherlists out of lower-level primitives such as kRSA or aECDSA as these do overlap with the eNULL ciphers. When in doubt, include !eNULL in your cipherlist.</p> </li> <li> <p>aNULL</p> <p>The cipher suites offering no authentication. This is currently the anonymous DH algorithms and anonymous ECDH algorithms. These cipher suites are vulnerable to a \"man in the middle\" attack and so their use is normally discouraged. These are excluded from the DEFAULT ciphers, but included in the ALL ciphers. Be careful when building cipherlists out of lower-level primitives such as kDHE or AES as these do overlap with the aNULL ciphers. When in doubt, include !aNULL in your cipherlist.</p> </li> <li> <p>kRSA, RSA</p> <p>cipher suites using RSA key exchange or authentication. RSA is an alias for kRSA.</p> </li> <li> <p>kDHr, kDHd, kDH</p> <p>cipher suites using DH key agreement and DH certificates signed by CAs with RSA and DSS keys or either respectively.</p> </li> <li> <p>kDHE, kEDH</p> <p>cipher suites using ephemeral DH key agreement, including anonymous cipher suites.</p> </li> <li> <p>DHE, EDH</p> <p>cipher suites using authenticated ephemeral DH key agreement.</p> </li> <li> <p>ADH</p> <p>anonymous DH cipher suites, note that this does not include anonymous Elliptic Curve DH (ECDH) cipher suites.</p> </li> <li> <p>DH</p> <p>cipher suites using DH, including anonymous DH, ephemeral DH and fixed DH.</p> </li> <li> <p>kECDHr, kECDHe, kECDH</p> <p>cipher suites using fixed ECDH key agreement signed by CAs with RSA and ECDSA keys or either respectively.</p> </li> <li> <p>kECDHE, kEECDH</p> <p>cipher suites using ephemeral ECDH key agreement, including anonymous cipher suites.</p> </li> <li> <p>ECDHE, EECDH</p> <p>cipher suites using authenticated ephemeral ECDH key agreement.</p> </li> <li> <p>AECDH</p> <p>anonymous Elliptic Curve Diffie Hellman cipher suites.</p> </li> <li> <p>ECDH</p> <p>cipher suites using ECDH key exchange, including anonymous, ephemeral and fixed ECDH.</p> </li> <li> <p>aRSA</p> <p>cipher suites using RSA authentication, i.e. the certificates carry RSA keys.</p> </li> <li> <p>aDSS, DSS</p> <p>cipher suites using DSS authentication, i.e. the certificates carry DSS keys.</p> </li> <li> <p>aDH</p> <p>cipher suites effectively using DH authentication, i.e. the certificates carry DH keys.</p> </li> <li> <p>aECDH</p> <p>cipher suites effectively using ECDH authentication, i.e. the certificates carry ECDH keys.</p> </li> <li> <p>aECDSA, ECDSA</p> <p>cipher suites using ECDSA authentication, i.e. the certificates carry ECDSA keys.</p> </li> <li> <p>kFZA, aFZA, eFZA, FZA</p> <p>ciphers suites using FORTEZZA key exchange, authentication, encryption or all FORTEZZA algorithms. Not implemented.</p> </li> <li> <p>TLSv1.2, TLSv1, SSLv3, SSLv2</p> <p>TLS v1.2, TLS v1.0, SSL v3.0 or SSL v2.0 cipher suites respectively. Note: there are no ciphersuites specific to TLS v1.1.</p> </li> <li> <p>AES128, AES256, AES</p> <p>cipher suites using 128 bit AES, 256 bit AES or either 128 or 256 bit AES.</p> </li> <li> <p>AESGCM</p> <p>AES in Galois Counter Mode (GCM): these ciphersuites are only supported in TLS v1.2.</p> </li> <li> <p>CAMELLIA128, CAMELLIA256, CAMELLIA</p> <p>cipher suites using 128 bit CAMELLIA, 256 bit CAMELLIA or either 128 or 256 bit CAMELLIA.</p> </li> <li> <p>3DES</p> <p>cipher suites using triple DES.</p> </li> <li> <p>DES</p> <p>cipher suites using DES (not triple DES).</p> </li> <li> <p>RC4</p> <p>cipher suites using RC4.</p> </li> <li> <p>RC2</p> <p>cipher suites using RC2.</p> </li> <li> <p>IDEA</p> <p>cipher suites using IDEA.</p> </li> <li> <p>SEED</p> <p>cipher suites using SEED.</p> </li> <li> <p>MD5</p> <p>cipher suites using MD5.</p> </li> <li> <p>SHA1, SHA</p> <p>cipher suites using SHA1.</p> </li> <li> <p>SHA256, SHA384</p> <p>ciphersuites using SHA256 or SHA384.</p> </li> <li> <p>aGOST </p> <p>cipher suites using GOST R 34.10 (either 2001 or 94) for authenticaction (needs an engine supporting GOST algorithms). </p> </li> <li> <p>aGOST01</p> <p>cipher suites using GOST R 34.10-2001 authentication.</p> </li> <li> <p>aGOST94</p> <p>cipher suites using GOST R 34.10-94 authentication (note that R 34.10-94 standard has been expired so use GOST R 34.10-2001)</p> </li> <li> <p>kGOST</p> <p>cipher suites, using VKO 34.10 key exchange, specified in the RFC 4357.</p> </li> <li> <p>GOST94</p> <p>cipher suites, using HMAC based on GOST R 34.11-94.</p> </li> <li> <p>GOST89MAC</p> <p>cipher suites using GOST 28147-89 MAC instead of HMAC.</p> </li> <li> <p>PSK</p> <p>cipher suites using pre-shared keys (PSK).</p> </li> <li> <p>SUITEB128, SUITEB128ONLY, SUITEB192</p> <p>enables suite B mode operation using 128 (permitting 192 bit mode by peer) 128 bit (not permitting 192 bit by peer) or 192 bit level of security respectively. If used these cipherstrings should appear first in the cipher list and anything after them is ignored. Setting Suite B mode has additional consequences required to comply with RFC6460. In particular the supported signature algorithms is reduced to support only ECDSA and SHA256 or SHA384, only the elliptic curves P-256 and P-384 can be used and only the two suite B compliant ciphersuites (ECDHE-ECDSA-AES128-GCM-SHA256 and ECDHE-ECDSA-AES256-GCM-SHA384) are permissible.</p> </li> </ul>"},{"location":"man1/ciphers/#cipher-suite-names","title":"CIPHER SUITE NAMES","text":"<p>The following lists give the SSL or TLS cipher suites names from the relevant specification and their OpenSSL equivalents. It should be noted, that several cipher suite names do not include the authentication used, e.g. DES-CBC3-SHA. In these cases, RSA authentication is used.</p>"},{"location":"man1/ciphers/#ssl-v30-cipher-suites","title":"SSL v3.0 cipher suites.","text":"<pre><code>SSL_RSA_WITH_NULL_MD5                   NULL-MD5\nSSL_RSA_WITH_NULL_SHA                   NULL-SHA\nSSL_RSA_EXPORT_WITH_RC4_40_MD5          EXP-RC4-MD5\nSSL_RSA_WITH_RC4_128_MD5                RC4-MD5\nSSL_RSA_WITH_RC4_128_SHA                RC4-SHA\nSSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5      EXP-RC2-CBC-MD5\nSSL_RSA_WITH_IDEA_CBC_SHA               IDEA-CBC-SHA\nSSL_RSA_EXPORT_WITH_DES40_CBC_SHA       EXP-DES-CBC-SHA\nSSL_RSA_WITH_DES_CBC_SHA                DES-CBC-SHA\nSSL_RSA_WITH_3DES_EDE_CBC_SHA           DES-CBC3-SHA\n\nSSL_DH_DSS_WITH_DES_CBC_SHA             DH-DSS-DES-CBC-SHA\nSSL_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH-DSS-DES-CBC3-SHA\nSSL_DH_RSA_WITH_DES_CBC_SHA             DH-RSA-DES-CBC-SHA\nSSL_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH-RSA-DES-CBC3-SHA\nSSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA   EXP-EDH-DSS-DES-CBC-SHA\nSSL_DHE_DSS_WITH_DES_CBC_SHA            EDH-DSS-CBC-SHA\nSSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA       EDH-DSS-DES-CBC3-SHA\nSSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA   EXP-EDH-RSA-DES-CBC-SHA\nSSL_DHE_RSA_WITH_DES_CBC_SHA            EDH-RSA-DES-CBC-SHA\nSSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA       EDH-RSA-DES-CBC3-SHA\n\nSSL_DH_anon_EXPORT_WITH_RC4_40_MD5      EXP-ADH-RC4-MD5\nSSL_DH_anon_WITH_RC4_128_MD5            ADH-RC4-MD5\nSSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA   EXP-ADH-DES-CBC-SHA\nSSL_DH_anon_WITH_DES_CBC_SHA            ADH-DES-CBC-SHA\nSSL_DH_anon_WITH_3DES_EDE_CBC_SHA       ADH-DES-CBC3-SHA\n\nSSL_FORTEZZA_KEA_WITH_NULL_SHA          Not implemented.\nSSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA  Not implemented.\nSSL_FORTEZZA_KEA_WITH_RC4_128_SHA       Not implemented.\n</code></pre>"},{"location":"man1/ciphers/#tls-v10-cipher-suites","title":"TLS v1.0 cipher suites.","text":"<pre><code>TLS_RSA_WITH_NULL_MD5                   NULL-MD5\nTLS_RSA_WITH_NULL_SHA                   NULL-SHA\nTLS_RSA_EXPORT_WITH_RC4_40_MD5          EXP-RC4-MD5\nTLS_RSA_WITH_RC4_128_MD5                RC4-MD5\nTLS_RSA_WITH_RC4_128_SHA                RC4-SHA\nTLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5      EXP-RC2-CBC-MD5\nTLS_RSA_WITH_IDEA_CBC_SHA               IDEA-CBC-SHA\nTLS_RSA_EXPORT_WITH_DES40_CBC_SHA       EXP-DES-CBC-SHA\nTLS_RSA_WITH_DES_CBC_SHA                DES-CBC-SHA\nTLS_RSA_WITH_3DES_EDE_CBC_SHA           DES-CBC3-SHA\n\nTLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA    Not implemented.\nTLS_DH_DSS_WITH_DES_CBC_SHA             Not implemented.\nTLS_DH_DSS_WITH_3DES_EDE_CBC_SHA        Not implemented.\nTLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA    Not implemented.\nTLS_DH_RSA_WITH_DES_CBC_SHA             Not implemented.\nTLS_DH_RSA_WITH_3DES_EDE_CBC_SHA        Not implemented.\nTLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA   EXP-EDH-DSS-DES-CBC-SHA\nTLS_DHE_DSS_WITH_DES_CBC_SHA            EDH-DSS-CBC-SHA\nTLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       EDH-DSS-DES-CBC3-SHA\nTLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA   EXP-EDH-RSA-DES-CBC-SHA\nTLS_DHE_RSA_WITH_DES_CBC_SHA            EDH-RSA-DES-CBC-SHA\nTLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       EDH-RSA-DES-CBC3-SHA\n\nTLS_DH_anon_EXPORT_WITH_RC4_40_MD5      EXP-ADH-RC4-MD5\nTLS_DH_anon_WITH_RC4_128_MD5            ADH-RC4-MD5\nTLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA   EXP-ADH-DES-CBC-SHA\nTLS_DH_anon_WITH_DES_CBC_SHA            ADH-DES-CBC-SHA\nTLS_DH_anon_WITH_3DES_EDE_CBC_SHA       ADH-DES-CBC3-SHA\n</code></pre>"},{"location":"man1/ciphers/#aes-ciphersuites-from-rfc3268-extending-tls-v10","title":"AES ciphersuites from RFC3268, extending TLS v1.0","text":"<pre><code>TLS_RSA_WITH_AES_128_CBC_SHA            AES128-SHA\nTLS_RSA_WITH_AES_256_CBC_SHA            AES256-SHA\n\nTLS_DH_DSS_WITH_AES_128_CBC_SHA         DH-DSS-AES128-SHA\nTLS_DH_DSS_WITH_AES_256_CBC_SHA         DH-DSS-AES256-SHA\nTLS_DH_RSA_WITH_AES_128_CBC_SHA         DH-RSA-AES128-SHA\nTLS_DH_RSA_WITH_AES_256_CBC_SHA         DH-RSA-AES256-SHA\n\nTLS_DHE_DSS_WITH_AES_128_CBC_SHA        DHE-DSS-AES128-SHA\nTLS_DHE_DSS_WITH_AES_256_CBC_SHA        DHE-DSS-AES256-SHA\nTLS_DHE_RSA_WITH_AES_128_CBC_SHA        DHE-RSA-AES128-SHA\nTLS_DHE_RSA_WITH_AES_256_CBC_SHA        DHE-RSA-AES256-SHA\n\nTLS_DH_anon_WITH_AES_128_CBC_SHA        ADH-AES128-SHA\nTLS_DH_anon_WITH_AES_256_CBC_SHA        ADH-AES256-SHA\n</code></pre>"},{"location":"man1/ciphers/#camellia-ciphersuites-from-rfc4132-extending-tls-v10","title":"Camellia ciphersuites from RFC4132, extending TLS v1.0","text":"<pre><code>TLS_RSA_WITH_CAMELLIA_128_CBC_SHA      CAMELLIA128-SHA\nTLS_RSA_WITH_CAMELLIA_256_CBC_SHA      CAMELLIA256-SHA\n\nTLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA   DH-DSS-CAMELLIA128-SHA\nTLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA   DH-DSS-CAMELLIA256-SHA\nTLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA   DH-RSA-CAMELLIA128-SHA\nTLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA   DH-RSA-CAMELLIA256-SHA\n\nTLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA  DHE-DSS-CAMELLIA128-SHA\nTLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA  DHE-DSS-CAMELLIA256-SHA\nTLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA  DHE-RSA-CAMELLIA128-SHA\nTLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA  DHE-RSA-CAMELLIA256-SHA\n\nTLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA  ADH-CAMELLIA128-SHA\nTLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA  ADH-CAMELLIA256-SHA\n</code></pre>"},{"location":"man1/ciphers/#seed-ciphersuites-from-rfc4162-extending-tls-v10","title":"SEED ciphersuites from RFC4162, extending TLS v1.0","text":"<pre><code>TLS_RSA_WITH_SEED_CBC_SHA              SEED-SHA\n\nTLS_DH_DSS_WITH_SEED_CBC_SHA           DH-DSS-SEED-SHA\nTLS_DH_RSA_WITH_SEED_CBC_SHA           DH-RSA-SEED-SHA\n\nTLS_DHE_DSS_WITH_SEED_CBC_SHA          DHE-DSS-SEED-SHA\nTLS_DHE_RSA_WITH_SEED_CBC_SHA          DHE-RSA-SEED-SHA\n\nTLS_DH_anon_WITH_SEED_CBC_SHA          ADH-SEED-SHA\n</code></pre>"},{"location":"man1/ciphers/#gost-ciphersuites-from-draft-chudov-cryptopro-cptls-extending-tls-v10","title":"GOST ciphersuites from draft-chudov-cryptopro-cptls, extending TLS v1.0","text":"<p>Note: these ciphers require an engine which including GOST cryptographic algorithms, such as the ccgost engine, included in the OpenSSL distribution.</p> <pre><code>TLS_GOSTR341094_WITH_28147_CNT_IMIT GOST94-GOST89-GOST89\nTLS_GOSTR341001_WITH_28147_CNT_IMIT GOST2001-GOST89-GOST89\nTLS_GOSTR341094_WITH_NULL_GOSTR3411 GOST94-NULL-GOST94\nTLS_GOSTR341001_WITH_NULL_GOSTR3411 GOST2001-NULL-GOST94\n</code></pre>"},{"location":"man1/ciphers/#additional-export-1024-and-other-cipher-suites","title":"Additional Export 1024 and other cipher suites","text":"<p>Note: these ciphers can also be used in SSL v3.</p> <pre><code>TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA     EXP1024-DES-CBC-SHA\nTLS_RSA_EXPORT1024_WITH_RC4_56_SHA      EXP1024-RC4-SHA\nTLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA EXP1024-DHE-DSS-DES-CBC-SHA\nTLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA  EXP1024-DHE-DSS-RC4-SHA\nTLS_DHE_DSS_WITH_RC4_128_SHA            DHE-DSS-RC4-SHA\n</code></pre>"},{"location":"man1/ciphers/#elliptic-curve-cipher-suites","title":"Elliptic curve cipher suites.","text":"<pre><code>TLS_ECDH_RSA_WITH_NULL_SHA              ECDH-RSA-NULL-SHA\nTLS_ECDH_RSA_WITH_RC4_128_SHA           ECDH-RSA-RC4-SHA\nTLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA      ECDH-RSA-DES-CBC3-SHA\nTLS_ECDH_RSA_WITH_AES_128_CBC_SHA       ECDH-RSA-AES128-SHA\nTLS_ECDH_RSA_WITH_AES_256_CBC_SHA       ECDH-RSA-AES256-SHA\n\nTLS_ECDH_ECDSA_WITH_NULL_SHA            ECDH-ECDSA-NULL-SHA\nTLS_ECDH_ECDSA_WITH_RC4_128_SHA         ECDH-ECDSA-RC4-SHA\nTLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA    ECDH-ECDSA-DES-CBC3-SHA\nTLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA     ECDH-ECDSA-AES128-SHA\nTLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA     ECDH-ECDSA-AES256-SHA\n\nTLS_ECDHE_RSA_WITH_NULL_SHA             ECDHE-RSA-NULL-SHA\nTLS_ECDHE_RSA_WITH_RC4_128_SHA          ECDHE-RSA-RC4-SHA\nTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     ECDHE-RSA-DES-CBC3-SHA\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      ECDHE-RSA-AES128-SHA\nTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      ECDHE-RSA-AES256-SHA\n\nTLS_ECDHE_ECDSA_WITH_NULL_SHA           ECDHE-ECDSA-NULL-SHA\nTLS_ECDHE_ECDSA_WITH_RC4_128_SHA        ECDHE-ECDSA-RC4-SHA\nTLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA   ECDHE-ECDSA-DES-CBC3-SHA\nTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    ECDHE-ECDSA-AES128-SHA\nTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    ECDHE-ECDSA-AES256-SHA\n\nTLS_ECDH_anon_WITH_NULL_SHA             AECDH-NULL-SHA\nTLS_ECDH_anon_WITH_RC4_128_SHA          AECDH-RC4-SHA\nTLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA     AECDH-DES-CBC3-SHA\nTLS_ECDH_anon_WITH_AES_128_CBC_SHA      AECDH-AES128-SHA\nTLS_ECDH_anon_WITH_AES_256_CBC_SHA      AECDH-AES256-SHA\n</code></pre>"},{"location":"man1/ciphers/#tls-v12-cipher-suites","title":"TLS v1.2 cipher suites","text":"<pre><code>TLS_RSA_WITH_NULL_SHA256                  NULL-SHA256\n\nTLS_RSA_WITH_AES_128_CBC_SHA256           AES128-SHA256\nTLS_RSA_WITH_AES_256_CBC_SHA256           AES256-SHA256\nTLS_RSA_WITH_AES_128_GCM_SHA256           AES128-GCM-SHA256\nTLS_RSA_WITH_AES_256_GCM_SHA384           AES256-GCM-SHA384\n\nTLS_DH_RSA_WITH_AES_128_CBC_SHA256        DH-RSA-AES128-SHA256\nTLS_DH_RSA_WITH_AES_256_CBC_SHA256        DH-RSA-AES256-SHA256\nTLS_DH_RSA_WITH_AES_128_GCM_SHA256        DH-RSA-AES128-GCM-SHA256\nTLS_DH_RSA_WITH_AES_256_GCM_SHA384        DH-RSA-AES256-GCM-SHA384\n\nTLS_DH_DSS_WITH_AES_128_CBC_SHA256        DH-DSS-AES128-SHA256\nTLS_DH_DSS_WITH_AES_256_CBC_SHA256        DH-DSS-AES256-SHA256\nTLS_DH_DSS_WITH_AES_128_GCM_SHA256        DH-DSS-AES128-GCM-SHA256\nTLS_DH_DSS_WITH_AES_256_GCM_SHA384        DH-DSS-AES256-GCM-SHA384\n\nTLS_DHE_RSA_WITH_AES_128_CBC_SHA256       DHE-RSA-AES128-SHA256\nTLS_DHE_RSA_WITH_AES_256_CBC_SHA256       DHE-RSA-AES256-SHA256\nTLS_DHE_RSA_WITH_AES_128_GCM_SHA256       DHE-RSA-AES128-GCM-SHA256\nTLS_DHE_RSA_WITH_AES_256_GCM_SHA384       DHE-RSA-AES256-GCM-SHA384\n\nTLS_DHE_DSS_WITH_AES_128_CBC_SHA256       DHE-DSS-AES128-SHA256\nTLS_DHE_DSS_WITH_AES_256_CBC_SHA256       DHE-DSS-AES256-SHA256\nTLS_DHE_DSS_WITH_AES_128_GCM_SHA256       DHE-DSS-AES128-GCM-SHA256\nTLS_DHE_DSS_WITH_AES_256_GCM_SHA384       DHE-DSS-AES256-GCM-SHA384\n\nTLS_ECDH_RSA_WITH_AES_128_CBC_SHA256      ECDH-RSA-AES128-SHA256\nTLS_ECDH_RSA_WITH_AES_256_CBC_SHA384      ECDH-RSA-AES256-SHA384\nTLS_ECDH_RSA_WITH_AES_128_GCM_SHA256      ECDH-RSA-AES128-GCM-SHA256\nTLS_ECDH_RSA_WITH_AES_256_GCM_SHA384      ECDH-RSA-AES256-GCM-SHA384\n\nTLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256    ECDH-ECDSA-AES128-SHA256\nTLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384    ECDH-ECDSA-AES256-SHA384\nTLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256    ECDH-ECDSA-AES128-GCM-SHA256\nTLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384    ECDH-ECDSA-AES256-GCM-SHA384\n\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256     ECDHE-RSA-AES128-SHA256\nTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384     ECDHE-RSA-AES256-SHA384\nTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256     ECDHE-RSA-AES128-GCM-SHA256\nTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384     ECDHE-RSA-AES256-GCM-SHA384\n\nTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256   ECDHE-ECDSA-AES128-SHA256\nTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384   ECDHE-ECDSA-AES256-SHA384\nTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256   ECDHE-ECDSA-AES128-GCM-SHA256\nTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384   ECDHE-ECDSA-AES256-GCM-SHA384\n\nTLS_DH_anon_WITH_AES_128_CBC_SHA256       ADH-AES128-SHA256\nTLS_DH_anon_WITH_AES_256_CBC_SHA256       ADH-AES256-SHA256\nTLS_DH_anon_WITH_AES_128_GCM_SHA256       ADH-AES128-GCM-SHA256\nTLS_DH_anon_WITH_AES_256_GCM_SHA384       ADH-AES256-GCM-SHA384\n</code></pre>"},{"location":"man1/ciphers/#pre-shared-keying-psk-cipheruites","title":"Pre shared keying (PSK) cipheruites","text":"<pre><code>TLS_PSK_WITH_RC4_128_SHA                  PSK-RC4-SHA\nTLS_PSK_WITH_3DES_EDE_CBC_SHA             PSK-3DES-EDE-CBC-SHA\nTLS_PSK_WITH_AES_128_CBC_SHA              PSK-AES128-CBC-SHA\nTLS_PSK_WITH_AES_256_CBC_SHA              PSK-AES256-CBC-SHA\n</code></pre>"},{"location":"man1/ciphers/#deprecated-ssl-v20-cipher-suites","title":"Deprecated SSL v2.0 cipher suites.","text":"<pre><code>SSL_CK_RC4_128_WITH_MD5                 RC4-MD5\nSSL_CK_RC4_128_EXPORT40_WITH_MD5        Not implemented.\nSSL_CK_RC2_128_CBC_WITH_MD5             RC2-CBC-MD5\nSSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5    Not implemented.\nSSL_CK_IDEA_128_CBC_WITH_MD5            IDEA-CBC-MD5\nSSL_CK_DES_64_CBC_WITH_MD5              Not implemented.\nSSL_CK_DES_192_EDE3_CBC_WITH_MD5        DES-CBC3-MD5\n</code></pre>"},{"location":"man1/ciphers/#notes","title":"NOTES","text":"<p>Some compiled versions of OpenSSL may not include all the ciphers listed here because some ciphers were excluded at compile time.</p>"},{"location":"man1/ciphers/#examples","title":"EXAMPLES","text":"<p>Verbose listing of all OpenSSL ciphers including NULL ciphers:</p> <pre><code>openssl ciphers -v 'ALL:eNULL'\n</code></pre> <p>Include all ciphers except NULL and anonymous DH then sort by strength:</p> <pre><code>openssl ciphers -v 'ALL:!ADH:@STRENGTH'\n</code></pre> <p>Include all ciphers except ones with no encryption (eNULL) or no authentication (aNULL):</p> <pre><code>openssl ciphers -v 'ALL:!aNULL'\n</code></pre> <p>Include only 3DES ciphers and then place RSA ciphers last:</p> <pre><code>openssl ciphers -v '3DES:+RSA'\n</code></pre> <p>Include all RC4 ciphers but leave out those without authentication:</p> <pre><code>openssl ciphers -v 'RC4:!COMPLEMENTOFDEFAULT'\n</code></pre> <p>Include all chiphers with RSA authentication but leave out ciphers without encryption.</p> <pre><code>openssl ciphers -v 'RSA:!COMPLEMENTOFALL'\n</code></pre>"},{"location":"man1/ciphers/#see-also","title":"SEE ALSO","text":"<p>s_client(1), s_server(1), ssl(3)</p>"},{"location":"man1/ciphers/#history","title":"HISTORY","text":"<p>The COMPLENTOFALL and COMPLEMENTOFDEFAULT selection options for cipherlist strings were added in OpenSSL 0.9.7. The -V option for the ciphers command was added in OpenSSL 1.0.0.</p>"},{"location":"man1/cms/","title":"cms","text":""},{"location":"man1/cms/#name","title":"NAME","text":"<p>openssl-cms, cms - CMS utility</p>"},{"location":"man1/cms/#synopsis","title":"SYNOPSIS","text":"<p>openssl cms [-encrypt] [-decrypt] [-sign] [-verify] [-cmsout] [-resign] [-data_create] [-data_out] [-digest_create] [-digest_verify] [-compress] [-uncompress] [-EncryptedData_encrypt] [-sign_receipt] [-verify_receipt receipt] [-in filename] [-inform SMIME|PEM|DER] [-rctform SMIME|PEM|DER] [-out filename] [-outform SMIME|PEM|DER] [-stream -indef -noindef] [-noindef] [-content filename] [-text] [-noout] [-print] [-CAfile file] [-CApath dir] [-no_alt_chains] [-md digest] [-[cipher]] [-nointern] [-no_signer_cert_verify] [-nocerts] [-noattr] [-nosmimecap] [-binary] [-nodetach] [-certfile file] [-certsout file] [-signer file] [-recip file] [-keyid] [-receipt_request_all -receipt_request_first] [-receipt_request_from emailaddress] [-receipt_request_to emailaddress] [-receipt_request_print] [-secretkey key] [-secretkeyid id] [-econtent_type type] [-inkey file] [-keyopt name:parameter] [-passin arg] [-rand file(s)] [cert.pem...] [-to addr] [-from addr] [-subject subj] [cert.pem]...</p>"},{"location":"man1/cms/#description","title":"DESCRIPTION","text":"<p>The cms command handles S/MIME v3.1 mail. It can encrypt, decrypt, sign and verify, compress and uncompress S/MIME messages.</p>"},{"location":"man1/cms/#command-options","title":"COMMAND OPTIONS","text":"<p>There are fourteen operation options that set the type of operation to be performed. The meaning of the other options varies according to the operation type.</p> <ul> <li> <p>-encrypt</p> <p>encrypt mail for the given recipient certificates. Input file is the message to be encrypted. The output file is the encrypted mail in MIME format. The actual CMS type is &lt;B&gt;EnvelopedData&lt;B&gt;.</p> <p>Note that no revocation check is done for the recipient cert, so if that key has been compromised, others may be able to decrypt the text.</p> </li> <li> <p>-decrypt</p> <p>decrypt mail using the supplied certificate and private key. Expects an encrypted mail message in MIME format for the input file. The decrypted mail is written to the output file.</p> </li> <li> <p>-debug_decrypt</p> <p>this option sets the CMS_DEBUG_DECRYPT flag. This option should be used with caution: see the notes section below.</p> </li> <li> <p>-sign</p> <p>sign mail using the supplied certificate and private key. Input file is the message to be signed. The signed message in MIME format is written to the output file.</p> </li> <li> <p>-verify</p> <p>verify signed mail. Expects a signed mail message on input and outputs the signed data. Both clear text and opaque signing is supported.</p> </li> <li> <p>-cmsout</p> <p>takes an input message and writes out a PEM encoded CMS structure.</p> </li> <li> <p>-resign</p> <p>resign a message: take an existing message and one or more new signers.</p> </li> <li> <p>-data_create</p> <p>Create a CMS Data type.</p> </li> <li> <p>-data_out</p> <p>Data type and output the content.</p> </li> <li> <p>-digest_create</p> <p>Create a CMS DigestedData type.</p> </li> <li> <p>-digest_verify</p> <p>Verify a CMS DigestedData type and output the content.</p> </li> <li> <p>-compress</p> <p>Create a CMS CompressedData type. OpenSSL must be compiled with zlib support for this option to work, otherwise it will output an error.</p> </li> <li> <p>-uncompress</p> <p>Uncompress a CMS CompressedData type and output the content. OpenSSL must be compiled with zlib support for this option to work, otherwise it will output an error.</p> </li> <li> <p>-EncryptedData_encrypt</p> <p>Encrypt content using supplied symmetric key and algorithm using a CMS EncrytedData type and output the content.</p> </li> <li> <p>-sign_receipt</p> <p>Generate and output a signed receipt for the supplied message. The input  message must contain a signed receipt request. Functionality is otherwise similar to the -sign operation.</p> </li> <li> <p>-verify_receipt receipt</p> <p>Verify a signed receipt in filename receipt. The input message must  contain the original receipt request. Functionality is otherwise similar to the -verify operation.</p> </li> <li> <p>-in filename</p> <p>the input message to be encrypted or signed or the message to be decrypted or verified.</p> </li> <li> <p>-inform SMIME|PEM|DER</p> <p>this specifies the input format for the CMS structure. The default is SMIME which reads an S/MIME format message. PEM and DER format change this to expect PEM and DER format CMS structures instead. This currently only affects the input format of the CMS structure, if no CMS structure is being input (for example with -encrypt or -sign) this option has no effect.</p> </li> <li> <p>-rctform SMIME|PEM|DER</p> <p>specify the format for a signed receipt for use with the -receipt_verify operation.</p> </li> <li> <p>-out filename</p> <p>the message text that has been decrypted or verified or the output MIME format message that has been signed or verified.</p> </li> <li> <p>-outform SMIME|PEM|DER</p> <p>this specifies the output format for the CMS structure. The default is SMIME which writes an S/MIME format message. PEM and DER format change this to write PEM and DER format CMS structures instead. This currently only affects the output format of the CMS structure, if no CMS structure is being output (for example with -verify or -decrypt) this option has no effect.</p> </li> <li> <p>-stream -indef -noindef</p> <p>the -stream and -indef options are equivalent and enable streaming I/O for encoding operations. This permits single pass processing of data without the need to hold the entire contents in memory, potentially supporting very large files. Streaming is automatically set for S/MIME signing with detached data if the output format is SMIME it is currently off by default for all other operations.</p> </li> <li> <p>-noindef</p> <p>disable streaming I/O where it would produce and indefinite length constructed encoding. This option currently has no effect. In future streaming will be enabled by default on all relevant operations and this option will disable it.</p> </li> <li> <p>-content filename</p> <p>This specifies a file containing the detached content, this is only useful with the -verify command. This is only usable if the CMS structure is using the detached signature form where the content is not included. This option will override any content if the input format is S/MIME and it uses the multipart/signed MIME content type.</p> </li> <li> <p>-text</p> <p>this option adds plain text (text/plain) MIME headers to the supplied message if encrypting or signing. If decrypting or verifying it strips off text headers: if the decrypted or verified message is not of MIME  type text/plain then an error occurs.</p> </li> <li> <p>-noout</p> <p>for the -cmsout operation do not output the parsed CMS structure. This is useful when combined with the -print option or if the syntax of the CMS structure is being checked.</p> </li> <li> <p>-print</p> <p>for the -cmsout operation print out all fields of the CMS structure. This is mainly useful for testing purposes.</p> </li> <li> <p>-CAfile file</p> <p>a file containing trusted CA certificates, only used with -verify.</p> </li> <li> <p>-CApath dir</p> <p>a directory containing trusted CA certificates, only used with -verify. This directory must be a standard certificate directory: that is a hash of each subject name (using x509 -hash) should be linked to each certificate.</p> </li> <li> <p>-md digest</p> <p>digest algorithm to use when signing or resigning. If not present then the default digest algorithm for the signing key will be used (usually SHA1).</p> </li> <li> <p>-[cipher]</p> <p>the encryption algorithm to use. For example triple DES (168 bits) - -des3 or 256 bit AES - -aes256. Any standard algorithm name (as used by the EVP_get_cipherbyname() function) can also be used preceded by a dash, for  example -aes_128_cbc. See enc for a list of ciphers supported by your version of OpenSSL.</p> <p>If not specified triple DES is used. Only used with -encrypt and  -EncryptedData_create commands.</p> </li> <li> <p>-nointern</p> <p>when verifying a message normally certificates (if any) included in the message are searched for the signing certificate. With this option only the certificates specified in the -certfile option are used. The supplied certificates can still be used as untrusted CAs however.</p> </li> <li> <p>-no_signer_cert_verify</p> <p>do not verify the signers certificate of a signed message.</p> </li> <li> <p>-nocerts</p> <p>when signing a message the signer's certificate is normally included with this option it is excluded. This will reduce the size of the signed message but the verifier must have a copy of the signers certificate available locally (passed using the -certfile option for example).</p> </li> <li> <p>-noattr</p> <p>normally when a message is signed a set of attributes are included which include the signing time and supported symmetric algorithms. With this option they are not included.</p> </li> <li> <p>-nosmimecap</p> <p>exclude the list of supported algorithms from signed attributes, other options such as signing time and content type are still included.</p> </li> <li> <p>-binary</p> <p>normally the input message is converted to \"canonical\" format which is effectively using CR and LF as end of line: as required by the S/MIME specification. When this option is present no translation occurs. This is useful when handling binary data which may not be in MIME format.</p> </li> <li> <p>-nodetach</p> <p>when signing a message use opaque signing: this form is more resistant to translation by mail relays but it cannot be read by mail agents that do not support S/MIME.  Without this option cleartext signing with the MIME type multipart/signed is used.</p> </li> <li> <p>-certfile file</p> <p>allows additional certificates to be specified. When signing these will be included with the message. When verifying these will be searched for the signers certificates. The certificates should be in PEM format.</p> </li> <li> <p>-certsout file</p> <p>any certificates contained in the message are written to file.</p> </li> <li> <p>-signer file</p> <p>a signing certificate when signing or resigning a message, this option can be used multiple times if more than one signer is required. If a message is being verified then the signers certificates will be written to this file if the verification was successful.</p> </li> <li> <p>-recip file</p> <p>when decrypting a message this specifies the recipients certificate. The certificate must match one of the recipients of the message or an error occurs.</p> <p>When encrypting a message this option may be used multiple times to specify each recipient. This form must be used if customised parameters are required (for example to specify RSA-OAEP).</p> <p>Only certificates carrying RSA, Diffie-Hellman or EC keys are supported by this option.</p> </li> <li> <p>-keyid</p> <p>use subject key identifier to identify certificates instead of issuer name and serial number. The supplied certificate must include a subject key identifier extension. Supported by -sign and -encrypt options.</p> </li> <li> <p>-receipt_request_all -receipt_request_first</p> <p>for -sign option include a signed receipt request. Indicate requests should be provided by all receipient or first tier recipients (those mailed directly and not from a mailing list). Ignored it -receipt_request_from is included.</p> </li> <li> <p>-receipt_request_from emailaddress</p> <p>for -sign option include a signed receipt request. Add an explicit email address where receipts should be supplied.</p> </li> <li> <p>-receipt_request_to emailaddress</p> <p>Add an explicit email address where signed receipts should be sent to. This  option must but supplied if a signed receipt it requested.</p> </li> <li> <p>-receipt_request_print</p> <p>For the -verify operation print out the contents of any signed receipt requests.</p> </li> <li> <p>-secretkey key</p> <p>specify symmetric key to use. The key must be supplied in hex format and be consistent with the algorithm used. Supported by the -EncryptedData_encrypt -EncrryptedData_decrypt, -encrypt and -decrypt options. When used with -encrypt or -decrypt the supplied key is used to wrap or unwrap the content encryption key using an AES key in the KEKRecipientInfo type.</p> </li> <li> <p>-secretkeyid id</p> <p>the key identifier for the supplied symmetric key for KEKRecipientInfo type. This option must be present if the -secretkey option is used with -encrypt. With -decrypt operations the id is used to locate the relevant key if it is not supplied then an attempt is used to decrypt any KEKRecipientInfo structures.</p> </li> <li> <p>-econtent_type type</p> <p>set the encapsulated content type to type if not supplied the Data type is used. The type argument can be any valid OID name in either text or numerical format. </p> </li> <li> <p>-inkey file</p> <p>the private key to use when signing or decrypting. This must match the corresponding certificate. If this option is not specified then the private key must be included in the certificate file specified with the -recip or -signer file. When signing this option can be used multiple times to specify successive keys.</p> </li> <li> <p>-keyopt name:opt</p> <p>for signing and encryption this option can be used multiple times to set customised parameters for the preceding key or certificate. It can currently be used to set RSA-PSS for signing, RSA-OAEP for encryption or to modify default parameters for ECDH.</p> </li> <li> <p>-passin arg</p> <p>the private key password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-rand file(s)</p> <p>a file or files containing random data used to seed the random number generator, or an EGD socket (see RAND_egd(3)). Multiple files can be specified separated by a OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others.</p> </li> <li> <p>cert.pem...</p> <p>one or more certificates of message recipients: used when encrypting a message. </p> </li> <li> <p>-to, -from, -subject</p> <p>the relevant mail headers. These are included outside the signed portion of a message so they may be included manually. If signing then many S/MIME mail clients check the signers certificate's email address matches that specified in the From: address.</p> </li> <li> <p>-purpose, -ignore_critical, -issuer_checks, -crl_check, -crl_check_all, -policy_check, -extended_crl, -x509_strict, -policy -check_ss_sig -no_alt_chains</p> <p>Set various certificate chain valiadition option. See the verify manual page for details.</p> </li> </ul>"},{"location":"man1/cms/#notes","title":"NOTES","text":"<p>The MIME message must be sent without any blank lines between the headers and the output. Some mail programs will automatically add a blank line. Piping the mail directly to sendmail is one way to achieve the correct format.</p> <p>The supplied message to be signed or encrypted must include the necessary MIME headers or many S/MIME clients wont display it properly (if at all). You can use the -text option to automatically add plain text headers.</p> <p>A \"signed and encrypted\" message is one where a signed message is then encrypted. This can be produced by encrypting an already signed message: see the examples section.</p> <p>This version of the program only allows one signer per message but it will verify multiple signers on received messages. Some S/MIME clients choke if a message contains multiple signers. It is possible to sign messages \"in parallel\" by signing an already signed message.</p> <p>The options -encrypt and -decrypt reflect common usage in S/MIME clients. Strictly speaking these process CMS enveloped data: CMS encrypted data is used for other purposes.</p> <p>The -resign option uses an existing message digest when adding a new signer. This means that attributes must be present in at least one existing signer using the same message digest or this operation will fail.</p> <p>The -stream and -indef options enable experimental streaming I/O support. As a result the encoding is BER using indefinite length constructed encoding and no longer DER. Streaming is supported for the -encrypt operation and the -sign operation if the content is not detached.</p> <p>Streaming is always used for the -sign operation with detached data but since the content is no longer part of the CMS structure the encoding remains DER.</p> <p>If the -decrypt option is used without a recipient certificate then an attempt is made to locate the recipient by trying each potential recipient in turn using the supplied private key. To thwart the MMA attack (Bleichenbacher's attack on PKCS #1 v1.5 RSA padding) all recipients are tried whether they succeed or not and if no recipients match the message is \"decrypted\" using a random key which will typically output garbage.  The -debug_decrypt option can be used to disable the MMA attack protection and return an error if no recipient can be found: this option should be used with caution. For a fuller description see CMS_decrypt(3)).</p>"},{"location":"man1/cms/#exit-codes","title":"EXIT CODES","text":"<ul> <li> <p>0</p> <p>the operation was completely successfully.</p> </li> <li> <p>1</p> <p>an error occurred parsing the command options.</p> </li> <li> <p>2</p> <p>one of the input files could not be read.</p> </li> <li> <p>3</p> <p>an error occurred creating the CMS file or when reading the MIME message.</p> </li> <li> <p>4</p> <p>an error occurred decrypting or verifying the message.</p> </li> <li> <p>5</p> <p>the message was verified correctly but an error occurred writing out the signers certificates.</p> </li> </ul>"},{"location":"man1/cms/#compatibility-with-pkcs7-format","title":"COMPATIBILITY WITH PKCS#7 format.","text":"<p>The smime utility can only process the older PKCS#7 format. The cms utility supports Cryptographic Message Syntax format. Use of some features will result in messages which cannot be processed by applications which only support the older format. These are detailed below.</p> <p>The use of the -keyid option with -sign or -encrypt.</p> <p>The -outform PEM option uses different headers.</p> <p>The -compress option.</p> <p>The -secretkey option when used with -encrypt.</p> <p>The use of PSS with -sign.</p> <p>The use of OAEP or non-RSA keys with -encrypt.</p> <p>Additionally the -EncryptedData_create and -data_create type cannot be processed by the older smime command.</p>"},{"location":"man1/cms/#examples","title":"EXAMPLES","text":"<p>Create a cleartext signed message:</p> <pre><code>openssl cms -sign -in message.txt -text -out mail.msg \\\n       -signer mycert.pem\n</code></pre> <p>Create an opaque signed message</p> <pre><code>openssl cms -sign -in message.txt -text -out mail.msg -nodetach \\\n       -signer mycert.pem\n</code></pre> <p>Create a signed message, include some additional certificates and read the private key from another file:</p> <pre><code>openssl cms -sign -in in.txt -text -out mail.msg \\\n       -signer mycert.pem -inkey mykey.pem -certfile mycerts.pem\n</code></pre> <p>Create a signed message with two signers, use key identifier:</p> <pre><code>openssl cms -sign -in message.txt -text -out mail.msg \\\n       -signer mycert.pem -signer othercert.pem -keyid\n</code></pre> <p>Send a signed message under Unix directly to sendmail, including headers:</p> <pre><code>openssl cms -sign -in in.txt -text -signer mycert.pem \\\n       -from steve@openssl.org -to someone@somewhere \\\n       -subject \"Signed message\" | sendmail someone@somewhere\n</code></pre> <p>Verify a message and extract the signer's certificate if successful:</p> <pre><code>openssl cms -verify -in mail.msg -signer user.pem -out signedtext.txt\n</code></pre> <p>Send encrypted mail using triple DES:</p> <pre><code>openssl cms -encrypt -in in.txt -from steve@openssl.org \\\n       -to someone@somewhere -subject \"Encrypted message\" \\\n       -des3 user.pem -out mail.msg\n</code></pre> <p>Sign and encrypt mail:</p> <pre><code>openssl cms -sign -in ml.txt -signer my.pem -text \\\n       | openssl cms -encrypt -out mail.msg \\\n       -from steve@openssl.org -to someone@somewhere \\\n       -subject \"Signed and Encrypted message\" -des3 user.pem\n</code></pre> <p>Note: the encryption command does not include the -text option because the message being encrypted already has MIME headers.</p> <p>Decrypt mail:</p> <pre><code>openssl cms -decrypt -in mail.msg -recip mycert.pem -inkey key.pem\n</code></pre> <p>The output from Netscape form signing is a PKCS#7 structure with the detached signature format. You can use this program to verify the signature by line wrapping the base64 encoded structure and surrounding it with:</p> <pre><code>-----BEGIN PKCS7-----\n-----END PKCS7-----\n</code></pre> <p>and using the command, </p> <pre><code>openssl cms -verify -inform PEM -in signature.pem -content content.txt\n</code></pre> <p>alternatively you can base64 decode the signature and use</p> <pre><code>openssl cms -verify -inform DER -in signature.der -content content.txt\n</code></pre> <p>Create an encrypted message using 128 bit Camellia:</p> <pre><code>openssl cms -encrypt -in plain.txt -camellia128 -out mail.msg cert.pem\n</code></pre> <p>Add a signer to an existing message:</p> <pre><code>openssl cms -resign -in mail.msg -signer newsign.pem -out mail2.msg\n</code></pre> <p>Sign mail using RSA-PSS:</p> <pre><code>openssl cms -sign -in message.txt -text -out mail.msg \\\n       -signer mycert.pem -keyopt rsa_padding_mode:pss\n</code></pre> <p>Create encrypted mail using RSA-OAEP:</p> <pre><code>openssl cms -encrypt -in plain.txt -out mail.msg \\\n       -recip cert.pem -keyopt rsa_padding_mode:oaep\n</code></pre> <p>Use SHA256 KDF with an ECDH certificate:</p> <pre><code>openssl cms -encrypt -in plain.txt -out mail.msg \\\n       -recip ecdhcert.pem -keyopt ecdh_kdf_md:sha256\n</code></pre>"},{"location":"man1/cms/#bugs","title":"BUGS","text":"<p>The MIME parser isn't very clever: it seems to handle most messages that I've thrown at it but it may choke on others.</p> <p>The code currently will only write out the signer's certificate to a file: if the signer has a separate encryption certificate this must be manually extracted. There should be some heuristic that determines the correct encryption certificate.</p> <p>Ideally a database should be maintained of a certificates for each email address.</p> <p>The code doesn't currently take note of the permitted symmetric encryption algorithms as supplied in the SMIMECapabilities signed attribute. this means the user has to manually include the correct encryption algorithm. It should store the list of permitted ciphers in a database and only use those.</p> <p>No revocation checking is done on the signer's certificate.</p>"},{"location":"man1/cms/#history","title":"HISTORY","text":"<p>The use of multiple -signer options and the -resign command were first added in OpenSSL 1.0.0.</p> <p>The keyopt option was first added in OpenSSL 1.0.2.</p> <p>Support for RSA-OAEP and RSA-PSS was first added to OpenSSL 1.0.2.</p> <p>The use of non-RSA keys with -encrypt and -decrypt was first added to OpenSSL 1.0.2.</p> <p>The -no_alt_chains options was first added to OpenSSL 1.0.2b.</p>"},{"location":"man1/config/","title":"config","text":""},{"location":"man1/config/#name","title":"NAME","text":"<p>config - OpenSSL CONF library configuration files</p>"},{"location":"man1/config/#description","title":"DESCRIPTION","text":"<p>The OpenSSL CONF library can be used to read configuration files. It is used for the OpenSSL master configuration file openssl.cnf and in a few other places like SPKAC files and certificate extension files for the x509 utility. OpenSSL applications can also use the CONF library for their own purposes.</p> <p>A configuration file is divided into a number of sections. Each section starts with a line [ section_name ] and ends when a new section is started or end of file is reached. A section name can consist of alphanumeric characters and underscores.</p> <p>The first section of a configuration file is special and is referred to as the default section. This section is usually unnamed and spans from the start of file until the first named section. When a name is being looked up it is first looked up in a named section (if any) and then the default section.</p> <p>The environment is mapped onto a section called ENV.</p> <p>Comments can be included by preceding them with the # character</p> <p>Each section in a configuration file consists of a number of name and value pairs of the form name=value</p> <p>The name string can contain any alphanumeric characters as well as a few punctuation symbols such as . , ; and _.</p> <p>The value string consists of the string following the = character until end of line with any leading and trailing white space removed.</p> <p>The value string undergoes variable expansion. This can be done by including the form $var or ${var}: this will substitute the value of the named variable in the current section. It is also possible to substitute a value from another section using the syntax $section::name or ${section::name}. By using the form $ENV::name environment variables can be substituted. It is also possible to assign values to environment variables by using the name ENV::name, this will work if the program looks up environment variables using the CONF library instead of calling getenv() directly. The value string must not exceed 64k in length after variable expansion. Otherwise an error will occur.</p> <p>It is possible to escape certain characters by using any kind of quote or the \\ character. By making the last character of a line a \\ a value string can be spread across multiple lines. In addition the sequences \\n, \\r, \\b and \\t are recognized.</p>"},{"location":"man1/config/#openssl-library-configuration","title":"OPENSSL LIBRARY CONFIGURATION","text":"<p>In OpenSSL 0.9.7 and later applications can automatically configure certain aspects of OpenSSL using the master OpenSSL configuration file, or optionally an alternative configuration file. The openssl utility includes this functionality: any sub command uses the master OpenSSL configuration file unless an option is used in the sub command to use an alternative configuration file.</p> <p>To enable library configuration the default section needs to contain an  appropriate line which points to the main configuration section. The default name is openssl_conf which is used by the openssl utility. Other applications may use an alternative name such as myapplicaton_conf.</p> <p>The configuration section should consist of a set of name value pairs which contain specific module configuration information. The name represents the name of the configuration module the meaning of the value is  module specific: it may, for example, represent a further configuration section containing configuration module specific information. E.g.</p> <pre><code>openssl_conf = openssl_init\n\n[openssl_init]\n\noid_section = new_oids\nengines = engine_section\n\n[new_oids]\n\n... new oids here ...\n\n[engine_section]\n\n... engine stuff here ...\n</code></pre> <p>The features of each configuration module are described below.</p>"},{"location":"man1/config/#asn1-object-configuration-module","title":"ASN1 OBJECT CONFIGURATION MODULE","text":"<p>This module has the name oid_section. The value of this variable points to a section containing name value pairs of OIDs: the name is the OID short and long name, the value is the numerical form of the OID. Although some of the openssl utility sub commands already have their own ASN1 OBJECT section functionality not all do. By using the ASN1 OBJECT configuration module all the openssl utility sub commands can see the new objects as well as any compliant applications. For example:</p> <pre><code>[new_oids]\n\nsome_new_oid = 1.2.3.4\nsome_other_oid = 1.2.3.5\n</code></pre> <p>In OpenSSL 0.9.8 it is also possible to set the value to the long name followed by a comma and the numerical OID form. For example:</p> <pre><code>shortName = some object long name, 1.2.3.4\n</code></pre>"},{"location":"man1/config/#engine-configuration-module","title":"ENGINE CONFIGURATION MODULE","text":"<p>This ENGINE configuration module has the name engines. The value of this variable points to a section containing further ENGINE configuration information.</p> <p>The section pointed to by engines is a table of engine names (though see engine_id below) and further sections containing configuration information specific to each ENGINE.</p> <p>Each ENGINE specific section is used to set default algorithms, load dynamic, perform initialization and send ctrls. The actual operation performed depends on the command name which is the name of the name value pair. The currently supported commands are listed below.</p> <p>For example:</p> <pre><code>[engine_section]\n\n# Configure ENGINE named \"foo\"\nfoo = foo_section\n# Configure ENGINE named \"bar\"\nbar = bar_section\n\n[foo_section]\n... foo ENGINE specific commands ...\n\n[bar_section]\n... \"bar\" ENGINE specific commands ...\n</code></pre> <p>The command engine_id is used to give the ENGINE name. If used this  command must be first. For example:</p> <pre><code>[engine_section]\n# This would normally handle an ENGINE named \"foo\"\nfoo = foo_section\n\n[foo_section]\n# Override default name and use \"myfoo\" instead.\nengine_id = myfoo\n</code></pre> <p>The command dynamic_path loads and adds an ENGINE from the given path. It is equivalent to sending the ctrls SO_PATH with the path argument followed by LIST_ADD with value 2 and LOAD to the dynamic ENGINE. If this is not the required behaviour then alternative ctrls can be sent directly to the dynamic ENGINE using ctrl commands.</p> <p>The command init determines whether to initialize the ENGINE. If the value is 0 the ENGINE will not be initialized, if 1 and attempt it made to initialized the ENGINE immediately. If the init command is not present then an attempt will be made to initialize the ENGINE after all commands in its section have been processed.</p> <p>The command default_algorithms sets the default algorithms an ENGINE will supply using the functions ENGINE_set_default_string()</p> <p>If the name matches none of the above command names it is assumed to be a ctrl command which is sent to the ENGINE. The value of the command is the  argument to the ctrl command. If the value is the string EMPTY then no value is sent to the command.</p> <p>For example:</p> <pre><code>[engine_section]\n\n# Configure ENGINE named \"foo\"\nfoo = foo_section\n\n[foo_section]\n# Load engine from DSO\ndynamic_path = /some/path/fooengine.so\n# A foo specific ctrl.\nsome_ctrl = some_value\n# Another ctrl that doesn't take a value.\nother_ctrl = EMPTY\n# Supply all default algorithms\ndefault_algorithms = ALL\n</code></pre>"},{"location":"man1/config/#evp-configuration-module","title":"EVP CONFIGURATION MODULE","text":"<p>This modules has the name alg_section which points to a section containing algorithm commands.</p> <p>Currently the only algorithm command supported is fips_mode whose value should be a boolean string such as on or off. If the value is on this attempt to enter FIPS mode. If the call fails or the library is not FIPS capable then an error occurs.</p> <p>For example:</p> <pre><code>alg_section = evp_settings\n\n[evp_settings]\n\nfips_mode = on\n</code></pre>"},{"location":"man1/config/#notes","title":"NOTES","text":"<p>If a configuration file attempts to expand a variable that doesn't exist then an error is flagged and the file will not load. This can happen if an attempt is made to expand an environment variable that doesn't exist. For example in a previous version of OpenSSL the default OpenSSL master configuration file used the value of HOME which may not be defined on non Unix systems and would cause an error.</p> <p>This can be worked around by including a default section to provide a default value: then if the environment lookup fails the default value will be used instead. For this to work properly the default value must be defined earlier in the configuration file than the expansion. See the EXAMPLES section for an example of how to do this.</p> <p>If the same variable exists in the same section then all but the last value will be silently ignored. In certain circumstances such as with DNs the same field may occur multiple times. This is usually worked around by ignoring any characters before an initial . e.g.</p> <pre><code>1.OU=\"My first OU\"\n2.OU=\"My Second OU\"\n</code></pre>"},{"location":"man1/config/#examples","title":"EXAMPLES","text":"<p>Here is a sample configuration file using some of the features mentioned above.</p> <pre><code># This is the default section.\n\nHOME=/temp\nRANDFILE= ${ENV::HOME}/.rnd\nconfigdir=$ENV::HOME/config\n\n[ section_one ]\n\n# We are now in section one.\n\n# Quotes permit leading and trailing whitespace\nany = \" any variable name \"\n\nother = A string that can \\\ncover several lines \\\nby including \\\\ characters\n\nmessage = Hello World\\n\n\n[ section_two ]\n\ngreeting = $section_one::message\n</code></pre> <p>This next example shows how to expand environment variables safely.</p> <p>Suppose you want a variable called tmpfile to refer to a temporary filename. The directory it is placed in can determined by the the TEMP or TMP environment variables but they may not be set to any value at all. If you just include the environment variable names and the variable doesn't exist then this will cause an error when an attempt is made to load the configuration file. By making use of the default section both values can be looked up with TEMP taking  priority and /tmp used if neither is defined:</p> <pre><code>TMP=/tmp\n# The above value is used if TMP isn't in the environment\nTEMP=$ENV::TMP\n# The above value is used if TEMP isn't in the environment\ntmpfile=${ENV::TEMP}/tmp.filename\n</code></pre> <p>Simple OpenSSL library configuration example to enter FIPS mode:</p> <pre><code># Default appname: should match \"appname\" parameter (if any)\n# supplied to CONF_modules_load_file et al.\nopenssl_conf = openssl_conf_section\n\n[openssl_conf_section]\n# Configuration module list\nalg_section = evp_sect\n\n[evp_sect]\n# Set to \"yes\" to enter FIPS mode if supported\nfips_mode = yes\n</code></pre> <p>Note: in the above example you will get an error in non FIPS capable versions of OpenSSL.</p> <p>More complex OpenSSL library configuration. Add OID and don't enter FIPS mode:</p> <pre><code># Default appname: should match \"appname\" parameter (if any)\n# supplied to CONF_modules_load_file et al.\nopenssl_conf = openssl_conf_section\n\n[openssl_conf_section]\n# Configuration module list\nalg_section = evp_sect\noid_section = new_oids\n\n[evp_sect]\n# This will have no effect as FIPS mode is off by default.\n# Set to \"yes\" to enter FIPS mode, if supported\nfips_mode = no\n\n[new_oids]\n# New OID, just short name\nnewoid1 = 1.2.3.4.1\n# New OID shortname and long name\nnewoid2 = New OID 2 long name, 1.2.3.4.2\n</code></pre> <p>The above examples can be used with with any application supporting library configuration if \"openssl_conf\" is modified to match the appropriate \"appname\".</p> <p>For example if the second sample file above is saved to \"example.cnf\" then the command line:</p> <pre><code>OPENSSL_CONF=example.cnf openssl asn1parse -genstr OID:1.2.3.4.1\n</code></pre> <p>will output:</p> <pre><code>0:d=0  hl=2 l=   4 prim: OBJECT            :newoid1\n</code></pre> <p>showing that the OID \"newoid1\" has been added as \"1.2.3.4.1\".</p>"},{"location":"man1/config/#bugs","title":"BUGS","text":"<p>Currently there is no way to include characters using the octal \\nnn form. Strings are all null terminated so nulls cannot form part of the value.</p> <p>The escaping isn't quite right: if you want to use sequences like \\n you can't use any quote escaping on the same line.</p> <p>Files are loaded in a single pass. This means that an variable expansion will only work if the variables referenced are defined earlier in the file.</p>"},{"location":"man1/config/#see-also","title":"SEE ALSO","text":"<p>x509(1), req(1), ca(1)</p>"},{"location":"man1/crl/","title":"crl","text":""},{"location":"man1/crl/#name","title":"NAME","text":"<p>openssl-crl, crl - CRL utility</p>"},{"location":"man1/crl/#synopsis","title":"SYNOPSIS","text":"<p>openssl crl [-inform PEM|DER] [-outform PEM|DER] [-text] [-in filename] [-out filename] [-nameopt option] [-noout] [-hash] [-issuer] [-lastupdate] [-nextupdate] [-CAfile file] [-CApath dir]</p>"},{"location":"man1/crl/#description","title":"DESCRIPTION","text":"<p>The crl command processes CRL files in DER or PEM format.</p>"},{"location":"man1/crl/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-inform DER|PEM</p> <p>This specifies the input format. DER format is DER encoded CRL structure. PEM (the default) is a base64 encoded version of the DER form with header and footer lines.</p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read from or standard input if this option is not specified.</p> </li> <li> <p>-out filename</p> <p>specifies the output filename to write to or standard output by default.</p> </li> <li> <p>-text</p> <p>print out the CRL in text form.</p> </li> <li> <p>-nameopt option</p> <p>option which determines how the subject or issuer names are displayed. See the description of -nameopt in x509(1).</p> </li> <li> <p>-noout</p> <p>don't output the encoded version of the CRL.</p> </li> <li> <p>-hash</p> <p>output a hash of the issuer name. This can be use to lookup CRLs in a directory by issuer name.</p> </li> <li> <p>-hash_old</p> <p>outputs the \"hash\" of the CRL issuer name using the older algorithm as used by OpenSSL versions before 1.0.0.</p> </li> <li> <p>-issuer</p> <p>output the issuer name.</p> </li> <li> <p>-lastupdate</p> <p>output the lastUpdate field.</p> </li> <li> <p>-nextupdate</p> <p>output the nextUpdate field.</p> </li> <li> <p>-CAfile file</p> <p>verify the signature on a CRL by looking up the issuing certificate in file</p> </li> <li> <p>-CApath dir</p> <p>verify the signature on a CRL by looking up the issuing certificate in dir. This directory must be a standard certificate directory: that is a hash of each subject name (using x509 -hash) should be linked to each certificate.</p> </li> </ul>"},{"location":"man1/crl/#notes","title":"NOTES","text":"<p>The PEM CRL format uses the header and footer lines:</p> <pre><code>-----BEGIN X509 CRL-----\n-----END X509 CRL-----\n</code></pre>"},{"location":"man1/crl/#examples","title":"EXAMPLES","text":"<p>Convert a CRL file from PEM to DER:</p> <pre><code>openssl crl -in crl.pem -outform DER -out crl.der\n</code></pre> <p>Output the text form of a DER encoded certificate:</p> <pre><code>openssl crl -in crl.der -inform DER -text -noout\n</code></pre>"},{"location":"man1/crl/#bugs","title":"BUGS","text":"<p>Ideally it should be possible to create a CRL using appropriate options and files too.</p>"},{"location":"man1/crl/#see-also","title":"SEE ALSO","text":"<p>crl2pkcs7(1), ca(1), x509(1)</p>"},{"location":"man1/crl2pkcs7/","title":"crl2pkcs7","text":""},{"location":"man1/crl2pkcs7/#name","title":"NAME","text":"<p>openssl-crl2pkcs7, crl2pkcs7 - Create a PKCS#7 structure from a CRL and certificates.</p>"},{"location":"man1/crl2pkcs7/#synopsis","title":"SYNOPSIS","text":"<p>openssl crl2pkcs7 [-inform PEM|DER] [-outform PEM|DER] [-in filename] [-out filename] [-certfile filename] [-nocrl]</p>"},{"location":"man1/crl2pkcs7/#description","title":"DESCRIPTION","text":"<p>The crl2pkcs7 command takes an optional CRL and one or more certificates and converts them into a PKCS#7 degenerate \"certificates only\" structure.</p>"},{"location":"man1/crl2pkcs7/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-inform DER|PEM</p> <p>This specifies the CRL input format. DER format is DER encoded CRL structure.PEM (the default) is a base64 encoded version of the DER form with header and footer lines.</p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the PKCS#7 structure output format. DER format is DER encoded PKCS#7 structure.PEM (the default) is a base64 encoded version of the DER form with header and footer lines.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read a CRL from or standard input if this option is not specified.</p> </li> <li> <p>-out filename</p> <p>specifies the output filename to write the PKCS#7 structure to or standard output by default.</p> </li> <li> <p>-certfile filename</p> <p>specifies a filename containing one or more certificates in PEM format. All certificates in the file will be added to the PKCS#7 structure. This option can be used more than once to read certificates form multiple files.</p> </li> <li> <p>-nocrl</p> <p>normally a CRL is included in the output file. With this option no CRL is included in the output file and a CRL is not read from the input file.</p> </li> </ul>"},{"location":"man1/crl2pkcs7/#examples","title":"EXAMPLES","text":"<p>Create a PKCS#7 structure from a certificate and CRL:</p> <pre><code>openssl crl2pkcs7 -in crl.pem -certfile cert.pem -out p7.pem\n</code></pre> <p>Creates a PKCS#7 structure in DER format with no CRL from several different certificates:</p> <pre><code>openssl crl2pkcs7 -nocrl -certfile newcert.pem \n       -certfile demoCA/cacert.pem -outform DER -out p7.der\n</code></pre>"},{"location":"man1/crl2pkcs7/#notes","title":"NOTES","text":"<p>The output file is a PKCS#7 signed data structure containing no signers and just certificates and an optional CRL.</p> <p>This utility can be used to send certificates and CAs to Netscape as part of the certificate enrollment process. This involves sending the DER encoded output as MIME type application/x-x509-user-cert.</p> <p>The PEM encoded form with the header and footer lines removed can be used to install user certificates and CAs in MSIE using the Xenroll control.</p>"},{"location":"man1/crl2pkcs7/#see-also","title":"SEE ALSO","text":"<p>pkcs7(1)</p>"},{"location":"man1/dgst/","title":"dgst","text":""},{"location":"man1/dgst/#name","title":"NAME","text":"<p>openssl-dgst, dgst, sha, sha1, mdc2, ripemd160, sha224, sha256, sha384, sha512, md2, md4, md5, dss1 - message digests</p>"},{"location":"man1/dgst/#synopsis","title":"SYNOPSIS","text":"<p>openssl dgst  [-sha|-sha1|-mdc2|-ripemd160|-sha224|-sha256|-sha384|-sha512|-md2|-md4|-md5|-dss1] [-c] [-d] [-hex] [-binary] [-r] [-non-fips-allow] [-out filename] [-sign filename] [-keyform arg] [-passin arg] [-verify filename] [-prverify filename] [-signature filename] [-hmac key] [-non-fips-allow] [-fips-fingerprint] [file...]</p> <p>openssl [digest] [...]</p>"},{"location":"man1/dgst/#description","title":"DESCRIPTION","text":"<p>The digest functions output the message digest of a supplied file or files in hexadecimal.  The digest functions also generate and verify digital signatures using message digests.</p>"},{"location":"man1/dgst/#options","title":"OPTIONS","text":"<ul> <li> <p>-c</p> <p>print out the digest in two digit groups separated by colons, only relevant if hex format output is used.</p> </li> <li> <p>-d</p> <p>print out BIO debugging information.</p> </li> <li> <p>-hex</p> <p>digest is to be output as a hex dump. This is the default case for a \"normal\" digest as opposed to a digital signature.  See NOTES below for digital signatures using -hex.</p> </li> <li> <p>-binary</p> <p>output the digest or signature in binary form.</p> </li> <li> <p>-r</p> <p>output the digest in the \"coreutils\" format used by programs like sha1sum.</p> </li> <li> <p>-non-fips-allow</p> <p>Allow use of non FIPS digest when in FIPS mode.  This has no effect when not in FIPS mode.</p> </li> <li> <p>-out filename</p> <p>filename to output to, or standard output by default.</p> </li> <li> <p>-sign filename</p> <p>digitally sign the digest using the private key in \"filename\".</p> </li> <li> <p>-keyform arg</p> <p>Specifies the key format to sign digest with. The DER, PEM, P12, and ENGINE formats are supported.</p> </li> <li> <p>-engine id</p> <p>Use engine id for operations (including private key storage). This engine is not used as source for digest algorithms, unless it is also specified in the configuration file.</p> </li> <li> <p>-sigopt nm:v</p> <p>Pass options to the signature algorithm during sign or verify operations. Names and values of these options are algorithm-specific.</p> </li> <li> <p>-passin arg</p> <p>the private key password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-verify filename</p> <p>verify the signature using the the public key in \"filename\". The output is either \"Verification OK\" or \"Verification Failure\".</p> </li> <li> <p>-prverify filename</p> <p>verify the signature using the  the private key in \"filename\".</p> </li> <li> <p>-signature filename</p> <p>the actual signature to verify.</p> </li> <li> <p>-hmac key</p> <p>create a hashed MAC using \"key\".</p> </li> <li> <p>-mac alg</p> <p>create MAC (keyed Message Authentication Code). The most popular MAC algorithm is HMAC (hash-based MAC), but there are other MAC algorithms which are not based on hash, for instance gost-mac algorithm, supported by ccgost engine. MAC keys and other options should be set via -macopt parameter.</p> </li> <li> <p>-macopt nm:v</p> <p>Passes options to MAC algorithm, specified by -mac key. Following options are supported by both by HMAC and gost-mac:</p> <ul> <li> <p>key:string</p> <p>Specifies MAC key as alphnumeric string (use if key contain printable characters only). String length must conform to any restrictions of the MAC algorithm for example exactly 32 chars for gost-mac.</p> </li> <li> <p>hexkey:string</p> <p>Specifies MAC key in hexadecimal form (two hex digits per byte). Key length must conform to any restrictions of the MAC algorithm for example exactly 32 chars for gost-mac.</p> </li> </ul> </li> <li> <p>-rand file(s)</p> <p>a file or files containing random data used to seed the random number generator, or an EGD socket (see RAND_egd(3)). Multiple files can be specified separated by a OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others. </p> </li> <li> <p>-non-fips-allow</p> <p>enable use of non-FIPS algorithms such as MD5 even in FIPS mode.</p> </li> <li> <p>-fips-fingerprint</p> <p>compute HMAC using a specific key for certain OpenSSL-FIPS operations.</p> </li> <li> <p>file...</p> <p>file or files to digest. If no files are specified then standard input is used.</p> </li> </ul>"},{"location":"man1/dgst/#examples","title":"EXAMPLES","text":"<p>To create a hex-encoded message digest of a file:  openssl dgst -md5 -hex file.txt</p> <p>To sign a file using SHA-256 with binary file output:  openssl dgst -sha256 -sign privatekey.pem -out signature.sign file.txt</p> <p>To verify a signature:  openssl dgst -sha256 -verify publickey.pem \\  -signature signature.sign \\  file.txt</p>"},{"location":"man1/dgst/#notes","title":"NOTES","text":"<p>The digest of choice for all new applications is SHA1. Other digests are however still widely used.</p> <p>When signing a file, dgst will automatically determine the algorithm (RSA, ECC, etc) to use for signing based on the private key's ASN.1 info. When verifying signatures, it only handles the RSA, DSA, or ECDSA signature itself, not the related data to identify the signer and algorithm used in formats such as x.509, CMS, and S/MIME.</p> <p>A source of random numbers is required for certain signing algorithms, in particular ECDSA and DSA.</p> <p>The signing and verify options should only be used if a single file is being signed or verified.</p> <p>Hex signatures cannot be verified using openssl.  Instead, use \"xxd -r\" or similar program to transform the hex signature into a binary signature prior to verification.</p>"},{"location":"man1/dhparam/","title":"dhparam","text":""},{"location":"man1/dhparam/#name","title":"NAME","text":"<p>openssl-dhparam, dhparam - DH parameter manipulation and generation</p>"},{"location":"man1/dhparam/#synopsis","title":"SYNOPSIS","text":"<p>openssl dhparam [-inform DER|PEM] [-outform DER|PEM] [-in filename] [-out filename] [-dsaparam] [-check] [-noout] [-text] [-C] [-2] [-5] [-rand file(s)] [-engine id] [numbits]</p>"},{"location":"man1/dhparam/#description","title":"DESCRIPTION","text":"<p>This command is used to manipulate DH parameter files.</p>"},{"location":"man1/dhparam/#options","title":"OPTIONS","text":"<ul> <li> <p>-inform DER|PEM</p> <p>This specifies the input format. The DER option uses an ASN1 DER encoded form compatible with the PKCS#3 DHparameter structure. The PEM form is the default format: it consists of the DER format base64 encoded with additional header and footer lines.</p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read parameters from or standard input if this option is not specified.</p> </li> <li> <p>-out filename</p> <p>This specifies the output filename parameters to. Standard output is used if this option is not present. The output filename should not be the same as the input filename.</p> </li> <li> <p>-dsaparam</p> <p>If this option is used, DSA rather than DH parameters are read or created; they are converted to DH format.  Otherwise, \"strong\" primes (such that (p-1)/2 is also prime) will be used for DH parameter generation.</p> <p>DH parameter generation with the -dsaparam option is much faster, and the recommended exponent length is shorter, which makes DH key exchange more efficient.  Beware that with such DSA-style DH parameters, a fresh DH key should be created for each use to avoid small-subgroup attacks that may be possible otherwise.</p> </li> <li> <p>-check</p> <p>check if the parameters are valid primes and generator.</p> </li> <li> <p>-2, -5</p> <p>The generator to use, either 2 or 5. If present then the input file is ignored and parameters are generated instead. If not present but numbits is present, parameters are generated with the default generator 2.</p> </li> <li> <p>-rand file(s)</p> <p>a file or files containing random data used to seed the random number generator, or an EGD socket (see RAND_egd(3)). Multiple files can be specified separated by a OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others.</p> </li> <li> <p>numbits</p> <p>this option specifies that a parameter set should be generated of size numbits. It must be the last option. If this option is present then the input file is ignored and parameters are generated instead. If this option is not present but a generator (-2 or -5) is present, parameters are generated with a default length of 2048 bits.</p> </li> <li> <p>-noout</p> <p>this option inhibits the output of the encoded version of the parameters.</p> </li> <li> <p>-text</p> <p>this option prints out the DH parameters in human readable form.</p> </li> <li> <p>-C</p> <p>this option converts the parameters into C code. The parameters can then be loaded by calling the get_dhnumbits() function.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause dhparam to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> </ul>"},{"location":"man1/dhparam/#warnings","title":"WARNINGS","text":"<p>The program dhparam combines the functionality of the programs dh and gendh in previous versions of OpenSSL and SSLeay. The dh and gendh programs are retained for now but may have different purposes in future  versions of OpenSSL.</p>"},{"location":"man1/dhparam/#notes","title":"NOTES","text":"<p>PEM format DH parameters use the header and footer lines:</p> <pre><code>-----BEGIN DH PARAMETERS-----\n-----END DH PARAMETERS-----\n</code></pre> <p>OpenSSL currently only supports the older PKCS#3 DH, not the newer X9.42 DH.</p> <p>This program manipulates DH parameters not keys.</p>"},{"location":"man1/dhparam/#bugs","title":"BUGS","text":"<p>There should be a way to generate and manipulate DH keys.</p>"},{"location":"man1/dhparam/#see-also","title":"SEE ALSO","text":"<p>dsaparam(1)</p>"},{"location":"man1/dhparam/#history","title":"HISTORY","text":"<p>The dhparam command was added in OpenSSL 0.9.5. The -dsaparam option was added in OpenSSL 0.9.6.</p>"},{"location":"man1/dsa/","title":"dsa","text":""},{"location":"man1/dsa/#name","title":"NAME","text":"<p>openssl-dsa, dsa - DSA key processing</p>"},{"location":"man1/dsa/#synopsis","title":"SYNOPSIS","text":"<p>openssl dsa [-inform PEM|DER] [-outform PEM|DER] [-in filename] [-passin arg] [-out filename] [-passout arg] [-aes128] [-aes192] [-aes256] [-camellia128] [-camellia192] [-camellia256] [-des] [-des3] [-idea] [-text] [-noout] [-modulus] [-pubin] [-pubout] [-engine id]</p>"},{"location":"man1/dsa/#description","title":"DESCRIPTION","text":"<p>The dsa command processes DSA keys. They can be converted between various forms and their components printed out. Note This command uses the traditional SSLeay compatible format for private key encryption: newer applications should use the more secure PKCS#8 format using the pkcs8</p>"},{"location":"man1/dsa/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-inform DER|PEM</p> <p>This specifies the input format. The DER option with a private key uses an ASN1 DER encoded form of an ASN.1 SEQUENCE consisting of the values of version (currently zero), p, q, g, the public and private key components respectively as ASN.1 INTEGERs. When used with a public key it uses a SubjectPublicKeyInfo structure: it is an error if the key is not DSA.</p> <p>The PEM form is the default format: it consists of the DER format base64 encoded with additional header and footer lines. In the case of a private key PKCS#8 format is also accepted.</p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read a key from or standard input if this option is not specified. If the key is encrypted a pass phrase will be prompted for.</p> </li> <li> <p>-passin arg</p> <p>the input file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-out filename</p> <p>This specifies the output filename to write a key to or standard output by is not specified. If any encryption options are set then a pass phrase will be prompted for. The output filename should not be the same as the input filename.</p> </li> <li> <p>-passout arg</p> <p>the output file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-aes128|-aes192|-aes256|-camellia128|-camellia192|-camellia256|-des|-des3|-idea</p> <p>These options encrypt the private key with the specified cipher before outputting it. A pass phrase is prompted for. If none of these options is specified the key is written in plain text. This means that using the dsa utility to read in an encrypted key with no encryption option can be used to remove the pass phrase from a key, or by setting the encryption options it can be use to add or change the pass phrase. These options can only be used with PEM format output files.</p> </li> <li> <p>-text</p> <p>prints out the public, private key components and parameters.</p> </li> <li> <p>-noout</p> <p>this option prevents output of the encoded version of the key.</p> </li> <li> <p>-modulus</p> <p>this option prints out the value of the public key component of the key.</p> </li> <li> <p>-pubin</p> <p>by default a private key is read from the input file: with this option a public key is read instead.</p> </li> <li> <p>-pubout</p> <p>by default a private key is output. With this option a public key will be output instead. This option is automatically set if the input is a public key.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause dsa to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> </ul>"},{"location":"man1/dsa/#notes","title":"NOTES","text":"<p>The PEM private key format uses the header and footer lines:</p> <pre><code>-----BEGIN DSA PRIVATE KEY-----\n-----END DSA PRIVATE KEY-----\n</code></pre> <p>The PEM public key format uses the header and footer lines:</p> <pre><code>-----BEGIN PUBLIC KEY-----\n-----END PUBLIC KEY-----\n</code></pre>"},{"location":"man1/dsa/#examples","title":"EXAMPLES","text":"<p>To remove the pass phrase on a DSA private key:</p> <pre><code>openssl dsa -in key.pem -out keyout.pem\n</code></pre> <p>To encrypt a private key using triple DES:</p> <pre><code>openssl dsa -in key.pem -des3 -out keyout.pem\n</code></pre> <p>To convert a private key from PEM to DER format: </p> <pre><code>openssl dsa -in key.pem -outform DER -out keyout.der\n</code></pre> <p>To print out the components of a private key to standard output:</p> <pre><code>openssl dsa -in key.pem -text -noout\n</code></pre> <p>To just output the public part of a private key:</p> <pre><code>openssl dsa -in key.pem -pubout -out pubkey.pem\n</code></pre>"},{"location":"man1/dsa/#see-also","title":"SEE ALSO","text":"<p>dsaparam(1), gendsa(1), rsa(1), genrsa(1)</p>"},{"location":"man1/dsaparam/","title":"dsaparam","text":""},{"location":"man1/dsaparam/#name","title":"NAME","text":"<p>openssl-dsaparam, dsaparam - DSA parameter manipulation and generation</p>"},{"location":"man1/dsaparam/#synopsis","title":"SYNOPSIS","text":"<p>openssl dsaparam [-inform DER|PEM] [-outform DER|PEM] [-in filename] [-out filename] [-noout] [-text] [-C] [-rand file(s)] [-genkey] [-engine id] [numbits]</p>"},{"location":"man1/dsaparam/#description","title":"DESCRIPTION","text":"<p>This command is used to manipulate or generate DSA parameter files.</p>"},{"location":"man1/dsaparam/#options","title":"OPTIONS","text":"<ul> <li> <p>-inform DER|PEM</p> <p>This specifies the input format. The DER option uses an ASN1 DER encoded form compatible with RFC2459 (PKIX) DSS-Parms that is a SEQUENCE consisting of p, q and g respectively. The PEM form is the default format: it consists of the DER format base64 encoded with additional header and footer lines.</p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read parameters from or standard input if this option is not specified. If the numbits parameter is included then this option will be ignored.</p> </li> <li> <p>-out filename</p> <p>This specifies the output filename parameters to. Standard output is used if this option is not present. The output filename should not be the same as the input filename.</p> </li> <li> <p>-noout</p> <p>this option inhibits the output of the encoded version of the parameters.</p> </li> <li> <p>-text</p> <p>this option prints out the DSA parameters in human readable form.</p> </li> <li> <p>-C</p> <p>this option converts the parameters into C code. The parameters can then be loaded by calling the get_dsaXXX() function.</p> </li> <li> <p>-genkey</p> <p>this option will generate a DSA either using the specified or generated parameters.</p> </li> <li> <p>-rand file(s)</p> <p>a file or files containing random data used to seed the random number generator, or an EGD socket (see RAND_egd(3)). Multiple files can be specified separated by a OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others.</p> </li> <li> <p>numbits</p> <p>this option specifies that a parameter set should be generated of size numbits. It must be the last option. If this option is included then the input file (if any) is ignored.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause dsaparam to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> </ul>"},{"location":"man1/dsaparam/#notes","title":"NOTES","text":"<p>PEM format DSA parameters use the header and footer lines:</p> <pre><code>-----BEGIN DSA PARAMETERS-----\n-----END DSA PARAMETERS-----\n</code></pre> <p>DSA parameter generation is a slow process and as a result the same set of DSA parameters is often used to generate several distinct keys.</p>"},{"location":"man1/dsaparam/#see-also","title":"SEE ALSO","text":"<p>gendsa(1), dsa(1), genrsa(1), rsa(1)</p>"},{"location":"man1/ec/","title":"ec","text":""},{"location":"man1/ec/#name","title":"NAME","text":"<p>openssl-ec, ec - EC key processing</p>"},{"location":"man1/ec/#synopsis","title":"SYNOPSIS","text":"<p>openssl ec [-inform PEM|DER] [-outform PEM|DER] [-in filename] [-passin arg] [-out filename] [-passout arg] [-des] [-des3] [-idea] [-text] [-noout] [-param_out] [-pubin] [-pubout] [-conv_form arg] [-param_enc arg] [-engine id]</p>"},{"location":"man1/ec/#description","title":"DESCRIPTION","text":"<p>The ec command processes EC keys. They can be converted between various forms and their components printed out. Note OpenSSL uses the  private key format specified in 'SEC 1: Elliptic Curve Cryptography' (http://www.secg.org/). To convert a OpenSSL EC private key into the PKCS#8 private key format use the pkcs8 command.</p>"},{"location":"man1/ec/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-inform DER|PEM</p> <p>This specifies the input format. The DER option with a private key uses an ASN.1 DER encoded SEC1 private key. When used with a public key it uses the SubjectPublicKeyInfo structure as specified in RFC 3280. The PEM form is the default format: it consists of the DER format base64 encoded with additional header and footer lines. In the case of a private key PKCS#8 format is also accepted.</p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read a key from or standard input if this option is not specified. If the key is encrypted a pass phrase will be prompted for.</p> </li> <li> <p>-passin arg</p> <p>the input file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-out filename</p> <p>This specifies the output filename to write a key to or standard output by is not specified. If any encryption options are set then a pass phrase will be prompted for. The output filename should not be the same as the input filename.</p> </li> <li> <p>-passout arg</p> <p>the output file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-des|-des3|-idea</p> <p>These options encrypt the private key with the DES, triple DES, IDEA or  any other cipher supported by OpenSSL before outputting it. A pass phrase is prompted for. If none of these options is specified the key is written in plain text. This means that using the ec utility to read in an encrypted key with no encryption option can be used to remove the pass phrase from a key, or by setting the encryption options it can be use to add or change the pass phrase. These options can only be used with PEM format output files.</p> </li> <li> <p>-text</p> <p>prints out the public, private key components and parameters.</p> </li> <li> <p>-noout</p> <p>this option prevents output of the encoded version of the key.</p> </li> <li> <p>-modulus</p> <p>this option prints out the value of the public key component of the key.</p> </li> <li> <p>-pubin</p> <p>by default a private key is read from the input file: with this option a public key is read instead.</p> </li> <li> <p>-pubout</p> <p>by default a private key is output. With this option a public key will be output instead. This option is automatically set if the input is a public key.</p> </li> <li> <p>-conv_form</p> <p>This specifies how the points on the elliptic curve are converted into octet strings. Possible values are: compressed (the default value), uncompressed and hybrid. For more information regarding the point conversion forms please read the X9.62 standard. Note Due to patent issues the compressed option is disabled by default for binary curves and can be enabled by defining the preprocessor macro OPENSSL_EC_BIN_PT_COMP at compile time.</p> </li> <li> <p>-param_enc arg</p> <p>This specifies how the elliptic curve parameters are encoded. Possible value are: named_curve, i.e. the ec parameters are specified by a OID, or explicit where the ec parameters are explicitly given (see RFC 3279 for the definition of the  EC parameters structures). The default value is named_curve. Note the implicitlyCA alternative ,as specified in RFC 3279, is currently not implemented in OpenSSL.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause ec to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> </ul>"},{"location":"man1/ec/#notes","title":"NOTES","text":"<p>The PEM private key format uses the header and footer lines:</p> <pre><code>-----BEGIN EC PRIVATE KEY-----\n-----END EC PRIVATE KEY-----\n</code></pre> <p>The PEM public key format uses the header and footer lines:</p> <pre><code>-----BEGIN PUBLIC KEY-----\n-----END PUBLIC KEY-----\n</code></pre>"},{"location":"man1/ec/#examples","title":"EXAMPLES","text":"<p>To encrypt a private key using triple DES:</p> <pre><code>openssl ec -in key.pem -des3 -out keyout.pem\n</code></pre> <p>To convert a private key from PEM to DER format: </p> <pre><code>openssl ec -in key.pem -outform DER -out keyout.der\n</code></pre> <p>To print out the components of a private key to standard output:</p> <pre><code>openssl ec -in key.pem -text -noout\n</code></pre> <p>To just output the public part of a private key:</p> <pre><code>openssl ec -in key.pem -pubout -out pubkey.pem\n</code></pre> <p>To change the parameters encoding to explicit:</p> <pre><code>openssl ec -in key.pem -param_enc explicit -out keyout.pem\n</code></pre> <p>To change the point conversion form to compressed:</p> <pre><code>openssl ec -in key.pem -conv_form compressed -out keyout.pem\n</code></pre>"},{"location":"man1/ec/#see-also","title":"SEE ALSO","text":"<p>ecparam(1), dsa(1), rsa(1)</p>"},{"location":"man1/ec/#history","title":"HISTORY","text":"<p>The ec command was first introduced in OpenSSL 0.9.8.</p>"},{"location":"man1/ec/#author","title":"AUTHOR","text":"<p>Nils Larsch for the OpenSSL project (http://www.openssl.org).</p>"},{"location":"man1/ecparam/","title":"ecparam","text":""},{"location":"man1/ecparam/#name","title":"NAME","text":"<p>openssl-ecparam, ecparam - EC parameter manipulation and generation</p>"},{"location":"man1/ecparam/#synopsis","title":"SYNOPSIS","text":"<p>openssl ecparam [-inform DER|PEM] [-outform DER|PEM] [-in filename] [-out filename] [-noout] [-text] [-C] [-check] [-name arg] [-list_curves] [-conv_form arg] [-param_enc arg] [-no_seed] [-rand file(s)] [-genkey] [-engine id]</p>"},{"location":"man1/ecparam/#description","title":"DESCRIPTION","text":"<p>This command is used to manipulate or generate EC parameter files.</p>"},{"location":"man1/ecparam/#options","title":"OPTIONS","text":"<ul> <li> <p>-inform DER|PEM</p> <p>This specifies the input format. The DER option uses an ASN.1 DER encoded form compatible with RFC 3279 EcpkParameters. The PEM form is the default format: it consists of the DER format base64 encoded with additional  header and footer lines.</p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read parameters from or standard input if this option is not specified.</p> </li> <li> <p>-out filename</p> <p>This specifies the output filename parameters to. Standard output is used if this option is not present. The output filename should not be the same as the input filename.</p> </li> <li> <p>-noout</p> <p>This option inhibits the output of the encoded version of the parameters.</p> </li> <li> <p>-text</p> <p>This option prints out the EC parameters in human readable form.</p> </li> <li> <p>-C</p> <p>This option converts the EC parameters into C code. The parameters can then be loaded by calling the get_ec_group_XXX() function.</p> </li> <li> <p>-check</p> <p>Validate the elliptic curve parameters.</p> </li> <li> <p>-name arg</p> <p>Use the EC parameters with the specified 'short' name. Use -list_curves to get a list of all currently implemented EC parameters.</p> </li> <li> <p>-list_curves</p> <p>If this options is specified ecparam will print out a list of all currently implemented EC parameters names and exit.</p> </li> <li> <p>-conv_form</p> <p>This specifies how the points on the elliptic curve are converted into octet strings. Possible values are: compressed, uncompressed (the default value) and hybrid. For more information regarding the point conversion forms please read the X9.62 standard. Note Due to patent issues the compressed option is disabled by default for binary curves and can be enabled by defining the preprocessor macro OPENSSL_EC_BIN_PT_COMP at compile time.</p> </li> <li> <p>-param_enc arg</p> <p>This specifies how the elliptic curve parameters are encoded. Possible value are: named_curve, i.e. the ec parameters are specified by a OID, or explicit where the ec parameters are explicitly given (see RFC 3279 for the definition of the  EC parameters structures). The default value is named_curve. Note the implicitlyCA alternative ,as specified in RFC 3279, is currently not implemented in OpenSSL.</p> </li> <li> <p>-no_seed</p> <p>This option inhibits that the 'seed' for the parameter generation is included in the ECParameters structure (see RFC 3279).</p> </li> <li> <p>-genkey</p> <p>This option will generate a EC private key using the specified parameters.</p> </li> <li> <p>-rand file(s)</p> <p>a file or files containing random data used to seed the random number generator, or an EGD socket (see RAND_egd(3)). Multiple files can be specified separated by a OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause ecparam to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> </ul>"},{"location":"man1/ecparam/#notes","title":"NOTES","text":"<p>PEM format EC parameters use the header and footer lines:</p> <pre><code>-----BEGIN EC PARAMETERS-----\n-----END EC PARAMETERS-----\n</code></pre> <p>OpenSSL is currently not able to generate new groups and therefore ecparam can only create EC parameters from known (named) curves. </p>"},{"location":"man1/ecparam/#examples","title":"EXAMPLES","text":"<p>To create EC parameters with the group 'prime192v1':</p> <pre><code>openssl ecparam -out ec_param.pem -name prime192v1\n</code></pre> <p>To create EC parameters with explicit parameters:</p> <pre><code>openssl ecparam -out ec_param.pem -name prime192v1 -param_enc explicit\n</code></pre> <p>To validate given EC parameters:</p> <pre><code>openssl ecparam -in ec_param.pem -check\n</code></pre> <p>To create EC parameters and a private key:</p> <pre><code>openssl ecparam -out ec_key.pem -name prime192v1 -genkey\n</code></pre> <p>To change the point encoding to 'compressed':</p> <pre><code>openssl ecparam -in ec_in.pem -out ec_out.pem -conv_form compressed\n</code></pre> <p>To print out the EC parameters to standard output:</p> <pre><code>openssl ecparam -in ec_param.pem -noout -text\n</code></pre>"},{"location":"man1/ecparam/#see-also","title":"SEE ALSO","text":"<p>ec(1), dsaparam(1)</p>"},{"location":"man1/ecparam/#history","title":"HISTORY","text":"<p>The ecparam command was first introduced in OpenSSL 0.9.8.</p>"},{"location":"man1/ecparam/#author","title":"AUTHOR","text":"<p>Nils Larsch for the OpenSSL project (http://www.openssl.org)</p>"},{"location":"man1/enc/","title":"enc","text":""},{"location":"man1/enc/#name","title":"NAME","text":"<p>openssl-enc, enc - symmetric cipher routines</p>"},{"location":"man1/enc/#synopsis","title":"SYNOPSIS","text":"<p>openssl enc -ciphername [-in filename] [-out filename] [-pass arg] [-e] [-d] [-a/-base64] [-A] [-k password] [-kfile filename] [-K key] [-iv IV] [-S salt] [-salt] [-nosalt] [-z] [-md] [-p] [-P] [-bufsize number] [-nopad] [-debug] [-none] [-engine id]</p>"},{"location":"man1/enc/#description","title":"DESCRIPTION","text":"<p>The symmetric cipher commands allow data to be encrypted or decrypted using various block and stream ciphers using keys based on passwords or explicitly provided. Base64 encoding or decoding can also be performed either by itself or in addition to the encryption or decryption.</p>"},{"location":"man1/enc/#options","title":"OPTIONS","text":"<ul> <li> <p>-in filename</p> <p>the input filename, standard input by default.</p> </li> <li> <p>-out filename</p> <p>the output filename, standard output by default.</p> </li> <li> <p>-pass arg</p> <p>the password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-salt</p> <p>use a salt in the key derivation routines. This is the default.</p> </li> <li> <p>-nosalt</p> <p>don't use a salt in the key derivation routines. This option SHOULD NOT be used except for test purposes or compatibility with ancient versions of OpenSSL and SSLeay.</p> </li> <li> <p>-e</p> <p>encrypt the input data: this is the default.</p> </li> <li> <p>-d</p> <p>decrypt the input data.</p> </li> <li> <p>-a</p> <p>base64 process the data. This means that if encryption is taking place the data is base64 encoded after encryption. If decryption is set then the input data is base64 decoded before being decrypted.</p> </li> <li> <p>-base64</p> <p>same as -a</p> </li> <li> <p>-A</p> <p>if the -a option is set then base64 process the data on one line.</p> </li> <li> <p>-k password</p> <p>the password to derive the key from. This is for compatibility with previous versions of OpenSSL. Superseded by the -pass argument.</p> </li> <li> <p>-kfile filename</p> <p>read the password to derive the key from the first line of filename. This is for compatibility with previous versions of OpenSSL. Superseded by the -pass argument.</p> </li> <li> <p>-nosalt</p> <p>do not use a salt </p> </li> <li> <p>-salt</p> <p>use salt (randomly generated or provide with -S option) when encrypting (this is the default).</p> </li> <li> <p>-S salt</p> <p>the actual salt to use: this must be represented as a string of hex digits.</p> </li> <li> <p>-K key</p> <p>the actual key to use: this must be represented as a string comprised only of hex digits. If only the key is specified, the IV must additionally specified using the -iv option. When both a key and a password are specified, the key given with the -K option will be used and the IV generated from the password will be taken. It probably does not make much sense to specify both key and password.</p> </li> <li> <p>-iv IV</p> <p>the actual IV to use: this must be represented as a string comprised only of hex digits. When only the key is specified using the -K option, the IV must explicitly be defined. When a password is being specified using one of the other options, the IV is generated from this password.</p> </li> <li> <p>-p</p> <p>print out the key and IV used.</p> </li> <li> <p>-P</p> <p>print out the key and IV used then immediately exit: don't do any encryption or decryption.</p> </li> <li> <p>-bufsize number</p> <p>set the buffer size for I/O</p> </li> <li> <p>-nopad</p> <p>disable standard block padding</p> </li> <li> <p>-debug</p> <p>debug the BIOs used for I/O.</p> </li> <li> <p>-z</p> <p>Compress or decompress clear text using zlib before encryption or after decryption. This option exists only if OpenSSL with compiled with zlib or zlib-dynamic option.</p> </li> <li> <p>-none</p> <p>Use NULL cipher (no encryption or decryption of input).</p> </li> </ul>"},{"location":"man1/enc/#notes","title":"NOTES","text":"<p>The program can be called either as openssl ciphername or openssl enc -ciphername. But the first form doesn't work with engine-provided ciphers, because this form is processed before the configuration file is read and any ENGINEs loaded.</p> <p>Engines which provide entirely new encryption algorithms (such as ccgost engine which provides gost89 algorithm) should be configured in the configuration file. Engines, specified in the command line using -engine options can only be used for hadrware-assisted implementations of ciphers, which are supported by OpenSSL core or other engine, specified in the configuration file.</p> <p>When enc command lists supported ciphers, ciphers provided by engines, specified in the configuration files are listed too.</p> <p>A password will be prompted for to derive the key and IV if necessary.</p> <p>The -salt option should ALWAYS be used if the key is being derived from a password unless you want compatibility with previous versions of OpenSSL and SSLeay.</p> <p>Without the -salt option it is possible to perform efficient dictionary attacks on the password and to attack stream cipher encrypted data. The reason for this is that without the salt the same password always generates the same encryption key. When the salt is being used the first eight bytes of the encrypted data are reserved for the salt: it is generated at random when encrypting a file and read from the encrypted file when it is decrypted.</p> <p>Some of the ciphers do not have large keys and others have security implications if not used correctly. A beginner is advised to just use a strong block cipher in CBC mode such as bf or des3.</p> <p>All the block ciphers normally use PKCS#5 padding also known as standard block padding: this allows a rudimentary integrity or password check to be performed. However since the chance of random data passing the test is better than 1 in 256 it isn't a very good test.</p> <p>If padding is disabled then the input data must be a multiple of the cipher block length.</p> <p>All RC2 ciphers have the same key and effective key length.</p> <p>Blowfish and RC5 algorithms use a 128 bit key.</p>"},{"location":"man1/enc/#supported-ciphers","title":"SUPPORTED CIPHERS","text":"<p>Note that some of these ciphers can be disabled at compile time and some are available only if an appropriate engine is configured in the configuration file. The output of the enc command run with unsupported options (for example openssl enc -help) includes a list of ciphers, supported by your versesion of OpenSSL, including ones provided by configured engines.</p> <p>The enc program does not support authenticated encryption modes like CCM and GCM. The utility does not store or retrieve the authentication tag.</p> <pre><code>base64             Base 64\n\nbf-cbc             Blowfish in CBC mode\nbf                 Alias for bf-cbc\nbf-cfb             Blowfish in CFB mode\nbf-ecb             Blowfish in ECB mode\nbf-ofb             Blowfish in OFB mode\n\ncast-cbc           CAST in CBC mode\ncast               Alias for cast-cbc\ncast5-cbc          CAST5 in CBC mode\ncast5-cfb          CAST5 in CFB mode\ncast5-ecb          CAST5 in ECB mode\ncast5-ofb          CAST5 in OFB mode\n\ndes-cbc            DES in CBC mode\ndes                Alias for des-cbc\ndes-cfb            DES in CBC mode\ndes-ofb            DES in OFB mode\ndes-ecb            DES in ECB mode\n\ndes-ede-cbc        Two key triple DES EDE in CBC mode\ndes-ede            Two key triple DES EDE in ECB mode\ndes-ede-cfb        Two key triple DES EDE in CFB mode\ndes-ede-ofb        Two key triple DES EDE in OFB mode\n\ndes-ede3-cbc       Three key triple DES EDE in CBC mode\ndes-ede3           Three key triple DES EDE in ECB mode\ndes3               Alias for des-ede3-cbc\ndes-ede3-cfb       Three key triple DES EDE CFB mode\ndes-ede3-ofb       Three key triple DES EDE in OFB mode\n\ndesx               DESX algorithm.\n\ngost89             GOST 28147-89 in CFB mode (provided by ccgost engine)\ngost89-cnt        `GOST 28147-89 in CNT mode (provided by ccgost engine)\n\nidea-cbc           IDEA algorithm in CBC mode\nidea               same as idea-cbc\nidea-cfb           IDEA in CFB mode\nidea-ecb           IDEA in ECB mode\nidea-ofb           IDEA in OFB mode\n\nrc2-cbc            128 bit RC2 in CBC mode\nrc2                Alias for rc2-cbc\nrc2-cfb            128 bit RC2 in CFB mode\nrc2-ecb            128 bit RC2 in ECB mode\nrc2-ofb            128 bit RC2 in OFB mode\nrc2-64-cbc         64 bit RC2 in CBC mode\nrc2-40-cbc         40 bit RC2 in CBC mode\n\nrc4                128 bit RC4\nrc4-64             64 bit RC4\nrc4-40             40 bit RC4\n\nrc5-cbc            RC5 cipher in CBC mode\nrc5                Alias for rc5-cbc\nrc5-cfb            RC5 cipher in CFB mode\nrc5-ecb            RC5 cipher in ECB mode\nrc5-ofb            RC5 cipher in OFB mode\n\naes-[128|192|256]-cbc  128/192/256 bit AES in CBC mode\naes-[128|192|256]      Alias for aes-[128|192|256]-cbc\naes-[128|192|256]-cfb  128/192/256 bit AES in 128 bit CFB mode\naes-[128|192|256]-cfb1 128/192/256 bit AES in 1 bit CFB mode\naes-[128|192|256]-cfb8 128/192/256 bit AES in 8 bit CFB mode\naes-[128|192|256]-ecb  128/192/256 bit AES in ECB mode\naes-[128|192|256]-ofb  128/192/256 bit AES in OFB mode\n</code></pre>"},{"location":"man1/enc/#examples","title":"EXAMPLES","text":"<p>Just base64 encode a binary file:</p> <pre><code>openssl base64 -in file.bin -out file.b64\n</code></pre> <p>Decode the same file</p> <pre><code>openssl base64 -d -in file.b64 -out file.bin\n</code></pre> <p>Encrypt a file using triple DES in CBC mode using a prompted password:</p> <pre><code>openssl des3 -salt -in file.txt -out file.des3\n</code></pre> <p>Decrypt a file using a supplied password:</p> <pre><code>openssl des3 -d -salt -in file.des3 -out file.txt -k mypassword\n</code></pre> <p>Encrypt a file then base64 encode it (so it can be sent via mail for example) using Blowfish in CBC mode:</p> <pre><code>openssl bf -a -salt -in file.txt -out file.bf\n</code></pre> <p>Base64 decode a file then decrypt it:</p> <pre><code>openssl bf -d -salt -a -in file.bf -out file.txt\n</code></pre> <p>Decrypt some data using a supplied 40 bit RC4 key:</p> <pre><code>openssl rc4-40 -in file.rc4 -out file.txt -K 0102030405\n</code></pre>"},{"location":"man1/enc/#bugs","title":"BUGS","text":"<p>The -A option when used with large files doesn't work properly.</p> <p>There should be an option to allow an iteration count to be included.</p> <p>The enc program only supports a fixed number of algorithms with certain parameters. So if, for example, you want to use RC2 with a 76 bit key or RC4 with an 84 bit key you can't use this program.</p>"},{"location":"man1/errstr/","title":"errstr","text":""},{"location":"man1/errstr/#name","title":"NAME","text":"<p>openssl-errstr, errstr - lookup error codes</p>"},{"location":"man1/errstr/#synopsis","title":"SYNOPSIS","text":"<p>openssl errstr error_code</p>"},{"location":"man1/errstr/#description","title":"DESCRIPTION","text":"<p>Sometimes an application will not load error message and only numerical forms will be available. The errstr utility can be used to  display the meaning of the hex code. The hex code is the hex digits after the second colon.</p>"},{"location":"man1/errstr/#example","title":"EXAMPLE","text":"<p>The error code:</p> <pre><code>27594:error:2006D080:lib(32):func(109):reason(128):bss_file.c:107:\n</code></pre> <p>can be displayed with:</p> <pre><code>openssl errstr 2006D080\n</code></pre> <p>to produce the error message:</p> <pre><code>error:2006D080:BIO routines:BIO_new_file:no such file\n</code></pre>"},{"location":"man1/errstr/#see-also","title":"SEE ALSO","text":"<p>err(3), ERR_load_crypto_strings(3), SSL_load_error_strings(3)</p>"},{"location":"man1/gendsa/","title":"gendsa","text":""},{"location":"man1/gendsa/#name","title":"NAME","text":"<p>openssl-gendsa, gendsa - generate a DSA private key from a set of parameters</p>"},{"location":"man1/gendsa/#synopsis","title":"SYNOPSIS","text":"<p>openssl gendsa [-out filename] [-aes128] [-aes192] [-aes256] [-camellia128] [-camellia192] [-camellia256] [-des] [-des3] [-idea] [-rand file(s)] [-engine id] [paramfile]</p>"},{"location":"man1/gendsa/#description","title":"DESCRIPTION","text":"<p>The gendsa command generates a DSA private key from a DSA parameter file (which will be typically generated by the openssl dsaparam command).</p>"},{"location":"man1/gendsa/#options","title":"OPTIONS","text":"<ul> <li> <p>-aes128|-aes192|-aes256|-camellia128|-camellia192|-camellia256|-des|-des3|-idea</p> <p>These options encrypt the private key with specified cipher before outputting it. A pass phrase is prompted for. If none of these options is specified no encryption is used.</p> </li> <li> <p>-rand file(s)</p> <p>a file or files containing random data used to seed the random number generator, or an EGD socket (see RAND_egd(3)). Multiple files can be specified separated by a OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause gendsa to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> <li> <p>paramfile</p> <p>This option specifies the DSA parameter file to use. The parameters in this file determine the size of the private key. DSA parameters can be generated and examined using the openssl dsaparam command.</p> </li> </ul>"},{"location":"man1/gendsa/#notes","title":"NOTES","text":"<p>DSA key generation is little more than random number generation so it is much quicker that RSA key generation for example.</p>"},{"location":"man1/gendsa/#see-also","title":"SEE ALSO","text":"<p>dsaparam(1), dsa(1), genrsa(1), rsa(1)</p>"},{"location":"man1/genpkey/","title":"genpkey","text":""},{"location":"man1/genpkey/#name","title":"NAME","text":"<p>openssl-genpkey, genpkey - generate a private key</p>"},{"location":"man1/genpkey/#synopsis","title":"SYNOPSIS","text":"<p>openssl genpkey [-out filename] [-outform PEM|DER] [-pass arg] [-cipher] [-engine id] [-paramfile file] [-algorithm alg] [-pkeyopt opt:value] [-genparam] [-text]</p>"},{"location":"man1/genpkey/#description","title":"DESCRIPTION","text":"<p>The genpkey command generates a private key.</p>"},{"location":"man1/genpkey/#options","title":"OPTIONS","text":"<ul> <li> <p>-out filename</p> <p>the output filename. If this argument is not specified then standard output is used.  </p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the output format DER or PEM. The default format is PEM.</p> </li> <li> <p>-pass arg</p> <p>The output file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-cipher</p> <p>This option encrypts the private key with the supplied cipher. Any algorithm name accepted by EVP_get_cipherbyname() is acceptable such as des3.</p> </li> <li> <p>-engine id</p> <p>Specifying an engine (by its unique id string) will cause genpkey to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms. If used this option should precede all other options.</p> </li> <li> <p>-algorithm alg</p> <p>Public key algorithm to use such as RSA, DSA or DH. If used this option must precede any -pkeyopt options. The options -paramfile and -algorithm are mutually exclusive. Engines may add algorithms in addition to the standard built-in ones.</p> <p>Valid built-in algorithm names for private key generation are RSA and EC.</p> <p>Valid built-in algorithm names for parameter generation (see the -genparam option) are DH, DSA and EC.</p> <p>Note that the algorithm name X9.42 DH may be used as a synonym for the DH algorithm. These are identical and do not indicate the type of parameters that will be generated. Use the dh_paramgen_type option to indicate whether PKCS#3 or X9.42 DH parameters are required. See \"DH Parameter Generation Options\" below for more details.</p> </li> <li> <p>-pkeyopt opt:value</p> <p>Set the public key algorithm option opt to value. The precise set of options supported depends on the public key algorithm used and its implementation. See \"KEY GENERATION OPTIONS\" and \"PARAMETER GENERATION OPTIONS\" below for more details.</p> </li> <li> <p>-genparam</p> <p>Generate a set of parameters instead of a private key. If used this option must precede any -algorithm, -paramfile or -pkeyopt options.</p> </li> <li> <p>-paramfile filename</p> <p>Some public key algorithms generate a private key based on a set of parameters. They can be supplied using this option. If this option is used the public key algorithm used is determined by the parameters. If used this option must precede and -pkeyopt options. The options -paramfile and -algorithm are mutually exclusive.</p> </li> <li> <p>-text</p> <p>Print an (unencrypted) text representation of private and public keys and parameters along with the PEM or DER structure.</p> </li> </ul>"},{"location":"man1/genpkey/#key-generation-options","title":"KEY GENERATION OPTIONS","text":"<p>The options supported by each algorith and indeed each implementation of an algorithm can vary. The options for the OpenSSL implementations are detailed below.</p>"},{"location":"man1/genpkey/#rsa-key-generation-options","title":"RSA Key Generation Options","text":"<ul> <li> <p>rsa_keygen_bits:numbits</p> <p>The number of bits in the generated key. If not specified 2048 is used.</p> </li> <li> <p>rsa_keygen_pubexp:value</p> <p>The RSA public exponent value. This can be a large decimal or hexadecimal value if preceded by 0x. Default value is 65537.</p> </li> </ul>"},{"location":"man1/genpkey/#ec-key-generation-options","title":"EC Key Generation Options","text":"<p>The EC key generation options can also be used for parameter generation.</p> <ul> <li> <p>ec_paramgen_curve:curve</p> <p>The EC curve to use. OpenSSL supports NIST curve names such as \"P-256\".</p> </li> <li> <p>ec_param_enc:encoding</p> <p>The encoding to use for parameters. The \"encoding\" parameter must be either \"named_curve\" or \"explicit\". The default value is \"named_curve\".</p> </li> </ul>"},{"location":"man1/genpkey/#parameter-generation-options","title":"PARAMETER GENERATION OPTIONS","text":"<p>The options supported by each algorithm and indeed each implementation of an algorithm can vary. The options for the OpenSSL implementations are detailed below.</p>"},{"location":"man1/genpkey/#dsa-parameter-generation-options","title":"DSA Parameter Generation Options","text":"<ul> <li> <p>dsa_paramgen_bits:numbits</p> <p>The number of bits in the generated prime. If not specified 2048 is used.</p> </li> <li> <p>dsa_paramgen_q_bits:numbits</p> <p>The number of bits in the q parameter. Must be one of 160, 224 or 256. If not specified 224 is used.</p> </li> <li> <p>dsa_paramgen_md:digest</p> <p>The digest to use during parameter generation. Must be one of sha1, sha224 or sha256. If set, then the number of bits in q will match the output size of the specified digest and the dsa_paramgen_q_bits parameter will be ignored. If not set, then a digest will be used that gives an output matching the number of bits in q, i.e. sha1 if q length is 160, sha224 if it 224 or sha256 if it is 256.</p> </li> </ul>"},{"location":"man1/genpkey/#dh-parameter-generation-options","title":"DH Parameter Generation Options","text":"<ul> <li> <p>dh_paramgen_prime_len:numbits</p> <p>The number of bits in the prime parameter p. The default is 2048.</p> </li> <li> <p>dh_paramgen_subprime_len:numbits</p> <p>The number of bits in the sub prime parameter q. The default is 256 if the prime is at least 2048 bits long or 160 otherwise. Only relevant if used in conjunction with the dh_paramgen_type option to generate X9.42 DH parameters.</p> </li> <li> <p>dh_paramgen_generator:value</p> <p>The value to use for the generator g. The default is 2.</p> </li> <li> <p>dh_paramgen_type:value</p> <p>The type of DH parameters to generate. Use 0 for PKCS#3 DH and 1 for X9.42 DH. The default is 0.</p> </li> <li> <p>dh_rfc5114:num</p> <p>If this option is set, then the appropriate RFC5114 parameters are used instead of generating new parameters. The value num can take the values 1, 2 or 3 corresponding to RFC5114 DH parameters consisting of 1024 bit group with 160 bit subgroup, 2048 bit group with 224 bit subgroup and 2048 bit group with 256 bit subgroup as mentioned in RFC5114 sections 2.1, 2.2 and 2.3 respectively. If present this overrides all other DH parameter options.</p> </li> </ul>"},{"location":"man1/genpkey/#ec-parameter-generation-options","title":"EC Parameter Generation Options","text":"<p>The EC parameter generation options are the same as for key generation. See \"EC Key Generation Options\" above.</p>"},{"location":"man1/genpkey/#gost2001-key-generation-and-parameter-options","title":"GOST2001 KEY GENERATION AND PARAMETER OPTIONS","text":"<p>Gost 2001 support is not enabled by default. To enable this algorithm, one should load the ccgost engine in the OpenSSL configuration file. See README.gost file in the engines/ccgost directiry of the source distribution for more details.</p> <p>Use of a parameter file for the GOST R 34.10 algorithm is optional. Parameters can be specified during key generation directly as well as during generation of parameter file.</p> <ul> <li> <p>paramset:name</p> <p>Specifies GOST R 34.10-2001 parameter set according to RFC 4357. Parameter set can be specified using abbreviated name, object short name or numeric OID. Following parameter sets are supported:</p> <pre><code>paramset   OID               Usage\nA          1.2.643.2.2.35.1  Signature\nB          1.2.643.2.2.35.2  Signature\nC          1.2.643.2.2.35.3  Signature\nXA         1.2.643.2.2.36.0  Key exchange\nXB         1.2.643.2.2.36.1  Key exchange\ntest       1.2.643.2.2.35.0  Test purposes\n</code></pre> </li> </ul>"},{"location":"man1/genpkey/#notes","title":"NOTES","text":"<p>The use of the genpkey program is encouraged over the algorithm specific utilities because additional algorithm options and ENGINE provided algorithms can be used.</p>"},{"location":"man1/genpkey/#examples","title":"EXAMPLES","text":"<p>Generate an RSA private key using default parameters:</p> <pre><code>openssl genpkey -algorithm RSA -out key.pem\n</code></pre> <p>Encrypt output private key using 128 bit AES and the passphrase \"hello\":</p> <pre><code>openssl genpkey -algorithm RSA -out key.pem -aes-128-cbc -pass pass:hello\n</code></pre> <p>Generate a 2048 bit RSA key using 3 as the public exponent:</p> <pre><code>openssl genpkey -algorithm RSA -out key.pem -pkeyopt rsa_keygen_bits:2048 \\\n                                               -pkeyopt rsa_keygen_pubexp:3\n</code></pre> <p>Generate 2048 bit DSA parameters:</p> <pre><code>openssl genpkey -genparam -algorithm DSA -out dsap.pem \\\n                                               -pkeyopt dsa_paramgen_bits:2048\n</code></pre> <p>Generate DSA key from parameters:</p> <pre><code>openssl genpkey -paramfile dsap.pem -out dsakey.pem\n</code></pre> <p>Generate 2048 bit DH parameters:</p> <pre><code>openssl genpkey -genparam -algorithm DH -out dhp.pem \\\n                                       -pkeyopt dh_paramgen_prime_len:2048\n</code></pre> <p>Generate 2048 bit X9.42 DH parameters:</p> <pre><code>openssl genpkey -genparam -algorithm DH -out dhpx.pem \\\n                                       -pkeyopt dh_paramgen_prime_len:2048 \\\n                                       -pkeyopt dh_paramgen_type:1\n</code></pre> <p>Output RFC5114 2048 bit DH parameters with 224 bit subgroup:</p> <pre><code>openssl genpkey -genparam -algorithm DH -out dhp.pem -pkeyopt dh_rfc5114:2\n</code></pre> <p>Generate DH key from parameters:</p> <pre><code>openssl genpkey -paramfile dhp.pem -out dhkey.pem\n</code></pre> <p>Generate EC key directly:</p> <pre><code>openssl genpkey -algorithm EC -out eckey.pem \\\n       -pkeyopt ec_paramgen_curve:P-384 \\\n       -pkeyopt ec_param_enc:named_curve\n</code></pre>"},{"location":"man1/genpkey/#history","title":"HISTORY","text":"<p>The ability to use NIST curve names, and to generate an EC key directly, were added in OpenSSL 1.0.2.</p>"},{"location":"man1/genrsa/","title":"genrsa","text":""},{"location":"man1/genrsa/#name","title":"NAME","text":"<p>openssl-genrsa, genrsa - generate an RSA private key</p>"},{"location":"man1/genrsa/#synopsis","title":"SYNOPSIS","text":"<p>openssl genrsa [-help] [-out filename] [-passout arg] [-aes128] [-aes192] [-aes256] [-aria128] [-aria192] [-aria256] [-camellia128] [-camellia192] [-camellia256] [-des] [-des3] [-idea] [-f4] [-3] [-rand file(s)] [-engine id] [numbits]</p>"},{"location":"man1/genrsa/#description","title":"DESCRIPTION","text":"<p>The genrsa command generates an RSA private key.</p>"},{"location":"man1/genrsa/#options","title":"OPTIONS","text":"<ul> <li> <p>-help</p> <p>Print out a usage message.</p> </li> <li> <p>-out filename</p> <p>Output the key to the specified file. If this argument is not specified then standard output is used.</p> </li> <li> <p>-passout arg</p> <p>the output file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-aes128|-aes192|-aes256|-aria128|-aria192|-aria256|-camellia128|-camellia192|-camellia256|-des|-des3|-idea</p> <p>These options encrypt the private key with specified cipher before outputting it. If none of these options is specified no encryption is used. If encryption is used a pass phrase is prompted for if it is not supplied via the -passout argument.</p> </li> <li> <p>-F4|-3</p> <p>the public exponent to use, either 65537 or 3. The default is 65537.</p> </li> <li> <p>-rand file(s)</p> <p>a file or files containing random data used to seed the random number generator, or an EGD socket (see RAND_egd(3)). Multiple files can be specified separated by an OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause genrsa to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> <li> <p>numbits</p> <p>the size of the private key to generate in bits. This must be the last option specified. The default is 2048.</p> </li> </ul>"},{"location":"man1/genrsa/#notes","title":"NOTES","text":"<p>RSA private key generation essentially involves the generation of two prime numbers. When generating a private key various symbols will be output to indicate the progress of the generation. A . represents each number which has passed an initial sieve test, + means a number has passed a single round of the Miller-Rabin primality test. A newline means that the number has passed all the prime tests (the actual number depends on the key size).</p> <p>Because key generation is a random process the time taken to generate a key may vary somewhat.</p>"},{"location":"man1/genrsa/#bugs","title":"BUGS","text":"<p>A quirk of the prime generation algorithm is that it cannot generate small primes. Therefore the number of bits should not be less that 64. For typical private keys this will not matter because for security reasons they will be much larger (typically 1024 bits).</p>"},{"location":"man1/genrsa/#see-also","title":"SEE ALSO","text":"<p>gendsa(1)</p>"},{"location":"man1/genrsa/#copyright","title":"COPYRIGHT","text":"<p>Copyright 2000-2017 The OpenSSL Project Authors. All Rights Reserved.</p> <p>Licensed under the OpenSSL license (the \"License\").  You may not use this file except in compliance with the License.  You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html.</p>"},{"location":"man1/nseq/","title":"nseq","text":""},{"location":"man1/nseq/#name","title":"NAME","text":"<p>openssl-nseq, nseq - create or examine a netscape certificate sequence</p>"},{"location":"man1/nseq/#synopsis","title":"SYNOPSIS","text":"<p>openssl nseq [-in filename] [-out filename] [-toseq]</p>"},{"location":"man1/nseq/#description","title":"DESCRIPTION","text":"<p>The nseq command takes a file containing a Netscape certificate sequence and prints out the certificates contained in it or takes a file of certificates and converts it into a Netscape certificate sequence.</p>"},{"location":"man1/nseq/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-in filename</p> <p>This specifies the input filename to read or standard input if this option is not specified.</p> </li> <li> <p>-out filename</p> <p>specifies the output filename or standard output by default.</p> </li> <li> <p>-toseq</p> <p>normally a Netscape certificate sequence will be input and the output is the certificates contained in it. With the -toseq option the situation is reversed: a Netscape certificate sequence is created from a file of certificates.</p> </li> </ul>"},{"location":"man1/nseq/#examples","title":"EXAMPLES","text":"<p>Output the certificates in a Netscape certificate sequence</p> <pre><code>openssl nseq -in nseq.pem -out certs.pem\n</code></pre> <p>Create a Netscape certificate sequence</p> <pre><code>openssl nseq -in certs.pem -toseq -out nseq.pem\n</code></pre>"},{"location":"man1/nseq/#notes","title":"NOTES","text":"<p>The PEM encoded form uses the same headers and footers as a certificate:</p> <pre><code>-----BEGIN CERTIFICATE-----\n-----END CERTIFICATE-----\n</code></pre> <p>A Netscape certificate sequence is a Netscape specific form that can be sent to browsers as an alternative to the standard PKCS#7 format when several certificates are sent to the browser: for example during certificate enrollment. It is used by Netscape certificate server for example.</p>"},{"location":"man1/nseq/#bugs","title":"BUGS","text":"<p>This program needs a few more options: like allowing DER or PEM input and output files and allowing multiple certificate files to be used.</p>"},{"location":"man1/ocsp/","title":"ocsp","text":""},{"location":"man1/ocsp/#name","title":"NAME","text":"<p>openssl-ocsp, ocsp - Online Certificate Status Protocol utility</p>"},{"location":"man1/ocsp/#synopsis","title":"SYNOPSIS","text":"<p>openssl ocsp [-out file] [-issuer file] [-cert file] [-serial n] [-signer file] [-signkey file] [-sign_other file] [-no_certs] [-req_text] [-resp_text] [-text] [-reqout file] [-respout file] [-reqin file] [-respin file] [-nonce] [-no_nonce] [-url URL] [-host host:n] [-header name value] [-path] [-CApath dir] [-CAfile file] [-no_alt_chains] [-VAfile file] [-validity_period n] [-status_age n] [-noverify] [-verify_other file] [-trust_other] [-no_intern] [-no_signature_verify] [-no_cert_verify] [-no_chain] [-no_cert_checks] [-no_explicit] [-port num] [-index file] [-CA file] [-rsigner file] [-rkey file] [-rother file] [-resp_no_certs] [-nmin n] [-ndays n] [-resp_key_id] [-nrequest n] [-md5|-sha1|...]</p>"},{"location":"man1/ocsp/#description","title":"DESCRIPTION","text":"<p>The Online Certificate Status Protocol (OCSP) enables applications to determine the (revocation) state of an identified certificate (RFC 2560).</p> <p>The ocsp command performs many common OCSP tasks. It can be used to print out requests and responses, create requests and send queries to an OCSP responder and behave like a mini OCSP server itself.</p>"},{"location":"man1/ocsp/#ocsp-client-options","title":"OCSP CLIENT OPTIONS","text":"<ul> <li> <p>-out filename</p> <p>specify output filename, default is standard output.</p> </li> <li> <p>-issuer filename</p> <p>This specifies the current issuer certificate. This option can be used multiple times. The certificate specified in filename must be in PEM format. This option MUST come before any -cert options.</p> </li> <li> <p>-cert filename</p> <p>Add the certificate filename to the request. The issuer certificate is taken from the previous issuer option, or an error occurs if no issuer certificate is specified.</p> </li> <li> <p>-serial num</p> <p>Same as the cert option except the certificate with serial number num is added to the request. The serial number is interpreted as a decimal integer unless preceded by 0x. Negative integers can also be specified by preceding the value by a - sign.</p> </li> <li> <p>-signer filename, -signkey filename</p> <p>Sign the OCSP request using the certificate specified in the signer option and the private key specified by the signkey option. If the signkey option is not present then the private key is read from the same file as the certificate. If neither option is specified then the OCSP request is not signed.</p> </li> <li> <p>-sign_other filename</p> <p>Additional certificates to include in the signed request.</p> </li> <li> <p>-nonce, -no_nonce</p> <p>Add an OCSP nonce extension to a request or disable OCSP nonce addition. Normally if an OCSP request is input using the respin option no nonce is added: using the nonce option will force addition of a nonce. If an OCSP request is being created (using cert and serial options) a nonce is automatically added specifying no_nonce overrides this.</p> </li> <li> <p>-req_text, -resp_text, -text</p> <p>print out the text form of the OCSP request, response or both respectively.</p> </li> <li> <p>-reqout file, -respout file</p> <p>write out the DER encoded certificate request or response to file.</p> </li> <li> <p>-reqin file, -respin file</p> <p>read OCSP request or response file from file. These option are ignored if OCSP request or response creation is implied by other options (for example with serial, cert and host options).</p> </li> <li> <p>-url responder_url</p> <p>specify the responder URL. Both HTTP and HTTPS (SSL/TLS) URLs can be specified.</p> </li> <li> <p>-host hostname:port, -path pathname</p> <p>if the host option is present then the OCSP request is sent to the host hostname on port port. path specifies the HTTP path name to use or \"/\" by default.</p> </li> <li> <p>-header name value</p> <p>If sending a request to an OCSP server, then the specified header name and value are added to the HTTP request.  Note that the name and value must be specified as two separate parameters, not as a single quoted string, and that the header name does not have the trailing colon. Some OCSP responders require a Host header; use this flag to provide it.</p> </li> <li> <p>-timeout seconds</p> <p>connection timeout to the OCSP responder in seconds</p> </li> <li> <p>-CAfile file, -CApath pathname</p> <p>file or pathname containing trusted CA certificates. These are used to verify the signature on the OCSP response.</p> </li> <li> <p>-no_alt_chains</p> <p>See verify manual page for details.</p> </li> <li> <p>-verify_other file</p> <p>file containing additional certificates to search when attempting to locate the OCSP response signing certificate. Some responders omit the actual signer's certificate from the response: this option can be used to supply the necessary certificate in such cases.</p> </li> <li> <p>-trust_other</p> <p>the certificates specified by the -verify_other option should be explicitly trusted and no additional checks will be performed on them. This is useful when the complete responder certificate chain is not available or trusting a root CA is not appropriate.</p> </li> <li> <p>-VAfile file</p> <p>file containing explicitly trusted responder certificates. Equivalent to the -verify_other and -trust_other options.</p> </li> <li> <p>-noverify</p> <p>don't attempt to verify the OCSP response signature or the nonce values. This option will normally only be used for debugging since it disables all verification of the responders certificate.</p> </li> <li> <p>-no_intern</p> <p>ignore certificates contained in the OCSP response when searching for the signers certificate. With this option the signers certificate must be specified with either the -verify_other or -VAfile options.</p> </li> <li> <p>-no_signature_verify</p> <p>don't check the signature on the OCSP response. Since this option tolerates invalid signatures on OCSP responses it will normally only be used for testing purposes.</p> </li> <li> <p>-no_cert_verify</p> <p>don't verify the OCSP response signers certificate at all. Since this option allows the OCSP response to be signed by any certificate it should only be used for testing purposes.</p> </li> <li> <p>-no_chain</p> <p>do not use certificates in the response as additional untrusted CA certificates.</p> </li> <li> <p>-no_explicit</p> <p>do not explicitly trust the root CA if it is set to be trusted for OCSP signing.</p> </li> <li> <p>-no_cert_checks</p> <p>don't perform any additional checks on the OCSP response signers certificate. That is do not make any checks to see if the signers certificate is authorised to provide the necessary status information: as a result this option should only be used for testing purposes.</p> </li> <li> <p>-validity_period nsec, -status_age age</p> <p>these options specify the range of times, in seconds, which will be tolerated in an OCSP response. Each certificate status response includes a notBefore time and an optional notAfter time. The current time should fall between these two values, but the interval between the two times may be only a few seconds. In practice the OCSP responder and clients clocks may not be precisely synchronised and so such a check may fail. To avoid this the -validity_period option can be used to specify an acceptable error range in seconds, the default value is 5 minutes.</p> <p>If the notAfter time is omitted from a response then this means that new status information is immediately available. In this case the age of the notBefore field is checked to see it is not older than age seconds old. By default this additional check is not performed.</p> </li> <li> <p>-md5|-sha1|-sha256|-ripemod160|...</p> <p>this option sets digest algorithm to use for certificate identification in the OCSP request. By default SHA-1 is used. </p> </li> </ul>"},{"location":"man1/ocsp/#ocsp-server-options","title":"OCSP SERVER OPTIONS","text":"<ul> <li> <p>-index indexfile</p> <p>indexfile is a text index file in ca format containing certificate revocation information.</p> <p>If the index option is specified the ocsp utility is in responder mode, otherwise it is in client mode. The request(s) the responder processes can be either specified on the command line (using issuer and serial options), supplied in a file (using the respin option) or via external OCSP clients (if port or url is specified).</p> <p>If the index option is present then the CA and rsigner options must also be present.</p> </li> <li> <p>-CA file</p> <p>CA certificate corresponding to the revocation information in indexfile.</p> </li> <li> <p>-rsigner file</p> <p>The certificate to sign OCSP responses with.</p> </li> <li> <p>-rother file</p> <p>Additional certificates to include in the OCSP response.</p> </li> <li> <p>-resp_no_certs</p> <p>Don't include any certificates in the OCSP response.</p> </li> <li> <p>-resp_key_id</p> <p>Identify the signer certificate using the key ID, default is to use the subject name.</p> </li> <li> <p>-rkey file</p> <p>The private key to sign OCSP responses with: if not present the file specified in the rsigner option is used.</p> </li> <li> <p>-port portnum</p> <p>Port to listen for OCSP requests on. The port may also be specified using the url option.</p> </li> <li> <p>-nrequest number</p> <p>The OCSP server will exit after receiving number requests, default unlimited. </p> </li> <li> <p>-nmin minutes, -ndays days</p> <p>Number of minutes or days when fresh revocation information is available: used in the nextUpdate field. If neither option is present then the nextUpdate field is  omitted meaning fresh revocation information is immediately available.</p> </li> </ul>"},{"location":"man1/ocsp/#ocsp-response-verification","title":"OCSP Response verification.","text":"<p>OCSP Response follows the rules specified in RFC2560.</p> <p>Initially the OCSP responder certificate is located and the signature on the OCSP request checked using the responder certificate's public key.</p> <p>Then a normal certificate verify is performed on the OCSP responder certificate building up a certificate chain in the process. The locations of the trusted certificates used to build the chain can be specified by the CAfile and CApath options or they will be looked for in the standard OpenSSL certificates directory.</p> <p>If the initial verify fails then the OCSP verify process halts with an error.</p> <p>Otherwise the issuing CA certificate in the request is compared to the OCSP responder certificate: if there is a match then the OCSP verify succeeds.</p> <p>Otherwise the OCSP responder certificate's CA is checked against the issuing CA certificate in the request. If there is a match and the OCSPSigning extended key usage is present in the OCSP responder certificate then the OCSP verify succeeds.</p> <p>Otherwise, if -no_explicit is not set the root CA of the OCSP responders CA is checked to see if it is trusted for OCSP signing. If it is the OCSP verify succeeds.</p> <p>If none of these checks is successful then the OCSP verify fails.</p> <p>What this effectively means if that if the OCSP responder certificate is authorised directly by the CA it is issuing revocation information about (and it is correctly configured) then verification will succeed.</p> <p>If the OCSP responder is a \"global responder\" which can give details about multiple CAs and has its own separate certificate chain then its root CA can be trusted for OCSP signing. For example:</p> <pre><code>openssl x509 -in ocspCA.pem -addtrust OCSPSigning -out trustedCA.pem\n</code></pre> <p>Alternatively the responder certificate itself can be explicitly trusted with the -VAfile option.</p>"},{"location":"man1/ocsp/#notes","title":"NOTES","text":"<p>As noted, most of the verify options are for testing or debugging purposes. Normally only the -CApath, -CAfile and (if the responder is a 'global VA') -VAfile options need to be used.</p> <p>The OCSP server is only useful for test and demonstration purposes: it is not really usable as a full OCSP responder. It contains only a very simple HTTP request handling and can only handle the POST form of OCSP queries. It also handles requests serially meaning it cannot respond to new requests until it has processed the current one. The text index file format of revocation is also inefficient for large quantities of revocation data.</p> <p>It is possible to run the ocsp application in responder mode via a CGI script using the respin and respout options.</p>"},{"location":"man1/ocsp/#examples","title":"EXAMPLES","text":"<p>Create an OCSP request and write it to a file:</p> <pre><code>openssl ocsp -issuer issuer.pem -cert c1.pem -cert c2.pem -reqout req.der\n</code></pre> <p>Send a query to an OCSP responder with URL http://ocsp.myhost.com/ save the  response to a file and print it out in text form</p> <pre><code>openssl ocsp -issuer issuer.pem -cert c1.pem -cert c2.pem \\\n    -url http://ocsp.myhost.com/ -resp_text -respout resp.der\n</code></pre> <p>Read in an OCSP response and print out text form:</p> <pre><code>openssl ocsp -respin resp.der -text\n</code></pre> <p>OCSP server on port 8888 using a standard ca configuration, and a separate responder certificate. All requests and responses are printed to a file.</p> <pre><code>openssl ocsp -index demoCA/index.txt -port 8888 -rsigner rcert.pem -CA demoCA/cacert.pem\n       -text -out log.txt\n</code></pre> <p>As above but exit after processing one request:</p> <pre><code>openssl ocsp -index demoCA/index.txt -port 8888 -rsigner rcert.pem -CA demoCA/cacert.pem\n    -nrequest 1\n</code></pre> <p>Query status information using internally generated request:</p> <pre><code>openssl ocsp -index demoCA/index.txt -rsigner rcert.pem -CA demoCA/cacert.pem\n    -issuer demoCA/cacert.pem -serial 1\n</code></pre> <p>Query status information using request read from a file, write response to a second file.</p> <pre><code>openssl ocsp -index demoCA/index.txt -rsigner rcert.pem -CA demoCA/cacert.pem\n    -reqin req.der -respout resp.der\n</code></pre>"},{"location":"man1/ocsp/#history","title":"HISTORY","text":"<p>The -no_alt_chains options was first added to OpenSSL 1.0.2b.</p>"},{"location":"man1/openssl/","title":"openssl","text":""},{"location":"man1/openssl/#name","title":"NAME","text":"<p>openssl - OpenSSL command line tool</p>"},{"location":"man1/openssl/#synopsis","title":"SYNOPSIS","text":"<p>openssl command [ command_opts ] [ command_args ]</p> <p>openssl [ list-standard-commands | list-message-digest-commands | list-cipher-commands | list-cipher-algorithms | list-message-digest-algorithms | list-public-key-algorithms]</p> <p>openssl no-XXX [ arbitrary options ]</p>"},{"location":"man1/openssl/#description","title":"DESCRIPTION","text":"<p>OpenSSL is a cryptography toolkit implementing the Secure Sockets Layer (SSL v2/v3) and Transport Layer Security (TLS v1) network protocols and related cryptography standards required by them.</p> <p>The openssl program is a command line tool for using the various cryptography functions of OpenSSL's crypto library from the shell.  It can be used for </p> <pre><code>o  Creation and management of private keys, public keys and parameters\no  Public key cryptographic operations\no  Creation of X.509 certificates, CSRs and CRLs \no  Calculation of Message Digests\no  Encryption and Decryption with Ciphers\no  SSL/TLS Client and Server Tests\no  Handling of S/MIME signed or encrypted mail\no  Time Stamp requests, generation and verification\n</code></pre>"},{"location":"man1/openssl/#command-summary","title":"COMMAND SUMMARY","text":"<p>The openssl program provides a rich variety of commands (command in the SYNOPSIS above), each of which often has a wealth of options and arguments (command_opts and command_args in the SYNOPSIS).</p> <p>The pseudo-commands list-standard-commands, list-message-digest-commands, and list-cipher-commands output a list (one entry per line) of the names of all standard commands, message digest commands, or cipher commands, respectively, that are available in the present openssl utility.</p> <p>The pseudo-commands list-cipher-algorithms and list-message-digest-algorithms list all cipher and message digest names, one entry per line. Aliases are listed as:</p> <pre><code>from =&gt; to\n</code></pre> <p>The pseudo-command list-public-key-algorithms lists all supported public key algorithms.</p> <p>The pseudo-command no-XXX tests whether a command of the specified name is available.  If no command named XXX exists, it returns 0 (success) and prints no-XXX; otherwise it returns 1 and prints XXX.  In both cases, the output goes to stdout and nothing is printed to stderr.  Additional command line arguments are always ignored.  Since for each cipher there is a command of the same name, this provides an easy way for shell scripts to test for the availability of ciphers in the openssl program.  (no-XXX is not able to detect pseudo-commands such as quit, list-...-commands, or no-XXX itself.)</p>"},{"location":"man1/openssl/#standard-commands","title":"STANDARD COMMANDS","text":"<ul> <li> <p>asn1parse</p> <p>Parse an ASN.1 sequence.</p> </li> <li> <p>ca</p> <p>Certificate Authority (CA) Management.  </p> </li> <li> <p>ciphers</p> <p>Cipher Suite Description Determination.</p> </li> <li> <p>cms</p> <p>CMS (Cryptographic Message Syntax) utility</p> </li> <li> <p>crl</p> <p>Certificate Revocation List (CRL) Management.</p> </li> <li> <p>crl2pkcs7</p> <p>CRL to PKCS#7 Conversion.</p> </li> <li> <p>dgst</p> <p>Message Digest Calculation.</p> </li> <li> <p>dh</p> <p>Diffie-Hellman Parameter Management. Obsoleted by dhparam.</p> </li> <li> <p>dhparam</p> <p>Generation and Management of Diffie-Hellman Parameters. Superseded by  genpkey and pkeyparam</p> </li> <li> <p>dsa</p> <p>DSA Data Management.</p> </li> <li> <p>dsaparam</p> <p>DSA Parameter Generation and Management. Superseded by  genpkey and pkeyparam</p> </li> <li> <p>ec</p> <p>EC (Elliptic curve) key processing</p> </li> <li> <p>ecparam</p> <p>EC parameter manipulation and generation</p> </li> <li> <p>enc</p> <p>Encoding with Ciphers.</p> </li> <li> <p>engine</p> <p>Engine (loadble module) information and manipulation.</p> </li> <li> <p>errstr</p> <p>Error Number to Error String Conversion.</p> </li> <li> <p>gendh</p> <p>Generation of Diffie-Hellman Parameters. Obsoleted by dhparam.</p> </li> <li> <p>gendsa</p> <p>Generation of DSA Private Key from Parameters. Superseded by  genpkey and pkey</p> </li> <li> <p>genpkey</p> <p>Generation of Private Key or Parameters.</p> </li> <li> <p>genrsa</p> <p>Generation of RSA Private Key. Superceded by genpkey.</p> </li> <li> <p>nseq</p> <p>Create or examine a netscape certificate sequence</p> </li> <li> <p>ocsp</p> <p>Online Certificate Status Protocol utility.</p> </li> <li> <p>passwd</p> <p>Generation of hashed passwords.</p> </li> <li> <p>pkcs12</p> <p>PKCS#12 Data Management.</p> </li> <li> <p>pkcs7</p> <p>PKCS#7 Data Management.</p> </li> <li> <p>pkey</p> <p>Public and private key management.</p> </li> <li> <p>pkeyparam</p> <p>Public key algorithm parameter management.</p> </li> <li> <p>pkeyutl</p> <p>Public key algorithm cryptographic operation utility.</p> </li> <li> <p>rand</p> <p>Generate pseudo-random bytes.</p> </li> <li> <p>req</p> <p>PKCS#10 X.509 Certificate Signing Request (CSR) Management.</p> </li> <li> <p>rsa</p> <p>RSA key management.</p> </li> <li> <p>rsautl</p> <p>RSA utility for signing, verification, encryption, and decryption. Superseded by  pkeyutl</p> </li> <li> <p>s_client</p> <p>This implements a generic SSL/TLS client which can establish a transparent connection to a remote server speaking SSL/TLS. It's intended for testing purposes only and provides only rudimentary interface functionality but internally uses mostly all functionality of the OpenSSL ssl library.</p> </li> <li> <p>s_server</p> <p>This implements a generic SSL/TLS server which accepts connections from remote clients speaking SSL/TLS. It's intended for testing purposes only and provides only rudimentary interface functionality but internally uses mostly all functionality of the OpenSSL ssl library.  It provides both an own command line oriented protocol for testing SSL functions and a simple HTTP response facility to emulate an SSL/TLS-aware webserver.</p> </li> <li> <p>s_time</p> <p>SSL Connection Timer.</p> </li> <li> <p>sess_id</p> <p>SSL Session Data Management.</p> </li> <li> <p>smime</p> <p>S/MIME mail processing.</p> </li> <li> <p>speed</p> <p>Algorithm Speed Measurement.</p> </li> <li> <p>spkac</p> <p>SPKAC printing and generating utility</p> </li> <li> <p>ts</p> <p>Time Stamping Authority tool (client/server)</p> </li> <li> <p>verify</p> <p>X.509 Certificate Verification.</p> </li> <li> <p>version</p> <p>OpenSSL Version Information.</p> </li> <li> <p>x509</p> <p>X.509 Certificate Data Management.</p> </li> </ul>"},{"location":"man1/openssl/#message-digest-commands","title":"MESSAGE DIGEST COMMANDS","text":"<ul> <li> <p>md2</p> <p>MD2 Digest</p> </li> <li> <p>md5</p> <p>MD5 Digest</p> </li> <li> <p>mdc2</p> <p>MDC2 Digest</p> </li> <li> <p>rmd160</p> <p>RMD-160 Digest</p> </li> <li> <p>sha </p> <p>SHA Digest</p> </li> <li> <p>sha1 </p> <p>SHA-1 Digest</p> </li> <li> <p>sha224</p> <p>SHA-224 Digest</p> </li> <li> <p>sha256</p> <p>SHA-256 Digest</p> </li> <li> <p>sha384</p> <p>SHA-384 Digest</p> </li> <li> <p>sha512</p> <p>SHA-512 Digest</p> </li> </ul>"},{"location":"man1/openssl/#encoding-and-cipher-commands","title":"ENCODING AND CIPHER COMMANDS","text":"<ul> <li> <p>base64</p> <p>Base64 Encoding</p> </li> <li> <p>bf bf-cbc bf-cfb bf-ecb bf-ofb</p> <p>Blowfish Cipher</p> </li> <li> <p>cast cast-cbc</p> <p>CAST Cipher</p> </li> <li> <p>cast5-cbc cast5-cfb cast5-ecb cast5-ofb</p> <p>CAST5 Cipher</p> </li> <li> <p>des des-cbc des-cfb des-ecb des-ede des-ede-cbc des-ede-cfb des-ede-ofb des-ofb</p> <p>DES Cipher</p> </li> <li> <p>des3 desx des-ede3 des-ede3-cbc des-ede3-cfb des-ede3-ofb</p> <p>Triple-DES Cipher</p> </li> <li> <p>idea idea-cbc idea-cfb idea-ecb idea-ofb</p> <p>IDEA Cipher</p> </li> <li> <p>rc2 rc2-cbc rc2-cfb rc2-ecb rc2-ofb</p> <p>RC2 Cipher</p> </li> <li> <p>rc4</p> <p>RC4 Cipher</p> </li> <li> <p>rc5 rc5-cbc rc5-cfb rc5-ecb rc5-ofb</p> <p>RC5 Cipher</p> </li> </ul>"},{"location":"man1/openssl/#pass-phrase-arguments","title":"PASS PHRASE ARGUMENTS","text":"<p>Several commands accept password arguments, typically using -passin and -passout for input and output passwords respectively. These allow the password to be obtained from a variety of sources. Both of these options take a single argument whose format is described below. If no password argument is given and a password is required then the user is prompted to enter one: this will typically be read from the current terminal with echoing turned off.</p> <ul> <li> <p>pass:password</p> <p>the actual password is password. Since the password is visible to utilities (like 'ps' under Unix) this form should only be used where security is not important.</p> </li> <li> <p>env:var</p> <p>obtain the password from the environment variable var. Since the environment of other processes is visible on certain platforms (e.g. ps under certain Unix OSes) this option should be used with caution.</p> </li> <li> <p>file:pathname</p> <p>the first line of pathname is the password. If the same pathname argument is supplied to -passin and -passout arguments then the first line will be used for the input password and the next line for the output password. pathname need not refer to a regular file: it could for example refer to a device or named pipe.</p> </li> <li> <p>fd:number</p> <p>read the password from the file descriptor number. This can be used to send the data via a pipe for example.</p> </li> <li> <p>stdin</p> <p>read the password from standard input.</p> </li> </ul>"},{"location":"man1/openssl/#see-also","title":"SEE ALSO","text":"<p>asn1parse(1), ca(1), config(5), crl(1), crl2pkcs7(1), dgst(1), dhparam(1), dsa(1), dsaparam(1), enc(1), gendsa(1), genpkey(1), genrsa(1), nseq(1), openssl(1), passwd(1), pkcs12(1), pkcs7(1), pkcs8(1), rand(1), req(1), rsa(1), rsautl(1), s_client(1), s_server(1), s_time(1), smime(1), spkac(1), verify(1), version(1), x509(1), crypto(3), ssl(3), x509v3_config(5) </p>"},{"location":"man1/openssl/#history","title":"HISTORY","text":"<p>The openssl(1) document appeared in OpenSSL 0.9.2. The list-XXX-commands pseudo-commands were added in OpenSSL 0.9.3; The list-XXX-algorithms pseudo-commands were added in OpenSSL 1.0.0; the no-XXX pseudo-commands were added in OpenSSL 0.9.5a. For notes on the availability of other commands, see their individual manual pages.</p>"},{"location":"man1/passwd/","title":"passwd","text":""},{"location":"man1/passwd/#name","title":"NAME","text":"<p>openssl-passwd, passwd - compute password hashes</p>"},{"location":"man1/passwd/#synopsis","title":"SYNOPSIS","text":"<p>openssl passwd [-crypt] [-1] [-apr1] [-salt string] [-in file] [-stdin] [-noverify] [-quiet] [-table] {password}</p>"},{"location":"man1/passwd/#description","title":"DESCRIPTION","text":"<p>The passwd command computes the hash of a password typed at run-time or the hash of each password in a list.  The password list is taken from the named file for option -in file, from stdin for option -stdin, or from the command line, or from the terminal otherwise. The Unix standard algorithm crypt and the MD5-based BSD password algorithm 1 and its Apache variant apr1 are available.</p>"},{"location":"man1/passwd/#options","title":"OPTIONS","text":"<ul> <li> <p>-crypt</p> <p>Use the crypt algorithm (default).</p> </li> <li> <p>-1</p> <p>Use the MD5 based BSD password algorithm 1.</p> </li> <li> <p>-apr1</p> <p>Use the apr1 algorithm (Apache variant of the BSD algorithm).</p> </li> <li> <p>-salt string</p> <p>Use the specified salt. When reading a password from the terminal, this implies -noverify.</p> </li> <li> <p>-in file</p> <p>Read passwords from file.</p> </li> <li> <p>-stdin</p> <p>Read passwords from stdin.</p> </li> <li> <p>-noverify</p> <p>Don't verify when reading a password from the terminal.</p> </li> <li> <p>-quiet</p> <p>Don't output warnings when passwords given at the command line are truncated.</p> </li> <li> <p>-table</p> <p>In the output list, prepend the cleartext password and a TAB character to each password hash.</p> </li> </ul>"},{"location":"man1/passwd/#examples","title":"EXAMPLES","text":"<p>openssl passwd -crypt -salt xx password prints xxj31ZMTZzkVA.</p> <p>openssl passwd -1 -salt xxxxxxxx password prints $1$xxxxxxxx$UYCIxa628.9qXjpQCjM4a..</p> <p>openssl passwd -apr1 -salt xxxxxxxx password prints $apr1$xxxxxxxx$dxHfLAsjHkDRmG83UXe8K0.</p>"},{"location":"man1/pkcs12/","title":"pkcs12","text":""},{"location":"man1/pkcs12/#name","title":"NAME","text":"<p>openssl-pkcs12, pkcs12 - PKCS#12 file utility</p>"},{"location":"man1/pkcs12/#synopsis","title":"SYNOPSIS","text":"<p>openssl pkcs12 [-export] [-chain] [-inkey filename] [-certfile filename] [-name name] [-caname name] [-in filename] [-out filename] [-noout] [-nomacver] [-nocerts] [-clcerts] [-cacerts] [-nokeys] [-info] [-des | -des3 | -idea | -aes128 | -aes192 | -aes256 | -camellia128 | -camellia192 | -camellia256 | -nodes] [-noiter] [-maciter | -nomaciter | -nomac] [-twopass] [-descert] [-certpbe cipher] [-keypbe cipher] [-macalg digest] [-keyex] [-keysig] [-password arg] [-passin arg] [-passout arg] [-rand file(s)] [-CAfile file] [-CApath dir] [-CSP name]</p>"},{"location":"man1/pkcs12/#description","title":"DESCRIPTION","text":"<p>The pkcs12 command allows PKCS#12 files (sometimes referred to as PFX files) to be created and parsed. PKCS#12 files are used by several programs including Netscape, MSIE and MS Outlook.</p>"},{"location":"man1/pkcs12/#command-options","title":"COMMAND OPTIONS","text":"<p>There are a lot of options the meaning of some depends of whether a PKCS#12 file is being created or parsed. By default a PKCS#12 file is parsed. A PKCS#12 file can be created by using the -export option (see below).</p>"},{"location":"man1/pkcs12/#parsing-options","title":"PARSING OPTIONS","text":"<ul> <li> <p>-in filename</p> <p>This specifies filename of the PKCS#12 file to be parsed. Standard input is used by default.</p> </li> <li> <p>-out filename</p> <p>The filename to write certificates and private keys to, standard output by default.  They are all written in PEM format.</p> </li> <li> <p>-passin arg</p> <p>the PKCS#12 file (i.e. input file) password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-passout arg</p> <p>pass phrase source to encrypt any outputted private keys with. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-password arg</p> <p>With -export, -password is equivalent to -passout. Otherwise, -password is equivalent to -passin.</p> </li> <li> <p>-noout</p> <p>this option inhibits output of the keys and certificates to the output file version of the PKCS#12 file.</p> </li> <li> <p>-clcerts</p> <p>only output client certificates (not CA certificates).</p> </li> <li> <p>-cacerts</p> <p>only output CA certificates (not client certificates).</p> </li> <li> <p>-nocerts</p> <p>no certificates at all will be output.</p> </li> <li> <p>-nokeys</p> <p>no private keys will be output.</p> </li> <li> <p>-info</p> <p>output additional information about the PKCS#12 file structure, algorithms used and iteration counts.</p> </li> <li> <p>-des</p> <p>use DES to encrypt private keys before outputting.</p> </li> <li> <p>-des3</p> <p>use triple DES to encrypt private keys before outputting, this is the default.</p> </li> <li> <p>-idea</p> <p>use IDEA to encrypt private keys before outputting.</p> </li> <li> <p>-aes128, -aes192, -aes256</p> <p>use AES to encrypt private keys before outputting.</p> </li> <li> <p>-camellia128, -camellia192, -camellia256</p> <p>use Camellia to encrypt private keys before outputting.</p> </li> <li> <p>-nodes</p> <p>don't encrypt the private keys at all.</p> </li> <li> <p>-nomacver</p> <p>don't attempt to verify the integrity MAC before reading the file.</p> </li> <li> <p>-twopass</p> <p>prompt for separate integrity and encryption passwords: most software always assumes these are the same so this option will render such PKCS#12 files unreadable.</p> </li> </ul>"},{"location":"man1/pkcs12/#file-creation-options","title":"FILE CREATION OPTIONS","text":"<ul> <li> <p>-export</p> <p>This option specifies that a PKCS#12 file will be created rather than parsed.</p> </li> <li> <p>-out filename</p> <p>This specifies filename to write the PKCS#12 file to. Standard output is used by default.</p> </li> <li> <p>-in filename</p> <p>The filename to read certificates and private keys from, standard input by default.  They must all be in PEM format. The order doesn't matter but one private key and its corresponding certificate should be present. If additional certificates are present they will also be included in the PKCS#12 file.</p> </li> <li> <p>-inkey filename</p> <p>file to read private key from. If not present then a private key must be present in the input file.</p> </li> <li> <p>-name friendlyname</p> <p>This specifies the \"friendly name\" for the certificate and private key. This name is typically displayed in list boxes by software importing the file.</p> </li> <li> <p>-certfile filename</p> <p>A filename to read additional certificates from.</p> </li> <li> <p>-caname friendlyname</p> <p>This specifies the \"friendly name\" for other certificates. This option may be used multiple times to specify names for all certificates in the order they appear. Netscape ignores friendly names on other certificates whereas MSIE displays them.</p> </li> <li> <p>-pass arg, -passout arg</p> <p>the PKCS#12 file (i.e. output file) password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-passin password</p> <p>pass phrase source to decrypt any input private keys with. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-chain</p> <p>if this option is present then an attempt is made to include the entire certificate chain of the user certificate. The standard CA store is used for this search. If the search fails it is considered a fatal error.</p> </li> <li> <p>-descert</p> <p>encrypt the certificate using triple DES, this may render the PKCS#12 file unreadable by some \"export grade\" software. By default the private key is encrypted using triple DES and the certificate using 40 bit RC2.</p> </li> <li> <p>-keypbe alg, -certpbe alg</p> <p>these options allow the algorithm used to encrypt the private key and certificates to be selected. Any PKCS#5 v1.5 or PKCS#12 PBE algorithm name can be used (see NOTES section for more information). If a cipher name (as output by the list-cipher-algorithms command is specified then it is used with PKCS#5 v2.0. For interoperability reasons it is advisable to only use PKCS#12 algorithms.</p> </li> <li> <p>-keyex|-keysig</p> <p>specifies that the private key is to be used for key exchange or just signing. This option is only interpreted by MSIE and similar MS software. Normally \"export grade\" software will only allow 512 bit RSA keys to be used for encryption purposes but arbitrary length keys for signing. The -keysig option marks the key for signing only. Signing only keys can be used for S/MIME signing, authenticode (ActiveX control signing)  and SSL client authentication, however due to a bug only MSIE 5.0 and later support the use of signing only keys for SSL client authentication.</p> </li> <li> <p>-macalg digest</p> <p>specify the MAC digest algorithm. If not included them SHA1 will be used.</p> </li> <li> <p>-nomaciter, -noiter</p> <p>these options affect the iteration counts on the MAC and key algorithms. Unless you wish to produce files compatible with MSIE 4.0 you should leave these options alone.</p> <p>To discourage attacks by using large dictionaries of common passwords the algorithm that derives keys from passwords can have an iteration count applied to it: this causes a certain part of the algorithm to be repeated and slows it down. The MAC is used to check the file integrity but since it will normally have the same password as the keys and certificates it could also be attacked. By default both MAC and encryption iteration counts are set to 2048, using these options the MAC and encryption iteration counts can be set to 1, since this reduces the file security you should not use these options unless you really have to. Most software supports both MAC and key iteration counts. MSIE 4.0 doesn't support MAC iteration counts so it needs the -nomaciter option.</p> </li> <li> <p>-maciter</p> <p>This option is included for compatibility with previous versions, it used to be needed to use MAC iterations counts but they are now used by default.</p> </li> <li> <p>-nomac</p> <p>don't attempt to provide the MAC integrity.</p> </li> <li> <p>-rand file(s)</p> <p>a file or files containing random data used to seed the random number generator, or an EGD socket (see RAND_egd(3)). Multiple files can be specified separated by a OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others.</p> </li> <li> <p>-CAfile file</p> <p>CA storage as a file.</p> </li> <li> <p>-CApath dir</p> <p>CA storage as a directory. This directory must be a standard certificate directory: that is a hash of each subject name (using x509 -hash) should be linked to each certificate.</p> </li> <li> <p>-CSP name</p> <p>write name as a Microsoft CSP name.</p> </li> </ul>"},{"location":"man1/pkcs12/#notes","title":"NOTES","text":"<p>Although there are a large number of options most of them are very rarely used. For PKCS#12 file parsing only -in and -out need to be used for PKCS#12 file creation -export and -name are also used.</p> <p>If none of the -clcerts, -cacerts or -nocerts options are present then all certificates will be output in the order they appear in the input PKCS#12 files. There is no guarantee that the first certificate present is the one corresponding to the private key. Certain software which requires a private key and certificate and assumes the first certificate in the file is the one corresponding to the private key: this may not always be the case. Using the -clcerts option will solve this problem by only outputting the certificate corresponding to the private key. If the CA certificates are required then they can be output to a separate file using the -nokeys -cacerts options to just output CA certificates.</p> <p>The -keypbe and -certpbe algorithms allow the precise encryption algorithms for private keys and certificates to be specified. Normally the defaults are fine but occasionally software can't handle triple DES encrypted private keys, then the option -keypbe PBE-SHA1-RC2-40 can be used to reduce the private key encryption to 40 bit RC2. A complete description of all algorithms is contained in the pkcs8 manual page.</p>"},{"location":"man1/pkcs12/#examples","title":"EXAMPLES","text":"<p>Parse a PKCS#12 file and output it to a file:</p> <pre><code>openssl pkcs12 -in file.p12 -out file.pem\n</code></pre> <p>Output only client certificates to a file:</p> <pre><code>openssl pkcs12 -in file.p12 -clcerts -out file.pem\n</code></pre> <p>Don't encrypt the private key:</p> <pre><code>openssl pkcs12 -in file.p12 -out file.pem -nodes\n</code></pre> <p>Print some info about a PKCS#12 file:</p> <pre><code>openssl pkcs12 -in file.p12 -info -noout\n</code></pre> <p>Create a PKCS#12 file:</p> <pre><code>openssl pkcs12 -export -in file.pem -out file.p12 -name \"My Certificate\"\n</code></pre> <p>Include some extra certificates:</p> <pre><code>openssl pkcs12 -export -in file.pem -out file.p12 -name \"My Certificate\" \\\n -certfile othercerts.pem\n</code></pre>"},{"location":"man1/pkcs12/#bugs","title":"BUGS","text":"<p>Some would argue that the PKCS#12 standard is one big bug :-)</p> <p>Versions of OpenSSL before 0.9.6a had a bug in the PKCS#12 key generation routines. Under rare circumstances this could produce a PKCS#12 file encrypted with an invalid key. As a result some PKCS#12 files which triggered this bug from other implementations (MSIE or Netscape) could not be decrypted by OpenSSL and similarly OpenSSL could produce PKCS#12 files which could not be decrypted by other implementations. The chances of producing such a file are relatively small: less than 1 in 256.</p> <p>A side effect of fixing this bug is that any old invalidly encrypted PKCS#12 files cannot no longer be parsed by the fixed version. Under such circumstances the pkcs12 utility will report that the MAC is OK but fail with a decryption error when extracting private keys.</p> <p>This problem can be resolved by extracting the private keys and certificates from the PKCS#12 file using an older version of OpenSSL and recreating the PKCS#12 file from the keys and certificates using a newer version of OpenSSL. For example:</p> <pre><code>old-openssl -in bad.p12 -out keycerts.pem\nopenssl -in keycerts.pem -export -name \"My PKCS#12 file\" -out fixed.p12\n</code></pre>"},{"location":"man1/pkcs12/#see-also","title":"SEE ALSO","text":"<p>pkcs8(1)</p>"},{"location":"man1/pkcs7/","title":"pkcs7","text":""},{"location":"man1/pkcs7/#name","title":"NAME","text":"<p>openssl-pkcs7, pkcs7 - PKCS#7 utility</p>"},{"location":"man1/pkcs7/#synopsis","title":"SYNOPSIS","text":"<p>openssl pkcs7 [-inform PEM|DER] [-outform PEM|DER] [-in filename] [-out filename] [-print_certs] [-text] [-noout] [-engine id]</p>"},{"location":"man1/pkcs7/#description","title":"DESCRIPTION","text":"<p>The pkcs7 command processes PKCS#7 files in DER or PEM format.</p>"},{"location":"man1/pkcs7/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-inform DER|PEM</p> <p>This specifies the input format. DER format is DER encoded PKCS#7 v1.5 structure.PEM (the default) is a base64 encoded version of the DER form with header and footer lines.</p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read from or standard input if this option is not specified.</p> </li> <li> <p>-out filename</p> <p>specifies the output filename to write to or standard output by default.</p> </li> <li> <p>-print_certs</p> <p>prints out any certificates or CRLs contained in the file. They are preceded by their subject and issuer names in one line format.</p> </li> <li> <p>-text</p> <p>prints out certificates details in full rather than just subject and issuer names.</p> </li> <li> <p>-noout</p> <p>don't output the encoded version of the PKCS#7 structure (or certificates is -print_certs is set).</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause pkcs7 to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> </ul>"},{"location":"man1/pkcs7/#examples","title":"EXAMPLES","text":"<p>Convert a PKCS#7 file from PEM to DER:</p> <pre><code>openssl pkcs7 -in file.pem -outform DER -out file.der\n</code></pre> <p>Output all certificates in a file:</p> <pre><code>openssl pkcs7 -in file.pem -print_certs -out certs.pem\n</code></pre>"},{"location":"man1/pkcs7/#notes","title":"NOTES","text":"<p>The PEM PKCS#7 format uses the header and footer lines:</p> <pre><code>-----BEGIN PKCS7-----\n-----END PKCS7-----\n</code></pre> <p>For compatibility with some CAs it will also accept:</p> <pre><code>-----BEGIN CERTIFICATE-----\n-----END CERTIFICATE-----\n</code></pre>"},{"location":"man1/pkcs7/#restrictions","title":"RESTRICTIONS","text":"<p>There is no option to print out all the fields of a PKCS#7 file.</p> <p>This PKCS#7 routines only understand PKCS#7 v 1.5 as specified in RFC2315 they  cannot currently parse, for example, the new CMS as described in RFC2630.</p>"},{"location":"man1/pkcs7/#see-also","title":"SEE ALSO","text":"<p>crl2pkcs7(1)</p>"},{"location":"man1/pkcs8/","title":"pkcs8","text":""},{"location":"man1/pkcs8/#name","title":"NAME","text":"<p>openssl-pkcs8, pkcs8 - PKCS#8 format private key conversion tool</p>"},{"location":"man1/pkcs8/#synopsis","title":"SYNOPSIS","text":"<p>openssl pkcs8 [-topk8] [-inform PEM|DER] [-outform PEM|DER] [-in filename] [-passin arg] [-out filename] [-passout arg] [-noiter] [-nocrypt] [-nooct] [-embed] [-nsdb] [-v2 alg] [-v2prf alg] [-v1 alg] [-engine id]</p>"},{"location":"man1/pkcs8/#description","title":"DESCRIPTION","text":"<p>The pkcs8 command processes private keys in PKCS#8 format. It can handle both unencrypted PKCS#8 PrivateKeyInfo format and EncryptedPrivateKeyInfo format with a variety of PKCS#5 (v1.5 and v2.0) and PKCS#12 algorithms.</p>"},{"location":"man1/pkcs8/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-topk8</p> <p>Normally a PKCS#8 private key is expected on input and a traditional format private key will be written. With the -topk8 option the situation is reversed: it reads a traditional format private key and writes a PKCS#8 format key.</p> </li> <li> <p>-inform DER|PEM</p> <p>This specifies the input format. If a PKCS#8 format key is expected on input then either a DER or PEM encoded version of a PKCS#8 key will be expected. Otherwise the DER or PEM format of the traditional format private key is used.</p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read a key from or standard input if this option is not specified. If the key is encrypted a pass phrase will be prompted for.</p> </li> <li> <p>-passin arg</p> <p>the input file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-out filename</p> <p>This specifies the output filename to write a key to or standard output by default. If any encryption options are set then a pass phrase will be prompted for. The output filename should not be the same as the input filename.</p> </li> <li> <p>-passout arg</p> <p>the output file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-nocrypt</p> <p>PKCS#8 keys generated or input are normally PKCS#8 EncryptedPrivateKeyInfo structures using an appropriate password based encryption algorithm. With this option an unencrypted PrivateKeyInfo structure is expected or output. This option does not encrypt private keys at all and should only be used when absolutely necessary. Certain software such as some versions of Java code signing software used unencrypted private keys.</p> </li> <li> <p>-nooct</p> <p>This option generates RSA private keys in a broken format that some software uses. Specifically the private key should be enclosed in a OCTET STRING but some software just includes the structure itself without the surrounding OCTET STRING.</p> </li> <li> <p>-embed</p> <p>This option generates DSA keys in a broken format. The DSA parameters are embedded inside the PrivateKey structure. In this form the OCTET STRING contains an ASN1 SEQUENCE consisting of two structures: a SEQUENCE containing the parameters and an ASN1 INTEGER containing the private key.</p> </li> <li> <p>-nsdb</p> <p>This option generates DSA keys in a broken format compatible with Netscape private key databases. The PrivateKey contains a SEQUENCE consisting of the public and private keys respectively.</p> </li> <li> <p>-v2 alg</p> <p>This option enables the use of PKCS#5 v2.0 algorithms. Normally PKCS#8 private keys are encrypted with the password based encryption algorithm called pbeWithMD5AndDES-CBC this uses 56 bit DES encryption but it was the strongest encryption algorithm supported in PKCS#5 v1.5. Using  the -v2 option PKCS#5 v2.0 algorithms are used which can use any encryption algorithm such as 168 bit triple DES or 128 bit RC2 however not many implementations support PKCS#5 v2.0 yet. If you are just using private keys with OpenSSL then this doesn't matter.</p> <p>The alg argument is the encryption algorithm to use, valid values include des, des3 and rc2. It is recommended that des3 is used.</p> </li> <li> <p>-v2prf alg</p> <p>This option sets the PRF algorithm to use with PKCS#5 v2.0. A typical value values would be hmacWithSHA256. If this option isn't set then the default for the cipher is used or hmacWithSHA1 if there is no default.</p> </li> <li> <p>-v1 alg</p> <p>This option specifies a PKCS#5 v1.5 or PKCS#12 algorithm to use. A complete list of possible algorithms is included below.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause pkcs8 to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> </ul>"},{"location":"man1/pkcs8/#notes","title":"NOTES","text":"<p>The encrypted form of a PEM encode PKCS#8 files uses the following headers and footers:</p> <pre><code>-----BEGIN ENCRYPTED PRIVATE KEY-----\n-----END ENCRYPTED PRIVATE KEY-----\n</code></pre> <p>The unencrypted form uses:</p> <pre><code>-----BEGIN PRIVATE KEY-----\n-----END PRIVATE KEY-----\n</code></pre> <p>Private keys encrypted using PKCS#5 v2.0 algorithms and high iteration counts are more secure that those encrypted using the traditional SSLeay compatible formats. So if additional security is considered important the keys should be converted.</p> <p>The default encryption is only 56 bits because this is the encryption that most current implementations of PKCS#8 will support.</p> <p>Some software may use PKCS#12 password based encryption algorithms with PKCS#8 format private keys: these are handled automatically but there is no option to produce them.</p> <p>It is possible to write out DER encoded encrypted private keys in PKCS#8 format because the encryption details are included at an ASN1 level whereas the traditional format includes them at a PEM level.</p>"},{"location":"man1/pkcs8/#pkcs5-v15-and-pkcs12-algorithms","title":"PKCS#5 v1.5 and PKCS#12 algorithms.","text":"<p>Various algorithms can be used with the -v1 command line option, including PKCS#5 v1.5 and PKCS#12. These are described in more detail below.</p> <ul> <li> <p>PBE-MD2-DES PBE-MD5-DES</p> <p>These algorithms were included in the original PKCS#5 v1.5 specification. They only offer 56 bits of protection since they both use DES.</p> </li> <li> <p>PBE-SHA1-RC2-64 PBE-MD2-RC2-64 PBE-MD5-RC2-64 PBE-SHA1-DES</p> <p>These algorithms are not mentioned in the original PKCS#5 v1.5 specification but they use the same key derivation algorithm and are supported by some software. They are mentioned in PKCS#5 v2.0. They use either 64 bit RC2 or 56 bit DES.</p> </li> <li> <p>PBE-SHA1-RC4-128 PBE-SHA1-RC4-40 PBE-SHA1-3DES PBE-SHA1-2DES PBE-SHA1-RC2-128 PBE-SHA1-RC2-40</p> <p>These algorithms use the PKCS#12 password based encryption algorithm and allow strong encryption algorithms like triple DES or 128 bit RC2 to be used.</p> </li> </ul>"},{"location":"man1/pkcs8/#examples","title":"EXAMPLES","text":"<p>Convert a private from traditional to PKCS#5 v2.0 format using triple DES:</p> <pre><code>openssl pkcs8 -in key.pem -topk8 -v2 des3 -out enckey.pem\n</code></pre> <p>Convert a private from traditional to PKCS#5 v2.0 format using AES with 256 bits in CBC mode and hmacWithSHA256 PRF:</p> <pre><code>openssl pkcs8 -in key.pem -topk8 -v2 aes-256-cbc -v2prf hmacWithSHA256 -out enckey.pem\n</code></pre> <p>Convert a private key to PKCS#8 using a PKCS#5 1.5 compatible algorithm (DES):</p> <pre><code>openssl pkcs8 -in key.pem -topk8 -out enckey.pem\n</code></pre> <p>Convert a private key to PKCS#8 using a PKCS#12 compatible algorithm (3DES):</p> <pre><code>openssl pkcs8 -in key.pem -topk8 -out enckey.pem -v1 PBE-SHA1-3DES\n</code></pre> <p>Read a DER unencrypted PKCS#8 format private key:</p> <pre><code>openssl pkcs8 -inform DER -nocrypt -in key.der -out key.pem\n</code></pre> <p>Convert a private key from any PKCS#8 format to traditional format:</p> <pre><code>openssl pkcs8 -in pk8.pem -out key.pem\n</code></pre>"},{"location":"man1/pkcs8/#standards","title":"STANDARDS","text":"<p>Test vectors from this PKCS#5 v2.0 implementation were posted to the pkcs-tng mailing list using triple DES, DES and RC2 with high iteration counts, several people confirmed that they could decrypt the private keys produced and Therefore it can be assumed that the PKCS#5 v2.0 implementation is reasonably accurate at least as far as these algorithms are concerned.</p> <p>The format of PKCS#8 DSA (and other) private keys is not well documented: it is hidden away in PKCS#11 v2.01, section 11.9. OpenSSL's default DSA PKCS#8 private key format complies with this standard.</p>"},{"location":"man1/pkcs8/#bugs","title":"BUGS","text":"<p>There should be an option that prints out the encryption algorithm in use and other details such as the iteration count.</p> <p>PKCS#8 using triple DES and PKCS#5 v2.0 should be the default private key format for OpenSSL: for compatibility several of the utilities use the old format at present.</p>"},{"location":"man1/pkcs8/#see-also","title":"SEE ALSO","text":"<p>dsa(1), rsa(1), genrsa(1), gendsa(1) </p>"},{"location":"man1/pkey/","title":"pkey","text":""},{"location":"man1/pkey/#name","title":"NAME","text":"<p>openssl-pkey, pkey - public or private key processing tool</p>"},{"location":"man1/pkey/#synopsis","title":"SYNOPSIS","text":"<p>openssl pkey [-inform PEM|DER] [-outform PEM|DER] [-in filename] [-passin arg] [-out filename] [-passout arg] [-cipher] [-text] [-text_pub] [-noout] [-pubin] [-pubout] [-engine id]</p>"},{"location":"man1/pkey/#description","title":"DESCRIPTION","text":"<p>The pkey command processes public or private keys. They can be converted between various forms and their components printed out.</p>"},{"location":"man1/pkey/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-inform DER|PEM</p> <p>This specifies the input format DER or PEM.</p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read a key from or standard input if this option is not specified. If the key is encrypted a pass phrase will be prompted for.</p> </li> <li> <p>-passin arg</p> <p>the input file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-out filename</p> <p>This specifies the output filename to write a key to or standard output if this option is not specified. If any encryption options are set then a pass phrase will be prompted for. The output filename should not be the same as the input filename.</p> </li> <li> <p>-passout password</p> <p>the output file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-cipher</p> <p>These options encrypt the private key with the supplied cipher. Any algorithm name accepted by EVP_get_cipherbyname() is acceptable such as des3.</p> </li> <li> <p>-text</p> <p>prints out the various public or private key components in plain text in addition to the encoded version. </p> </li> <li> <p>-text_pub</p> <p>print out only public key components even if a private key is being processed.</p> </li> <li> <p>-noout</p> <p>do not output the encoded version of the key.</p> </li> <li> <p>-pubin</p> <p>by default a private key is read from the input file: with this option a public key is read instead.</p> </li> <li> <p>-pubout</p> <p>by default a private key is output: with this option a public key will be output instead. This option is automatically set if the input is a public key.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause pkey to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> </ul>"},{"location":"man1/pkey/#examples","title":"EXAMPLES","text":"<p>To remove the pass phrase on an RSA private key:</p> <pre><code>openssl pkey -in key.pem -out keyout.pem\n</code></pre> <p>To encrypt a private key using triple DES:</p> <pre><code>openssl pkey -in key.pem -des3 -out keyout.pem\n</code></pre> <p>To convert a private key from PEM to DER format: </p> <pre><code>openssl pkey -in key.pem -outform DER -out keyout.der\n</code></pre> <p>To print out the components of a private key to standard output:</p> <pre><code>openssl pkey -in key.pem -text -noout\n</code></pre> <p>To print out the public components of a private key to standard output:</p> <pre><code>openssl pkey -in key.pem -text_pub -noout\n</code></pre> <p>To just output the public part of a private key:</p> <pre><code>openssl pkey -in key.pem -pubout -out pubkey.pem\n</code></pre>"},{"location":"man1/pkey/#see-also","title":"SEE ALSO","text":"<p>genpkey(1), rsa(1), pkcs8(1), dsa(1), genrsa(1), gendsa(1) </p>"},{"location":"man1/pkeyparam/","title":"pkeyparam","text":""},{"location":"man1/pkeyparam/#name","title":"NAME","text":"<p>openssl-pkeyparam, pkeyparam - public key algorithm parameter processing tool</p>"},{"location":"man1/pkeyparam/#synopsis","title":"SYNOPSIS","text":"<p>openssl pkeyparam [-in filename] [-out filename] [-text] [-noout] [-engine id]</p>"},{"location":"man1/pkeyparam/#description","title":"DESCRIPTION","text":"<p>The pkey command processes public or private keys. They can be converted between various forms and their components printed out.</p>"},{"location":"man1/pkeyparam/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-in filename</p> <p>This specifies the input filename to read parameters from or standard input if this option is not specified.</p> </li> <li> <p>-out filename</p> <p>This specifies the output filename to write parameters to or standard output if this option is not specified.</p> </li> <li> <p>-text</p> <p>prints out the parameters in plain text in addition to the encoded version. </p> </li> <li> <p>-noout</p> <p>do not output the encoded version of the parameters.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause pkeyparam to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> </ul>"},{"location":"man1/pkeyparam/#example","title":"EXAMPLE","text":"<p>Print out text version of parameters:</p> <pre><code>openssl pkeyparam -in param.pem -text\n</code></pre>"},{"location":"man1/pkeyparam/#notes","title":"NOTES","text":"<p>There are no -inform or -outform options for this command because only PEM format is supported because the key type is determined by the PEM headers.</p>"},{"location":"man1/pkeyparam/#see-also","title":"SEE ALSO","text":"<p>genpkey(1), rsa(1), pkcs8(1), dsa(1), genrsa(1), gendsa(1) </p>"},{"location":"man1/pkeyutl/","title":"pkeyutl","text":""},{"location":"man1/pkeyutl/#name","title":"NAME","text":"<p>openssl-pkeyutl, pkeyutl - public key algorithm utility</p>"},{"location":"man1/pkeyutl/#synopsis","title":"SYNOPSIS","text":"<p>openssl pkeyutl [-in file] [-out file] [-sigfile file] [-inkey file] [-keyform PEM|DER] [-passin arg] [-peerkey file] [-peerform PEM|DER] [-pubin] [-certin] [-rev] [-sign] [-verify] [-verifyrecover] [-encrypt] [-decrypt] [-derive] [-pkeyopt opt:value] [-hexdump] [-asn1parse] [-engine id]</p>"},{"location":"man1/pkeyutl/#description","title":"DESCRIPTION","text":"<p>The pkeyutl command can be used to perform public key operations using any supported algorithm.</p>"},{"location":"man1/pkeyutl/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-in filename</p> <p>This specifies the input filename to read data from or standard input if this option is not specified.</p> </li> <li> <p>-out filename</p> <p>specifies the output filename to write to or standard output by default.</p> </li> <li> <p>-inkey file</p> <p>the input key file, by default it should be a private key.</p> </li> <li> <p>-keyform PEM|DER</p> <p>the key format PEM, DER or ENGINE.</p> </li> <li> <p>-passin arg</p> <p>the input key password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-peerkey file</p> <p>the peer key file, used by key derivation (agreement) operations.</p> </li> <li> <p>-peerform PEM|DER</p> <p>the peer key format PEM, DER or ENGINE.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause pkeyutl to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> <li> <p>-pubin</p> <p>the input file is a public key. </p> </li> <li> <p>-certin</p> <p>the input is a certificate containing a public key. </p> </li> <li> <p>-rev</p> <p>reverse the order of the input buffer. This is useful for some libraries (such as CryptoAPI) which represent the buffer in little endian format.</p> </li> <li> <p>-sign</p> <p>sign the input data and output the signed result. This requires a private key.</p> </li> <li> <p>-verify</p> <p>verify the input data against the signature file and indicate if the verification succeeded or failed.</p> </li> <li> <p>-verifyrecover</p> <p>verify the input data and output the recovered data.</p> </li> <li> <p>-encrypt</p> <p>encrypt the input data using a public key.</p> </li> <li> <p>-decrypt</p> <p>decrypt the input data using a private key.</p> </li> <li> <p>-derive</p> <p>derive a shared secret using the peer key.</p> </li> <li> <p>-hexdump</p> <p>hex dump the output data.</p> </li> <li> <p>-asn1parse</p> <p>asn1parse the output data, this is useful when combined with the -verifyrecover option when an ASN1 structure is signed.</p> </li> </ul>"},{"location":"man1/pkeyutl/#notes","title":"NOTES","text":"<p>The operations and options supported vary according to the key algorithm and its implementation. The OpenSSL operations and options are indicated below.</p> <p>Unless otherwise mentioned all algorithms support the digest:alg option which specifies the digest in use for sign, verify and verifyrecover operations. The value alg should represent a digest name as used in the EVP_get_digestbyname() function for example sha1. This value is used only for sanity-checking the lengths of data passed in to the pkeyutl and for creating the structures that make up the signature (e.g. DigestInfo in RSASSA PKCS#1 v1.5 signatures). In case of RSA, ECDSA and DSA signatures, this utility will not perform hashing on input data but rather use the data directly as input of signature algorithm. Depending on key type, signature type and mode of padding, the maximum acceptable lengths of input data differ. In general, with RSA the signed data can't be longer than the key modulus, in case of ECDSA and DSA the data shouldn't be longer than field size, otherwise it will be silently truncated to field size.</p> <p>In other words, if the value of digest is sha1 the input should be 20 bytes long binary encoding of SHA-1 hash function output.</p>"},{"location":"man1/pkeyutl/#rsa-algorithm","title":"RSA ALGORITHM","text":"<p>The RSA algorithm supports encrypt, decrypt, sign, verify and verifyrecover operations in general. Some padding modes only support some of these  operations however.</p> <ul> <li> <p>-rsa_padding_mode:mode</p> <p>This sets the RSA padding mode. Acceptable values for mode are pkcs1 for PKCS#1 padding, sslv23 for SSLv23 padding, none for no padding, oaep for OAEP mode, x931 for X9.31 mode and pss for PSS.</p> <p>In PKCS#1 padding if the message digest is not set then the supplied data is  signed or verified directly instead of using a DigestInfo structure. If a digest is set then the a DigestInfo structure is used and its the length must correspond to the digest type.</p> <p>For oeap mode only encryption and decryption is supported.</p> <p>For x931 if the digest type is set it is used to format the block data otherwise the first byte is used to specify the X9.31 digest ID. Sign, verify and verifyrecover are can be performed in this mode.</p> <p>For pss mode only sign and verify are supported and the digest type must be specified.</p> </li> <li> <p>rsa_pss_saltlen:len</p> <p>For pss mode only this option specifies the salt length. Two special values are supported: -1 sets the salt length to the digest length. When signing -2 sets the salt length to the maximum permissible value. When verifying -2 causes the salt length to be automatically determined based on the PSS block structure.</p> </li> </ul>"},{"location":"man1/pkeyutl/#dsa-algorithm","title":"DSA ALGORITHM","text":"<p>The DSA algorithm supports signing and verification operations only. Currently there are no additional options other than digest. Only the SHA1 digest can be used and this digest is assumed by default.</p>"},{"location":"man1/pkeyutl/#dh-algorithm","title":"DH ALGORITHM","text":"<p>The DH algorithm only supports the derivation operation and no additional options.</p>"},{"location":"man1/pkeyutl/#ec-algorithm","title":"EC ALGORITHM","text":"<p>The EC algorithm supports sign, verify and derive operations. The sign and verify operations use ECDSA and derive uses ECDH. Currently there are no additional options other than digest. Only the SHA1 digest can be used and this digest is assumed by default.</p>"},{"location":"man1/pkeyutl/#examples","title":"EXAMPLES","text":"<p>Sign some data using a private key:</p> <pre><code>openssl pkeyutl -sign -in file -inkey key.pem -out sig\n</code></pre> <p>Recover the signed data (e.g. if an RSA key is used):</p> <pre><code>openssl pkeyutl -verifyrecover -in sig -inkey key.pem\n</code></pre> <p>Verify the signature (e.g. a DSA key):</p> <pre><code>openssl pkeyutl -verify -in file -sigfile sig -inkey key.pem\n</code></pre> <p>Sign data using a message digest value (this is currently only valid for RSA):</p> <pre><code>openssl pkeyutl -sign -in file -inkey key.pem -out sig -pkeyopt digest:sha256\n</code></pre> <p>Derive a shared secret value:</p> <pre><code>openssl pkeyutl -derive -inkey key.pem -peerkey pubkey.pem -out secret\n</code></pre>"},{"location":"man1/pkeyutl/#see-also","title":"SEE ALSO","text":"<p>genpkey(1), pkey(1), rsautl(1) dgst(1), rsa(1), genrsa(1)</p>"},{"location":"man1/rand/","title":"rand","text":""},{"location":"man1/rand/#name","title":"NAME","text":"<p>openssl-rand, rand - generate pseudo-random bytes</p>"},{"location":"man1/rand/#synopsis","title":"SYNOPSIS","text":"<p>openssl rand [-out file] [-rand file(s)] [-base64] [-hex] num</p>"},{"location":"man1/rand/#description","title":"DESCRIPTION","text":"<p>The rand command outputs num pseudo-random bytes after seeding the random number generator once.  As in other openssl command line tools, PRNG seeding uses the file $HOME/.rnd or .rnd in addition to the files given in the -rand option.  A new $HOME/.rnd or .rnd file will be written back if enough seeding was obtained from these sources.</p>"},{"location":"man1/rand/#options","title":"OPTIONS","text":"<ul> <li> <p>-out file</p> <p>Write to file instead of standard output.</p> </li> <li> <p>-rand file(s)</p> <p>Use specified file or files or EGD socket (see RAND_egd(3)) for seeding the random number generator. Multiple files can be specified separated by a OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others.</p> </li> <li> <p>-base64</p> <p>Perform base64 encoding on the output.</p> </li> <li> <p>-hex</p> <p>Show the output as a hex string.</p> </li> </ul>"},{"location":"man1/rand/#see-also","title":"SEE ALSO","text":"<p>RAND_bytes(3)</p>"},{"location":"man1/req/","title":"req","text":""},{"location":"man1/req/#name","title":"NAME","text":"<p>openssl-req, req - PKCS#10 certificate request and certificate generating utility.</p>"},{"location":"man1/req/#synopsis","title":"SYNOPSIS","text":"<p>openssl req [-inform PEM|DER] [-outform PEM|DER] [-in filename] [-passin arg] [-out filename] [-passout arg] [-text] [-pubkey] [-noout] [-verify] [-modulus] [-new] [-rand file(s)] [-newkey rsa:bits] [-newkey alg:file] [-nodes] [-key filename] [-keyform PEM|DER] [-keyout filename] [-keygen_engine id] [-[digest]] [-config filename] [-multivalue-rdn] [-x509] [-days n] [-set_serial n] [-asn1-kludge] [-no-asn1-kludge] [-newhdr] [-extensions section] [-reqexts section] [-utf8] [-nameopt] [-reqopt] [-subject] [-subj arg] [-batch] [-verbose] [-engine id]</p>"},{"location":"man1/req/#description","title":"DESCRIPTION","text":"<p>The req command primarily creates and processes certificate requests in PKCS#10 format. It can additionally create self signed certificates for use as root CAs for example.</p>"},{"location":"man1/req/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-inform DER|PEM</p> <p>This specifies the input format. The DER option uses an ASN1 DER encoded form compatible with the PKCS#10. The PEM form is the default format: it consists of the DER format base64 encoded with additional header and footer lines.</p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read a request from or standard input if this option is not specified. A request is only read if the creation options (-new and -newkey) are not specified.</p> </li> <li> <p>-passin arg</p> <p>the input file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-out filename</p> <p>This specifies the output filename to write to or standard output by default.</p> </li> <li> <p>-passout arg</p> <p>the output file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-text</p> <p>prints out the certificate request in text form.</p> </li> <li> <p>-subject</p> <p>prints out the request subject (or certificate subject if -x509 is specified)</p> </li> <li> <p>-pubkey</p> <p>outputs the public key.</p> </li> <li> <p>-noout</p> <p>this option prevents output of the encoded version of the request.</p> </li> <li> <p>-modulus</p> <p>this option prints out the value of the modulus of the public key contained in the request.</p> </li> <li> <p>-verify</p> <p>verifies the signature on the request.</p> </li> <li> <p>-new</p> <p>this option generates a new certificate request. It will prompt the user for the relevant field values. The actual fields prompted for and their maximum and minimum sizes are specified in the configuration file and any requested extensions.</p> <p>If the -key option is not used it will generate a new RSA private key using information specified in the configuration file.</p> </li> <li> <p>-subj arg</p> <p>Replaces subject field of input request with specified data and outputs modified request. The arg must be formatted as /type0=value0/type1=value1/type2=..., characters may be escaped by \\ (backslash), no spaces are skipped.</p> </li> <li> <p>-rand file(s)</p> <p>a file or files containing random data used to seed the random number generator, or an EGD socket (see RAND_egd(3)). Multiple files can be specified separated by a OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others.</p> </li> <li> <p>-newkey arg</p> <p>this option creates a new certificate request and a new private key. The argument takes one of several forms. rsa:nbits, where nbits is the number of bits, generates an RSA key nbits in size. If nbits is omitted, i.e. -newkey rsa specified, the default key size, specified in the configuration file is used.</p> <p>All other algorithms support the -newkey alg:file form, where file may be an algorithm parameter file, created by the genpkey -genparam command or and X.509 certificate for a key with approriate algorithm.</p> <p>param:file generates a key using the parameter file or certificate file, the algorithm is determined by the parameters. algname:file use algorithm algname and parameter file file: the two algorithms must match or an error occurs. algname just uses algorithm algname, and parameters, if neccessary should be specified via -pkeyopt parameter.</p> <p>dsa:filename generates a DSA key using the parameters in the file filename. ec:filename generates EC key (usable both with ECDSA or ECDH algorithms), gost2001:filename generates GOST R 34.10-2001 key (requires ccgost engine configured in the configuration file). If just gost2001 is specified a parameter set should be specified by -pkeyopt paramset:X</p> </li> <li> <p>-pkeyopt opt:value</p> <p>set the public key algorithm option opt to value. The precise set of options supported depends on the public key algorithm used and its implementation. See KEY GENERATION OPTIONS in the genpkey manual page for more details.</p> </li> <li> <p>-key filename</p> <p>This specifies the file to read the private key from. It also accepts PKCS#8 format private keys for PEM format files.</p> </li> <li> <p>-keyform PEM|DER</p> <p>the format of the private key file specified in the -key argument. PEM is the default.</p> </li> <li> <p>-keyout filename</p> <p>this gives the filename to write the newly created private key to. If this option is not specified then the filename present in the configuration file is used.</p> </li> <li> <p>-nodes</p> <p>if this option is specified then if a private key is created it will not be encrypted.</p> </li> <li> <p>-[digest]</p> <p>this specifies the message digest to sign the request with (such as -md5, -sha1). This overrides the digest algorithm specified in the configuration file.</p> <p>Some public key algorithms may override this choice. For instance, DSA signatures always use SHA1, GOST R 34.10 signatures always use GOST R 34.11-94 (-md_gost94).</p> </li> <li> <p>-config filename</p> <p>this allows an alternative configuration file to be specified, this overrides the compile time filename or any specified in the OPENSSL_CONF environment variable.</p> </li> <li> <p>-subj arg</p> <p>sets subject name for new request or supersedes the subject name when processing a request. The arg must be formatted as /type0=value0/type1=value1/type2=..., characters may be escaped by \\ (backslash), no spaces are skipped.</p> </li> <li> <p>-multivalue-rdn</p> <p>this option causes the -subj argument to be interpreted with full support for multivalued RDNs. Example:</p> <p>/DC=org/DC=OpenSSL/DC=users/UID=123456+CN=John Doe</p> <p>If -multi-rdn is not used then the UID value is 123456+CN=John Doe.</p> </li> <li> <p>-x509</p> <p>this option outputs a self signed certificate instead of a certificate request. This is typically used to generate a test certificate or a self signed root CA. The extensions added to the certificate (if any) are specified in the configuration file. Unless specified using the set_serial option, a large random number will be used for the serial number.</p> <p>If existing request is specified with the -in option, it is converted to the self signed certificate otherwise new request is created.</p> </li> <li> <p>-days n</p> <p>when the -x509 option is being used this specifies the number of days to certify the certificate for. The default is 30 days.</p> </li> <li> <p>-set_serial n</p> <p>serial number to use when outputting a self signed certificate. This may be specified as a decimal value or a hex value if preceded by 0x. It is possible to use negative serial numbers but this is not recommended.</p> </li> <li> <p>-extensions section</p> </li> <li> <p>-reqexts section</p> <p>these options specify alternative sections to include certificate extensions (if the -x509 option is present) or certificate request extensions. This allows several different sections to be used in the same configuration file to specify requests for a variety of purposes.</p> </li> <li> <p>-utf8</p> <p>this option causes field values to be interpreted as UTF8 strings, by  default they are interpreted as ASCII. This means that the field values, whether prompted from a terminal or obtained from a configuration file, must be valid UTF8 strings.</p> </li> <li> <p>-nameopt option</p> <p>option which determines how the subject or issuer names are displayed. The option argument can be a single option or multiple options separated by commas.  Alternatively the -nameopt switch may be used more than once to set multiple options. See the x509(1) manual page for details.</p> </li> <li> <p>-reqopt</p> <p>customise the output format used with -text. The option argument can be a single option or multiple options separated by commas. </p> <p>See discission of the  -certopt parameter in the x509 command.</p> </li> <li> <p>-asn1-kludge</p> <p>by default the req command outputs certificate requests containing no attributes in the correct PKCS#10 format. However certain CAs will only accept requests containing no attributes in an invalid form: this option produces this invalid format.</p> <p>More precisely the Attributes in a PKCS#10 certificate request are defined as a SET OF Attribute. They are not OPTIONAL so if no attributes are present then they should be encoded as an empty SET OF. The invalid form does not include the empty SET OF whereas the correct form does.</p> <p>It should be noted that very few CAs still require the use of this option.</p> </li> <li> <p>-no-asn1-kludge</p> <p>Reverses effect of -asn1-kludge</p> </li> <li> <p>-newhdr</p> <p>Adds the word NEW to the PEM file header and footer lines on the outputted request. Some software (Netscape certificate server) and some CAs need this.</p> </li> <li> <p>-batch</p> <p>non-interactive mode.</p> </li> <li> <p>-verbose</p> <p>print extra details about the operations being performed.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause req to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> <li> <p>-keygen_engine id</p> <p>specifies an engine (by its unique id string) which would be used for key generation operations.</p> </li> </ul>"},{"location":"man1/req/#configuration-file-format","title":"CONFIGURATION FILE FORMAT","text":"<p>The configuration options are specified in the req section of the configuration file. As with all configuration files if no value is specified in the specific section (i.e. req) then the initial unnamed or default section is searched too.</p> <p>The options available are described in detail below.</p> <ul> <li> <p>input_password output_password</p> <p>The passwords for the input private key file (if present) and the output private key file (if one will be created). The command line options passin and passout override the configuration file values.</p> </li> <li> <p>default_bits</p> <p>Specifies the default key size in bits.</p> <p>This option is used in conjunction with the -new option to generate a new key. It can be overridden by specifying an explicit key size in the -newkey option. The smallest accepted key size is 512 bits. If no key size is specified then 2048 bits is used.</p> </li> <li> <p>default_keyfile</p> <p>This is the default filename to write a private key to. If not specified the key is written to standard output. This can be overridden by the -keyout option.</p> </li> <li> <p>oid_file</p> <p>This specifies a file containing additional OBJECT IDENTIFIERS. Each line of the file should consist of the numerical form of the object identifier followed by white space then the short name followed by white space and finally the long name. </p> </li> <li> <p>oid_section</p> <p>This specifies a section in the configuration file containing extra object identifiers. Each line should consist of the short name of the object identifier followed by = and the numerical form. The short and long names are the same when this option is used.</p> </li> <li> <p>RANDFILE</p> <p>This specifies a filename in which random number seed information is placed and read from, or an EGD socket (see RAND_egd(3)). It is used for private key generation.</p> </li> <li> <p>encrypt_key</p> <p>If this is set to no then if a private key is generated it is not encrypted. This is equivalent to the -nodes command line option. For compatibility encrypt_rsa_key is an equivalent option.</p> </li> <li> <p>default_md</p> <p>This option specifies the digest algorithm to use. Possible values include md5 sha1 mdc2. This option can be overridden on the command line.</p> </li> <li> <p>string_mask</p> <p>This option masks out the use of certain string types in certain fields. Most users will not need to change this option.</p> <p>It can be set to several values default which is also the default option uses PrintableStrings, T61Strings and BMPStrings if the  pkix value is used then only PrintableStrings and BMPStrings will be used. This follows the PKIX recommendation in RFC2459. If the utf8only option is used then only UTF8Strings will be used: this is the PKIX recommendation in RFC2459 after 2003. Finally the nombstr option just uses PrintableStrings and T61Strings: certain software has problems with BMPStrings and UTF8Strings: in particular Netscape.</p> </li> <li> <p>req_extensions</p> <p>this specifies the configuration file section containing a list of extensions to add to the certificate request. It can be overridden by the -reqexts command line switch. See the  x509v3_config(5) manual page for details of the extension section format.</p> </li> <li> <p>x509_extensions</p> <p>this specifies the configuration file section containing a list of extensions to add to certificate generated when the -x509 switch is used. It can be overridden by the -extensions command line switch.</p> </li> <li> <p>prompt</p> <p>if set to the value no this disables prompting of certificate fields and just takes values from the config file directly. It also changes the expected format of the distinguished_name and attributes sections.</p> </li> <li> <p>utf8</p> <p>if set to the value yes then field values to be interpreted as UTF8 strings, by default they are interpreted as ASCII. This means that the field values, whether prompted from a terminal or obtained from a configuration file, must be valid UTF8 strings.</p> </li> <li> <p>attributes</p> <p>this specifies the section containing any request attributes: its format is the same as distinguished_name. Typically these may contain the challengePassword or unstructuredName types. They are currently ignored by OpenSSL's request signing utilities but some CAs might want them.</p> </li> <li> <p>distinguished_name</p> <p>This specifies the section containing the distinguished name fields to prompt for when generating a certificate or certificate request. The format is described in the next section.</p> </li> </ul>"},{"location":"man1/req/#distinguished-name-and-attribute-section-format","title":"DISTINGUISHED NAME AND ATTRIBUTE SECTION FORMAT","text":"<p>There are two separate formats for the distinguished name and attribute sections. If the prompt option is set to no then these sections just consist of field names and values: for example,</p> <pre><code>CN=My Name\nOU=My Organization\nemailAddress=someone@somewhere.org\n</code></pre> <p>This allows external programs (e.g. GUI based) to generate a template file with all the field names and values and just pass it to req. An example of this kind of configuration file is contained in the EXAMPLES section.</p> <p>Alternatively if the prompt option is absent or not set to no then the file contains field prompting information. It consists of lines of the form:</p> <pre><code>fieldName=\"prompt\"\nfieldName_default=\"default field value\"\nfieldName_min= 2\nfieldName_max= 4\n</code></pre> <p>\"fieldName\" is the field name being used, for example commonName (or CN). The \"prompt\" string is used to ask the user to enter the relevant details. If the user enters nothing then the default value is used if no default value is present then the field is omitted. A field can still be omitted if a default value is present if the user just enters the '.' character.</p> <p>The number of characters entered must be between the fieldName_min and fieldName_max limits: there may be additional restrictions based on the field being used (for example countryName can only ever be two characters long and must fit in a PrintableString).</p> <p>Some fields (such as organizationName) can be used more than once in a DN. This presents a problem because configuration files will not recognize the same name occurring twice. To avoid this problem if the fieldName contains some characters followed by a full stop they will be ignored. So for example a second organizationName can be input by calling it \"1.organizationName\".</p> <p>The actual permitted field names are any object identifier short or long names. These are compiled into OpenSSL and include the usual values such as commonName, countryName, localityName, organizationName, organizationalUnitName, stateOrProvinceName. Additionally emailAddress is include as well as name, surname, givenName initials and dnQualifier.</p> <p>Additional object identifiers can be defined with the oid_file or oid_section options in the configuration file. Any additional fields will be treated as though they were a DirectoryString.</p>"},{"location":"man1/req/#examples","title":"EXAMPLES","text":"<p>Examine and verify certificate request:</p> <pre><code>openssl req -in req.pem -text -verify -noout\n</code></pre> <p>Create a private key and then generate a certificate request from it:</p> <pre><code>openssl genrsa -out key.pem 2048\nopenssl req -new -key key.pem -out req.pem\n</code></pre> <p>The same but just using req:</p> <pre><code>openssl req -newkey rsa:2048 -keyout key.pem -out req.pem\n</code></pre> <p>Generate a self signed root certificate:</p> <pre><code>openssl req -x509 -newkey rsa:2048 -keyout key.pem -out req.pem\n</code></pre> <p>Example of a file pointed to by the oid_file option:</p> <pre><code>1.2.3.4        shortName       A longer Name\n1.2.3.6        otherName       Other longer Name\n</code></pre> <p>Example of a section pointed to by oid_section making use of variable expansion:</p> <pre><code>testoid1=1.2.3.5\ntestoid2=${testoid1}.6\n</code></pre> <p>Sample configuration file prompting for field values:</p> <pre><code>[ req ]\ndefault_bits           = 2048\ndefault_keyfile        = privkey.pem\ndistinguished_name     = req_distinguished_name\nattributes             = req_attributes\nx509_extensions        = v3_ca\n\ndirstring_type = nobmp\n\n[ req_distinguished_name ]\ncountryName                    = Country Name (2 letter code)\ncountryName_default            = AU\ncountryName_min                = 2\ncountryName_max                = 2\n\nlocalityName                   = Locality Name (eg, city)\n\norganizationalUnitName         = Organizational Unit Name (eg, section)\n\ncommonName                     = Common Name (eg, YOUR name)\ncommonName_max                 = 64\n\nemailAddress                   = Email Address\nemailAddress_max               = 40\n\n[ req_attributes ]\nchallengePassword              = A challenge password\nchallengePassword_min          = 4\nchallengePassword_max          = 20\n\n[ v3_ca ]\n\nsubjectKeyIdentifier=hash\nauthorityKeyIdentifier=keyid:always,issuer:always\nbasicConstraints = CA:true\n</code></pre> <p>Sample configuration containing all field values:</p> <pre><code>RANDFILE               = $ENV::HOME/.rnd\n\n[ req ]\ndefault_bits           = 2048\ndefault_keyfile        = keyfile.pem\ndistinguished_name     = req_distinguished_name\nattributes             = req_attributes\nprompt                 = no\noutput_password        = mypass\n\n[ req_distinguished_name ]\nC                      = GB\nST                     = Test State or Province\nL                      = Test Locality\nO                      = Organization Name\nOU                     = Organizational Unit Name\nCN                     = Common Name\nemailAddress           = test@email.address\n\n[ req_attributes ]\nchallengePassword              = A challenge password\n</code></pre>"},{"location":"man1/req/#notes","title":"NOTES","text":"<p>The header and footer lines in the PEM format are normally:</p> <pre><code>-----BEGIN CERTIFICATE REQUEST-----\n-----END CERTIFICATE REQUEST-----\n</code></pre> <p>some software (some versions of Netscape certificate server) instead needs:</p> <pre><code>-----BEGIN NEW CERTIFICATE REQUEST-----\n-----END NEW CERTIFICATE REQUEST-----\n</code></pre> <p>which is produced with the -newhdr option but is otherwise compatible. Either form is accepted transparently on input.</p> <p>The certificate requests generated by Xenroll with MSIE have extensions added. It includes the keyUsage extension which determines the type of key (signature only or general purpose) and any additional OIDs entered by the script in an extendedKeyUsage extension.</p>"},{"location":"man1/req/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following messages are frequently asked about:</p> <pre><code>    Using configuration from /some/path/openssl.cnf\n    Unable to load config info\n</code></pre> <p>This is followed some time later by...</p> <pre><code>    unable to find 'distinguished_name' in config\n    problems making Certificate Request\n</code></pre> <p>The first error message is the clue: it can't find the configuration file! Certain operations (like examining a certificate request) don't need a configuration file so its use isn't enforced. Generation of certificates or requests however does need a configuration file. This could be regarded as a bug.</p> <p>Another puzzling message is this:</p> <pre><code>    Attributes:\n        a0:00\n</code></pre> <p>this is displayed when no attributes are present and the request includes the correct empty SET OF structure (the DER encoding of which is 0xa0 0x00). If you just see:</p> <pre><code>    Attributes:\n</code></pre> <p>then the SET OF is missing and the encoding is technically invalid (but it is tolerated). See the description of the command line option -asn1-kludge for more information.</p>"},{"location":"man1/req/#environment-variables","title":"ENVIRONMENT VARIABLES","text":"<p>The variable OPENSSL_CONF if defined allows an alternative configuration file location to be specified, it will be overridden by the -config command line switch if it is present. For compatibility reasons the SSLEAY_CONF environment variable serves the same purpose but its use is discouraged.</p>"},{"location":"man1/req/#bugs","title":"BUGS","text":"<p>OpenSSL's handling of T61Strings (aka TeletexStrings) is broken: it effectively treats them as ISO-8859-1 (Latin 1), Netscape and MSIE have similar behaviour. This can cause problems if you need characters that aren't available in PrintableStrings and you don't want to or can't use BMPStrings.</p> <p>As a consequence of the T61String handling the only correct way to represent accented characters in OpenSSL is to use a BMPString: unfortunately Netscape currently chokes on these. If you have to use accented characters with Netscape and MSIE then you currently need to use the invalid T61String form.</p> <p>The current prompting is not very friendly. It doesn't allow you to confirm what you've just entered. Other things like extensions in certificate requests are statically defined in the configuration file. Some of these: like an email address in subjectAltName should be input by the user.</p>"},{"location":"man1/req/#see-also","title":"SEE ALSO","text":"<p>x509(1), ca(1), genrsa(1), gendsa(1), config(5), x509v3_config(5) </p>"},{"location":"man1/rsa/","title":"rsa","text":""},{"location":"man1/rsa/#name","title":"NAME","text":"<p>openssl-rsa, rsa - RSA key processing tool</p>"},{"location":"man1/rsa/#synopsis","title":"SYNOPSIS","text":"<p>openssl rsa [-inform PEM|NET|DER] [-outform PEM|NET|DER] [-in filename] [-passin arg] [-out filename] [-passout arg] [-sgckey] [-aes128] [-aes192] [-aes256] [-camellia128] [-camellia192] [-camellia256] [-des] [-des3] [-idea] [-text] [-noout] [-modulus] [-check] [-pubin] [-pubout] [-RSAPublicKey_in] [-RSAPublicKey_out] [-engine id]</p>"},{"location":"man1/rsa/#description","title":"DESCRIPTION","text":"<p>The rsa command processes RSA keys. They can be converted between various forms and their components printed out. Note this command uses the traditional SSLeay compatible format for private key encryption: newer applications should use the more secure PKCS#8 format using the pkcs8 utility.</p>"},{"location":"man1/rsa/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-inform DER|NET|PEM</p> <p>This specifies the input format. The DER option uses an ASN1 DER encoded form compatible with the PKCS#1 RSAPrivateKey or SubjectPublicKeyInfo format. The PEM form is the default format: it consists of the DER format base64 encoded with additional header and footer lines. On input PKCS#8 format private keys are also accepted. The NET form is a format is described in the NOTES section.</p> </li> <li> <p>-outform DER|NET|PEM</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read a key from or standard input if this option is not specified. If the key is encrypted a pass phrase will be prompted for.</p> </li> <li> <p>-passin arg</p> <p>the input file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-out filename</p> <p>This specifies the output filename to write a key to or standard output if this option is not specified. If any encryption options are set then a pass phrase will be prompted for. The output filename should not be the same as the input filename.</p> </li> <li> <p>-passout password</p> <p>the output file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-sgckey</p> <p>use the modified NET algorithm used with some versions of Microsoft IIS and SGC keys.</p> </li> <li> <p>-aes128|-aes192|-aes256|-camellia128|-camellia192|-camellia256|-des|-des3|-idea</p> <p>These options encrypt the private key with the specified cipher before outputting it. A pass phrase is prompted for. If none of these options is specified the key is written in plain text. This means that using the rsa utility to read in an encrypted key with no encryption option can be used to remove the pass phrase from a key, or by setting the encryption options it can be use to add or change the pass phrase. These options can only be used with PEM format output files.</p> </li> <li> <p>-text</p> <p>prints out the various public or private key components in plain text in addition to the encoded version. </p> </li> <li> <p>-noout</p> <p>this option prevents output of the encoded version of the key.</p> </li> <li> <p>-modulus</p> <p>this option prints out the value of the modulus of the key.</p> </li> <li> <p>-check</p> <p>this option checks the consistency of an RSA private key.</p> </li> <li> <p>-pubin</p> <p>by default a private key is read from the input file: with this option a public key is read instead.</p> </li> <li> <p>-pubout</p> <p>by default a private key is output: with this option a public key will be output instead. This option is automatically set if the input is a public key.</p> </li> <li> <p>-RSAPublicKey_in, -RSAPublicKey_out</p> <p>like -pubin and -pubout except RSAPublicKey format is used instead.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause rsa to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> </ul>"},{"location":"man1/rsa/#notes","title":"NOTES","text":"<p>The PEM private key format uses the header and footer lines:</p> <pre><code>-----BEGIN RSA PRIVATE KEY-----\n-----END RSA PRIVATE KEY-----\n</code></pre> <p>The PEM public key format uses the header and footer lines:</p> <pre><code>-----BEGIN PUBLIC KEY-----\n-----END PUBLIC KEY-----\n</code></pre> <p>The PEM RSAPublicKey format uses the header and footer lines:</p> <pre><code>-----BEGIN RSA PUBLIC KEY-----\n-----END RSA PUBLIC KEY-----\n</code></pre> <p>The NET form is a format compatible with older Netscape servers and Microsoft IIS .key files, this uses unsalted RC4 for its encryption. It is not very secure and so should only be used when necessary.</p> <p>Some newer version of IIS have additional data in the exported .key files. To use these with the utility, view the file with a binary editor and look for the string \"private-key\", then trace back to the byte sequence 0x30, 0x82 (this is an ASN1 SEQUENCE). Copy all the data from this point onwards to another file and use that as the input to the rsa utility with the -inform NET option. If you get an error after entering the password try the -sgckey option.</p>"},{"location":"man1/rsa/#examples","title":"EXAMPLES","text":"<p>To remove the pass phrase on an RSA private key:</p> <pre><code>openssl rsa -in key.pem -out keyout.pem\n</code></pre> <p>To encrypt a private key using triple DES:</p> <pre><code>openssl rsa -in key.pem -des3 -out keyout.pem\n</code></pre> <p>To convert a private key from PEM to DER format: </p> <pre><code>openssl rsa -in key.pem -outform DER -out keyout.der\n</code></pre> <p>To print out the components of a private key to standard output:</p> <pre><code>openssl rsa -in key.pem -text -noout\n</code></pre> <p>To just output the public part of a private key:</p> <pre><code>openssl rsa -in key.pem -pubout -out pubkey.pem\n</code></pre> <p>Output the public part of a private key in RSAPublicKey format:</p> <pre><code>openssl rsa -in key.pem -RSAPublicKey_out -out pubkey.pem\n</code></pre>"},{"location":"man1/rsa/#bugs","title":"BUGS","text":"<p>The command line password arguments don't currently work with NET format.</p> <p>There should be an option that automatically handles .key files, without having to manually edit them.</p>"},{"location":"man1/rsa/#see-also","title":"SEE ALSO","text":"<p>pkcs8(1), dsa(1), genrsa(1), gendsa(1) </p>"},{"location":"man1/rsautl/","title":"rsautl","text":""},{"location":"man1/rsautl/#name","title":"NAME","text":"<p>openssl-rsautl, rsautl - RSA utility</p>"},{"location":"man1/rsautl/#synopsis","title":"SYNOPSIS","text":"<p>openssl rsautl [-in file] [-out file] [-inkey file] [-pubin] [-certin] [-sign] [-verify] [-encrypt] [-decrypt] [-pkcs] [-ssl] [-raw] [-hexdump] [-asn1parse]</p>"},{"location":"man1/rsautl/#description","title":"DESCRIPTION","text":"<p>The rsautl command can be used to sign, verify, encrypt and decrypt data using the RSA algorithm.</p>"},{"location":"man1/rsautl/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-in filename</p> <p>This specifies the input filename to read data from or standard input if this option is not specified.</p> </li> <li> <p>-out filename</p> <p>specifies the output filename to write to or standard output by default.</p> </li> <li> <p>-inkey file</p> <p>the input key file, by default it should be an RSA private key.</p> </li> <li> <p>-pubin</p> <p>the input file is an RSA public key. </p> </li> <li> <p>-certin</p> <p>the input is a certificate containing an RSA public key. </p> </li> <li> <p>-sign</p> <p>sign the input data and output the signed result. This requires and RSA private key.</p> </li> <li> <p>-verify</p> <p>verify the input data and output the recovered data.</p> </li> <li> <p>-encrypt</p> <p>encrypt the input data using an RSA public key.</p> </li> <li> <p>-decrypt</p> <p>decrypt the input data using an RSA private key.</p> </li> <li> <p>-pkcs, -oaep, -ssl, -raw</p> <p>the padding to use: PKCS#1 v1.5 (the default), PKCS#1 OAEP, special padding used in SSL v2 backwards compatible handshakes, or no padding, respectively. For signatures, only -pkcs and -raw can be used.</p> </li> <li> <p>-hexdump</p> <p>hex dump the output data.</p> </li> <li> <p>-asn1parse</p> <p>asn1parse the output data, this is useful when combined with the -verify option.</p> </li> </ul>"},{"location":"man1/rsautl/#notes","title":"NOTES","text":"<p>rsautl because it uses the RSA algorithm directly can only be used to sign or verify small pieces of data.</p>"},{"location":"man1/rsautl/#examples","title":"EXAMPLES","text":"<p>Sign some data using a private key:</p> <pre><code>openssl rsautl -sign -in file -inkey key.pem -out sig\n</code></pre> <p>Recover the signed data</p> <pre><code>openssl rsautl -verify -in sig -inkey key.pem\n</code></pre> <p>Examine the raw signed data:</p> <pre><code>openssl rsautl -verify -in sig -inkey key.pem -raw -hexdump\n\n0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n0070 - ff ff ff ff 00 68 65 6c-6c 6f 20 77 6f 72 6c 64   .....hello world\n</code></pre> <p>The PKCS#1 block formatting is evident from this. If this was done using encrypt and decrypt the block would have been of type 2 (the second byte) and random padding data visible instead of the 0xff bytes.</p> <p>It is possible to analyse the signature of certificates using this utility in conjunction with asn1parse. Consider the self signed example in certs/pca-cert.pem . Running asn1parse as follows yields:</p> <pre><code>openssl asn1parse -in pca-cert.pem\n\n   0:d=0  hl=4 l= 742 cons: SEQUENCE          \n   4:d=1  hl=4 l= 591 cons:  SEQUENCE          \n   8:d=2  hl=2 l=   3 cons:   cont [ 0 ]        \n  10:d=3  hl=2 l=   1 prim:    INTEGER           :02\n  13:d=2  hl=2 l=   1 prim:   INTEGER           :00\n  16:d=2  hl=2 l=  13 cons:   SEQUENCE          \n  18:d=3  hl=2 l=   9 prim:    OBJECT            :md5WithRSAEncryption\n  29:d=3  hl=2 l=   0 prim:    NULL              \n  31:d=2  hl=2 l=  92 cons:   SEQUENCE          \n  33:d=3  hl=2 l=  11 cons:    SET               \n  35:d=4  hl=2 l=   9 cons:     SEQUENCE          \n  37:d=5  hl=2 l=   3 prim:      OBJECT            :countryName\n  42:d=5  hl=2 l=   2 prim:      PRINTABLESTRING   :AU\n ....\n 599:d=1  hl=2 l=  13 cons:  SEQUENCE          \n 601:d=2  hl=2 l=   9 prim:   OBJECT            :md5WithRSAEncryption\n 612:d=2  hl=2 l=   0 prim:   NULL              \n 614:d=1  hl=3 l= 129 prim:  BIT STRING\n</code></pre> <p>The final BIT STRING contains the actual signature. It can be extracted with:</p> <pre><code>openssl asn1parse -in pca-cert.pem -out sig -noout -strparse 614\n</code></pre> <p>The certificate public key can be extracted with:</p> <pre><code>openssl x509 -in test/testx509.pem -pubkey -noout &gt;pubkey.pem\n</code></pre> <p>The signature can be analysed with:</p> <pre><code>openssl rsautl -in sig -verify -asn1parse -inkey pubkey.pem -pubin\n\n   0:d=0  hl=2 l=  32 cons: SEQUENCE          \n   2:d=1  hl=2 l=  12 cons:  SEQUENCE          \n   4:d=2  hl=2 l=   8 prim:   OBJECT            :md5\n  14:d=2  hl=2 l=   0 prim:   NULL              \n  16:d=1  hl=2 l=  16 prim:  OCTET STRING      \n     0000 - f3 46 9e aa 1a 4a 73 c9-37 ea 93 00 48 25 08 b5   .F...Js.7...H%..\n</code></pre> <p>This is the parsed version of an ASN1 DigestInfo structure. It can be seen that the digest used was md5. The actual part of the certificate that was signed can be extracted with:</p> <pre><code>openssl asn1parse -in pca-cert.pem -out tbs -noout -strparse 4\n</code></pre> <p>and its digest computed with:</p> <pre><code>openssl md5 -c tbs\nMD5(tbs)= f3:46:9e:aa:1a:4a:73:c9:37:ea:93:00:48:25:08:b5\n</code></pre> <p>which it can be seen agrees with the recovered value above.</p>"},{"location":"man1/rsautl/#see-also","title":"SEE ALSO","text":"<p>dgst(1), rsa(1), genrsa(1)</p>"},{"location":"man1/s_client/","title":"s_client","text":""},{"location":"man1/s_client/#name","title":"NAME","text":"<p>openssl-s_client, s_client - SSL/TLS client program</p>"},{"location":"man1/s_client/#synopsis","title":"SYNOPSIS","text":"<p>openssl s_client [-connect host:port] [-servername name] [-verify depth] [-verify_return_error] [-cert filename] [-certform DER|PEM] [-key filename] [-keyform DER|PEM] [-pass arg] [-CApath directory] [-CAfile filename] [-no_alt_chains] [-reconnect] [-pause] [-showcerts] [-debug] [-msg] [-nbio_test] [-state] [-nbio] [-crlf] [-ign_eof] [-no_ign_eof] [-quiet] [-ssl2] [-ssl3] [-tls1] [-no_ssl2] [-no_ssl3] [-no_tls1] [-no_tls1_1] [-no_tls1_2] [-fallback_scsv] [-bugs] [-sigalgs sigalglist] [-curves curvelist] [-cipher cipherlist] [-serverpref] [-starttls protocol] [-engine id] [-tlsextdebug] [-no_ticket] [-sess_out filename] [-sess_in filename] [-rand file(s)] [-serverinfo types] [-status] [-alpn protocols] [-nextprotoneg protocols]</p>"},{"location":"man1/s_client/#description","title":"DESCRIPTION","text":"<p>The s_client command implements a generic SSL/TLS client which connects to a remote host using SSL/TLS. It is a very useful diagnostic tool for SSL servers.</p>"},{"location":"man1/s_client/#options","title":"OPTIONS","text":"<ul> <li> <p>-connect host:port</p> <p>This specifies the host and optional port to connect to. If not specified then an attempt is made to connect to the local host on port 4433.</p> </li> <li> <p>-servername name</p> <p>Set the TLS SNI (Server Name Indication) extension in the ClientHello message.</p> </li> <li> <p>-cert certname</p> <p>The certificate to use, if one is requested by the server. The default is not to use a certificate.</p> </li> <li> <p>-certform format</p> <p>The certificate format to use: DER or PEM. PEM is the default.</p> </li> <li> <p>-key keyfile</p> <p>The private key to use. If not specified then the certificate file will be used.</p> </li> <li> <p>-keyform format</p> <p>The private format to use: DER or PEM. PEM is the default.</p> </li> <li> <p>-pass arg</p> <p>the private key password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-verify depth</p> <p>The verify depth to use. This specifies the maximum length of the server certificate chain and turns on server certificate verification. Currently the verify operation continues after errors so all the problems with a certificate chain can be seen. As a side effect the connection will never fail due to a server certificate verify failure.</p> </li> <li> <p>-verify_return_error</p> <p>Return verification errors instead of continuing. This will typically abort the handshake with a fatal error.</p> </li> <li> <p>-CApath directory</p> <p>The directory to use for server certificate verification. This directory must be in \"hash format\", see verify for more information. These are also used when building the client certificate chain.</p> </li> <li> <p>-CAfile file</p> <p>A file containing trusted certificates to use during server authentication and to use when attempting to build the client certificate chain.</p> </li> <li> <p>-purpose, -ignore_critical, -issuer_checks, -crl_check, -crl_check_all, -policy_check, -extended_crl, -x509_strict, -policy -check_ss_sig -no_alt_chains</p> <p>Set various certificate chain valiadition option. See the verify manual page for details.</p> </li> <li> <p>-reconnect</p> <p>reconnects to the same server 5 times using the same session ID, this can be used as a test that session caching is working.</p> </li> <li> <p>-pause</p> <p>pauses 1 second between each read and write call.</p> </li> <li> <p>-showcerts</p> <p>Displays the server certificate list as sent by the server: it only consists of certificates the server has sent (in the order the server has sent them). It is not a verified chain.</p> </li> <li> <p>-prexit</p> <p>print session information when the program exits. This will always attempt to print out information even if the connection fails. Normally information will only be printed out once if the connection succeeds. This option is useful because the cipher in use may be renegotiated or the connection may fail because a client certificate is required or is requested only after an attempt is made to access a certain URL. Note: the output produced by this option is not always accurate because a connection might never have been established.</p> </li> <li> <p>-state</p> <p>prints out the SSL session states.</p> </li> <li> <p>-debug</p> <p>print extensive debugging information including a hex dump of all traffic.</p> </li> <li> <p>-msg</p> <p>show all protocol messages with hex dump.</p> </li> <li> <p>-nbio_test</p> <p>tests non-blocking I/O</p> </li> <li> <p>-nbio</p> <p>turns on non-blocking I/O</p> </li> <li> <p>-crlf</p> <p>this option translated a line feed from the terminal into CR+LF as required by some servers.</p> </li> <li> <p>-ign_eof</p> <p>inhibit shutting down the connection when end of file is reached in the input.</p> </li> <li> <p>-quiet</p> <p>inhibit printing of session and certificate information.  This implicitly turns on -ign_eof as well.</p> </li> <li> <p>-no_ign_eof</p> <p>shut down the connection when end of file is reached in the input. Can be used to override the implicit -ign_eof after -quiet.</p> </li> <li> <p>-psk_identity identity</p> <p>Use the PSK identity identity when using a PSK cipher suite. The default value is \"Client_identity\" (without the quotes).</p> </li> <li> <p>-psk key</p> <p>Use the PSK key key when using a PSK cipher suite. The key is given as a hexadecimal number without leading 0x, for example -psk 1a2b3c4d. This option must be provided in order to use a PSK cipher.</p> </li> <li> <p>-ssl2, -ssl3, -tls1, -tls1_1, -tls1_2, -no_ssl2, -no_ssl3, -no_tls1, -no_tls1_1, -no_tls1_2</p> <p>These options require or disable the use of the specified SSL or TLS protocols. By default the initial handshake uses a version-flexible method which will negotiate the highest mutually supported protocol version.</p> </li> <li> <p>-fallback_scsv</p> <p>Send TLS_FALLBACK_SCSV in the ClientHello.</p> </li> <li> <p>-bugs</p> <p>there are several known bug in SSL and TLS implementations. Adding this option enables various workarounds.</p> </li> <li> <p>-sigalgs sigalglist</p> <p>Specifies the list of signature algorithms that are sent by the client. The server selects one entry in the list based on its preferences. For example strings, see SSL_CTX_set1_sigalgs(3)</p> </li> <li> <p>-curves curvelist</p> <p>Specifies the list of supported curves to be sent by the client. The curve is is ultimately selected by the server. For a list of all curves, use:</p> <pre><code>$ openssl ecparam -list_curves\n</code></pre> </li> <li> <p>-cipher cipherlist</p> <p>this allows the cipher list sent by the client to be modified. Although the server determines which cipher suite is used it should take the first supported cipher in the list sent by the client. See the ciphers command for more information.</p> </li> <li> <p>-serverpref</p> <p>use the server's cipher preferences; only used for SSLV2.</p> </li> <li> <p>-starttls protocol</p> <p>send the protocol-specific message(s) to switch to TLS for communication. protocol is a keyword for the intended protocol.  Currently, the only supported keywords are \"smtp\", \"pop3\", \"imap\", \"ftp\" and \"xmpp\".</p> </li> <li> <p>-tlsextdebug</p> <p>print out a hex dump of any TLS extensions received from the server.</p> </li> <li> <p>-no_ticket</p> <p>disable RFC4507bis session ticket support. </p> </li> <li> <p>-sess_out filename</p> <p>output SSL session to filename</p> </li> <li> <p>-sess_in sess.pem</p> <p>load SSL session from filename. The client will attempt to resume a connection from this session.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause s_client to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> <li> <p>-rand file(s)</p> <p>a file or files containing random data used to seed the random number generator, or an EGD socket (see RAND_egd(3)). Multiple files can be specified separated by a OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others.</p> </li> <li> <p>-serverinfo types</p> <p>a list of comma-separated TLS Extension Types (numbers between 0 and  65535).  Each type will be sent as an empty ClientHello TLS Extension. The server's response (if any) will be encoded and displayed as a PEM file.</p> </li> <li> <p>-status</p> <p>sends a certificate status request to the server (OCSP stapling). The server response (if any) is printed out.</p> </li> <li> <p>-alpn protocols, -nextprotoneg protocols</p> <p>these flags enable the  Enable the Application-Layer Protocol Negotiation or Next Protocol Negotiation extension, respectively. ALPN is the IETF standard and replaces NPN. The protocols list is a comma-separated protocol names that the client should advertise support for. The list should contain most wanted protocols first. Protocol names are printable ASCII strings, for example \"http/1.1\" or \"spdy/3\". Empty list of protocols is treated specially and will cause the client to advertise support for the TLS extension but disconnect just after reciving ServerHello with a list of server supported protocols.</p> </li> </ul>"},{"location":"man1/s_client/#connected-commands","title":"CONNECTED COMMANDS","text":"<p>If a connection is established with an SSL server then any data received from the server is displayed and any key presses will be sent to the server. When used interactively (which means neither -quiet nor -ign_eof have been given), the session will be renegotiated if the line begins with an R, and if the line begins with a Q or if end of file is reached, the connection will be closed down.</p>"},{"location":"man1/s_client/#notes","title":"NOTES","text":"<p>s_client can be used to debug SSL servers. To connect to an SSL HTTP server the command:</p> <pre><code>openssl s_client -connect servername:443\n</code></pre> <p>would typically be used (https uses port 443). If the connection succeeds then an HTTP command can be given such as \"GET /\" to retrieve a web page.</p> <p>If the handshake fails then there are several possible causes, if it is nothing obvious like no client certificate then the -bugs, -ssl2, -ssl3, -tls1, -no_ssl2, -no_ssl3, -no_tls1 options can be tried in case it is a buggy server. In particular you should play with these options before submitting a bug report to an OpenSSL mailing list.</p> <p>A frequent problem when attempting to get client certificates working is that a web client complains it has no certificates or gives an empty list to choose from. This is normally because the server is not sending the clients certificate authority in its \"acceptable CA list\" when it requests a certificate. By using s_client the CA list can be viewed and checked. However some servers only request client authentication after a specific URL is requested. To obtain the list in this case it is necessary to use the -prexit option and send an HTTP request for an appropriate page.</p> <p>If a certificate is specified on the command line using the -cert option it will not be used unless the server specifically requests a client certificate. Therefor merely including a client certificate on the command line is no guarantee that the certificate works.</p> <p>If there are problems verifying a server certificate then the -showcerts option can be used to show all the certificates sent by the server.</p> <p>Since the SSLv23 client hello cannot include compression methods or extensions these will only be supported if its use is disabled, for example by using the -no_sslv2 option.</p> <p>The s_client utility is a test tool and is designed to continue the handshake after any certificate verification errors. As a result it will accept any certificate chain (trusted or not) sent by the peer. None test applications should not do this as it makes them vulnerable to a MITM attack. This behaviour can be changed by with the -verify_return_error option: any verify errors are then returned aborting the handshake.</p>"},{"location":"man1/s_client/#bugs","title":"BUGS","text":"<p>Because this program has a lot of options and also because some of the techniques used are rather old, the C source of s_client is rather hard to read and not a model of how things should be done. A typical SSL client program would be much simpler.</p> <p>The -prexit option is a bit of a hack. We should really report information whenever a session is renegotiated.</p>"},{"location":"man1/s_client/#see-also","title":"SEE ALSO","text":"<p>sess_id(1), s_server(1), ciphers(1)</p>"},{"location":"man1/s_client/#history","title":"HISTORY","text":"<p>The -no_alt_chains options was first added to OpenSSL 1.0.2b.</p>"},{"location":"man1/s_server/","title":"s_server","text":""},{"location":"man1/s_server/#name","title":"NAME","text":"<p>openssl-s_server, s_server - SSL/TLS server program</p>"},{"location":"man1/s_server/#synopsis","title":"SYNOPSIS","text":"<p>openssl s_server [-accept port] [-context id] [-verify depth] [-Verify depth] [-crl_check] [-crl_check_all] [-cert filename] [-certform DER|PEM] [-key keyfile] [-keyform DER|PEM] [-pass arg] [-dcert filename] [-dcertform DER|PEM] [-dkey keyfile] [-dkeyform DER|PEM] [-dpass arg] [-dhparam filename] [-nbio] [-nbio_test] [-crlf] [-debug] [-msg] [-state] [-CApath directory] [-CAfile filename] [-no_alt_chains] [-nocert] [-client_sigalgs sigalglist] [-named_curve curve] [-cipher cipherlist] [-serverpref] [-quiet] [-no_tmp_rsa] [-ssl2] [-ssl3] [-tls1] [-no_ssl2] [-no_ssl3] [-no_tls1] [-no_dhe] [-no_ecdhe] [-bugs] [-hack] [-www] [-WWW] [-HTTP] [-engine id] [-tlsextdebug] [-no_ticket] [-id_prefix arg] [-rand file(s)] [-serverinfo file] [-no_resumption_on_reneg] [-status] [-status_verbose] [-status_timeout nsec] [-status_url url] [-alpn protocols] [-nextprotoneg protocols]</p>"},{"location":"man1/s_server/#description","title":"DESCRIPTION","text":"<p>The s_server command implements a generic SSL/TLS server which listens for connections on a given port using SSL/TLS.</p>"},{"location":"man1/s_server/#options","title":"OPTIONS","text":"<ul> <li> <p>-accept port</p> <p>the TCP port to listen on for connections. If not specified 4433 is used.</p> </li> <li> <p>-context id</p> <p>sets the SSL context id. It can be given any string value. If this option is not present a default value will be used.</p> </li> <li> <p>-cert certname</p> <p>The certificate to use, most servers cipher suites require the use of a certificate and some require a certificate with a certain public key type: for example the DSS cipher suites require a certificate containing a DSS (DSA) key. If not specified then the filename \"server.pem\" will be used.</p> </li> <li> <p>-certform format</p> <p>The certificate format to use: DER or PEM. PEM is the default.</p> </li> <li> <p>-key keyfile</p> <p>The private key to use. If not specified then the certificate file will be used.</p> </li> <li> <p>-keyform format</p> <p>The private format to use: DER or PEM. PEM is the default.</p> </li> <li> <p>-pass arg</p> <p>the private key password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-dcert filename, -dkey keyname</p> <p>specify an additional certificate and private key, these behave in the same manner as the -cert and -key options except there is no default if they are not specified (no additional certificate and key is used). As noted above some cipher suites require a certificate containing a key of a certain type. Some cipher suites need a certificate carrying an RSA key and some a DSS (DSA) key. By using RSA and DSS certificates and keys a server can support clients which only support RSA or DSS cipher suites by using an appropriate certificate.</p> </li> <li> <p>-dcertform format, -dkeyform format, -dpass arg</p> <p>additional certificate and private key format and passphrase respectively.</p> </li> <li> <p>-nocert</p> <p>if this option is set then no certificate is used. This restricts the cipher suites available to the anonymous ones (currently just anonymous DH).</p> </li> <li> <p>-dhparam filename</p> <p>the DH parameter file to use. The ephemeral DH cipher suites generate keys using a set of DH parameters. If not specified then an attempt is made to load the parameters from the server certificate file. If this fails then a static set of parameters hard coded into the s_server program will be used.</p> </li> <li> <p>-no_dhe</p> <p>if this option is set then no DH parameters will be loaded effectively disabling the ephemeral DH cipher suites.</p> </li> <li> <p>-no_ecdhe</p> <p>if this option is set then no ECDH parameters will be selected, effectively disabling the ephemeral ECDH cipher suites.</p> </li> <li> <p>-no_tmp_rsa</p> <p>certain export cipher suites sometimes use a temporary RSA key, this option disables temporary RSA key generation.</p> </li> <li> <p>-verify depth, -Verify depth</p> <p>The verify depth to use. This specifies the maximum length of the client certificate chain and makes the server request a certificate from the client. With the -verify option a certificate is requested but the client does not have to send one, with the -Verify option the client must supply a certificate or an error occurs.</p> <p>If the ciphersuite cannot request a client certificate (for example an anonymous ciphersuite or PSK) this option has no effect.</p> </li> <li> <p>-crl_check, -crl_check_all</p> <p>Check the peer certificate has not been revoked by its CA. The CRL(s) are appended to the certificate file. With the -crl_check_all option all CRLs of all CAs in the chain are checked.</p> </li> <li> <p>-CApath directory</p> <p>The directory to use for client certificate verification. This directory must be in \"hash format\", see verify for more information. These are also used when building the server certificate chain.</p> </li> <li> <p>-CAfile file</p> <p>A file containing trusted certificates to use during client authentication and to use when attempting to build the server certificate chain. The list is also used in the list of acceptable client CAs passed to the client when a certificate is requested.</p> </li> <li> <p>-no_alt_chains</p> <p>See the verify manual page for details.</p> </li> <li> <p>-state</p> <p>prints out the SSL session states.</p> </li> <li> <p>-debug</p> <p>print extensive debugging information including a hex dump of all traffic.</p> </li> <li> <p>-msg</p> <p>show all protocol messages with hex dump.</p> </li> <li> <p>-nbio_test</p> <p>tests non blocking I/O</p> </li> <li> <p>-nbio</p> <p>turns on non blocking I/O</p> </li> <li> <p>-crlf</p> <p>this option translated a line feed from the terminal into CR+LF.</p> </li> <li> <p>-quiet</p> <p>inhibit printing of session and certificate information.</p> </li> <li> <p>-psk_hint hint</p> <p>Use the PSK identity hint hint when using a PSK cipher suite.</p> </li> <li> <p>-psk key</p> <p>Use the PSK key key when using a PSK cipher suite. The key is given as a hexadecimal number without leading 0x, for example -psk 1a2b3c4d. This option must be provided in order to use a PSK cipher.</p> </li> <li> <p>-ssl2, -ssl3, -tls1, -tls1_1, -tls1_2, -no_ssl2, -no_ssl3, -no_tls1, -no_tls1_1, -no_tls1_2</p> <p>These options require or disable the use of the specified SSL or TLS protocols. By default the initial handshake uses a version-flexible method which will negotiate the highest mutually supported protocol version.</p> </li> <li> <p>-bugs</p> <p>there are several known bug in SSL and TLS implementations. Adding this option enables various workarounds.</p> </li> <li> <p>-hack</p> <p>this option enables a further workaround for some some early Netscape SSL code (?).</p> </li> <li> <p>-client_sigalgs sigalglist</p> <p>Signature algorithms to support for client certificate authentication (colon-separated list)</p> </li> <li> <p>-named_curve curve</p> <p>Specifies the elliptic curve to use. NOTE: this is single curve, not a list. For a list of all possible curves, use:</p> <pre><code>$ openssl ecparam -list_curves\n</code></pre> </li> <li> <p>-cipher cipherlist</p> <p>this allows the cipher list used by the server to be modified.  When the client sends a list of supported ciphers the first client cipher also included in the server list is used. Because the client specifies the preference order, the order of the server cipherlist irrelevant. See the ciphers command for more information.</p> </li> <li> <p>-serverpref</p> <p>use the server's cipher preferences, rather than the client's preferences.</p> </li> <li> <p>-tlsextdebug</p> <p>print out a hex dump of any TLS extensions received from the server.</p> </li> <li> <p>-no_ticket</p> <p>disable RFC4507bis session ticket support. </p> </li> <li> <p>-www</p> <p>sends a status message back to the client when it connects. This includes lots of information about the ciphers used and various session parameters. The output is in HTML format so this option will normally be used with a web browser.</p> </li> <li> <p>-WWW</p> <p>emulates a simple web server. Pages will be resolved relative to the current directory, for example if the URL https://myhost/page.html is requested the file ./page.html will be loaded.</p> </li> <li> <p>-HTTP</p> <p>emulates a simple web server. Pages will be resolved relative to the current directory, for example if the URL https://myhost/page.html is requested the file ./page.html will be loaded. The files loaded are assumed to contain a complete and correct HTTP response (lines that are part of the HTTP response line and headers must end with CRLF).</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause s_server to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> <li> <p>-id_prefix arg</p> <p>generate SSL/TLS session IDs prefixed by arg. This is mostly useful for testing any SSL/TLS code (eg. proxies) that wish to deal with multiple servers, when each of which might be generating a unique range of session IDs (eg. with a certain prefix).</p> </li> <li> <p>-rand file(s)</p> <p>a file or files containing random data used to seed the random number generator, or an EGD socket (see RAND_egd(3)). Multiple files can be specified separated by a OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others.</p> </li> <li> <p>-serverinfo file</p> <p>a file containing one or more blocks of PEM data.  Each PEM block must encode a TLS ServerHello extension (2 bytes type, 2 bytes length, followed by \"length\" bytes of extension data).  If the client sends an empty TLS ClientHello extension matching the type, the corresponding ServerHello extension will be returned.</p> </li> <li> <p>-no_resumption_on_reneg</p> <p>set SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION flag.</p> </li> <li> <p>-status</p> <p>enables certificate status request support (aka OCSP stapling).</p> </li> <li> <p>-status_verbose</p> <p>enables certificate status request support (aka OCSP stapling) and gives a verbose printout of the OCSP response.</p> </li> <li> <p>-status_timeout nsec</p> <p>sets the timeout for OCSP response to nsec seconds.</p> </li> <li> <p>-status_url url</p> <p>sets a fallback responder URL to use if no responder URL is present in the server certificate. Without this option an error is returned if the server certificate does not contain a responder address.</p> </li> <li> <p>-alpn protocols, -nextprotoneg protocols</p> <p>these flags enable the  Enable the Application-Layer Protocol Negotiation or Next Protocol Negotiation extension, respectively. ALPN is the IETF standard and replaces NPN. The protocols list is a comma-separated list of supported protocol names. The list should contain most wanted protocols first. Protocol names are printable ASCII strings, for example \"http/1.1\" or \"spdy/3\".</p> </li> </ul>"},{"location":"man1/s_server/#connected-commands","title":"CONNECTED COMMANDS","text":"<p>If a connection request is established with an SSL client and neither the -www nor the -WWW option has been used then normally any data received from the client is displayed and any key presses will be sent to the client. </p> <p>Certain single letter commands are also recognized which perform special operations: these are listed below.</p> <ul> <li> <p>q</p> <p>end the current SSL connection but still accept new connections.</p> </li> <li> <p>Q</p> <p>end the current SSL connection and exit.</p> </li> <li> <p>r</p> <p>renegotiate the SSL session.</p> </li> <li> <p>R</p> <p>renegotiate the SSL session and request a client certificate.</p> </li> <li> <p>P</p> <p>send some plain text down the underlying TCP connection: this should cause the client to disconnect due to a protocol violation.</p> </li> <li> <p>S</p> <p>print out some session cache status information.</p> </li> </ul>"},{"location":"man1/s_server/#notes","title":"NOTES","text":"<p>s_server can be used to debug SSL clients. To accept connections from a web browser the command:</p> <pre><code>openssl s_server -accept 443 -www\n</code></pre> <p>can be used for example.</p> <p>Although specifying an empty list of CAs when requesting a client certificate is strictly speaking a protocol violation, some SSL clients interpret this to mean any CA is acceptable. This is useful for debugging purposes.</p> <p>The session parameters can printed out using the sess_id program.</p>"},{"location":"man1/s_server/#bugs","title":"BUGS","text":"<p>Because this program has a lot of options and also because some of the techniques used are rather old, the C source of s_server is rather hard to read and not a model of how things should be done. A typical SSL server program would be much simpler.</p> <p>The output of common ciphers is wrong: it just gives the list of ciphers that OpenSSL recognizes and the client supports.</p> <p>There should be a way for the s_server program to print out details of any unknown cipher suites a client says it supports.</p>"},{"location":"man1/s_server/#see-also","title":"SEE ALSO","text":"<p>sess_id(1), s_client(1), ciphers(1)</p>"},{"location":"man1/s_server/#history","title":"HISTORY","text":"<p>The -no_alt_chains options was first added to OpenSSL 1.0.2b.</p>"},{"location":"man1/s_time/","title":"s_time","text":""},{"location":"man1/s_time/#name","title":"NAME","text":"<p>openssl-s_time, s_time - SSL/TLS performance timing program</p>"},{"location":"man1/s_time/#synopsis","title":"SYNOPSIS","text":"<p>openssl s_time [-connect host:port] [-www page] [-cert filename] [-key filename] [-CApath directory] [-CAfile filename] [-reuse] [-new] [-verify depth] [-nbio] [-time seconds] [-ssl2] [-ssl3] [-bugs] [-cipher cipherlist]</p>"},{"location":"man1/s_time/#description","title":"DESCRIPTION","text":"<p>The s_time command implements a generic SSL/TLS client which connects to a remote host using SSL/TLS. It can request a page from the server and includes the time to transfer the payload data in its timing measurements. It measures the number of connections within a given timeframe, the amount of data transferred (if any), and calculates the average time spent for one connection.</p>"},{"location":"man1/s_time/#options","title":"OPTIONS","text":"<ul> <li> <p>-connect host:port</p> <p>This specifies the host and optional port to connect to.</p> </li> <li> <p>-www page</p> <p>This specifies the page to GET from the server. A value of '/' gets the index.htm[l] page. If this parameter is not specified, then s_time will only perform the handshake to establish SSL connections but not transfer any payload data.</p> </li> <li> <p>-cert certname</p> <p>The certificate to use, if one is requested by the server. The default is not to use a certificate. The file is in PEM format.</p> </li> <li> <p>-key keyfile</p> <p>The private key to use. If not specified then the certificate file will be used. The file is in PEM format.</p> </li> <li> <p>-verify depth</p> <p>The verify depth to use. This specifies the maximum length of the server certificate chain and turns on server certificate verification. Currently the verify operation continues after errors so all the problems with a certificate chain can be seen. As a side effect the connection will never fail due to a server certificate verify failure.</p> </li> <li> <p>-CApath directory</p> <p>The directory to use for server certificate verification. This directory must be in \"hash format\", see verify for more information. These are also used when building the client certificate chain.</p> </li> <li> <p>-CAfile file</p> <p>A file containing trusted certificates to use during server authentication and to use when attempting to build the client certificate chain.</p> </li> <li> <p>-new</p> <p>performs the timing test using a new session ID for each connection. If neither -new nor -reuse are specified, they are both on by default and executed in sequence.</p> </li> <li> <p>-reuse</p> <p>performs the timing test using the same session ID; this can be used as a test that session caching is working. If neither -new nor -reuse are specified, they are both on by default and executed in sequence.</p> </li> <li> <p>-nbio</p> <p>turns on non-blocking I/O.</p> </li> <li> <p>-ssl2, -ssl3</p> <p>these options disable the use of certain SSL or TLS protocols. By default the initial handshake uses a method which should be compatible with all servers and permit them to use SSL v3, SSL v2 or TLS as appropriate. The timing program is not as rich in options to turn protocols on and off as the s_client(1) program and may not connect to all servers.</p> <p>Unfortunately there are a lot of ancient and broken servers in use which cannot handle this technique and will fail to connect. Some servers only work if TLS is turned off with the -ssl3 option; others will only support SSL v2 and may need the -ssl2 option.</p> </li> <li> <p>-bugs</p> <p>there are several known bug in SSL and TLS implementations. Adding this option enables various workarounds.</p> </li> <li> <p>-cipher cipherlist</p> <p>this allows the cipher list sent by the client to be modified. Although the server determines which cipher suite is used it should take the first supported cipher in the list sent by the client. See the ciphers(1) command for more information.</p> </li> <li> <p>-time length</p> <p>specifies how long (in seconds) s_time should establish connections and optionally transfer payload data from a server. Server and client performance and the link speed determine how many connections s_time can establish.</p> </li> </ul>"},{"location":"man1/s_time/#notes","title":"NOTES","text":"<p>s_time can be used to measure the performance of an SSL connection. To connect to an SSL HTTP server and get the default page the command</p> <pre><code>openssl s_time -connect servername:443 -www / -CApath yourdir -CAfile yourfile.pem -cipher commoncipher [-ssl3]\n</code></pre> <p>would typically be used (https uses port 443). 'commoncipher' is a cipher to which both client and server can agree, see the ciphers(1) command for details.</p> <p>If the handshake fails then there are several possible causes, if it is nothing obvious like no client certificate then the -bugs, -ssl2, -ssl3 options can be tried in case it is a buggy server. In particular you should play with these options before submitting a bug report to an OpenSSL mailing list.</p> <p>A frequent problem when attempting to get client certificates working is that a web client complains it has no certificates or gives an empty list to choose from. This is normally because the server is not sending the clients certificate authority in its \"acceptable CA list\" when it requests a certificate. By using s_client(1) the CA list can be viewed and checked. However some servers only request client authentication after a specific URL is requested. To obtain the list in this case it is necessary to use the -prexit option of s_client(1) and send an HTTP request for an appropriate page.</p> <p>If a certificate is specified on the command line using the -cert option it will not be used unless the server specifically requests a client certificate. Therefor merely including a client certificate on the command line is no guarantee that the certificate works.</p>"},{"location":"man1/s_time/#bugs","title":"BUGS","text":"<p>Because this program does not have all the options of the s_client(1) program to turn protocols on and off, you may not be able to measure the performance of all protocols with all servers.</p> <p>The -verify option should really exit if the server verification fails.</p>"},{"location":"man1/s_time/#see-also","title":"SEE ALSO","text":"<p>s_client(1), s_server(1), ciphers(1)</p>"},{"location":"man1/sess_id/","title":"sess_id","text":""},{"location":"man1/sess_id/#name","title":"NAME","text":"<p>openssl-sess_id, sess_id - SSL/TLS session handling utility</p>"},{"location":"man1/sess_id/#synopsis","title":"SYNOPSIS","text":"<p>openssl sess_id [-inform PEM|DER] [-outform PEM|DER] [-in filename] [-out filename] [-text] [-noout] [-context ID]</p>"},{"location":"man1/sess_id/#description","title":"DESCRIPTION","text":"<p>The sess_id process the encoded version of the SSL session structure and optionally prints out SSL session details (for example the SSL session master key) in human readable format. Since this is a diagnostic tool that needs some knowledge of the SSL protocol to use properly, most users will not need to use it.</p> <ul> <li> <p>-inform DER|PEM</p> <p>This specifies the input format. The DER option uses an ASN1 DER encoded format containing session details. The precise format can vary from one version to the next.  The PEM form is the default format: it consists of the DER format base64 encoded with additional header and footer lines.</p> </li> <li> <p>-outform DER|PEM</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read session information from or standard input by default.</p> </li> <li> <p>-out filename</p> <p>This specifies the output filename to write session information to or standard output if this option is not specified.</p> </li> <li> <p>-text</p> <p>prints out the various public or private key components in plain text in addition to the encoded version. </p> </li> <li> <p>-cert</p> <p>if a certificate is present in the session it will be output using this option, if the -text option is also present then it will be printed out in text form.</p> </li> <li> <p>-noout</p> <p>this option prevents output of the encoded version of the session.</p> </li> <li> <p>-context ID</p> <p>this option can set the session id so the output session information uses the supplied ID. The ID can be any string of characters. This option wont normally be used.</p> </li> </ul>"},{"location":"man1/sess_id/#output","title":"OUTPUT","text":"<p>Typical output:</p> <pre><code>SSL-Session:\n    Protocol  : TLSv1\n    Cipher    : 0016\n    Session-ID: 871E62626C554CE95488823752CBD5F3673A3EF3DCE9C67BD916C809914B40ED\n    Session-ID-ctx: 01000000\n    Master-Key: A7CEFC571974BE02CAC305269DC59F76EA9F0B180CB6642697A68251F2D2BB57E51DBBB4C7885573192AE9AEE220FACD\n    Key-Arg   : None\n    Start Time: 948459261\n    Timeout   : 300 (sec)\n    Verify return code 0 (ok)\n</code></pre> <p>Theses are described below in more detail.</p> <ul> <li> <p>Protocol</p> <p>this is the protocol in use TLSv1, SSLv3 or SSLv2.</p> </li> <li> <p>Cipher</p> <p>the cipher used this is the actual raw SSL or TLS cipher code, see the SSL or TLS specifications for more information.</p> </li> <li> <p>Session-ID</p> <p>the SSL session ID in hex format.</p> </li> <li> <p>Session-ID-ctx</p> <p>the session ID context in hex format.</p> </li> <li> <p>Master-Key</p> <p>this is the SSL session master key.</p> </li> <li> <p>Key-Arg</p> <p>the key argument, this is only used in SSL v2.</p> </li> <li> <p>Start Time</p> <p>this is the session start time represented as an integer in standard Unix format.</p> </li> <li> <p>Timeout</p> <p>the timeout in seconds.</p> </li> <li> <p>Verify return code</p> <p>this is the return code when an SSL client certificate is verified.</p> </li> </ul>"},{"location":"man1/sess_id/#notes","title":"NOTES","text":"<p>The PEM encoded session format uses the header and footer lines:</p> <pre><code>-----BEGIN SSL SESSION PARAMETERS-----\n-----END SSL SESSION PARAMETERS-----\n</code></pre> <p>Since the SSL session output contains the master key it is possible to read the contents of an encrypted session using this information. Therefore appropriate security precautions should be taken if the information is being output by a \"real\" application. This is however strongly discouraged and should only be used for debugging purposes.</p>"},{"location":"man1/sess_id/#bugs","title":"BUGS","text":"<p>The cipher and start time should be printed out in human readable form.</p>"},{"location":"man1/sess_id/#see-also","title":"SEE ALSO","text":"<p>ciphers(1), s_server(1)</p>"},{"location":"man1/smime/","title":"smime","text":""},{"location":"man1/smime/#name","title":"NAME","text":"<p>openssl-smime, smime - S/MIME utility</p>"},{"location":"man1/smime/#synopsis","title":"SYNOPSIS","text":"<p>openssl smime [-encrypt] [-decrypt] [-sign] [-resign] [-verify] [-pk7out] [-[cipher]] [-in file] [-no_alt_chains] [-certfile file] [-signer file] [-recip  file] [-inform SMIME|PEM|DER] [-passin arg] [-inkey file] [-out file] [-outform SMIME|PEM|DER] [-content file] [-to addr] [-from ad] [-subject s] [-text] [-indef] [-noindef] [-stream] [-rand file(s)] [-md digest] [cert.pem]...</p>"},{"location":"man1/smime/#description","title":"DESCRIPTION","text":"<p>The smime command handles S/MIME mail. It can encrypt, decrypt, sign and verify S/MIME messages.</p>"},{"location":"man1/smime/#command-options","title":"COMMAND OPTIONS","text":"<p>There are six operation options that set the type of operation to be performed. The meaning of the other options varies according to the operation type.</p> <ul> <li> <p>-encrypt</p> <p>encrypt mail for the given recipient certificates. Input file is the message to be encrypted. The output file is the encrypted mail in MIME format.</p> <p>Note that no revocation check is done for the recipient cert, so if that key has been compromised, others may be able to decrypt the text.</p> </li> <li> <p>-decrypt</p> <p>decrypt mail using the supplied certificate and private key. Expects an encrypted mail message in MIME format for the input file. The decrypted mail is written to the output file.</p> </li> <li> <p>-sign</p> <p>sign mail using the supplied certificate and private key. Input file is the message to be signed. The signed message in MIME format is written to the output file.</p> </li> <li> <p>-verify</p> <p>verify signed mail. Expects a signed mail message on input and outputs the signed data. Both clear text and opaque signing is supported.</p> </li> <li> <p>-pk7out</p> <p>takes an input message and writes out a PEM encoded PKCS#7 structure.</p> </li> <li> <p>-resign</p> <p>resign a message: take an existing message and one or more new signers.</p> </li> <li> <p>-in filename</p> <p>the input message to be encrypted or signed or the MIME message to be decrypted or verified.</p> </li> <li> <p>-inform SMIME|PEM|DER</p> <p>this specifies the input format for the PKCS#7 structure. The default is SMIME which reads an S/MIME format message. PEM and DER format change this to expect PEM and DER format PKCS#7 structures instead. This currently only affects the input format of the PKCS#7 structure, if no PKCS#7 structure is being input (for example with -encrypt or -sign) this option has no effect.</p> </li> <li> <p>-out filename</p> <p>the message text that has been decrypted or verified or the output MIME format message that has been signed or verified.</p> </li> <li> <p>-outform SMIME|PEM|DER</p> <p>this specifies the output format for the PKCS#7 structure. The default is SMIME which write an S/MIME format message. PEM and DER format change this to write PEM and DER format PKCS#7 structures instead. This currently only affects the output format of the PKCS#7 structure, if no PKCS#7 structure is being output (for example with -verify or -decrypt) this option has no effect.</p> </li> <li> <p>-stream -indef -noindef</p> <p>the -stream and -indef options are equivalent and enable streaming I/O for encoding operations. This permits single pass processing of data without the need to hold the entire contents in memory, potentially supporting very large files. Streaming is automatically set for S/MIME signing with detached data if the output format is SMIME it is currently off by default for all other operations.</p> </li> <li> <p>-noindef</p> <p>disable streaming I/O where it would produce and indefinite length constructed encoding. This option currently has no effect. In future streaming will be enabled by default on all relevant operations and this option will disable it.</p> </li> <li> <p>-content filename</p> <p>This specifies a file containing the detached content, this is only useful with the -verify command. This is only usable if the PKCS#7 structure is using the detached signature form where the content is not included. This option will override any content if the input format is S/MIME and it uses the multipart/signed MIME content type.</p> </li> <li> <p>-text</p> <p>this option adds plain text (text/plain) MIME headers to the supplied message if encrypting or signing. If decrypting or verifying it strips off text headers: if the decrypted or verified message is not of MIME  type text/plain then an error occurs.</p> </li> <li> <p>-CAfile file</p> <p>a file containing trusted CA certificates, only used with -verify.</p> </li> <li> <p>-CApath dir</p> <p>a directory containing trusted CA certificates, only used with -verify. This directory must be a standard certificate directory: that is a hash of each subject name (using x509 -hash) should be linked to each certificate.</p> </li> <li> <p>-md digest</p> <p>digest algorithm to use when signing or resigning. If not present then the default digest algorithm for the signing key will be used (usually SHA1).</p> </li> <li> <p>-[cipher]</p> <p>the encryption algorithm to use. For example DES  (56 bits) - -des, triple DES (168 bits) - -des3, EVP_get_cipherbyname() function) can also be used preceded by a dash, for  example -aes_128_cbc. See enc for list of ciphers supported by your version of OpenSSL.</p> <p>If not specified triple DES is used. Only used with -encrypt.</p> </li> <li> <p>-nointern</p> <p>when verifying a message normally certificates (if any) included in the message are searched for the signing certificate. With this option only the certificates specified in the -certfile option are used. The supplied certificates can still be used as untrusted CAs however.</p> </li> <li> <p>-noverify</p> <p>do not verify the signers certificate of a signed message.</p> </li> <li> <p>-nochain</p> <p>do not do chain verification of signers certificates: that is don't use the certificates in the signed message as untrusted CAs.</p> </li> <li> <p>-nosigs</p> <p>don't try to verify the signatures on the message.</p> </li> <li> <p>-nocerts</p> <p>when signing a message the signer's certificate is normally included with this option it is excluded. This will reduce the size of the signed message but the verifier must have a copy of the signers certificate available locally (passed using the -certfile option for example).</p> </li> <li> <p>-noattr</p> <p>normally when a message is signed a set of attributes are included which include the signing time and supported symmetric algorithms. With this option they are not included.</p> </li> <li> <p>-binary</p> <p>normally the input message is converted to \"canonical\" format which is effectively using CR and LF as end of line: as required by the S/MIME specification. When this option is present no translation occurs. This is useful when handling binary data which may not be in MIME format.</p> </li> <li> <p>-nodetach</p> <p>when signing a message use opaque signing: this form is more resistant to translation by mail relays but it cannot be read by mail agents that do not support S/MIME.  Without this option cleartext signing with the MIME type multipart/signed is used.</p> </li> <li> <p>-certfile file</p> <p>allows additional certificates to be specified. When signing these will be included with the message. When verifying these will be searched for the signers certificates. The certificates should be in PEM format.</p> </li> <li> <p>-signer file</p> <p>a signing certificate when signing or resigning a message, this option can be used multiple times if more than one signer is required. If a message is being verified then the signers certificates will be written to this file if the verification was successful.</p> </li> <li> <p>-recip file</p> <p>the recipients certificate when decrypting a message. This certificate must match one of the recipients of the message or an error occurs.</p> </li> <li> <p>-inkey file</p> <p>the private key to use when signing or decrypting. This must match the corresponding certificate. If this option is not specified then the private key must be included in the certificate file specified with the -recip or -signer file. When signing this option can be used multiple times to specify successive keys.</p> </li> <li> <p>-passin arg</p> <p>the private key password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-rand file(s)</p> <p>a file or files containing random data used to seed the random number generator, or an EGD socket (see RAND_egd(3)). Multiple files can be specified separated by a OS-dependent character. The separator is ; for MS-Windows, , for OpenVMS, and : for all others.</p> </li> <li> <p>cert.pem...</p> <p>one or more certificates of message recipients: used when encrypting a message. </p> </li> <li> <p>-to, -from, -subject</p> <p>the relevant mail headers. These are included outside the signed portion of a message so they may be included manually. If signing then many S/MIME mail clients check the signers certificate's email address matches that specified in the From: address.</p> </li> <li> <p>-purpose, -ignore_critical, -issuer_checks, -crl_check, -crl_check_all, -policy_check, -extended_crl, -x509_strict, -policy -check_ss_sig -no_alt_chains</p> <p>Set various options of certificate chain verification. See verify manual page for details.</p> </li> </ul>"},{"location":"man1/smime/#notes","title":"NOTES","text":"<p>The MIME message must be sent without any blank lines between the headers and the output. Some mail programs will automatically add a blank line. Piping the mail directly to sendmail is one way to achieve the correct format.</p> <p>The supplied message to be signed or encrypted must include the necessary MIME headers or many S/MIME clients wont display it properly (if at all). You can use the -text option to automatically add plain text headers.</p> <p>A \"signed and encrypted\" message is one where a signed message is then encrypted. This can be produced by encrypting an already signed message: see the examples section.</p> <p>This version of the program only allows one signer per message but it will verify multiple signers on received messages. Some S/MIME clients choke if a message contains multiple signers. It is possible to sign messages \"in parallel\" by signing an already signed message.</p> <p>The options -encrypt and -decrypt reflect common usage in S/MIME clients. Strictly speaking these process PKCS#7 enveloped data: PKCS#7 encrypted data is used for other purposes.</p> <p>The -resign option uses an existing message digest when adding a new signer. This means that attributes must be present in at least one existing signer using the same message digest or this operation will fail.</p> <p>The -stream and -indef options enable experimental streaming I/O support. As a result the encoding is BER using indefinite length constructed encoding and no longer DER. Streaming is supported for the -encrypt operation and the -sign operation if the content is not detached.</p> <p>Streaming is always used for the -sign operation with detached data but since the content is no longer part of the PKCS#7 structure the encoding remains DER.</p>"},{"location":"man1/smime/#exit-codes","title":"EXIT CODES","text":"<ul> <li> <p>0</p> <p>the operation was completely successfully.</p> </li> <li> <p>1</p> <p>an error occurred parsing the command options.</p> </li> <li> <p>2</p> <p>one of the input files could not be read.</p> </li> <li> <p>3</p> <p>an error occurred creating the PKCS#7 file or when reading the MIME message.</p> </li> <li> <p>4</p> <p>an error occurred decrypting or verifying the message.</p> </li> <li> <p>5</p> <p>the message was verified correctly but an error occurred writing out the signers certificates.</p> </li> </ul>"},{"location":"man1/smime/#examples","title":"EXAMPLES","text":"<p>Create a cleartext signed message:</p> <pre><code>openssl smime -sign -in message.txt -text -out mail.msg \\\n       -signer mycert.pem\n</code></pre> <p>Create an opaque signed message:</p> <pre><code>openssl smime -sign -in message.txt -text -out mail.msg -nodetach \\\n       -signer mycert.pem\n</code></pre> <p>Create a signed message, include some additional certificates and read the private key from another file:</p> <pre><code>openssl smime -sign -in in.txt -text -out mail.msg \\\n       -signer mycert.pem -inkey mykey.pem -certfile mycerts.pem\n</code></pre> <p>Create a signed message with two signers:</p> <pre><code>openssl smime -sign -in message.txt -text -out mail.msg \\\n       -signer mycert.pem -signer othercert.pem\n</code></pre> <p>Send a signed message under Unix directly to sendmail, including headers:</p> <pre><code>openssl smime -sign -in in.txt -text -signer mycert.pem \\\n       -from steve@openssl.org -to someone@somewhere \\\n       -subject \"Signed message\" | sendmail someone@somewhere\n</code></pre> <p>Verify a message and extract the signer's certificate if successful:</p> <pre><code>openssl smime -verify -in mail.msg -signer user.pem -out signedtext.txt\n</code></pre> <p>Send encrypted mail using triple DES:</p> <pre><code>openssl smime -encrypt -in in.txt -from steve@openssl.org \\\n       -to someone@somewhere -subject \"Encrypted message\" \\\n       -des3 user.pem -out mail.msg\n</code></pre> <p>Sign and encrypt mail:</p> <pre><code>openssl smime -sign -in ml.txt -signer my.pem -text \\\n       | openssl smime -encrypt -out mail.msg \\\n       -from steve@openssl.org -to someone@somewhere \\\n       -subject \"Signed and Encrypted message\" -des3 user.pem\n</code></pre> <p>Note: the encryption command does not include the -text option because the message being encrypted already has MIME headers.</p> <p>Decrypt mail:</p> <pre><code>openssl smime -decrypt -in mail.msg -recip mycert.pem -inkey key.pem\n</code></pre> <p>The output from Netscape form signing is a PKCS#7 structure with the detached signature format. You can use this program to verify the signature by line wrapping the base64 encoded structure and surrounding it with:</p> <pre><code>-----BEGIN PKCS7-----\n-----END PKCS7-----\n</code></pre> <p>and using the command: </p> <pre><code>openssl smime -verify -inform PEM -in signature.pem -content content.txt\n</code></pre> <p>Alternatively you can base64 decode the signature and use:</p> <pre><code>openssl smime -verify -inform DER -in signature.der -content content.txt\n</code></pre> <p>Create an encrypted message using 128 bit Camellia:</p> <pre><code>openssl smime -encrypt -in plain.txt -camellia128 -out mail.msg cert.pem\n</code></pre> <p>Add a signer to an existing message:</p> <pre><code>openssl smime -resign -in mail.msg -signer newsign.pem -out mail2.msg\n</code></pre>"},{"location":"man1/smime/#bugs","title":"BUGS","text":"<p>The MIME parser isn't very clever: it seems to handle most messages that I've thrown at it but it may choke on others.</p> <p>The code currently will only write out the signer's certificate to a file: if the signer has a separate encryption certificate this must be manually extracted. There should be some heuristic that determines the correct encryption certificate.</p> <p>Ideally a database should be maintained of a certificates for each email address.</p> <p>The code doesn't currently take note of the permitted symmetric encryption algorithms as supplied in the SMIMECapabilities signed attribute. This means the user has to manually include the correct encryption algorithm. It should store the list of permitted ciphers in a database and only use those.</p> <p>No revocation checking is done on the signer's certificate.</p> <p>The current code can only handle S/MIME v2 messages, the more complex S/MIME v3 structures may cause parsing errors.</p>"},{"location":"man1/smime/#history","title":"HISTORY","text":"<p>The use of multiple -signer options and the -resign command were first added in OpenSSL 1.0.0</p> <p>The -no_alt_chains options was first added to OpenSSL 1.0.2b.</p>"},{"location":"man1/speed/","title":"speed","text":""},{"location":"man1/speed/#name","title":"NAME","text":"<p>openssl-speed, speed - test library performance</p>"},{"location":"man1/speed/#synopsis","title":"SYNOPSIS","text":"<p>openssl speed [-engine id] [md2] [mdc2] [md5] [hmac] [sha1] [rmd160] [idea-cbc] [rc2-cbc] [rc5-cbc] [bf-cbc] [des-cbc] [des-ede3] [rc4] [rsa512] [rsa1024] [rsa2048] [rsa4096] [dsa512] [dsa1024] [dsa2048] [idea] [rc2] [des] [rsa] [blowfish]</p>"},{"location":"man1/speed/#description","title":"DESCRIPTION","text":"<p>This command is used to test the performance of cryptographic algorithms.</p>"},{"location":"man1/speed/#options","title":"OPTIONS","text":"<ul> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause speed to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> <li> <p>[zero or more test algorithms]</p> <p>If any options are given, speed tests those algorithms, otherwise all of the above are tested.</p> </li> </ul>"},{"location":"man1/spkac/","title":"spkac","text":""},{"location":"man1/spkac/#name","title":"NAME","text":"<p>openssl-spkac, spkac - SPKAC printing and generating utility</p>"},{"location":"man1/spkac/#synopsis","title":"SYNOPSIS","text":"<p>openssl spkac [-in filename] [-out filename] [-key keyfile] [-passin arg] [-challenge string] [-pubkey] [-spkac spkacname] [-spksect section] [-noout] [-verify] [-engine id]</p>"},{"location":"man1/spkac/#description","title":"DESCRIPTION","text":"<p>The spkac command processes Netscape signed public key and challenge (SPKAC) files. It can print out their contents, verify the signature and produce its own SPKACs from a supplied private key.</p>"},{"location":"man1/spkac/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-in filename</p> <p>This specifies the input filename to read from or standard input if this option is not specified. Ignored if the -key option is used.</p> </li> <li> <p>-out filename</p> <p>specifies the output filename to write to or standard output by default.</p> </li> <li> <p>-key keyfile</p> <p>create an SPKAC file using the private key in keyfile. The -in, -noout, -spksect and -verify options are ignored if present.</p> </li> <li> <p>-passin password</p> <p>the input file password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-challenge string</p> <p>specifies the challenge string if an SPKAC is being created.</p> </li> <li> <p>-spkac spkacname</p> <p>allows an alternative name form the variable containing the SPKAC. The default is \"SPKAC\". This option affects both generated and input SPKAC files.</p> </li> <li> <p>-spksect section</p> <p>allows an alternative name form the section containing the SPKAC. The default is the default section.</p> </li> <li> <p>-noout</p> <p>don't output the text version of the SPKAC (not used if an SPKAC is being created).</p> </li> <li> <p>-pubkey</p> <p>output the public key of an SPKAC (not used if an SPKAC is being created).</p> </li> <li> <p>-verify</p> <p>verifies the digital signature on the supplied SPKAC.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause spkac to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> </ul>"},{"location":"man1/spkac/#examples","title":"EXAMPLES","text":"<p>Print out the contents of an SPKAC:</p> <pre><code>openssl spkac -in spkac.cnf\n</code></pre> <p>Verify the signature of an SPKAC:</p> <pre><code>openssl spkac -in spkac.cnf -noout -verify\n</code></pre> <p>Create an SPKAC using the challenge string \"hello\":</p> <pre><code>openssl spkac -key key.pem -challenge hello -out spkac.cnf\n</code></pre> <p>Example of an SPKAC, (long lines split up for clarity):</p> <pre><code>SPKAC=MIG5MGUwXDANBgkqhkiG9w0BAQEFAANLADBIAkEA1cCoq2Wa3Ixs47uI7F\\\nPVwHVIPDx5yso105Y6zpozam135a8R0CpoRvkkigIyXfcCjiVi5oWk+6FfPaD03u\\\nPFoQIDAQABFgVoZWxsbzANBgkqhkiG9w0BAQQFAANBAFpQtY/FojdwkJh1bEIYuc\\\n2EeM2KHTWPEepWYeawvHD0gQ3DngSC75YCWnnDdq+NQ3F+X4deMx9AaEglZtULwV\\\n4=\n</code></pre>"},{"location":"man1/spkac/#notes","title":"NOTES","text":"<p>A created SPKAC with suitable DN components appended can be fed into the ca utility.</p> <p>SPKACs are typically generated by Netscape when a form is submitted containing the KEYGEN tag as part of the certificate enrollment process.</p> <p>The challenge string permits a primitive form of proof of possession of private key. By checking the SPKAC signature and a random challenge string some guarantee is given that the user knows the private key corresponding to the public key being certified. This is important in some applications. Without this it is possible for a previous SPKAC to be used in a \"replay attack\".</p>"},{"location":"man1/spkac/#see-also","title":"SEE ALSO","text":"<p>ca(1)</p>"},{"location":"man1/ts/","title":"ts","text":""},{"location":"man1/ts/#name","title":"NAME","text":"<p>openssl-ts, ts - Time Stamping Authority tool (client/server)</p>"},{"location":"man1/ts/#synopsis","title":"SYNOPSIS","text":"<p>openssl ts -query [-rand file:file...] [-config configfile] [-data file_to_hash] [-digest digest_bytes] [-md2|-md4|-md5|-sha|-sha1|-mdc2|-ripemd160|...] [-policy object_id] [-no_nonce] [-cert] [-in request.tsq] [-out request.tsq] [-text]</p> <p>openssl ts -reply [-config configfile] [-section tsa_section] [-queryfile request.tsq] [-passin password_src] [-signer tsa_cert.pem] [-inkey private.pem] [-chain certs_file.pem] [-policy object_id] [-in response.tsr] [-token_in] [-out response.tsr] [-token_out] [-text] [-engine id]</p> <p>openssl ts -verify [-data file_to_hash] [-digest digest_bytes] [-queryfile request.tsq] [-in response.tsr] [-token_in] [-CApath trusted_cert_path] [-CAfile trusted_certs.pem] [-untrusted cert_file.pem]</p>"},{"location":"man1/ts/#description","title":"DESCRIPTION","text":"<p>The ts command is a basic Time Stamping Authority (TSA) client and server application as specified in RFC 3161 (Time-Stamp Protocol, TSP). A TSA can be part of a PKI deployment and its role is to provide long term proof of the existence of a certain datum before a particular time. Here is a brief description of the protocol:</p> <ol> <li>The TSA client computes a one-way hash value for a data file and sends the hash to the TSA.</li> <li>The TSA attaches the current date and time to the received hash value, signs them and sends the time stamp token back to the client. By creating this token the TSA certifies the existence of the original data file at the time of response generation.</li> <li>The TSA client receives the time stamp token and verifies the signature on it. It also checks if the token contains the same hash value that it had sent to the TSA.</li> </ol> <p>There is one DER encoded protocol data unit defined for transporting a time stamp request to the TSA and one for sending the time stamp response back to the client. The ts command has three main functions: creating a time stamp request based on a data file, creating a time stamp response based on a request, verifying if a response corresponds to a particular request or a data file.</p> <p>There is no support for sending the requests/responses automatically over HTTP or TCP yet as suggested in RFC 3161. The users must send the requests either by ftp or e-mail.</p>"},{"location":"man1/ts/#options","title":"OPTIONS","text":""},{"location":"man1/ts/#time-stamp-request-generation","title":"Time Stamp Request generation","text":"<p>The -query switch can be used for creating and printing a time stamp request with the following options:</p> <ul> <li> <p>-rand file:file...</p> <p>The files containing random data for seeding the random number generator. Multiple files can be specified, the separator is ; for MS-Windows, , for VMS and : for all other platforms. (Optional)</p> </li> <li> <p>-config configfile</p> <p>The configuration file to use, this option overrides the OPENSSL_CONF environment variable. Only the OID section of the config file is used with the -query command. (Optional)</p> </li> <li> <p>-data file_to_hash</p> <p>The data file for which the time stamp request needs to be created. stdin is the default if neither the -data nor the -digest parameter is specified. (Optional)</p> </li> <li> <p>-digest digest_bytes</p> <p>It is possible to specify the message imprint explicitly without the data file. The imprint must be specified in a hexadecimal format, two characters per byte, the bytes optionally separated by colons (e.g. 1A:F6:01:... or 1AF601...). The number of bytes must match the message digest algorithm  in use. (Optional)</p> </li> <li> <p>-md2|-md4|-md5|-sha|-sha1|-mdc2|-ripemd160|...</p> <p>The message digest to apply to the data file, it supports all the message digest algorithms that are supported by the openssl dgst command. The default is SHA-1. (Optional)</p> </li> <li> <p>-policy object_id</p> <p>The policy that the client expects the TSA to use for creating the time stamp token. Either the dotted OID notation or OID names defined in the config file can be used. If no policy is requested the TSA will use its own default policy. (Optional)</p> </li> <li> <p>-no_nonce</p> <p>No nonce is specified in the request if this option is given. Otherwise a 64 bit long pseudo-random none is included in the request. It is recommended to use nonce to protect against replay-attacks. (Optional)</p> </li> <li> <p>-cert</p> <p>The TSA is expected to include its signing certificate in the response. (Optional)</p> </li> <li> <p>-in request.tsq</p> <p>This option specifies a previously created time stamp request in DER format that will be printed into the output file. Useful when you need to examine the content of a request in human-readable</p> <p>format. (Optional)</p> </li> <li> <p>-out request.tsq</p> <p>Name of the output file to which the request will be written. Default is stdout. (Optional)</p> </li> <li> <p>-text</p> <p>If this option is specified the output is human-readable text format instead of DER. (Optional)</p> </li> </ul>"},{"location":"man1/ts/#time-stamp-response-generation","title":"Time Stamp Response generation","text":"<p>A time stamp response (TimeStampResp) consists of a response status and the time stamp token itself (ContentInfo), if the token generation was successful. The -reply command is for creating a time stamp response or time stamp token based on a request and printing the response/token in human-readable format. If -token_out is not specified the output is always a time stamp response (TimeStampResp), otherwise it is a time stamp token (ContentInfo).</p> <ul> <li> <p>-config configfile</p> <p>The configuration file to use, this option overrides the OPENSSL_CONF environment variable. See CONFIGURATION FILE OPTIONS for configurable variables. (Optional)</p> </li> <li> <p>-section tsa_section</p> <p>The name of the config file section conatining the settings for the response generation. If not specified the default TSA section is used, see CONFIGURATION FILE OPTIONS for details. (Optional)</p> </li> <li> <p>-queryfile request.tsq</p> <p>The name of the file containing a DER encoded time stamp request. (Optional)</p> </li> <li> <p>-passin password_src</p> <p>Specifies the password source for the private key of the TSA. See PASS PHRASE ARGUMENTS in openssl(1). (Optional)</p> </li> <li> <p>-signer tsa_cert.pem</p> <p>The signer certificate of the TSA in PEM format. The TSA signing certificate must have exactly one extended key usage assigned to it: timeStamping. The extended key usage must also be critical, otherwise the certificate is going to be refused. Overrides the signer_cert variable of the config file. (Optional)</p> </li> <li> <p>-inkey private.pem</p> <p>The signer private key of the TSA in PEM format. Overrides the signer_key config file option. (Optional)</p> </li> <li> <p>-chain certs_file.pem</p> <p>The collection of certificates in PEM format that will all be included in the response in addition to the signer certificate if the -cert option was used for the request. This file is supposed to contain the certificate chain for the signer certificate from its issuer upwards. The -reply command does not build a certificate chain automatically. (Optional)</p> </li> <li> <p>-policy object_id</p> <p>The default policy to use for the response unless the client explicitly requires a particular TSA policy. The OID can be specified either in dotted notation or with its name. Overrides the default_policy config file option. (Optional)</p> </li> <li> <p>-in response.tsr</p> <p>Specifies a previously created time stamp response or time stamp token (if -token_in is also specified) in DER format that will be written to the output file. This option does not require a request, it is useful e.g. when you need to examine the content of a response or token or you want to extract the time stamp token from a response. If the input is a token and the output is a time stamp response a default 'granted' status info is added to the token. (Optional)</p> </li> <li> <p>-token_in</p> <p>This flag can be used together with the -in option and indicates that the input is a DER encoded time stamp token (ContentInfo) instead of a time stamp response (TimeStampResp). (Optional)</p> </li> <li> <p>-out response.tsr</p> <p>The response is written to this file. The format and content of the file depends on other options (see -text, -token_out). The default is stdout. (Optional)</p> </li> <li> <p>-token_out</p> <p>The output is a time stamp token (ContentInfo) instead of time stamp response (TimeStampResp). (Optional)</p> </li> <li> <p>-text</p> <p>If this option is specified the output is human-readable text format instead of DER. (Optional)</p> </li> <li> <p>-engine id</p> <p>Specifying an engine (by its unique id string) will cause ts to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms. Default is builtin. (Optional)</p> </li> </ul>"},{"location":"man1/ts/#time-stamp-response-verification","title":"Time Stamp Response verification","text":"<p>The -verify command is for verifying if a time stamp response or time stamp token is valid and matches a particular time stamp request or data file. The -verify command does not use the configuration file.</p> <ul> <li> <p>-data file_to_hash</p> <p>The response or token must be verified against file_to_hash. The file is hashed with the message digest algorithm specified in the token.  The -digest and -queryfile options must not be specified with this one. (Optional)</p> </li> <li> <p>-digest digest_bytes</p> <p>The response or token must be verified against the message digest specified with this option. The number of bytes must match the message digest algorithm specified in the token. The -data and -queryfile options must not be specified with this one. (Optional)</p> </li> <li> <p>-queryfile request.tsq</p> <p>The original time stamp request in DER format. The -data and -digest options must not be specified with this one. (Optional)</p> </li> <li> <p>-in response.tsr</p> <p>The time stamp response that needs to be verified in DER format. (Mandatory)</p> </li> <li> <p>-token_in</p> <p>This flag can be used together with the -in option and indicates that the input is a DER encoded time stamp token (ContentInfo) instead of a time stamp response (TimeStampResp). (Optional)</p> </li> <li> <p>-CApath trusted_cert_path</p> <p>The name of the directory containing the trused CA certificates of the client. See the similar option of verify(1) for additional details. Either this option or -CAfile must be specified. (Optional)</p> </li> <li> <p>-CAfile trusted_certs.pem</p> <p>The name of the file containing a set of trusted self-signed CA  certificates in PEM format. See the similar option of  verify(1) for additional details. Either this option  or -CApath must be specified. (Optional)</p> </li> <li> <p>-untrusted cert_file.pem</p> <p>Set of additional untrusted certificates in PEM format which may be needed when building the certificate chain for the TSA's signing certificate. This file must contain the TSA signing certificate and all intermediate CA certificates unless the response includes them. (Optional)</p> </li> </ul>"},{"location":"man1/ts/#configuration-file-options","title":"CONFIGURATION FILE OPTIONS","text":"<p>The -query and -reply commands make use of a configuration file defined by the OPENSSL_CONF environment variable. See config(5) for a general description of the syntax of the config file. The -query command uses only the symbolic OID names section and it can work without it. However, the -reply command needs the config file for its operation.</p> <p>When there is a command line switch equivalent of a variable the switch always overrides the settings in the config file.</p> <ul> <li> <p>tsa section, default_tsa </p> <p>This is the main section and it specifies the name of another section that contains all the options for the -reply command. This default section can be overridden with the -section command line switch. (Optional)</p> </li> <li> <p>oid_file</p> <p>See ca(1) for description. (Optional)</p> </li> <li> <p>oid_section</p> <p>See ca(1) for description. (Optional)</p> </li> <li> <p>RANDFILE</p> <p>See ca(1) for description. (Optional)</p> </li> <li> <p>serial</p> <p>The name of the file containing the hexadecimal serial number of the last time stamp response created. This number is incremented by 1 for each response. If the file does not exist at the time of response generation a new file is created with serial number 1. (Mandatory)</p> </li> <li> <p>crypto_device</p> <p>Specifies the OpenSSL engine that will be set as the default for  all available algorithms. The default value is builtin, you can specify  any other engines supported by OpenSSL (e.g. use chil for the NCipher HSM). (Optional)</p> </li> <li> <p>signer_cert</p> <p>TSA signing certificate in PEM format. The same as the -signer command line option. (Optional)</p> </li> <li> <p>certs</p> <p>A file containing a set of PEM encoded certificates that need to be included in the response. The same as the -chain command line option. (Optional)</p> </li> <li> <p>signer_key</p> <p>The private key of the TSA in PEM format. The same as the -inkey command line option. (Optional)</p> </li> <li> <p>default_policy</p> <p>The default policy to use when the request does not mandate any policy. The same as the -policy command line option. (Optional)</p> </li> <li> <p>other_policies</p> <p>Comma separated list of policies that are also acceptable by the TSA and used only if the request explicitly specifies one of them. (Optional)</p> </li> <li> <p>digests</p> <p>The list of message digest algorithms that the TSA accepts. At least one algorithm must be specified. (Mandatory)</p> </li> <li> <p>accuracy</p> <p>The accuracy of the time source of the TSA in seconds, milliseconds and microseconds. E.g. secs:1, millisecs:500, microsecs:100. If any of the components is missing zero is assumed for that field. (Optional)</p> </li> <li> <p>clock_precision_digits</p> <p>Specifies the maximum number of digits, which represent the fraction of  seconds, that  need to be included in the time field. The trailing zeroes must be removed from the time, so there might actually be fewer digits, or no fraction of seconds at all. Supported only on UNIX platforms. The maximum value is 6, default is 0. (Optional)</p> </li> <li> <p>ordering</p> <p>If this option is yes the responses generated by this TSA can always be ordered, even if the time difference between two responses is less than the sum of their accuracies. Default is no. (Optional)</p> </li> <li> <p>tsa_name</p> <p>Set this option to yes if the subject name of the TSA must be included in the TSA name field of the response. Default is no. (Optional)</p> </li> <li> <p>ess_cert_id_chain</p> <p>The SignedData objects created by the TSA always contain the certificate identifier of the signing certificate in a signed attribute (see RFC 2634, Enhanced Security Services). If this option is set to yes and either the certs variable or the -chain option is specified then the certificate identifiers of the chain will also be included in the SigningCertificate signed attribute. If this variable is set to no, only the signing certificate identifier is included. Default is no. (Optional)</p> </li> </ul>"},{"location":"man1/ts/#environment-variables","title":"ENVIRONMENT VARIABLES","text":"<p>OPENSSL_CONF contains the path of the configuration file and can be overridden by the -config command line option.</p>"},{"location":"man1/ts/#examples","title":"EXAMPLES","text":"<p>All the examples below presume that OPENSSL_CONF is set to a proper configuration file, e.g. the example configuration file  openssl/apps/openssl.cnf will do.</p>"},{"location":"man1/ts/#time-stamp-request","title":"Time Stamp Request","text":"<p>To create a time stamp request for design1.txt with SHA-1  without nonce and policy and no certificate is required in the response:</p> <pre><code>openssl ts -query -data design1.txt -no_nonce \\\n      -out design1.tsq\n</code></pre> <p>To create a similar time stamp request with specifying the message imprint explicitly:</p> <pre><code>openssl ts -query -digest b7e5d3f93198b38379852f2c04e78d73abdd0f4b \\\n       -no_nonce -out design1.tsq\n</code></pre> <p>To print the content of the previous request in human readable format:</p> <pre><code>openssl ts -query -in design1.tsq -text\n</code></pre> <p>To create a time stamp request which includes the MD-5 digest  of design2.txt, requests the signer certificate and nonce, specifies a policy id (assuming the tsa_policy1 name is defined in the OID section of the config file):</p> <pre><code>openssl ts -query -data design2.txt -md5 \\\n      -policy tsa_policy1 -cert -out design2.tsq\n</code></pre>"},{"location":"man1/ts/#time-stamp-response","title":"Time Stamp Response","text":"<p>Before generating a response a signing certificate must be created for the TSA that contains the timeStamping critical extended key usage extension without any other key usage extensions. You can add the 'extendedKeyUsage = critical,timeStamping' line to the user certificate section of the config file to generate a proper certificate. See req(1), ca(1), x509(1) for instructions. The examples below assume that cacert.pem contains the certificate of the CA, tsacert.pem is the signing certificate issued by cacert.pem and tsakey.pem is the private key of the TSA.</p> <p>To create a time stamp response for a request:</p> <pre><code>openssl ts -reply -queryfile design1.tsq -inkey tsakey.pem \\\n      -signer tsacert.pem -out design1.tsr\n</code></pre> <p>If you want to use the settings in the config file you could just write:</p> <pre><code>openssl ts -reply -queryfile design1.tsq -out design1.tsr\n</code></pre> <p>To print a time stamp reply to stdout in human readable format:</p> <pre><code>openssl ts -reply -in design1.tsr -text\n</code></pre> <p>To create a time stamp token instead of time stamp response:</p> <pre><code>openssl ts -reply -queryfile design1.tsq -out design1_token.der -token_out\n</code></pre> <p>To print a time stamp token to stdout in human readable format:</p> <pre><code>openssl ts -reply -in design1_token.der -token_in -text -token_out\n</code></pre> <p>To extract the time stamp token from a response:</p> <pre><code>openssl ts -reply -in design1.tsr -out design1_token.der -token_out\n</code></pre> <p>To add 'granted' status info to a time stamp token thereby creating a valid response:</p> <pre><code>openssl ts -reply -in design1_token.der -token_in -out design1.tsr\n</code></pre>"},{"location":"man1/ts/#time-stamp-verification","title":"Time Stamp Verification","text":"<p>To verify a time stamp reply against a request:</p> <pre><code>openssl ts -verify -queryfile design1.tsq -in design1.tsr \\\n      -CAfile cacert.pem -untrusted tsacert.pem\n</code></pre> <p>To verify a time stamp reply that includes the certificate chain:</p> <pre><code>openssl ts -verify -queryfile design2.tsq -in design2.tsr \\\n      -CAfile cacert.pem\n</code></pre> <p>To verify a time stamp token against the original data file:   openssl ts -verify -data design2.txt -in design2.tsr \\     -CAfile cacert.pem</p> <p>To verify a time stamp token against a message imprint:   openssl ts -verify -digest b7e5d3f93198b38379852f2c04e78d73abdd0f4b \\      -in design2.tsr -CAfile cacert.pem</p> <p>You could also look at the 'test' directory for more examples.</p>"},{"location":"man1/ts/#bugs","title":"BUGS","text":"<p>If you find any bugs or you have suggestions please write to Zoltan Glozik &lt;zglozik@opentsa.org&gt;. Known issues:</p> <ul> <li>No support for time stamps over SMTP, though it is quite easy to implement an automatic e-mail based TSA with procmail(1)  and perl(1). HTTP server support is provided in the form of  a separate apache module. HTTP client support is provided by tsget(1). Pure TCP/IP protocol is not supported.</li> <li>The file containing the last serial number of the TSA is not locked when being read or written. This is a problem if more than one instance of openssl(1) is trying to create a time stamp response at the same time. This is not an issue when using the apache server module, it does proper locking.</li> <li>Look for the FIXME word in the source files.</li> <li>The source code should really be reviewed by somebody else, too.</li> <li>More testing is needed, I have done only some basic tests (see test/testtsa).</li> </ul>"},{"location":"man1/ts/#author","title":"AUTHOR","text":"<p>Zoltan Glozik &lt;zglozik@opentsa.org&gt;, OpenTSA project (http://www.opentsa.org)</p>"},{"location":"man1/ts/#see-also","title":"SEE ALSO","text":"<p>tsget(1), openssl(1), req(1),  x509(1), ca(1), genrsa(1),  config(5)</p>"},{"location":"man1/tsget/","title":"tsget","text":""},{"location":"man1/tsget/#name","title":"NAME","text":"<p>openssl-tsget, tsget - Time Stamping HTTP/HTTPS client</p>"},{"location":"man1/tsget/#synopsis","title":"SYNOPSIS","text":"<p>tsget -h server_url [-e extension] [-o output] [-v] [-d] [-k private_key.pem] [-p key_password] [-c client_cert.pem] [-C CA_certs.pem] [-P CA_path] [-r file:file...] [-g EGD_socket] [request]...</p>"},{"location":"man1/tsget/#description","title":"DESCRIPTION","text":"<p>The tsget command can be used for sending a time stamp request, as specified in RFC 3161, to a time stamp server over HTTP or HTTPS and storing the time stamp response in a file. This tool cannot be used for creating the requests and verifying responses, you can use the OpenSSL ts(1) command to do that. tsget can send several requests to the server without closing the TCP connection if more than one requests are specified on the command line.</p> <p>The tool sends the following HTTP request for each time stamp request:</p> <pre><code>    POST url HTTP/1.1\n    User-Agent: OpenTSA tsget.pl/&lt;version&gt;\n    Host: &lt;host&gt;:&lt;port&gt;\n    Pragma: no-cache\n    Content-Type: application/timestamp-query\n    Accept: application/timestamp-reply\n    Content-Length: length of body\n\n    ...binary request specified by the user...\n</code></pre> <p>tsget expects a response of type application/timestamp-reply, which is written to a file without any interpretation.</p>"},{"location":"man1/tsget/#options","title":"OPTIONS","text":"<ul> <li> <p>-h server_url</p> <p>The URL of the HTTP/HTTPS server listening for time stamp requests.</p> </li> <li> <p>-e extension</p> <p>If the -o option is not given this argument specifies the extension of the output files. The base name of the output file will be the same as those of the input files. Default extension is '.tsr'. (Optional)</p> </li> <li> <p>-o output</p> <p>This option can be specified only when just one request is sent to the server. The time stamp response will be written to the given output file. '-' means standard output. In case of multiple time stamp requests or the absence of this argument the names of the output files will be derived from the names of the input files and the default or specified extension argument. (Optional)</p> </li> <li> <p>-v</p> <p>The name of the currently processed request is printed on standard error. (Optional)</p> </li> <li> <p>-d</p> <p>Switches on verbose mode for the underlying curl library. You can see detailed debug messages for the connection. (Optional)</p> </li> <li> <p>-k private_key.pem</p> <p>(HTTPS) In case of certificate-based client authentication over HTTPS &lt;private_key.pem&gt; must contain the private key of the user. The private key file can optionally be protected by a passphrase. The -c option must also be specified. (Optional)</p> </li> <li> <p>-p key_password</p> <p>(HTTPS) Specifies the passphrase for the private key specified by the -k argument. If this option is omitted and the key is passphrase protected tsget will ask for it. (Optional)</p> </li> <li> <p>-c client_cert.pem</p> <p>(HTTPS) In case of certificate-based client authentication over HTTPS &lt;client_cert.pem&gt; must contain the X.509 certificate of the user.  The -k option must also be specified. If this option is not specified no certificate-based client authentication will take place. (Optional)</p> </li> <li> <p>-C CA_certs.pem</p> <p>(HTTPS) The trusted CA certificate store. The certificate chain of the peer's certificate must include one of the CA certificates specified in this file. Either option -C or option -P must be given in case of HTTPS. (Optional)</p> </li> <li> <p>-P CA_path</p> <p>(HTTPS) The path containing the trusted CA certificates to verify the peer's certificate. The directory must be prepared with the c_rehash OpenSSL utility. Either option -C or option -P must be given in case of HTTPS. (Optional)</p> </li> <li> <p>-rand file:file...</p> <p>The files containing random data for seeding the random number generator. Multiple files can be specified, the separator is ; for MS-Windows, , for VMS and : for all other platforms. (Optional)</p> </li> <li> <p>-g EGD_socket</p> <p>The name of an EGD socket to get random data from. (Optional)</p> </li> <li> <p>[request]...</p> <p>List of files containing RFC 3161 DER-encoded time stamp requests. If no requests are specified only one request will be sent to the server and it will be read from the standard input. (Optional)</p> </li> </ul>"},{"location":"man1/tsget/#environment-variables","title":"ENVIRONMENT VARIABLES","text":"<p>The TSGET environment variable can optionally contain default arguments. The content of this variable is added to the list of command line arguments.</p>"},{"location":"man1/tsget/#examples","title":"EXAMPLES","text":"<p>The examples below presume that file1.tsq and file2.tsq contain valid time stamp requests, tsa.opentsa.org listens at port 8080 for HTTP requests and at port 8443 for HTTPS requests, the TSA service is available at the /tsa absolute path.</p> <p>Get a time stamp response for file1.tsq over HTTP, output is written to  file1.tsr:</p> <pre><code>tsget -h http://tsa.opentsa.org:8080/tsa file1.tsq\n</code></pre> <p>Get a time stamp response for file1.tsq and file2.tsq over HTTP showing progress, output is written to file1.reply and file2.reply respectively:</p> <pre><code>tsget -h http://tsa.opentsa.org:8080/tsa -v -e .reply \\\n      file1.tsq file2.tsq\n</code></pre> <p>Create a time stamp request, write it to file3.tsq, send it to the server and write the response to file3.tsr:</p> <pre><code>openssl ts -query -data file3.txt -cert | tee file3.tsq \\\n      | tsget -h http://tsa.opentsa.org:8080/tsa \\\n      -o file3.tsr\n</code></pre> <p>Get a time stamp response for file1.tsq over HTTPS without client authentication:</p> <pre><code>tsget -h https://tsa.opentsa.org:8443/tsa \\\n      -C cacerts.pem file1.tsq\n</code></pre> <p>Get a time stamp response for file1.tsq over HTTPS with certificate-based client authentication (it will ask for the passphrase if client_key.pem is protected):</p> <pre><code>tsget -h https://tsa.opentsa.org:8443/tsa -C cacerts.pem \\\n      -k client_key.pem -c client_cert.pem file1.tsq\n</code></pre> <p>You can shorten the previous command line if you make use of the TSGET environment variable. The following commands do the same as the previous example:</p> <pre><code>TSGET='-h https://tsa.opentsa.org:8443/tsa -C cacerts.pem \\\n      -k client_key.pem -c client_cert.pem'\nexport TSGET\ntsget file1.tsq\n</code></pre>"},{"location":"man1/tsget/#author","title":"AUTHOR","text":"<p>Zoltan Glozik &lt;zglozik@opentsa.org&gt;, OpenTSA project (http://www.opentsa.org)</p>"},{"location":"man1/tsget/#see-also","title":"SEE ALSO","text":"<p>openssl(1), ts(1), curl(1),  RFC 3161</p>"},{"location":"man1/verify/","title":"verify","text":""},{"location":"man1/verify/#name","title":"NAME","text":"<p>openssl-verify, verify - Utility to verify certificates.</p>"},{"location":"man1/verify/#synopsis","title":"SYNOPSIS","text":"<p>openssl verify [-CApath directory] [-CAfile file] [-purpose purpose] [-policy arg] [-ignore_critical] [-attime timestamp] [-check_ss_sig] [-CRLfile file] [-crl_download] [-crl_check] [-crl_check_all] [-policy_check] [-explicit_policy] [-inhibit_any] [-inhibit_map] [-x509_strict] [-extended_crl] [-use_deltas] [-policy_print] [-no_alt_chains] [-allow_proxy_certs] [-untrusted file] [-help] [-issuer_checks] [-trusted file] [-verbose] [-] [certificates]</p>"},{"location":"man1/verify/#description","title":"DESCRIPTION","text":"<p>The verify command verifies certificate chains.</p>"},{"location":"man1/verify/#command-options","title":"COMMAND OPTIONS","text":"<ul> <li> <p>-CApath directory</p> <p>A directory of trusted certificates. The certificates should have names of the form: hash.0 or have symbolic links to them of this form (\"hash\" is the hashed certificate subject name: see the -hash option of the x509 utility). Under Unix the c_rehash script will automatically create symbolic links to a directory of certificates.</p> </li> <li> <p>-CAfile file A file of trusted certificates. The file should contain multiple certificates in PEM format concatenated together.</p> </li> <li> <p>-attime timestamp</p> <p>Perform validation checks using time specified by timestamp and not current system time. timestamp is the number of seconds since 01.01.1970 (UNIX time).</p> </li> <li> <p>-check_ss_sig</p> <p>Verify the signature on the self-signed root CA. This is disabled by default because it doesn't add any security.</p> </li> <li> <p>-CRLfile file</p> <p>File containing one or more CRL's (in PEM format) to load.</p> </li> <li> <p>-crl_download</p> <p>Attempt to download CRL information for this certificate.</p> </li> <li> <p>-crl_check</p> <p>Checks end entity certificate validity by attempting to look up a valid CRL. If a valid CRL cannot be found an error occurs.</p> </li> <li> <p>-untrusted file</p> <p>A file of untrusted certificates. The file should contain multiple certificates in PEM format concatenated together.</p> </li> <li> <p>-purpose purpose</p> <p>The intended use for the certificate. If this option is not specified, verify will not consider certificate purpose during chain verification. Currently accepted uses are sslclient, sslserver, nssslserver, smimesign, smimeencrypt. See the VERIFY OPERATION section for more information.</p> </li> <li> <p>-help</p> <p>Print out a usage message.</p> </li> <li> <p>-verbose</p> <p>Print extra information about the operations being performed.</p> </li> <li> <p>-issuer_checks</p> <p>Print out diagnostics relating to searches for the issuer certificate of the current certificate. This shows why each candidate issuer certificate was rejected. The presence of rejection messages does not itself imply that anything is wrong; during the normal verification process, several rejections may take place.</p> </li> <li> <p>-policy arg</p> <p>Enable policy processing and add arg to the user-initial-policy-set (see RFC5280). The policy arg can be an object name an OID in numeric form. This argument can appear more than once.</p> </li> <li> <p>-policy_check</p> <p>Enables certificate policy processing.</p> </li> <li> <p>-explicit_policy</p> <p>Set policy variable require-explicit-policy (see RFC5280).</p> </li> <li> <p>-inhibit_any</p> <p>Set policy variable inhibit-any-policy (see RFC5280).</p> </li> <li> <p>-inhibit_map</p> <p>Set policy variable inhibit-policy-mapping (see RFC5280).</p> </li> <li> <p>-no_alt_chains</p> <p>When building a certificate chain, if the first certificate chain found is not trusted, then OpenSSL will continue to check to see if an alternative chain can be found that is trusted. With this option that behaviour is suppressed so that only the first chain found is ever used. Using this option will force the behaviour to match that of previous OpenSSL versions.</p> </li> <li> <p>-allow_proxy_certs</p> <p>Allow the verification of proxy certificates.</p> </li> <li> <p>-trusted file</p> <p>A file of additional trusted certificates. The file should contain multiple certificates in PEM format concatenated together.</p> </li> <li> <p>-policy_print</p> <p>Print out diagnostics related to policy processing.</p> </li> <li> <p>-crl_check</p> <p>Checks end entity certificate validity by attempting to look up a valid CRL. If a valid CRL cannot be found an error occurs. </p> </li> <li> <p>-crl_check_all</p> <p>Checks the validity of all certificates in the chain by attempting to look up valid CRLs.</p> </li> <li> <p>-ignore_critical</p> <p>Normally if an unhandled critical extension is present which is not supported by OpenSSL the certificate is rejected (as required by RFC5280). If this option is set critical extensions are ignored.</p> </li> <li> <p>-x509_strict</p> <p>For strict X.509 compliance, disable non-compliant workarounds for broken certificates.</p> </li> <li> <p>-extended_crl</p> <p>Enable extended CRL features such as indirect CRLs and alternate CRL signing keys.</p> </li> <li> <p>-use_deltas</p> <p>Enable support for delta CRLs.</p> </li> <li> <p>-check_ss_sig</p> <p>Verify the signature on the self-signed root CA. This is disabled by default because it doesn't add any security.</p> </li> <li> <p>-</p> <p>Indicates the last option. All arguments following this are assumed to be certificate files. This is useful if the first certificate filename begins with a -.</p> </li> <li> <p>certificates</p> <p>One or more certificates to verify. If no certificates are given, verify will attempt to read a certificate from standard input. Certificates must be in PEM format.</p> </li> </ul>"},{"location":"man1/verify/#verify-operation","title":"VERIFY OPERATION","text":"<p>The verify program uses the same functions as the internal SSL and S/MIME verification, therefore this description applies to these verify operations too.</p> <p>There is one crucial difference between the verify operations performed by the verify program: wherever possible an attempt is made to continue after an error whereas normally the verify operation would halt on the first error. This allows all the problems with a certificate chain to be determined.</p> <p>The verify operation consists of a number of separate steps.</p> <p>Firstly a certificate chain is built up starting from the supplied certificate and ending in the root CA. It is an error if the whole chain cannot be built up. The chain is built up by looking up the issuers certificate of the current certificate. If a certificate is found which is its own issuer it is assumed  to be the root CA.</p> <p>The process of 'looking up the issuers certificate' itself involves a number of steps. In versions of OpenSSL before 0.9.5a the first certificate whose subject name matched the issuer of the current certificate was assumed to be the issuers certificate. In OpenSSL 0.9.6 and later all certificates whose subject name matches the issuer name of the current certificate are  subject to further tests. The relevant authority key identifier components of the current certificate (if present) must match the subject key identifier (if present) and issuer and serial number of the candidate issuer, in addition the keyUsage extension of the candidate issuer (if present) must permit certificate signing.</p> <p>The lookup first looks in the list of untrusted certificates and if no match is found the remaining lookups are from the trusted certificates. The root CA is always looked up in the trusted certificate list: if the certificate to verify is a root certificate then an exact match must be found in the trusted list.</p> <p>The second operation is to check every untrusted certificate's extensions for consistency with the supplied purpose. If the -purpose option is not included then no checks are done. The supplied or \"leaf\" certificate must have extensions compatible with the supplied purpose and all other certificates must also be valid CA certificates. The precise extensions required are described in more detail in the CERTIFICATE EXTENSIONS section of the x509 utility.</p> <p>The third operation is to check the trust settings on the root CA. The root CA should be trusted for the supplied purpose. For compatibility with previous versions of SSLeay and OpenSSL a certificate with no trust settings is considered to be valid for all purposes. </p> <p>The final operation is to check the validity of the certificate chain. The validity period is checked against the current system time and the notBefore and notAfter dates in the certificate. The certificate signatures are also checked at this point.</p> <p>If all operations complete successfully then certificate is considered valid. If any operation fails then the certificate is not valid.</p>"},{"location":"man1/verify/#diagnostics","title":"DIAGNOSTICS","text":"<p>When a verify operation fails the output messages can be somewhat cryptic. The general form of the error message is:</p> <pre><code>server.pem: /C=AU/ST=Queensland/O=CryptSoft Pty Ltd/CN=Test CA (1024 bit)\nerror 24 at 1 depth lookup:invalid CA certificate\n</code></pre> <p>The first line contains the name of the certificate being verified followed by the subject name of the certificate. The second line contains the error number and the depth. The depth is number of the certificate being verified when a problem was detected starting with zero for the certificate being verified itself then 1 for the CA that signed the certificate and so on. Finally a text version of the error number is presented.</p> <p>An exhaustive list of the error codes and messages is shown below, this also includes the name of the error code as defined in the header file x509_vfy.h Some of the error codes are defined but never returned: these are described as \"unused\".</p> <ul> <li> <p>0 X509_V_OK: ok</p> <p>the operation was successful.</p> </li> <li> <p>2 X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: unable to get issuer certificate</p> <p>the issuer certificate of a looked up certificate could not be found. This normally means the list of trusted certificates is not complete.</p> </li> <li> <p>3 X509_V_ERR_UNABLE_TO_GET_CRL: unable to get certificate CRL</p> <p>the CRL of a certificate could not be found.</p> </li> <li> <p>4 X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: unable to decrypt certificate's signature</p> <p>the certificate signature could not be decrypted. This means that the actual signature value could not be determined rather than it not matching the expected value, this is only meaningful for RSA keys.</p> </li> <li> <p>5 X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE: unable to decrypt CRL's signature</p> <p>the CRL signature could not be decrypted: this means that the actual signature value could not be determined rather than it not matching the expected value. Unused.</p> </li> <li> <p>6 X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: unable to decode issuer public key</p> <p>the public key in the certificate SubjectPublicKeyInfo could not be read.</p> </li> <li> <p>7 X509_V_ERR_CERT_SIGNATURE_FAILURE: certificate signature failure</p> <p>the signature of the certificate is invalid.</p> </li> <li> <p>8 X509_V_ERR_CRL_SIGNATURE_FAILURE: CRL signature failure</p> <p>the signature of the certificate is invalid.</p> </li> <li> <p>9 X509_V_ERR_CERT_NOT_YET_VALID: certificate is not yet valid</p> <p>the certificate is not yet valid: the notBefore date is after the current time.</p> </li> <li> <p>10 X509_V_ERR_CERT_HAS_EXPIRED: certificate has expired</p> <p>the certificate has expired: that is the notAfter date is before the current time.</p> </li> <li> <p>11 X509_V_ERR_CRL_NOT_YET_VALID: CRL is not yet valid</p> <p>the CRL is not yet valid.</p> </li> <li> <p>12 X509_V_ERR_CRL_HAS_EXPIRED: CRL has expired</p> <p>the CRL has expired.</p> </li> <li> <p>13 X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: format error in certificate's notBefore field</p> <p>the certificate notBefore field contains an invalid time.</p> </li> <li> <p>14 X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: format error in certificate's notAfter field</p> <p>the certificate notAfter field contains an invalid time.</p> </li> <li> <p>15 X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: format error in CRL's lastUpdate field</p> <p>the CRL lastUpdate field contains an invalid time.</p> </li> <li> <p>16 X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD: format error in CRL's nextUpdate field</p> <p>the CRL nextUpdate field contains an invalid time.</p> </li> <li> <p>17 X509_V_ERR_OUT_OF_MEM: out of memory</p> <p>an error occurred trying to allocate memory. This should never happen.</p> </li> <li> <p>18 X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: self signed certificate</p> <p>the passed certificate is self signed and the same certificate cannot be found in the list of trusted certificates.</p> </li> <li> <p>19 X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN: self signed certificate in certificate chain</p> <p>the certificate chain could be built up using the untrusted certificates but the root could not be found locally.</p> </li> <li> <p>20 X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: unable to get local issuer certificate</p> <p>the issuer certificate could not be found: this occurs if the issuer certificate of an untrusted certificate cannot be found.</p> </li> <li> <p>21 X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: unable to verify the first certificate</p> <p>no signatures could be verified because the chain contains only one certificate and it is not self signed.</p> </li> <li> <p>22 X509_V_ERR_CERT_CHAIN_TOO_LONG: certificate chain too long</p> <p>the certificate chain length is greater than the supplied maximum depth. Unused.</p> </li> <li> <p>23 X509_V_ERR_CERT_REVOKED: certificate revoked</p> <p>the certificate has been revoked.</p> </li> <li> <p>24 X509_V_ERR_INVALID_CA: invalid CA certificate</p> <p>a CA certificate is invalid. Either it is not a CA or its extensions are not consistent with the supplied purpose.</p> </li> <li> <p>25 X509_V_ERR_PATH_LENGTH_EXCEEDED: path length constraint exceeded</p> <p>the basicConstraints pathlength parameter has been exceeded.</p> </li> <li> <p>26 X509_V_ERR_INVALID_PURPOSE: unsupported certificate purpose</p> <p>the supplied certificate cannot be used for the specified purpose.</p> </li> <li> <p>27 X509_V_ERR_CERT_UNTRUSTED: certificate not trusted</p> <p>the root CA is not marked as trusted for the specified purpose.</p> </li> <li> <p>28 X509_V_ERR_CERT_REJECTED: certificate rejected</p> <p>the root CA is marked to reject the specified purpose.</p> </li> <li> <p>29 X509_V_ERR_SUBJECT_ISSUER_MISMATCH: subject issuer mismatch</p> <p>the current candidate issuer certificate was rejected because its subject name did not match the issuer name of the current certificate. Only displayed when the -issuer_checks option is set.</p> </li> <li> <p>30 X509_V_ERR_AKID_SKID_MISMATCH: authority and subject key identifier mismatch</p> <p>the current candidate issuer certificate was rejected because its subject key identifier was present and did not match the authority key identifier current certificate. Only displayed when the -issuer_checks option is set.</p> </li> <li> <p>31 X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH: authority and issuer serial number mismatch</p> <p>the current candidate issuer certificate was rejected because its issuer name and serial number was present and did not match the authority key identifier of the current certificate. Only displayed when the -issuer_checks option is set.</p> </li> <li> <p>32 X509_V_ERR_KEYUSAGE_NO_CERTSIGN:key usage does not include certificate signing</p> <p>the current candidate issuer certificate was rejected because its keyUsage extension does not permit certificate signing.</p> </li> <li> <p>50 X509_V_ERR_APPLICATION_VERIFICATION: application verification failure</p> <p>an application specific error. Unused.</p> </li> </ul>"},{"location":"man1/verify/#bugs","title":"BUGS","text":"<p>Although the issuer checks are a considerable improvement over the old technique they still suffer from limitations in the underlying X509_LOOKUP API. One consequence of this is that trusted certificates with matching subject name must either appear in a file (as specified by the -CAfile option) or a directory (as specified by -CApath. If they occur in both then only the certificates in the file will be recognised.</p> <p>Previous versions of OpenSSL assume certificates with matching subject name are identical and mishandled them.</p> <p>Previous versions of this documentation swapped the meaning of the X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT and 20 X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY error codes.</p>"},{"location":"man1/verify/#see-also","title":"SEE ALSO","text":"<p>x509(1)</p>"},{"location":"man1/verify/#history","title":"HISTORY","text":"<p>The -no_alt_chains options was first added to OpenSSL 1.0.2b.</p>"},{"location":"man1/version/","title":"version","text":""},{"location":"man1/version/#name","title":"NAME","text":"<p>openssl-version, version - print OpenSSL version information</p>"},{"location":"man1/version/#synopsis","title":"SYNOPSIS","text":"<p>openssl version [-a] [-v] [-b] [-o] [-f] [-p] [-d]</p>"},{"location":"man1/version/#description","title":"DESCRIPTION","text":"<p>This command is used to print out version information about OpenSSL.</p>"},{"location":"man1/version/#options","title":"OPTIONS","text":"<ul> <li> <p>-a</p> <p>all information, this is the same as setting all the other flags.</p> </li> <li> <p>-v</p> <p>the current OpenSSL version.</p> </li> <li> <p>-b</p> <p>the date the current version of OpenSSL was built.</p> </li> <li> <p>-o</p> <p>option information: various options set when the library was built.</p> </li> <li> <p>-f</p> <p>compilation flags.</p> </li> <li> <p>-p</p> <p>platform setting.</p> </li> <li> <p>-d</p> <p>OPENSSLDIR setting.</p> </li> </ul>"},{"location":"man1/version/#notes","title":"NOTES","text":"<p>The output of openssl version -a would typically be used when sending in a bug report.</p>"},{"location":"man1/version/#history","title":"HISTORY","text":"<p>The -d option was added in OpenSSL 0.9.7.</p>"},{"location":"man1/x509/","title":"x509","text":""},{"location":"man1/x509/#name","title":"NAME","text":"<p>openssl-x509, x509 - Certificate display and signing utility</p>"},{"location":"man1/x509/#synopsis","title":"SYNOPSIS","text":"<p>openssl x509 [-inform DER|PEM|NET] [-outform DER|PEM|NET] [-keyform DER|PEM] [-CAform DER|PEM] [-CAkeyform DER|PEM] [-in filename] [-out filename] [-serial] [-hash] [-subject_hash] [-issuer_hash] [-ocspid] [-subject] [-issuer] [-nameopt option] [-email] [-ocsp_uri] [-startdate] [-enddate] [-purpose] [-dates] [-checkend num] [-modulus] [-pubkey] [-fingerprint] [-alias] [-noout] [-trustout] [-clrtrust] [-clrreject] [-addtrust arg] [-addreject arg] [-setalias arg] [-days arg] [-set_serial n] [-signkey filename] [-passin arg] [-x509toreq] [-req] [-CA filename] [-CAkey filename] [-CAcreateserial] [-CAserial filename] [-force_pubkey key] [-text] [-certopt option] [-C] [-md2|-md5|-sha1|-mdc2] [-clrext] [-extfile filename] [-extensions section] [-engine id]</p>"},{"location":"man1/x509/#description","title":"DESCRIPTION","text":"<p>The x509 command is a multi purpose certificate utility. It can be used to display certificate information, convert certificates to various forms, sign certificate requests like a \"mini CA\" or edit certificate trust settings.</p> <p>Since there are a large number of options they will split up into various sections.</p>"},{"location":"man1/x509/#options","title":"OPTIONS","text":""},{"location":"man1/x509/#input-output-and-general-purpose-options","title":"INPUT, OUTPUT AND GENERAL PURPOSE OPTIONS","text":"<ul> <li> <p>-inform DER|PEM|NET</p> <p>This specifies the input format normally the command will expect an X509 certificate but this can change if other options such as -req are present. The DER format is the DER encoding of the certificate and PEM is the base64 encoding of the DER encoding with header and footer lines added. The NET option is an obscure Netscape server format that is now obsolete.</p> </li> <li> <p>-outform DER|PEM|NET</p> <p>This specifies the output format, the options have the same meaning as the  -inform option.</p> </li> <li> <p>-in filename</p> <p>This specifies the input filename to read a certificate from or standard input if this option is not specified.</p> </li> <li> <p>-out filename</p> <p>This specifies the output filename to write to or standard output by default.</p> </li> <li> <p>-md2|-md5|-sha1|-mdc2</p> <p>the digest to use. This affects any signing or display option that uses a message digest, such as the -fingerprint, -signkey and -CA options. If not specified then SHA1 is used. If the key being used to sign with is a DSA key then this option has no effect: SHA1 is always used with DSA keys.</p> </li> <li> <p>-engine id</p> <p>specifying an engine (by its unique id string) will cause x509 to attempt to obtain a functional reference to the specified engine, thus initialising it if needed. The engine will then be set as the default for all available algorithms.</p> </li> </ul>"},{"location":"man1/x509/#display-options","title":"DISPLAY OPTIONS","text":"<p>Note: the -alias and -purpose options are also display options but are described in the TRUST SETTINGS section.</p> <ul> <li> <p>-text</p> <p>prints out the certificate in text form. Full details are output including the public key, signature algorithms, issuer and subject names, serial number any extensions present and any trust settings.</p> </li> <li> <p>-certopt option</p> <p>customise the output format used with -text. The option argument can be a single option or multiple options separated by commas. The -certopt switch may be also be used more than once to set multiple options. See the TEXT OPTIONS section for more information.</p> </li> <li> <p>-noout</p> <p>this option prevents output of the encoded version of the request.</p> </li> <li> <p>-pubkey</p> <p>outputs the the certificate's SubjectPublicKeyInfo block in PEM format.</p> </li> <li> <p>-modulus</p> <p>this option prints out the value of the modulus of the public key contained in the certificate.</p> </li> <li> <p>-serial</p> <p>outputs the certificate serial number.</p> </li> <li> <p>-subject_hash</p> <p>outputs the \"hash\" of the certificate subject name. This is used in OpenSSL to form an index to allow certificates in a directory to be looked up by subject name.</p> </li> <li> <p>-issuer_hash</p> <p>outputs the \"hash\" of the certificate issuer name.</p> </li> <li> <p>-ocspid</p> <p>outputs the OCSP hash values for the subject name and public key.</p> </li> <li> <p>-hash</p> <p>synonym for \"-subject_hash\" for backward compatibility reasons.</p> </li> <li> <p>-subject_hash_old</p> <p>outputs the \"hash\" of the certificate subject name using the older algorithm as used by OpenSSL versions before 1.0.0.</p> </li> <li> <p>-issuer_hash_old</p> <p>outputs the \"hash\" of the certificate issuer name using the older algorithm as used by OpenSSL versions before 1.0.0.</p> </li> <li> <p>-subject</p> <p>outputs the subject name.</p> </li> <li> <p>-issuer</p> <p>outputs the issuer name.</p> </li> <li> <p>-nameopt option</p> <p>option which determines how the subject or issuer names are displayed. The option argument can be a single option or multiple options separated by commas.  Alternatively the -nameopt switch may be used more than once to set multiple options. See the NAME OPTIONS section for more information.</p> </li> <li> <p>-email</p> <p>outputs the email address(es) if any.</p> </li> <li> <p>-ocsp_uri</p> <p>outputs the OCSP responder address(es) if any.</p> </li> <li> <p>-startdate</p> <p>prints out the start date of the certificate, that is the notBefore date.</p> </li> <li> <p>-enddate</p> <p>prints out the expiry date of the certificate, that is the notAfter date.</p> </li> <li> <p>-dates</p> <p>prints out the start and expiry dates of a certificate.</p> </li> <li> <p>-checkend arg</p> <p>checks if the certificate expires within the next arg seconds and exits non-zero if yes it will expire or zero if not.</p> </li> <li> <p>-fingerprint</p> <p>Calculates and outputs the digest of the DER encoded version of the entire certificate (see digest options). This is commonly called a \"fingerprint\". Because of the nature of message digests, the fingerprint of a certificate is unique to that certificate and two certificates with the same fingerprint can be considered to be the same.</p> </li> <li> <p>-C</p> <p>this outputs the certificate in the form of a C source file.</p> </li> </ul>"},{"location":"man1/x509/#trust-settings","title":"TRUST SETTINGS","text":"<p>Please note these options are currently experimental and may well change.</p> <p>A trusted certificate is an ordinary certificate which has several additional pieces of information attached to it such as the permitted and prohibited uses of the certificate and an \"alias\".</p> <p>Normally when a certificate is being verified at least one certificate must be \"trusted\". By default a trusted certificate must be stored locally and must be a root CA: any certificate chain ending in this CA is then usable for any purpose.</p> <p>Trust settings currently are only used with a root CA. They allow a finer control over the purposes the root CA can be used for. For example a CA may be trusted for SSL client but not SSL server use.</p> <p>See the description of the verify utility for more information on the meaning of trust settings.</p> <p>Future versions of OpenSSL will recognize trust settings on any certificate: not just root CAs.</p> <ul> <li> <p>-trustout</p> <p>this causes x509 to output a trusted certificate. An ordinary or trusted certificate can be input but by default an ordinary certificate is output and any trust settings are discarded. With the -trustout option a trusted certificate is output. A trusted certificate is automatically output if any trust settings are modified.</p> </li> <li> <p>-setalias arg</p> <p>sets the alias of the certificate. This will allow the certificate to be referred to using a nickname for example \"Steve's Certificate\".</p> </li> <li> <p>-alias</p> <p>outputs the certificate alias, if any.</p> </li> <li> <p>-clrtrust</p> <p>clears all the permitted or trusted uses of the certificate.</p> </li> <li> <p>-clrreject</p> <p>clears all the prohibited or rejected uses of the certificate.</p> </li> <li> <p>-addtrust arg</p> <p>adds a trusted certificate use. Any object name can be used here but currently only clientAuth (SSL client use), serverAuth (SSL server use) and emailProtection (S/MIME email) are used. Other OpenSSL applications may define additional uses.</p> </li> <li> <p>-addreject arg</p> <p>adds a prohibited use. It accepts the same values as the -addtrust option.</p> </li> <li> <p>-purpose</p> <p>this option performs tests on the certificate extensions and outputs the results. For a more complete description see the CERTIFICATE EXTENSIONS section.</p> </li> </ul>"},{"location":"man1/x509/#signing-options","title":"SIGNING OPTIONS","text":"<p>The x509 utility can be used to sign certificates and requests: it can thus behave like a \"mini CA\".</p> <ul> <li> <p>-signkey filename</p> <p>this option causes the input file to be self signed using the supplied private key. </p> <p>If the input file is a certificate it sets the issuer name to the subject name (i.e.  makes it self signed) changes the public key to the supplied value and changes the start and end dates. The start date is set to the current time and the end date is set to a value determined by the -days option. Any certificate extensions are retained unless the -clrext option is supplied.</p> <p>If the input is a certificate request then a self signed certificate is created using the supplied private key using the subject name in the request.</p> </li> <li> <p>-passin arg</p> <p>the key password source. For more information about the format of arg see the PASS PHRASE ARGUMENTS section in openssl(1).</p> </li> <li> <p>-clrext</p> <p>delete any extensions from a certificate. This option is used when a certificate is being created from another certificate (for example with the -signkey or the -CA options). Normally all extensions are retained.</p> </li> <li> <p>-keyform PEM|DER</p> <p>specifies the format (DER or PEM) of the private key file used in the -signkey option.</p> </li> <li> <p>-days arg</p> <p>specifies the number of days to make a certificate valid for. The default is 30 days.</p> </li> <li> <p>-x509toreq</p> <p>converts a certificate into a certificate request. The -signkey option is used to pass the required private key.</p> </li> <li> <p>-req</p> <p>by default a certificate is expected on input. With this option a certificate request is expected instead.</p> </li> <li> <p>-set_serial n</p> <p>specifies the serial number to use. This option can be used with either the -signkey or -CA options. If used in conjunction with the -CA option the serial number file (as specified by the -CAserial or -CAcreateserial options) is not used.</p> <p>The serial number can be decimal or hex (if preceded by 0x). Negative serial numbers can also be specified but their use is not recommended.</p> </li> <li> <p>-CA filename</p> <p>specifies the CA certificate to be used for signing. When this option is present x509 behaves like a \"mini CA\". The input file is signed by this CA using this option: that is its issuer name is set to the subject name of the CA and it is digitally signed using the CAs private key.</p> <p>This option is normally combined with the -req option. Without the -req option the input is a certificate which must be self signed.</p> </li> <li> <p>-CAkey filename</p> <p>sets the CA private key to sign a certificate with. If this option is not specified then it is assumed that the CA private key is present in the CA certificate file.</p> </li> <li> <p>-CAserial filename</p> <p>sets the CA serial number file to use.</p> <p>When the -CA option is used to sign a certificate it uses a serial number specified in a file. This file consist of one line containing an even number of hex digits with the serial number to use. After each use the serial number is incremented and written out to the file again.</p> <p>The default filename consists of the CA certificate file base name with \".srl\" appended. For example if the CA certificate file is called  \"mycacert.pem\" it expects to find a serial number file called \"mycacert.srl\".</p> </li> <li> <p>-CAcreateserial</p> <p>with this option the CA serial number file is created if it does not exist: it will contain the serial number \"02\" and the certificate being signed will have the 1 as its serial number. Normally if the -CA option is specified and the serial number file does not exist it is an error.</p> </li> <li> <p>-extfile filename</p> <p>file containing certificate extensions to use. If not specified then no extensions are added to the certificate.</p> </li> <li> <p>-extensions section</p> <p>the section to add certificate extensions from. If this option is not specified then the extensions should either be contained in the unnamed (default) section or the default section should contain a variable called \"extensions\" which contains the section to use. See the x509v3_config(5) manual page for details of the extension section format.</p> </li> <li> <p>-force_pubkey key</p> <p>when a certificate is created set its public key to key instead of the key in the certificate or certificate request. This option is useful for creating certificates where the algorithm can't normally sign requests, for example DH.</p> <p>The format or key can be specified using the -keyform option.</p> </li> </ul>"},{"location":"man1/x509/#name-options","title":"NAME OPTIONS","text":"<p>The nameopt command line switch determines how the subject and issuer names are displayed. If no nameopt switch is present the default \"oneline\" format is used which is compatible with previous versions of OpenSSL. Each option is described in detail below, all options can be preceded by a - to turn the option off. Only the first four will normally be used.</p> <ul> <li> <p>compat</p> <p>use the old format. This is equivalent to specifying no name options at all.</p> </li> <li> <p>RFC2253</p> <p>displays names compatible with RFC2253 equivalent to esc_2253, esc_ctrl, esc_msb, utf8, dump_nostr, dump_unknown, dump_der, sep_comma_plus, dn_rev and sname.</p> </li> <li> <p>oneline</p> <p>a oneline format which is more readable than RFC2253. It is equivalent to specifying the  esc_2253, esc_ctrl, esc_msb, utf8, dump_nostr, dump_der, use_quote, sep_comma_plus_space, space_eq and sname options.</p> </li> <li> <p>multiline</p> <p>a multiline format. It is equivalent esc_ctrl, esc_msb, sep_multiline, space_eq, lname and align.</p> </li> <li> <p>esc_2253</p> <p>escape the \"special\" characters required by RFC2253 in a field That is ,+\"&lt;&gt;;. Additionally # is escaped at the beginning of a string and a space character at the beginning or end of a string.</p> </li> <li> <p>esc_ctrl</p> <p>escape control characters. That is those with ASCII values less than 0x20 (space) and the delete (0x7f) character. They are escaped using the RFC2253 \\XX notation (where XX are two hex digits representing the character value).</p> </li> <li> <p>esc_msb</p> <p>escape characters with the MSB set, that is with ASCII values larger than 127.</p> </li> <li> <p>use_quote</p> <p>escapes some characters by surrounding the whole string with \" characters, without the option all escaping is done with the \\ character.</p> </li> <li> <p>utf8</p> <p>convert all strings to UTF8 format first. This is required by RFC2253. If you are lucky enough to have a UTF8 compatible terminal then the use of this option (and not setting esc_msb) may result in the correct display of multibyte (international) characters. Is this option is not present then multibyte characters larger than 0xff will be represented using the format \\UXXXX for 16 bits and \\WXXXXXXXX for 32 bits. Also if this option is off any UTF8Strings will be converted to their character form first.</p> </li> <li> <p>ignore_type</p> <p>this option does not attempt to interpret multibyte characters in any way. That is their content octets are merely dumped as though one octet represents each character. This is useful for diagnostic purposes but will result in rather odd looking output.</p> </li> <li> <p>show_type</p> <p>show the type of the ASN1 character string. The type precedes the field contents. For example \"BMPSTRING: Hello World\".</p> </li> <li> <p>dump_der</p> <p>when this option is set any fields that need to be hexdumped will be dumped using the DER encoding of the field. Otherwise just the content octets will be displayed. Both options use the RFC2253 #XXXX... format.</p> </li> <li> <p>dump_nostr</p> <p>dump non character string types (for example OCTET STRING) if this option is not set then non character string types will be displayed as though each content octet represents a single character.</p> </li> <li> <p>dump_all</p> <p>dump all fields. This option when used with dump_der allows the DER encoding of the structure to be unambiguously determined.</p> </li> <li> <p>dump_unknown</p> <p>dump any field whose OID is not recognised by OpenSSL.</p> </li> <li> <p>sep_comma_plus, sep_comma_plus_space, sep_semi_plus_space, sep_multiline</p> <p>these options determine the field separators. The first character is between RDNs and the second between multiple AVAs (multiple AVAs are very rare and their use is discouraged). The options ending in \"space\" additionally place a space after the separator to make it more readable. The sep_multiline uses a linefeed character for the RDN separator and a spaced + for the AVA separator. It also indents the fields by four characters. If no field separator is specified then sep_comma_plus_space is used by default.</p> </li> <li> <p>dn_rev</p> <p>reverse the fields of the DN. This is required by RFC2253. As a side effect this also reverses the order of multiple AVAs but this is permissible.</p> </li> <li> <p>nofname, sname, lname, oid</p> <p>these options alter how the field name is displayed. nofname does not display the field at all. sname uses the \"short name\" form (CN for commonName for example). lname uses the long form. oid represents the OID in numerical form and is useful for diagnostic purpose.</p> </li> <li> <p>align</p> <p>align field values for a more readable output. Only usable with sep_multiline.</p> </li> <li> <p>space_eq</p> <p>places spaces round the = character which follows the field name.</p> </li> </ul>"},{"location":"man1/x509/#text-options","title":"TEXT OPTIONS","text":"<p>As well as customising the name output format, it is also possible to customise the actual fields printed using the certopt options when the text option is present. The default behaviour is to print all fields.</p> <ul> <li> <p>compatible</p> <p>use the old format. This is equivalent to specifying no output options at all.</p> </li> <li> <p>no_header</p> <p>don't print header information: that is the lines saying \"Certificate\" and \"Data\".</p> </li> <li> <p>no_version</p> <p>don't print out the version number.</p> </li> <li> <p>no_serial</p> <p>don't print out the serial number.</p> </li> <li> <p>no_signame</p> <p>don't print out the signature algorithm used.</p> </li> <li> <p>no_validity</p> <p>don't print the validity, that is the notBefore and notAfter fields.</p> </li> <li> <p>no_subject</p> <p>don't print out the subject name.</p> </li> <li> <p>no_issuer</p> <p>don't print out the issuer name.</p> </li> <li> <p>no_pubkey</p> <p>don't print out the public key.</p> </li> <li> <p>no_sigdump</p> <p>don't give a hexadecimal dump of the certificate signature.</p> </li> <li> <p>no_aux</p> <p>don't print out certificate trust information.</p> </li> <li> <p>no_extensions</p> <p>don't print out any X509V3 extensions.</p> </li> <li> <p>ext_default</p> <p>retain default extension behaviour: attempt to print out unsupported certificate extensions.</p> </li> <li> <p>ext_error</p> <p>print an error message for unsupported certificate extensions.</p> </li> <li> <p>ext_parse</p> <p>ASN1 parse unsupported extensions.</p> </li> <li> <p>ext_dump</p> <p>hex dump unsupported extensions.</p> </li> <li> <p>ca_default</p> <p>the value used by the ca utility, equivalent to no_issuer, no_pubkey, no_header, and no_version.</p> </li> </ul>"},{"location":"man1/x509/#examples","title":"EXAMPLES","text":"<p>Note: in these examples the '\\' means the example should be all on one line.</p> <p>Display the contents of a certificate:</p> <pre><code>openssl x509 -in cert.pem -noout -text\n</code></pre> <p>Display the certificate serial number:</p> <pre><code>openssl x509 -in cert.pem -noout -serial\n</code></pre> <p>Display the certificate subject name:</p> <pre><code>openssl x509 -in cert.pem -noout -subject\n</code></pre> <p>Display the certificate subject name in RFC2253 form:</p> <pre><code>openssl x509 -in cert.pem -noout -subject -nameopt RFC2253\n</code></pre> <p>Display the certificate subject name in oneline form on a terminal supporting UTF8:</p> <pre><code>openssl x509 -in cert.pem -noout -subject -nameopt oneline,-esc_msb\n</code></pre> <p>Display the certificate SHA1 fingerprint:</p> <pre><code>openssl x509 -sha1 -in cert.pem -noout -fingerprint\n</code></pre> <p>Convert a certificate from PEM to DER format:</p> <pre><code>openssl x509 -in cert.pem -inform PEM -out cert.der -outform DER\n</code></pre> <p>Convert a certificate to a certificate request:</p> <pre><code>openssl x509 -x509toreq -in cert.pem -out req.pem -signkey key.pem\n</code></pre> <p>Convert a certificate request into a self signed certificate using extensions for a CA:</p> <pre><code>openssl x509 -req -in careq.pem -extfile openssl.cnf -extensions v3_ca \\\n       -signkey key.pem -out cacert.pem\n</code></pre> <p>Sign a certificate request using the CA certificate above and add user certificate extensions:</p> <pre><code>openssl x509 -req -in req.pem -extfile openssl.cnf -extensions v3_usr \\\n       -CA cacert.pem -CAkey key.pem -CAcreateserial\n</code></pre> <p>Set a certificate to be trusted for SSL client use and change set its alias to \"Steve's Class 1 CA\"</p> <pre><code>openssl x509 -in cert.pem -addtrust clientAuth \\\n       -setalias \"Steve's Class 1 CA\" -out trust.pem\n</code></pre>"},{"location":"man1/x509/#notes","title":"NOTES","text":"<p>The PEM format uses the header and footer lines:</p> <pre><code>-----BEGIN CERTIFICATE-----\n-----END CERTIFICATE-----\n</code></pre> <p>it will also handle files containing:</p> <pre><code>-----BEGIN X509 CERTIFICATE-----\n-----END X509 CERTIFICATE-----\n</code></pre> <p>Trusted certificates have the lines</p> <pre><code>-----BEGIN TRUSTED CERTIFICATE-----\n-----END TRUSTED CERTIFICATE-----\n</code></pre> <p>The conversion to UTF8 format used with the name options assumes that T61Strings use the ISO8859-1 character set. This is wrong but Netscape and MSIE do this as do many certificates. So although this is incorrect it is more likely to display the majority of certificates correctly.</p> <p>The -email option searches the subject name and the subject alternative name extension. Only unique email addresses will be printed out: it will not print the same address more than once.</p>"},{"location":"man1/x509/#certificate-extensions","title":"CERTIFICATE EXTENSIONS","text":"<p>The -purpose option checks the certificate extensions and determines what the certificate can be used for. The actual checks done are rather complex and include various hacks and workarounds to handle broken certificates and software.</p> <p>The same code is used when verifying untrusted certificates in chains so this section is useful if a chain is rejected by the verify code.</p> <p>The basicConstraints extension CA flag is used to determine whether the certificate can be used as a CA. If the CA flag is true then it is a CA, if the CA flag is false then it is not a CA. All CAs should have the CA flag set to true.</p> <p>If the basicConstraints extension is absent then the certificate is considered to be a \"possible CA\" other extensions are checked according to the intended use of the certificate. A warning is given in this case because the certificate should really not be regarded as a CA: however it is allowed to be a CA to work around some broken software.</p> <p>If the certificate is a V1 certificate (and thus has no extensions) and it is self signed it is also assumed to be a CA but a warning is again given: this is to work around the problem of Verisign roots which are V1 self signed certificates.</p> <p>If the keyUsage extension is present then additional restraints are made on the uses of the certificate. A CA certificate must have the keyCertSign bit set if the keyUsage extension is present.</p> <p>The extended key usage extension places additional restrictions on the certificate uses. If this extension is present (whether critical or not) the key can only be used for the purposes specified.</p> <p>A complete description of each test is given below. The comments about basicConstraints and keyUsage and V1 certificates above apply to all CA certificates.</p> <ul> <li> <p>SSL Client</p> <p>The extended key usage extension must be absent or include the \"web client authentication\" OID.  keyUsage must be absent or it must have the digitalSignature bit set. Netscape certificate type must be absent or it must have the SSL client bit set.</p> </li> <li> <p>SSL Client CA</p> <p>The extended key usage extension must be absent or include the \"web client authentication\" OID. Netscape certificate type must be absent or it must have the SSL CA bit set: this is used as a work around if the basicConstraints extension is absent.</p> </li> <li> <p>SSL Server</p> <p>The extended key usage extension must be absent or include the \"web server authentication\" and/or one of the SGC OIDs.  keyUsage must be absent or it must have the digitalSignature, the keyEncipherment set or both bits set. Netscape certificate type must be absent or have the SSL server bit set.</p> </li> <li> <p>SSL Server CA</p> <p>The extended key usage extension must be absent or include the \"web server authentication\" and/or one of the SGC OIDs.  Netscape certificate type must be absent or the SSL CA bit must be set: this is used as a work around if the basicConstraints extension is absent.</p> </li> <li> <p>Netscape SSL Server</p> <p>For Netscape SSL clients to connect to an SSL server it must have the keyEncipherment bit set if the keyUsage extension is present. This isn't always valid because some cipher suites use the key for digital signing. Otherwise it is the same as a normal SSL server.</p> </li> <li> <p>Common S/MIME Client Tests</p> <p>The extended key usage extension must be absent or include the \"email protection\" OID. Netscape certificate type must be absent or should have the S/MIME bit set. If the S/MIME bit is not set in netscape certificate type then the SSL client bit is tolerated as an alternative but a warning is shown: this is because some Verisign certificates don't set the S/MIME bit.</p> </li> <li> <p>S/MIME Signing</p> <p>In addition to the common S/MIME client tests the digitalSignature bit must be set if the keyUsage extension is present.</p> </li> <li> <p>S/MIME Encryption</p> <p>In addition to the common S/MIME tests the keyEncipherment bit must be set if the keyUsage extension is present.</p> </li> <li> <p>S/MIME CA</p> <p>The extended key usage extension must be absent or include the \"email protection\" OID. Netscape certificate type must be absent or must have the S/MIME CA bit set: this is used as a work around if the basicConstraints extension is absent. </p> </li> <li> <p>CRL Signing</p> <p>The keyUsage extension must be absent or it must have the CRL signing bit set.</p> </li> <li> <p>CRL Signing CA</p> <p>The normal CA tests apply. Except in this case the basicConstraints extension must be present.</p> </li> </ul>"},{"location":"man1/x509/#bugs","title":"BUGS","text":"<p>Extensions in certificates are not transferred to certificate requests and vice versa.</p> <p>It is possible to produce invalid certificates or requests by specifying the wrong private key or using inconsistent options in some cases: these should be checked.</p> <p>There should be options to explicitly set such things as start and end dates rather than an offset from the current time.</p> <p>The code to implement the verify behaviour described in the TRUST SETTINGS is currently being developed. It thus describes the intended behaviour rather than the current behaviour. It is hoped that it will represent reality in OpenSSL 0.9.5 and later.</p>"},{"location":"man1/x509/#see-also","title":"SEE ALSO","text":"<p>req(1), ca(1), genrsa(1), gendsa(1), verify(1), x509v3_config(5) </p>"},{"location":"man1/x509/#history","title":"HISTORY","text":"<p>Before OpenSSL 0.9.8, the default digest for RSA keys was MD5.</p> <p>The hash algorithm used in the -subject_hash and -issuer_hash options before OpenSSL 1.0.0 was based on the deprecated MD5 algorithm and the encoding of the distinguished name. In OpenSSL 1.0.0 and later it is based on a canonical version of the DN using SHA1. This means that any directories using the old form must have their links rebuilt using c_rehash or similar. </p>"},{"location":"man1/x509v3_config/","title":"x509v3_config","text":""},{"location":"man1/x509v3_config/#name","title":"NAME","text":"<p>x509v3_config - X509 V3 certificate extension configuration format</p>"},{"location":"man1/x509v3_config/#description","title":"DESCRIPTION","text":"<p>Several of the OpenSSL utilities can add extensions to a certificate or certificate request based on the contents of a configuration file.</p> <p>Typically the application will contain an option to point to an extension section. Each line of the extension section takes the form:</p> <pre><code>extension_name=[critical,] extension_options\n</code></pre> <p>If critical is present then the extension will be critical.</p> <p>The format of extension_options depends on the value of extension_name.</p> <p>There are four main types of extension: string extensions, multi-valued extensions, raw and arbitrary extensions.</p> <p>String extensions simply have a string which contains either the value itself or how it is obtained.</p> <p>For example:</p> <pre><code>nsComment=\"This is a Comment\"\n</code></pre> <p>Multi-valued extensions have a short form and a long form. The short form is a list of names and values:</p> <pre><code>basicConstraints=critical,CA:true,pathlen:1\n</code></pre> <p>The long form allows the values to be placed in a separate section:</p> <pre><code>basicConstraints=critical,@bs_section\n\n[bs_section]\n\nCA=true\npathlen=1\n</code></pre> <p>Both forms are equivalent.</p> <p>The syntax of raw extensions is governed by the extension code: it can for example contain data in multiple sections. The correct syntax to use is defined by the extension code itself: check out the certificate policies extension for an example.</p> <p>If an extension type is unsupported then the arbitrary extension syntax must be used, see the ARBITRARY EXTENSIONS section for more details.</p>"},{"location":"man1/x509v3_config/#standard-extensions","title":"STANDARD EXTENSIONS","text":"<p>The following sections describe each supported extension in detail.</p>"},{"location":"man1/x509v3_config/#basic-constraints","title":"Basic Constraints.","text":"<p>This is a multi valued extension which indicates whether a certificate is a CA certificate. The first (mandatory) name is CA followed by TRUE or FALSE. If CA is TRUE then an optional pathlen name followed by an non-negative value can be included.</p> <p>For example:</p> <pre><code>basicConstraints=CA:TRUE\n\nbasicConstraints=CA:FALSE\n\nbasicConstraints=critical,CA:TRUE, pathlen:0\n</code></pre> <p>A CA certificate must include the basicConstraints value with the CA field set to TRUE. An end user certificate must either set CA to FALSE or exclude the extension entirely. Some software may require the inclusion of basicConstraints with CA set to FALSE for end entity certificates.</p> <p>The pathlen parameter indicates the maximum number of CAs that can appear below this one in a chain. So if you have a CA with a pathlen of zero it can only be used to sign end user certificates and not further CAs.</p>"},{"location":"man1/x509v3_config/#key-usage","title":"Key Usage.","text":"<p>Key usage is a multi valued extension consisting of a list of names of the permitted key usages.</p> <p>The supporte names are: digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment, keyAgreement, keyCertSign, cRLSign, encipherOnly and decipherOnly.</p> <p>Examples:</p> <pre><code>keyUsage=digitalSignature, nonRepudiation\n\nkeyUsage=critical, keyCertSign\n</code></pre>"},{"location":"man1/x509v3_config/#extended-key-usage","title":"Extended Key Usage.","text":"<p>This extensions consists of a list of usages indicating purposes for which the certificate public key can be used for,</p> <p>These can either be object short names or the dotted numerical form of OIDs. While any OID can be used only certain values make sense. In particular the following PKIX, NS and MS values are meaningful:</p> <pre><code>Value                  Meaning\n-----                  -------\nserverAuth             SSL/TLS Web Server Authentication.\nclientAuth             SSL/TLS Web Client Authentication.\ncodeSigning            Code signing.\nemailProtection        E-mail Protection (S/MIME).\ntimeStamping           Trusted Timestamping\nmsCodeInd              Microsoft Individual Code Signing (authenticode)\nmsCodeCom              Microsoft Commercial Code Signing (authenticode)\nmsCTLSign              Microsoft Trust List Signing\nmsSGC                  Microsoft Server Gated Crypto\nmsEFS                  Microsoft Encrypted File System\nnsSGC                  Netscape Server Gated Crypto\n</code></pre> <p>Examples:</p> <pre><code>extendedKeyUsage=critical,codeSigning,1.2.3.4\nextendedKeyUsage=nsSGC,msSGC\n</code></pre>"},{"location":"man1/x509v3_config/#subject-key-identifier","title":"Subject Key Identifier.","text":"<p>This is really a string extension and can take two possible values. Either the word hash which will automatically follow the guidelines in RFC3280 or a hex string giving the extension value to include. The use of the hex string is strongly discouraged.</p> <p>Example:</p> <pre><code>subjectKeyIdentifier=hash\n</code></pre>"},{"location":"man1/x509v3_config/#authority-key-identifier","title":"Authority Key Identifier.","text":"<p>The authority key identifier extension permits two options. keyid and issuer: both can take the optional value \"always\".</p> <p>If the keyid option is present an attempt is made to copy the subject key identifier from the parent certificate. If the value \"always\" is present then an error is returned if the option fails.</p> <p>The issuer option copies the issuer and serial number from the issuer certificate. This will only be done if the keyid option fails or is not included unless the \"always\" flag will always include the value.</p> <p>Example:</p> <pre><code>authorityKeyIdentifier=keyid,issuer\n</code></pre>"},{"location":"man1/x509v3_config/#subject-alternative-name","title":"Subject Alternative Name.","text":"<p>The subject alternative name extension allows various literal values to be included in the configuration file. These include email (an email address) URI a uniform resource indicator, DNS (a DNS domain name), RID (a registered ID: OBJECT IDENTIFIER), IP (an IP address), dirName (a distinguished name) and otherName.</p> <p>The email option include a special 'copy' value. This will automatically include and email addresses contained in the certificate subject name in the extension.</p> <p>The IP address used in the IP options can be in either IPv4 or IPv6 format.</p> <p>The value of dirName should point to a section containing the distinguished name to use as a set of name value pairs. Multi values AVAs can be formed by prefacing the name with a + character.</p> <p>otherName can include arbitrary data associated with an OID: the value should be the OID followed by a semicolon and the content in standard ASN1_generate_nconf(3) format.</p> <p>Examples:</p> <pre><code>subjectAltName=email:copy,email:my@other.address,URI:http://my.url.here/\nsubjectAltName=IP:192.168.7.1\nsubjectAltName=IP:13::17\nsubjectAltName=email:my@other.address,RID:1.2.3.4\nsubjectAltName=otherName:1.2.3.4;UTF8:some other identifier\n\nsubjectAltName=dirName:dir_sect\n\n[dir_sect]\nC=UK\nO=My Organization\nOU=My Unit\nCN=My Name\n</code></pre>"},{"location":"man1/x509v3_config/#issuer-alternative-name","title":"Issuer Alternative Name.","text":"<p>The issuer alternative name option supports all the literal options of subject alternative name. It does not support the email:copy option because that would not make sense. It does support an additional issuer:copy option that will copy all the subject alternative name values from the issuer  certificate (if possible).</p> <p>Example:</p> <pre><code>issuserAltName = issuer:copy\n</code></pre>"},{"location":"man1/x509v3_config/#authority-info-access","title":"Authority Info Access.","text":"<p>The authority information access extension gives details about how to access certain information relating to the CA. Its syntax is accessOID;location where location has the same syntax as subject alternative name (except that email:copy is not supported). accessOID can be any valid OID but only certain values are meaningful, for example OCSP and caIssuers.</p> <p>Example:</p> <pre><code>authorityInfoAccess = OCSP;URI:http://ocsp.my.host/\nauthorityInfoAccess = caIssuers;URI:http://my.ca/ca.html\n</code></pre>"},{"location":"man1/x509v3_config/#crl-distribution-points","title":"CRL distribution points.","text":"<p>This is a multi-valued extension whose options can be either in name:value pair using the same form as subject alternative name or a single value representing a section name containing all the distribution point fields.</p> <p>For a name:value pair a new DistributionPoint with the fullName field set to the given value both the cRLissuer and reasons fields are omitted in this case.</p> <p>In the single option case the section indicated contains values for each field. In this section:</p> <p>If the name is \"fullname\" the value field should contain the full name of the distribution point in the same format as subject alternative name.</p> <p>If the name is \"relativename\" then the value field should contain a section name whose contents represent a DN fragment to be placed in this field.</p> <p>The name \"CRLIssuer\" if present should contain a value for this field in subject alternative name format.</p> <p>If the name is \"reasons\" the value field should consist of a comma separated field containing the reasons. Valid reasons are: \"keyCompromise\", \"CACompromise\", \"affiliationChanged\", \"superseded\", \"cessationOfOperation\", \"certificateHold\", \"privilegeWithdrawn\" and \"AACompromise\".</p> <p>Simple examples:</p> <pre><code>crlDistributionPoints=URI:http://myhost.com/myca.crl\ncrlDistributionPoints=URI:http://my.com/my.crl,URI:http://oth.com/my.crl\n</code></pre> <p>Full distribution point example:</p> <pre><code>crlDistributionPoints=crldp1_section\n\n[crldp1_section]\n\nfullname=URI:http://myhost.com/myca.crl\nCRLissuer=dirName:issuer_sect\nreasons=keyCompromise, CACompromise\n\n[issuer_sect]\nC=UK\nO=Organisation\nCN=Some Name\n</code></pre>"},{"location":"man1/x509v3_config/#issuing-distribution-point","title":"Issuing Distribution Point","text":"<p>This extension should only appear in CRLs. It is a multi valued extension whose syntax is similar to the \"section\" pointed to by the CRL distribution points extension with a few differences.</p> <p>The names \"reasons\" and \"CRLissuer\" are not recognized.</p> <p>The name \"onlysomereasons\" is accepted which sets this field. The value is in the same format as the CRL distribution point \"reasons\" field.</p> <p>The names \"onlyuser\", \"onlyCA\", \"onlyAA\" and \"indirectCRL\" are also accepted the values should be a boolean value (TRUE or FALSE) to indicate the value of the corresponding field.</p> <p>Example:</p> <pre><code>issuingDistributionPoint=critical, @idp_section\n\n[idp_section]\n\nfullname=URI:http://myhost.com/myca.crl\nindirectCRL=TRUE\nonlysomereasons=keyCompromise, CACompromise\n\n[issuer_sect]\nC=UK\nO=Organisation\nCN=Some Name\n</code></pre>"},{"location":"man1/x509v3_config/#certificate-policies","title":"Certificate Policies.","text":"<p>This is a raw extension. All the fields of this extension can be set by using the appropriate syntax.</p> <p>If you follow the PKIX recommendations and just using one OID then you just include the value of that OID. Multiple OIDs can be set separated by commas, for example:</p> <pre><code>certificatePolicies= 1.2.4.5, 1.1.3.4\n</code></pre> <p>If you wish to include qualifiers then the policy OID and qualifiers need to be specified in a separate section: this is done by using the @section syntax instead of a literal OID value.</p> <p>The section referred to must include the policy OID using the name policyIdentifier, cPSuri qualifiers can be included using the syntax:</p> <pre><code>CPS.nnn=value\n</code></pre> <p>userNotice qualifiers can be set using the syntax:</p> <pre><code>userNotice.nnn=@notice\n</code></pre> <p>The value of the userNotice qualifier is specified in the relevant section. This section can include explicitText, organization and noticeNumbers options. explicitText and organization are text strings, noticeNumbers is a comma separated list of numbers. The organization and noticeNumbers options (if included) must BOTH be present. If you use the userNotice option with IE5 then you need the 'ia5org' option at the top level to modify the encoding: otherwise it will not be interpreted properly.</p> <p>Example:</p> <pre><code>certificatePolicies=ia5org,1.2.3.4,1.5.6.7.8,@polsect\n\n[polsect]\n\npolicyIdentifier = 1.3.5.8\nCPS.1=\"http://my.host.name/\"\nCPS.2=\"http://my.your.name/\"\nuserNotice.1=@notice\n\n[notice]\n\nexplicitText=\"Explicit Text Here\"\norganization=\"Organisation Name\"\nnoticeNumbers=1,2,3,4\n</code></pre> <p>The ia5org option changes the type of the organization field. In RFC2459 it can only be of type DisplayText. In RFC3280 IA5Strring is also permissible. Some software (for example some versions of MSIE) may require ia5org.</p>"},{"location":"man1/x509v3_config/#policy-constraints","title":"Policy Constraints","text":"<p>This is a multi-valued extension which consisting of the names requireExplicitPolicy or inhibitPolicyMapping and a non negative intger value. At least one component must be present.</p> <p>Example:</p> <pre><code>policyConstraints = requireExplicitPolicy:3\n</code></pre>"},{"location":"man1/x509v3_config/#inhibit-any-policy","title":"Inhibit Any Policy","text":"<p>This is a string extension whose value must be a non negative integer.</p> <p>Example:</p> <pre><code>inhibitAnyPolicy = 2\n</code></pre>"},{"location":"man1/x509v3_config/#name-constraints","title":"Name Constraints","text":"<p>The name constraints extension is a multi-valued extension. The name should begin with the word permitted or excluded followed by a ;. The rest of the name and the value follows the syntax of subjectAltName except email:copy is not supported and the IP form should consist of an IP addresses and  subnet mask separated by a /.</p> <p>Examples:</p> <pre><code>nameConstraints=permitted;IP:192.168.0.0/255.255.0.0\n\nnameConstraints=permitted;email:.somedomain.com\n\nnameConstraints=excluded;email:.com\n</code></pre>"},{"location":"man1/x509v3_config/#ocsp-no-check","title":"OCSP No Check","text":"<p>The OCSP No Check extension is a string extension but its value is ignored.</p> <p>Example:</p> <pre><code>noCheck = ignored\n</code></pre>"},{"location":"man1/x509v3_config/#deprecated-extensions","title":"DEPRECATED EXTENSIONS","text":"<p>The following extensions are non standard, Netscape specific and largely obsolete. Their use in new applications is discouraged.</p>"},{"location":"man1/x509v3_config/#netscape-string-extensions","title":"Netscape String extensions.","text":"<p>Netscape Comment (nsComment) is a string extension containing a comment which will be displayed when the certificate is viewed in some browsers.</p> <p>Example:</p> <pre><code>nsComment = \"Some Random Comment\"\n</code></pre> <p>Other supported extensions in this category are: nsBaseUrl, nsRevocationUrl, nsCaRevocationUrl, nsRenewalUrl, nsCaPolicyUrl and nsSslServerName.</p>"},{"location":"man1/x509v3_config/#netscape-certificate-type","title":"Netscape Certificate Type","text":"<p>This is a multi-valued extensions which consists of a list of flags to be included. It was used to indicate the purposes for which a certificate could be used. The basicConstraints, keyUsage and extended key usage extensions are now used instead.</p> <p>Acceptable values for nsCertType are: client, server, email, objsign, reserved, sslCA, emailCA, objCA.</p>"},{"location":"man1/x509v3_config/#arbitrary-extensions","title":"ARBITRARY EXTENSIONS","text":"<p>If an extension is not supported by the OpenSSL code then it must be encoded using the arbitrary extension format. It is also possible to use the arbitrary format for supported extensions. Extreme care should be taken to ensure that the data is formatted correctly for the given extension type.</p> <p>There are two ways to encode arbitrary extensions.</p> <p>The first way is to use the word ASN1 followed by the extension content using the same syntax as ASN1_generate_nconf(3). For example:</p> <pre><code>1.2.3.4=critical,ASN1:UTF8String:Some random data\n\n1.2.3.4=ASN1:SEQUENCE:seq_sect\n\n[seq_sect]\n\nfield1 = UTF8:field1\nfield2 = UTF8:field2\n</code></pre> <p>It is also possible to use the word DER to include the raw encoded data in any extension.</p> <pre><code>1.2.3.4=critical,DER:01:02:03:04\n1.2.3.4=DER:01020304\n</code></pre> <p>The value following DER is a hex dump of the DER encoding of the extension Any extension can be placed in this form to override the default behaviour. For example:</p> <pre><code>basicConstraints=critical,DER:00:01:02:03\n</code></pre>"},{"location":"man1/x509v3_config/#warning","title":"WARNING","text":"<p>There is no guarantee that a specific implementation will process a given extension. It may therefore be sometimes possible to use certificates for purposes prohibited by their extensions because a specific application does not recognize or honour the values of the relevant extensions.</p> <p>The DER and ASN1 options should be used with caution. It is possible to create totally invalid extensions if they are not used carefully.</p>"},{"location":"man1/x509v3_config/#notes","title":"NOTES","text":"<p>If an extension is multi-value and a field value must contain a comma the long form must be used otherwise the comma would be misinterpreted as a field separator. For example:</p> <pre><code>subjectAltName=URI:ldap://somehost.com/CN=foo,OU=bar\n</code></pre> <p>will produce an error but the equivalent form:</p> <pre><code>subjectAltName=@subject_alt_section\n\n[subject_alt_section]\nsubjectAltName=URI:ldap://somehost.com/CN=foo,OU=bar\n</code></pre> <p>is valid. </p> <p>Due to the behaviour of the OpenSSL conf library the same field name can only occur once in a section. This means that:</p> <pre><code>subjectAltName=@alt_section\n\n[alt_section]\n\nemail=steve@here\nemail=steve@there\n</code></pre> <p>will only recognize the last value. This can be worked around by using the form:</p> <pre><code>[alt_section]\n\nemail.1=steve@here\nemail.2=steve@there\n</code></pre>"},{"location":"man1/x509v3_config/#history","title":"HISTORY","text":"<p>The X509v3 extension code was first added to OpenSSL 0.9.2.</p> <p>Policy mappings, inhibit any policy and name constraints support was added in OpenSSL 0.9.8</p> <p>The directoryName and otherName option as well as the ASN1 option for arbitrary extensions was added in OpenSSL 0.9.8</p>"},{"location":"man1/x509v3_config/#see-also","title":"SEE ALSO","text":"<p>req(1), ca(1), x509(1), ASN1_generate_nconf(3)</p>"},{"location":"man3/ASN1_OBJECT_new/","title":"ASN1_OBJECT_new","text":""},{"location":"man3/ASN1_OBJECT_new/#name","title":"NAME","text":"<p>ASN1_OBJECT_new, ASN1_OBJECT_free, - object allocation functions</p>"},{"location":"man3/ASN1_OBJECT_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/asn1.h&gt;\n\nASN1_OBJECT *ASN1_OBJECT_new(void);\nvoid ASN1_OBJECT_free(ASN1_OBJECT *a);\n</code></pre>"},{"location":"man3/ASN1_OBJECT_new/#description","title":"DESCRIPTION","text":"<p>The ASN1_OBJECT allocation routines, allocate and free an ASN1_OBJECT structure, which represents an ASN1 OBJECT IDENTIFIER.</p> <p>ASN1_OBJECT_new() allocates and initializes a ASN1_OBJECT structure.</p> <p>ASN1_OBJECT_free() frees up the ASN1_OBJECT structure a.</p>"},{"location":"man3/ASN1_OBJECT_new/#notes","title":"NOTES","text":"<p>Although ASN1_OBJECT_new() allocates a new ASN1_OBJECT structure it is almost never used in applications. The ASN1 object utility functions such as OBJ_nid2obj() are used instead.</p>"},{"location":"man3/ASN1_OBJECT_new/#return-values","title":"RETURN VALUES","text":"<p>If the allocation fails, ASN1_OBJECT_new() returns NULL and sets an error code that can be obtained by ERR_get_error(3). Otherwise it returns a pointer to the newly allocated structure.</p> <p>ASN1_OBJECT_free() returns no value.</p>"},{"location":"man3/ASN1_OBJECT_new/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), d2i_ASN1_OBJECT(3)</p>"},{"location":"man3/ASN1_OBJECT_new/#history","title":"HISTORY","text":"<p>ASN1_OBJECT_new() and ASN1_OBJECT_free() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/ASN1_STRING_length/","title":"ASN1_STRING_length","text":""},{"location":"man3/ASN1_STRING_length/#name","title":"NAME","text":"<p>ASN1_STRING_dup, ASN1_STRING_cmp, ASN1_STRING_set, ASN1_STRING_length, ASN1_STRING_length_set, ASN1_STRING_type, ASN1_STRING_data, ASN1_STRING_to_UTF8 - ASN1_STRING utility functions</p>"},{"location":"man3/ASN1_STRING_length/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/asn1.h&gt;\n\nint ASN1_STRING_length(ASN1_STRING *x);\nunsigned char * ASN1_STRING_data(ASN1_STRING *x);\n\nASN1_STRING * ASN1_STRING_dup(ASN1_STRING *a);\n\nint ASN1_STRING_cmp(ASN1_STRING *a, ASN1_STRING *b);\n\nint ASN1_STRING_set(ASN1_STRING *str, const void *data, int len);\n\nint ASN1_STRING_type(ASN1_STRING *x);\n\nint ASN1_STRING_to_UTF8(unsigned char **out, ASN1_STRING *in);\n</code></pre>"},{"location":"man3/ASN1_STRING_length/#description","title":"DESCRIPTION","text":"<p>These functions allow an ASN1_STRING structure to be manipulated.</p> <p>ASN1_STRING_length() returns the length of the content of x.</p> <p>ASN1_STRING_data() returns an internal pointer to the data of x. Since this is an internal pointer it should not be freed or modified in any way.</p> <p>ASN1_STRING_dup() returns a copy of the structure a.</p> <p>ASN1_STRING_cmp() compares a and b returning 0 if the two are identical. The string types and content are compared.</p> <p>ASN1_STRING_set() sets the data of string str to the buffer data or length len. The supplied data is copied. If len is -1 then the length is determined by strlen(data).</p> <p>ASN1_STRING_type() returns the type of x, using standard constants such as V_ASN1_OCTET_STRING.</p> <p>ASN1_STRING_to_UTF8() converts the string in to UTF8 format, the converted data is allocated in a buffer in *out. The length of out is returned or a negative error code. The buffer *out should be free using OPENSSL_free().</p>"},{"location":"man3/ASN1_STRING_length/#notes","title":"NOTES","text":"<p>Almost all ASN1 types in OpenSSL are represented as an ASN1_STRING structure. Other types such as ASN1_OCTET_STRING are simply typedefed to ASN1_STRING and the functions call the ASN1_STRING equivalents. ASN1_STRING is also used for some CHOICE types which consist entirely of primitive string types such as DirectoryString and Time.</p> <p>These functions should not be used to examine or modify ASN1_INTEGER or ASN1_ENUMERATED types: the relevant INTEGER or ENUMERATED utility functions should be used instead.</p> <p>In general it cannot be assumed that the data returned by ASN1_STRING_data() is null terminated or does not contain embedded nulls. The actual format of the data will depend on the actual string type itself: for example for an IA5String the data will be ASCII, for a BMPString two bytes per character in big endian format, and for an UTF8String it will be in UTF8 format.</p> <p>Similar care should be take to ensure the data is in the correct format when calling ASN1_STRING_set().</p>"},{"location":"man3/ASN1_STRING_length/#return-values","title":"RETURN VALUES","text":""},{"location":"man3/ASN1_STRING_length/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3)</p>"},{"location":"man3/ASN1_STRING_length/#history","title":"HISTORY","text":""},{"location":"man3/ASN1_STRING_new/","title":"ASN1_STRING_new","text":""},{"location":"man3/ASN1_STRING_new/#name","title":"NAME","text":"<p>ASN1_STRING_new, ASN1_STRING_type_new, ASN1_STRING_free - ASN1_STRING allocation functions</p>"},{"location":"man3/ASN1_STRING_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/asn1.h&gt;\n\nASN1_STRING * ASN1_STRING_new(void);\nASN1_STRING * ASN1_STRING_type_new(int type);\nvoid ASN1_STRING_free(ASN1_STRING *a);\n</code></pre>"},{"location":"man3/ASN1_STRING_new/#description","title":"DESCRIPTION","text":"<p>ASN1_STRING_new() returns an allocated ASN1_STRING structure. Its type is undefined.</p> <p>ASN1_STRING_type_new() returns an allocated ASN1_STRING structure of type type.</p> <p>ASN1_STRING_free() frees up a.</p>"},{"location":"man3/ASN1_STRING_new/#notes","title":"NOTES","text":"<p>Other string types call the ASN1_STRING functions. For example ASN1_OCTET_STRING_new() calls ASN1_STRING_type(V_ASN1_OCTET_STRING).</p>"},{"location":"man3/ASN1_STRING_new/#return-values","title":"RETURN VALUES","text":"<p>ASN1_STRING_new() and ASN1_STRING_type_new() return a valid ASN1_STRING structure or NULL if an error occurred.</p> <p>ASN1_STRING_free() does not return a value.</p>"},{"location":"man3/ASN1_STRING_new/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3)</p>"},{"location":"man3/ASN1_STRING_new/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/ASN1_STRING_print_ex/","title":"ASN1_STRING_print_ex","text":""},{"location":"man3/ASN1_STRING_print_ex/#name","title":"NAME","text":"<p>ASN1_STRING_print_ex, ASN1_STRING_print_ex_fp, ASN1_STRING_print - ASN1_STRING output routines.</p>"},{"location":"man3/ASN1_STRING_print_ex/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/asn1.h&gt;\n\nint ASN1_STRING_print_ex(BIO *out, ASN1_STRING *str, unsigned long flags);\nint ASN1_STRING_print_ex_fp(FILE *fp, ASN1_STRING *str, unsigned long flags);\nint ASN1_STRING_print(BIO *out, ASN1_STRING *str);\n</code></pre>"},{"location":"man3/ASN1_STRING_print_ex/#description","title":"DESCRIPTION","text":"<p>These functions output an ASN1_STRING structure. ASN1_STRING is used to represent all the ASN1 string types.</p> <p>ASN1_STRING_print_ex() outputs str to out, the format is determined by the options flags. ASN1_STRING_print_ex_fp() is identical except it outputs to fp instead.</p> <p>ASN1_STRING_print() prints str to out but using a different format to ASN1_STRING_print_ex(). It replaces unprintable characters (other than CR, LF) with '.'.</p>"},{"location":"man3/ASN1_STRING_print_ex/#notes","title":"NOTES","text":"<p>ASN1_STRING_print() is a legacy function which should be avoided in new applications.</p> <p>Although there are a large number of options frequently ASN1_STRFLGS_RFC2253 is  suitable, or on UTF8 terminals ASN1_STRFLGS_RFC2253 &amp; ~ASN1_STRFLGS_ESC_MSB.</p> <p>The complete set of supported options for flags is listed below.</p> <p>Various characters can be escaped. If ASN1_STRFLGS_ESC_2253 is set the characters determined by RFC2253 are escaped. If ASN1_STRFLGS_ESC_CTRL is set control characters are escaped. If ASN1_STRFLGS_ESC_MSB is set characters with the MSB set are escaped: this option should not be used if the terminal correctly interprets UTF8 sequences.</p> <p>Escaping takes several forms.</p> <p>If the character being escaped is a 16 bit character then the form \"\\UXXXX\" is used using exactly four characters for the hex representation. If it is 32 bits then \"\\WXXXXXXXX\" is used using eight characters of its hex representation. These forms will only be used if UTF8 conversion is not set (see below).</p> <p>Printable characters are normally escaped using the backslash '\\' character. If ASN1_STRFLGS_ESC_QUOTE is set then the whole string is instead surrounded by double quote characters: this is arguably more readable than the backslash notation. Other characters use the \"\\XX\" using exactly two characters of the hex representation.</p> <p>If ASN1_STRFLGS_UTF8_CONVERT is set then characters are converted to UTF8 format first. If the terminal supports the display of UTF8 sequences then this option will correctly display multi byte characters.</p> <p>If ASN1_STRFLGS_IGNORE_TYPE is set then the string type is not interpreted at all: everything is assumed to be one byte per character. This is primarily for debugging purposes and can result in confusing output in multi character strings.</p> <p>If ASN1_STRFLGS_SHOW_TYPE is set then the string type itself is printed out before its value (for example \"BMPSTRING\"), this actually uses ASN1_tag2str().</p> <p>The content of a string instead of being interpreted can be \"dumped\": this just outputs the value of the string using the form #XXXX using hex format for each octet.</p> <p>If ASN1_STRFLGS_DUMP_ALL is set then any type is dumped.</p> <p>Normally non character string types (such as OCTET STRING) are assumed to be one byte per character, if ASN1_STRFLGS_DUMP_UNKNOWN is set then they will be dumped instead.</p> <p>When a type is dumped normally just the content octets are printed, if  ASN1_STRFLGS_DUMP_DER is set then the complete encoding is dumped instead (including tag and length octets).</p> <p>ASN1_STRFLGS_RFC2253 includes all the flags required by RFC2253. It is equivalent to:  ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB |  ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN ASN1_STRFLGS_DUMP_DER</p>"},{"location":"man3/ASN1_STRING_print_ex/#see-also","title":"SEE ALSO","text":"<p>X509_NAME_print_ex(3), ASN1_tag2str(3)</p>"},{"location":"man3/ASN1_STRING_print_ex/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/ASN1_TIME_set/","title":"ASN1_TIME_set","text":""},{"location":"man3/ASN1_TIME_set/#name","title":"NAME","text":"<p>ASN1_TIME_set, ASN1_TIME_adj, ASN1_TIME_check, ASN1_TIME_set_string, ASN1_TIME_print, ASN1_TIME_diff - ASN.1 Time functions.</p>"},{"location":"man3/ASN1_TIME_set/#synopsis","title":"SYNOPSIS","text":"<pre><code>ASN1_TIME *ASN1_TIME_set(ASN1_TIME *s, time_t t);\nASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s, time_t t,\n                         int offset_day, long offset_sec);\nint ASN1_TIME_set_string(ASN1_TIME *s, const char *str);\nint ASN1_TIME_check(const ASN1_TIME *t);\nint ASN1_TIME_print(BIO *b, const ASN1_TIME *s);\n\nint ASN1_TIME_diff(int *pday, int *psec,\n                   const ASN1_TIME *from, const ASN1_TIME *to);\n</code></pre>"},{"location":"man3/ASN1_TIME_set/#description","title":"DESCRIPTION","text":"<p>The function ASN1_TIME_set() sets the ASN1_TIME structure s to the time represented by the time_t value t. If s is NULL a new ASN1_TIME structure is allocated and returned.</p> <p>ASN1_TIME_adj() sets the ASN1_TIME structure s to the time represented by the time offset_day and offset_sec after the time_t value t. The values of offset_day or offset_sec can be negative to set a time before t. The offset_sec value can also exceed the number of seconds in a day. If s is NULL a new ASN1_TIME structure is allocated and returned.</p> <p>ASN1_TIME_set_string() sets ASN1_TIME structure s to the time represented by string str which must be in appropriate ASN.1 time format (for example YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ).</p> <p>ASN1_TIME_check() checks the syntax of ASN1_TIME structure s.</p> <p>ASN1_TIME_print() prints out the time s to BIO b in human readable format. It will be of the format MMM DD HH:MM:SS YYYY [GMT], for example \"Feb  3 00:55:52 2015 GMT\" it does not include a newline. If the time structure has invalid format it prints out \"Bad time value\" and returns an error.</p> <p>ASN1_TIME_diff() sets *pday and *psec to the time difference between from and to. If to represents a time later than from then one or both (depending on the time difference) of *pday and *psec will be positive. If to represents a time earlier than from then one or both of *pday and *psec will be negative. If to and from represent the same time then *pday and *psec will both be zero. If both *pday and *psec are non-zero they will always have the same sign. The value of *psec will always be less than the number of seconds in a day. If from or to is NULL the current time is used.</p>"},{"location":"man3/ASN1_TIME_set/#notes","title":"NOTES","text":"<p>The ASN1_TIME structure corresponds to the ASN.1 structure Time defined in RFC5280 et al. The time setting functions obey the rules outlined in RFC5280: if the date can be represented by UTCTime it is used, else GeneralizedTime is used.</p> <p>The ASN1_TIME structure is represented as an ASN1_STRING internally and can be freed up using ASN1_STRING_free().</p> <p>The ASN1_TIME structure can represent years from 0000 to 9999 but no attempt is made to correct ancient calendar changes (for example from Julian to Gregorian calendars).</p> <p>Some applications add offset times directly to a time_t value and pass the results to ASN1_TIME_set() (or equivalent). This can cause problems as the time_t value can overflow on some systems resulting in unexpected results. New applications should use ASN1_TIME_adj() instead and pass the offset value in the offset_sec and offset_day parameters instead of directly manipulating a time_t value.</p>"},{"location":"man3/ASN1_TIME_set/#bugs","title":"BUGS","text":"<p>ASN1_TIME_print() currently does not print out the time zone: it either prints out \"GMT\" or nothing. But all certificates complying with RFC5280 et al use GMT anyway.</p>"},{"location":"man3/ASN1_TIME_set/#examples","title":"EXAMPLES","text":"<p>Set a time structure to one hour after the current time and print it out:</p> <pre><code>#include &lt;time.h&gt;\n#include &lt;openssl/asn1.h&gt;\nASN1_TIME *tm;\ntime_t t;\nBIO *b;\nt = time(NULL);\ntm = ASN1_TIME_adj(NULL, t, 0, 60 * 60);\nb = BIO_new_fp(stdout, BIO_NOCLOSE);\nASN1_TIME_print(b, tm);\nASN1_STRING_free(tm);\nBIO_free(b);\n</code></pre> <p>Determine if one time is later or sooner than the current time:</p> <pre><code>int day, sec;\n\nif (!ASN1_TIME_diff(&amp;day, &amp;sec, NULL, to))\n       /* Invalid time format */\n\nif (day &gt; 0 || sec &gt; 0)\n  printf(\"Later\\n\");\nelse if (day &lt; 0 || sec &lt; 0)\n  printf(\"Sooner\\n\");\nelse\n  printf(\"Same\\n\");\n</code></pre>"},{"location":"man3/ASN1_TIME_set/#return-values","title":"RETURN VALUES","text":"<p>ASN1_TIME_set() and ASN1_TIME_adj() return a pointer to an ASN1_TIME structure or NULL if an error occurred.</p> <p>ASN1_TIME_set_string() returns 1 if the time value is successfully set and 0 otherwise.</p> <p>ASN1_TIME_check() returns 1 if the structure is syntactically correct and 0 otherwise.</p> <p>ASN1_TIME_print() returns 1 if the time is successfully printed out and 0 if an error occurred (I/O error or invalid time format).</p> <p>ASN1_TIME_diff() returns 1 for sucess and 0 for failure. It can fail if the pass ASN1_TIME structure has invalid syntax for example.</p>"},{"location":"man3/ASN1_generate_nconf/","title":"ASN1_generate_nconf","text":""},{"location":"man3/ASN1_generate_nconf/#name","title":"NAME","text":"<p>ASN1_generate_nconf, ASN1_generate_v3 - ASN1 generation functions</p>"},{"location":"man3/ASN1_generate_nconf/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/asn1.h&gt;\n\nASN1_TYPE *ASN1_generate_nconf(char *str, CONF *nconf);\nASN1_TYPE *ASN1_generate_v3(char *str, X509V3_CTX *cnf);\n</code></pre>"},{"location":"man3/ASN1_generate_nconf/#description","title":"DESCRIPTION","text":"<p>These functions generate the ASN1 encoding of a string in an ASN1_TYPE structure.</p> <p>str contains the string to encode nconf or cnf contains the optional configuration information where additional strings will be read from. nconf will typically come from a config file wherease cnf is obtained from an X509V3_CTX structure which will typically be used by X509 v3 certificate extension functions. cnf or nconf can be set to NULL if no additional configuration will be used.</p>"},{"location":"man3/ASN1_generate_nconf/#generation-string-format","title":"GENERATION STRING FORMAT","text":"<p>The actual data encoded is determined by the string str and the configuration information. The general format of the string is:</p> <ul> <li>[modifier,]type[:value]</li> </ul> <p>That is zero or more comma separated modifiers followed by a type followed by an optional colon and a value. The formats of type, value and modifier are explained below.</p>"},{"location":"man3/ASN1_generate_nconf/#supported-types","title":"SUPPORTED TYPES","text":"<p>The supported types are listed below. Unless otherwise specified only the ASCII format is permissible.</p> <ul> <li> <p>BOOLEAN, BOOL</p> <p>This encodes a boolean type. The value string is mandatory and should be TRUE or FALSE. Additionally TRUE, true, Y, y, YES, yes, FALSE, false, N, n, NO and no are acceptable. </p> </li> <li> <p>NULL</p> <p>Encode the NULL type, the value string must not be present.</p> </li> <li> <p>INTEGER, INT</p> <p>Encodes an ASN1 INTEGER type. The value string represents the value of the integer, it can be prefaced by a minus sign and is normally interpreted as a decimal value unless the prefix 0x is included.</p> </li> <li> <p>ENUMERATED, ENUM</p> <p>Encodes the ASN1 ENUMERATED type, it is otherwise identical to INTEGER.</p> </li> <li> <p>OBJECT, OID</p> <p>Encodes an ASN1 OBJECT IDENTIFIER, the value string can be a short name, a long name or numerical format.</p> </li> <li> <p>UTCTIME, UTC</p> <p>Encodes an ASN1 UTCTime structure, the value should be in the format YYMMDDHHMMSSZ. </p> </li> <li> <p>GENERALIZEDTIME, GENTIME</p> <p>Encodes an ASN1 GeneralizedTime structure, the value should be in the format YYYYMMDDHHMMSSZ. </p> </li> <li> <p>OCTETSTRING, OCT</p> <p>Encodes an ASN1 OCTET STRING. value represents the contents of this structure, the format strings ASCII and HEX can be used to specify the format of value.</p> </li> <li> <p>BITSTRING, BITSTR</p> <p>Encodes an ASN1 BIT STRING. value represents the contents of this structure, the format strings ASCII, HEX and BITLIST can be used to specify the format of value.</p> <p>If the format is anything other than BITLIST the number of unused bits is set to zero.</p> </li> <li> <p>UNIVERSALSTRING, UNIV, IA5, IA5STRING, UTF8, UTF8String, BMP, BMPSTRING, VISIBLESTRING, VISIBLE, PRINTABLESTRING, PRINTABLE, T61, T61STRING, TELETEXSTRING, GeneralString, NUMERICSTRING, NUMERIC</p> <p>These encode the corresponding string types. value represents the contents of this structure. The format can be ASCII or UTF8.</p> </li> <li> <p>SEQUENCE, SEQ, SET</p> <p>Formats the result as an ASN1 SEQUENCE or SET type. value should be a section name which will contain the contents. The field names in the section are ignored and the values are in the generated string format. If value is absent then an empty SEQUENCE will be encoded.</p> </li> </ul>"},{"location":"man3/ASN1_generate_nconf/#modifiers","title":"MODIFIERS","text":"<p>Modifiers affect the following structure, they can be used to add EXPLICIT or IMPLICIT tagging, add wrappers or to change the string format of the final type and value. The supported formats are documented below.</p> <ul> <li> <p>EXPLICIT, EXP</p> <p>Add an explicit tag to the following structure. This string should be followed by a colon and the tag value to use as a decimal value.</p> <p>By following the number with U, A, P or C UNIVERSAL, APPLICATION, PRIVATE or CONTEXT SPECIFIC tagging can be used, the default is CONTEXT SPECIFIC.</p> </li> <li> <p>IMPLICIT, IMP</p> <p>This is the same as EXPLICIT except IMPLICIT tagging is used instead.</p> </li> <li> <p>OCTWRAP, SEQWRAP, SETWRAP, BITWRAP</p> <p>The following structure is surrounded by an OCTET STRING, a SEQUENCE, a SET or a BIT STRING respectively. For a BIT STRING the number of unused bits is set to zero.</p> </li> <li> <p>FORMAT</p> <p>This specifies the format of the ultimate value. It should be followed by a colon and one of the strings ASCII, UTF8, HEX or BITLIST.</p> <p>If no format specifier is included then ASCII is used. If UTF8 is specified then the value string must be a valid UTF8 string. For HEX the output must be a set of hex digits. BITLIST (which is only valid for a BIT STRING) is a comma separated list of the indices of the set bits, all other bits are zero.</p> </li> </ul>"},{"location":"man3/ASN1_generate_nconf/#examples","title":"EXAMPLES","text":"<p>A simple IA5String:</p> <pre><code>IA5STRING:Hello World\n</code></pre> <p>An IA5String explicitly tagged:</p> <pre><code>EXPLICIT:0,IA5STRING:Hello World\n</code></pre> <p>An IA5String explicitly tagged using APPLICATION tagging:</p> <pre><code>EXPLICIT:0A,IA5STRING:Hello World\n</code></pre> <p>A BITSTRING with bits 1 and 5 set and all others zero:</p> <pre><code>FORMAT:BITLIST,BITSTRING:1,5\n</code></pre> <p>A more complex example using a config file to produce a SEQUENCE consiting of a BOOL an OID and a UTF8String:</p> <pre><code>asn1 = SEQUENCE:seq_section\n\n[seq_section]\n\nfield1 = BOOLEAN:TRUE\nfield2 = OID:commonName\nfield3 = UTF8:Third field\n</code></pre> <p>This example produces an RSAPrivateKey structure, this is the key contained in the file client.pem in all OpenSSL distributions (note: the field names such as 'coeff' are ignored and are present just for clarity):</p> <pre><code>asn1=SEQUENCE:private_key\n[private_key]\nversion=INTEGER:0\n\nn=INTEGER:0xBB6FE79432CC6EA2D8F970675A5A87BFBE1AFF0BE63E879F2AFFB93644\\\nD4D2C6D000430DEC66ABF47829E74B8C5108623A1C0EE8BE217B3AD8D36D5EB4FCA1D9\n\ne=INTEGER:0x010001\n\nd=INTEGER:0x6F05EAD2F27FFAEC84BEC360C4B928FD5F3A9865D0FCAAD291E2A52F4A\\\nF810DC6373278C006A0ABBA27DC8C63BF97F7E666E27C5284D7D3B1FFFE16B7A87B51D\n\np=INTEGER:0xF3929B9435608F8A22C208D86795271D54EBDFB09DDEF539AB083DA912\\\nD4BD57\n\nq=INTEGER:0xC50016F89DFF2561347ED1186A46E150E28BF2D0F539A1594BBD7FE467\\\n46EC4F\n\nexp1=INTEGER:0x9E7D4326C924AFC1DEA40B45650134966D6F9DFA3A7F9D698CD4ABEA\\\n9C0A39B9\n\nexp2=INTEGER:0xBA84003BB95355AFB7C50DF140C60513D0BA51D637272E355E397779\\\nE7B2458F\n\ncoeff=INTEGER:0x30B9E4F2AFA5AC679F920FC83F1F2DF1BAF1779CF989447FABC2F5\\\n628657053A\n</code></pre> <p>This example is the corresponding public key in a SubjectPublicKeyInfo structure:</p> <pre><code># Start with a SEQUENCE\nasn1=SEQUENCE:pubkeyinfo\n\n# pubkeyinfo contains an algorithm identifier and the public key wrapped\n# in a BIT STRING\n[pubkeyinfo]\nalgorithm=SEQUENCE:rsa_alg\npubkey=BITWRAP,SEQUENCE:rsapubkey\n\n# algorithm ID for RSA is just an OID and a NULL\n[rsa_alg]\nalgorithm=OID:rsaEncryption\nparameter=NULL\n\n# Actual public key: modulus and exponent\n[rsapubkey]\nn=INTEGER:0xBB6FE79432CC6EA2D8F970675A5A87BFBE1AFF0BE63E879F2AFFB93644\\\nD4D2C6D000430DEC66ABF47829E74B8C5108623A1C0EE8BE217B3AD8D36D5EB4FCA1D9\n\ne=INTEGER:0x010001\n</code></pre>"},{"location":"man3/ASN1_generate_nconf/#return-values","title":"RETURN VALUES","text":"<p>ASN1_generate_nconf() and ASN1_generate_v3() return the encoded data as an ASN1_TYPE structure or NULL if an error occurred.</p> <p>The error codes that can be obtained by ERR_get_error(3).</p>"},{"location":"man3/ASN1_generate_nconf/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3)</p>"},{"location":"man3/ASN1_generate_nconf/#history","title":"HISTORY","text":"<p>ASN1_generate_nconf() and ASN1_generate_v3() were added to OpenSSL 0.9.8</p>"},{"location":"man3/BIO_ctrl/","title":"BIO_ctrl","text":""},{"location":"man3/BIO_ctrl/#name","title":"NAME","text":"<p>BIO_ctrl, BIO_callback_ctrl, BIO_ptr_ctrl, BIO_int_ctrl, BIO_reset, BIO_seek, BIO_tell, BIO_flush, BIO_eof, BIO_set_close, BIO_get_close, BIO_pending, BIO_wpending, BIO_ctrl_pending, BIO_ctrl_wpending, BIO_get_info_callback, BIO_set_info_callback - BIO control operations</p>"},{"location":"man3/BIO_ctrl/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nlong BIO_ctrl(BIO *bp,int cmd,long larg,void *parg);\nlong BIO_callback_ctrl(BIO *b, int cmd, void (*fp)(struct bio_st *, int, const char *, int, long, long));\nchar * BIO_ptr_ctrl(BIO *bp,int cmd,long larg);\nlong BIO_int_ctrl(BIO *bp,int cmd,long larg,int iarg);\n\nint BIO_reset(BIO *b);\nint BIO_seek(BIO *b, int ofs);\nint BIO_tell(BIO *b);\nint BIO_flush(BIO *b);\nint BIO_eof(BIO *b);\nint BIO_set_close(BIO *b,long flag);\nint BIO_get_close(BIO *b);\nint BIO_pending(BIO *b);\nint BIO_wpending(BIO *b);\nsize_t BIO_ctrl_pending(BIO *b);\nsize_t BIO_ctrl_wpending(BIO *b);\n\nint BIO_get_info_callback(BIO *b,bio_info_cb **cbp);\nint BIO_set_info_callback(BIO *b,bio_info_cb *cb);\n\ntypedef void bio_info_cb(BIO *b, int oper, const char *ptr, int arg1, long arg2, long arg3);\n</code></pre>"},{"location":"man3/BIO_ctrl/#description","title":"DESCRIPTION","text":"<p>BIO_ctrl(), BIO_callback_ctrl(), BIO_ptr_ctrl() and BIO_int_ctrl() are BIO \"control\" operations taking arguments of various types. These functions are not normally called directly, various macros are used instead. The standard macros are described below, macros specific to a particular type of BIO are described in the specific BIOs manual page as well as any special features of the standard calls.</p> <p>BIO_reset() typically resets a BIO to some initial state, in the case of file related BIOs for example it rewinds the file pointer to the start of the file.</p> <p>BIO_seek() resets a file related BIO's (that is file descriptor and FILE BIOs) file position pointer to ofs bytes from start of file.</p> <p>BIO_tell() returns the current file position of a file related BIO.</p> <p>BIO_flush() normally writes out any internally buffered data, in some cases it is used to signal EOF and that no more data will be written.</p> <p>BIO_eof() returns 1 if the BIO has read EOF, the precise meaning of \"EOF\" varies according to the BIO type.</p> <p>BIO_set_close() sets the BIO b close flag to flag. flag can take the value BIO_CLOSE or BIO_NOCLOSE. Typically BIO_CLOSE is used in a source/sink BIO to indicate that the underlying I/O stream should be closed when the BIO is freed.</p> <p>BIO_get_close() returns the BIOs close flag.</p> <p>BIO_pending(), BIO_ctrl_pending(), BIO_wpending() and BIO_ctrl_wpending() return the number of pending characters in the BIOs read and write buffers. Not all BIOs support these calls. BIO_ctrl_pending() and BIO_ctrl_wpending() return a size_t type and are functions, BIO_pending() and BIO_wpending() are macros which call BIO_ctrl().</p>"},{"location":"man3/BIO_ctrl/#return-values","title":"RETURN VALUES","text":"<p>BIO_reset() normally returns 1 for success and 0 or -1 for failure. File BIOs are an exception, they return 0 for success and -1 for failure.</p> <p>BIO_seek() and BIO_tell() both return the current file position on success and -1 for failure, except file BIOs which for BIO_seek() always return 0 for success and -1 for failure.</p> <p>BIO_flush() returns 1 for success and 0 or -1 for failure.</p> <p>BIO_eof() returns 1 if EOF has been reached 0 otherwise.</p> <p>BIO_set_close() always returns 1.</p> <p>BIO_get_close() returns the close flag value: BIO_CLOSE or BIO_NOCLOSE.</p> <p>BIO_pending(), BIO_ctrl_pending(), BIO_wpending() and BIO_ctrl_wpending() return the amount of pending data.</p>"},{"location":"man3/BIO_ctrl/#notes","title":"NOTES","text":"<p>BIO_flush(), because it can write data may return 0 or -1 indicating that the call should be retried later in a similar manner to BIO_write().  The BIO_should_retry() call should be used and appropriate action taken is the call fails.</p> <p>The return values of BIO_pending() and BIO_wpending() may not reliably determine the amount of pending data in all cases. For example in the case of a file BIO some data may be available in the FILE structures internal buffers but it is not possible to determine this in a portably way. For other types of BIO they may not be supported.</p> <p>Filter BIOs if they do not internally handle a particular BIO_ctrl() operation usually pass the operation to the next BIO in the chain. This often means there is no need to locate the required BIO for a particular operation, it can be called on a chain and it will be automatically passed to the relevant BIO. However this can cause unexpected results: for example no current filter BIOs implement BIO_seek(), but this may still succeed if the chain ends in a FILE or file descriptor BIO.</p> <p>Source/sink BIOs return an 0 if they do not recognize the BIO_ctrl() operation.</p>"},{"location":"man3/BIO_ctrl/#bugs","title":"BUGS","text":"<p>Some of the return values are ambiguous and care should be taken. In particular a return value of 0 can be returned if an operation is not supported, if an error occurred, if EOF has not been reached and in the case of BIO_seek() on a file BIO for a successful operation. </p>"},{"location":"man3/BIO_ctrl/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_f_base64/","title":"BIO_f_base64","text":""},{"location":"man3/BIO_f_base64/#name","title":"NAME","text":"<p>BIO_f_base64 - base64 BIO filter</p>"},{"location":"man3/BIO_f_base64/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n#include &lt;openssl/evp.h&gt;\n\nBIO_METHOD *   BIO_f_base64(void);\n</code></pre>"},{"location":"man3/BIO_f_base64/#description","title":"DESCRIPTION","text":"<p>BIO_f_base64() returns the base64 BIO method. This is a filter BIO that base64 encodes any data written through it and decodes any data read through it.</p> <p>Base64 BIOs do not support BIO_gets() or BIO_puts(). </p> <p>BIO_flush() on a base64 BIO that is being written through is used to signal that no more data is to be encoded: this is used to flush the final block through the BIO.</p> <p>The flag BIO_FLAGS_BASE64_NO_NL can be set with BIO_set_flags() to encode the data all on one line or expect the data to be all on one line.</p>"},{"location":"man3/BIO_f_base64/#notes","title":"NOTES","text":"<p>Because of the format of base64 encoding the end of the encoded block cannot always be reliably determined.</p>"},{"location":"man3/BIO_f_base64/#return-values","title":"RETURN VALUES","text":"<p>BIO_f_base64() returns the base64 BIO method.</p>"},{"location":"man3/BIO_f_base64/#examples","title":"EXAMPLES","text":"<p>Base64 encode the string \"Hello World\\n\" and write the result to standard output:</p> <pre><code>BIO *bio, *b64;\nchar message[] = \"Hello World \\n\";\n\nb64 = BIO_new(BIO_f_base64());\nbio = BIO_new_fp(stdout, BIO_NOCLOSE);\nBIO_push(b64, bio);\nBIO_write(b64, message, strlen(message));\nBIO_flush(b64);\n\nBIO_free_all(b64);\n</code></pre> <p>Read Base64 encoded data from standard input and write the decoded data to standard output:</p> <pre><code>BIO *bio, *b64, *bio_out;\nchar inbuf[512];\nint inlen;\n\nb64 = BIO_new(BIO_f_base64());\nbio = BIO_new_fp(stdin, BIO_NOCLOSE);\nbio_out = BIO_new_fp(stdout, BIO_NOCLOSE);\nBIO_push(b64, bio);\nwhile((inlen = BIO_read(b64, inbuf, 512)) &gt; 0) \n       BIO_write(bio_out, inbuf, inlen);\n\nBIO_flush(bio_out);\nBIO_free_all(b64);\n</code></pre>"},{"location":"man3/BIO_f_base64/#bugs","title":"BUGS","text":"<p>The ambiguity of EOF in base64 encoded data can cause additional data following the base64 encoded block to be misinterpreted.</p> <p>There should be some way of specifying a test that the BIO can perform to reliably determine EOF (for example a MIME boundary).</p>"},{"location":"man3/BIO_f_base64/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_f_buffer/","title":"BIO_f_buffer","text":""},{"location":"man3/BIO_f_buffer/#name","title":"NAME","text":"<p>BIO_f_buffer - buffering BIO</p>"},{"location":"man3/BIO_f_buffer/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO_METHOD * BIO_f_buffer(void);\n\n#define BIO_get_buffer_num_lines(b)    BIO_ctrl(b,BIO_C_GET_BUFF_NUM_LINES,0,NULL)\n#define BIO_set_read_buffer_size(b,size) BIO_int_ctrl(b,BIO_C_SET_BUFF_SIZE,size,0)\n#define BIO_set_write_buffer_size(b,size) BIO_int_ctrl(b,BIO_C_SET_BUFF_SIZE,size,1)\n#define BIO_set_buffer_size(b,size)    BIO_ctrl(b,BIO_C_SET_BUFF_SIZE,size,NULL)\n#define BIO_set_buffer_read_data(b,buf,num) BIO_ctrl(b,BIO_C_SET_BUFF_READ_DATA,num,buf)\n</code></pre>"},{"location":"man3/BIO_f_buffer/#description","title":"DESCRIPTION","text":"<p>BIO_f_buffer() returns the buffering BIO method.</p> <p>Data written to a buffering BIO is buffered and periodically written to the next BIO in the chain. Data read from a buffering BIO comes from an internal buffer which is filled from the next BIO in the chain. Both BIO_gets() and BIO_puts() are supported.</p> <p>Calling BIO_reset() on a buffering BIO clears any buffered data.</p> <p>BIO_get_buffer_num_lines() returns the number of lines currently buffered.</p> <p>BIO_set_read_buffer_size(), BIO_set_write_buffer_size() and BIO_set_buffer_size() set the read, write or both read and write buffer sizes to size. The initial buffer size is DEFAULT_BUFFER_SIZE, currently 4096. Any attempt to reduce the buffer size below DEFAULT_BUFFER_SIZE is ignored. Any buffered data is cleared when the buffer is resized.</p> <p>BIO_set_buffer_read_data() clears the read buffer and fills it with num bytes of buf. If num is larger than the current buffer size the buffer is expanded.</p>"},{"location":"man3/BIO_f_buffer/#notes","title":"NOTES","text":"<p>Buffering BIOs implement BIO_gets() by using BIO_read() operations on the next BIO in the chain. By prepending a buffering BIO to a chain it is therefore possible to provide BIO_gets() functionality if the following BIOs do not support it (for example SSL BIOs).</p> <p>Data is only written to the next BIO in the chain when the write buffer fills or when BIO_flush() is called. It is therefore important to call BIO_flush() whenever any pending data should be written such as when removing a buffering BIO using BIO_pop(). BIO_flush() may need to be retried if the ultimate source/sink BIO is non blocking.</p>"},{"location":"man3/BIO_f_buffer/#return-values","title":"RETURN VALUES","text":"<p>BIO_f_buffer() returns the buffering BIO method.</p> <p>BIO_get_buffer_num_lines() returns the number of lines buffered (may be 0).</p> <p>BIO_set_read_buffer_size(), BIO_set_write_buffer_size() and BIO_set_buffer_size() return 1 if the buffer was successfully resized or 0 for failure.</p> <p>BIO_set_buffer_read_data() returns 1 if the data was set correctly or 0 if there was an error.</p>"},{"location":"man3/BIO_f_buffer/#see-also","title":"SEE ALSO","text":"<p>BIO(3), BIO_reset(3), BIO_flush(3), BIO_pop(3), BIO_ctrl(3), BIO_int_ctrl(3)</p>"},{"location":"man3/BIO_f_cipher/","title":"BIO_f_cipher","text":""},{"location":"man3/BIO_f_cipher/#name","title":"NAME","text":"<p>BIO_f_cipher, BIO_set_cipher, BIO_get_cipher_status, BIO_get_cipher_ctx - cipher BIO filter</p>"},{"location":"man3/BIO_f_cipher/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n#include &lt;openssl/evp.h&gt;\n\nBIO_METHOD *   BIO_f_cipher(void);\nvoid BIO_set_cipher(BIO *b,const EVP_CIPHER *cipher,\n               unsigned char *key, unsigned char *iv, int enc);\nint BIO_get_cipher_status(BIO *b)\nint BIO_get_cipher_ctx(BIO *b, EVP_CIPHER_CTX **pctx)\n</code></pre>"},{"location":"man3/BIO_f_cipher/#description","title":"DESCRIPTION","text":"<p>BIO_f_cipher() returns the cipher BIO method. This is a filter BIO that encrypts any data written through it, and decrypts any data read from it. It is a BIO wrapper for the cipher routines EVP_CipherInit(), EVP_CipherUpdate() and EVP_CipherFinal().</p> <p>Cipher BIOs do not support BIO_gets() or BIO_puts(). </p> <p>BIO_flush() on an encryption BIO that is being written through is used to signal that no more data is to be encrypted: this is used to flush and possibly pad the final block through the BIO.</p> <p>BIO_set_cipher() sets the cipher of BIO b to cipher using key key and IV iv. enc should be set to 1 for encryption and zero for decryption.</p> <p>When reading from an encryption BIO the final block is automatically decrypted and checked when EOF is detected. BIO_get_cipher_status() is a BIO_ctrl() macro which can be called to determine whether the decryption operation was successful.</p> <p>BIO_get_cipher_ctx() is a BIO_ctrl() macro which retrieves the internal BIO cipher context. The retrieved context can be used in conjunction with the standard cipher routines to set it up. This is useful when BIO_set_cipher() is not flexible enough for the applications needs.</p>"},{"location":"man3/BIO_f_cipher/#notes","title":"NOTES","text":"<p>When encrypting BIO_flush() must be called to flush the final block through the BIO. If it is not then the final block will fail a subsequent decrypt.</p> <p>When decrypting an error on the final block is signalled by a zero return value from the read operation. A successful decrypt followed by EOF will also return zero for the final read. BIO_get_cipher_status() should be called to determine if the decrypt was successful.</p> <p>As always, if BIO_gets() or BIO_puts() support is needed then it can be achieved by preceding the cipher BIO with a buffering BIO.</p>"},{"location":"man3/BIO_f_cipher/#return-values","title":"RETURN VALUES","text":"<p>BIO_f_cipher() returns the cipher BIO method.</p> <p>BIO_set_cipher() does not return a value.</p> <p>BIO_get_cipher_status() returns 1 for a successful decrypt and 0 for failure.</p> <p>BIO_get_cipher_ctx() currently always returns 1.</p>"},{"location":"man3/BIO_f_cipher/#examples","title":"EXAMPLES","text":"<p>TBA</p>"},{"location":"man3/BIO_f_cipher/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_f_md/","title":"BIO_f_md","text":""},{"location":"man3/BIO_f_md/#name","title":"NAME","text":"<p>BIO_f_md, BIO_set_md, BIO_get_md, BIO_get_md_ctx - message digest BIO filter</p>"},{"location":"man3/BIO_f_md/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n#include &lt;openssl/evp.h&gt;\n\nBIO_METHOD *   BIO_f_md(void);\nint BIO_set_md(BIO *b,EVP_MD *md);\nint BIO_get_md(BIO *b,EVP_MD **mdp);\nint BIO_get_md_ctx(BIO *b,EVP_MD_CTX **mdcp);\n</code></pre>"},{"location":"man3/BIO_f_md/#description","title":"DESCRIPTION","text":"<p>BIO_f_md() returns the message digest BIO method. This is a filter BIO that digests any data passed through it, it is a BIO wrapper for the digest routines EVP_DigestInit(), EVP_DigestUpdate() and EVP_DigestFinal().</p> <p>Any data written or read through a digest BIO using BIO_read() and BIO_write() is digested.</p> <p>BIO_gets(), if its size parameter is large enough finishes the digest calculation and returns the digest value. BIO_puts() is not supported.</p> <p>BIO_reset() reinitialises a digest BIO.</p> <p>BIO_set_md() sets the message digest of BIO b to md: this must be called to initialize a digest BIO before any data is passed through it. It is a BIO_ctrl() macro.</p> <p>BIO_get_md() places the a pointer to the digest BIOs digest method in mdp, it is a BIO_ctrl() macro.</p> <p>BIO_get_md_ctx() returns the digest BIOs context into mdcp.</p>"},{"location":"man3/BIO_f_md/#notes","title":"NOTES","text":"<p>The context returned by BIO_get_md_ctx() can be used in calls to EVP_DigestFinal() and also the signature routines EVP_SignFinal() and EVP_VerifyFinal().</p> <p>The context returned by BIO_get_md_ctx() is an internal context structure. Changes made to this context will affect the digest BIO itself and the context pointer will become invalid when the digest BIO is freed.</p> <p>After the digest has been retrieved from a digest BIO it must be reinitialized by calling BIO_reset(), or BIO_set_md() before any more data is passed through it.</p> <p>If an application needs to call BIO_gets() or BIO_puts() through a chain containing digest BIOs then this can be done by prepending a buffering BIO.</p> <p>Before OpenSSL 1.0.0 the call to BIO_get_md_ctx() would only work if the BIO had been initialized for example by calling BIO_set_md() ). In OpenSSL 1.0.0 and later the context is always returned and the BIO is state is set to initialized. This allows applications to initialize the context externally if the standard calls such as BIO_set_md() are not sufficiently flexible.</p>"},{"location":"man3/BIO_f_md/#return-values","title":"RETURN VALUES","text":"<p>BIO_f_md() returns the digest BIO method.</p> <p>BIO_set_md(), BIO_get_md() and BIO_md_ctx() return 1 for success and 0 for failure.</p>"},{"location":"man3/BIO_f_md/#examples","title":"EXAMPLES","text":"<p>The following example creates a BIO chain containing an SHA1 and MD5 digest BIO and passes the string \"Hello World\" through it. Error checking has been omitted for clarity.</p> <pre><code>BIO *bio, *mdtmp;\nchar message[] = \"Hello World\";\nbio = BIO_new(BIO_s_null());\nmdtmp = BIO_new(BIO_f_md());\nBIO_set_md(mdtmp, EVP_sha1());\n/* For BIO_push() we want to append the sink BIO and keep a note of\n * the start of the chain.\n */\nbio = BIO_push(mdtmp, bio);\nmdtmp = BIO_new(BIO_f_md());\nBIO_set_md(mdtmp, EVP_md5());\nbio = BIO_push(mdtmp, bio);\n/* Note: mdtmp can now be discarded */\nBIO_write(bio, message, strlen(message));\n</code></pre> <p>The next example digests data by reading through a chain instead:</p> <pre><code>BIO *bio, *mdtmp;\nchar buf[1024];\nint rdlen;\nbio = BIO_new_file(file, \"rb\");\nmdtmp = BIO_new(BIO_f_md());\nBIO_set_md(mdtmp, EVP_sha1());\nbio = BIO_push(mdtmp, bio);\nmdtmp = BIO_new(BIO_f_md());\nBIO_set_md(mdtmp, EVP_md5());\nbio = BIO_push(mdtmp, bio);\ndo {\n       rdlen = BIO_read(bio, buf, sizeof(buf));\n       /* Might want to do something with the data here */\n} while(rdlen &gt; 0);\n</code></pre> <p>This next example retrieves the message digests from a BIO chain and outputs them. This could be used with the examples above.</p> <pre><code>BIO *mdtmp;\nunsigned char mdbuf[EVP_MAX_MD_SIZE];\nint mdlen;\nint i;\nmdtmp = bio;   /* Assume bio has previously been set up */\ndo {\n       EVP_MD *md;\n       mdtmp = BIO_find_type(mdtmp, BIO_TYPE_MD);\n       if(!mdtmp) break;\n       BIO_get_md(mdtmp, &amp;md);\n       printf(\"%s digest\", OBJ_nid2sn(EVP_MD_type(md)));\n       mdlen = BIO_gets(mdtmp, mdbuf, EVP_MAX_MD_SIZE);\n       for(i = 0; i &lt; mdlen; i++) printf(\":%02X\", mdbuf[i]);\n       printf(\"\\n\");\n       mdtmp = BIO_next(mdtmp);\n} while(mdtmp);\n\nBIO_free_all(bio);\n</code></pre>"},{"location":"man3/BIO_f_md/#bugs","title":"BUGS","text":"<p>The lack of support for BIO_puts() and the non standard behaviour of BIO_gets() could be regarded as anomalous. It could be argued that BIO_gets() and BIO_puts() should be passed to the next BIO in the chain and digest the data passed through and that digests should be retrieved using a separate BIO_ctrl() call.</p>"},{"location":"man3/BIO_f_md/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_f_null/","title":"BIO_f_null","text":""},{"location":"man3/BIO_f_null/#name","title":"NAME","text":"<p>BIO_f_null - null filter</p>"},{"location":"man3/BIO_f_null/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO_METHOD *   BIO_f_null(void);\n</code></pre>"},{"location":"man3/BIO_f_null/#description","title":"DESCRIPTION","text":"<p>BIO_f_null() returns the null filter BIO method. This is a filter BIO that does nothing.</p> <p>All requests to a null filter BIO are passed through to the next BIO in the chain: this means that a BIO chain containing a null filter BIO behaves just as though the BIO was not there.</p>"},{"location":"man3/BIO_f_null/#notes","title":"NOTES","text":"<p>As may be apparent a null filter BIO is not particularly useful.</p>"},{"location":"man3/BIO_f_null/#return-values","title":"RETURN VALUES","text":"<p>BIO_f_null() returns the null filter BIO method.</p>"},{"location":"man3/BIO_f_null/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_f_ssl/","title":"BIO_f_ssl","text":""},{"location":"man3/BIO_f_ssl/#name","title":"NAME","text":"<p>BIO_f_ssl, BIO_set_ssl, BIO_get_ssl, BIO_set_ssl_mode, BIO_set_ssl_renegotiate_bytes, BIO_get_num_renegotiates, BIO_set_ssl_renegotiate_timeout, BIO_new_ssl, BIO_new_ssl_connect, BIO_new_buffer_ssl_connect, BIO_ssl_copy_session_id, BIO_ssl_shutdown - SSL BIO</p>"},{"location":"man3/BIO_f_ssl/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n#include &lt;openssl/ssl.h&gt;\n\nBIO_METHOD *BIO_f_ssl(void);\n\n#define BIO_set_ssl(b,ssl,c)   BIO_ctrl(b,BIO_C_SET_SSL,c,(char *)ssl)\n#define BIO_get_ssl(b,sslp)    BIO_ctrl(b,BIO_C_GET_SSL,0,(char *)sslp)\n#define BIO_set_ssl_mode(b,client)     BIO_ctrl(b,BIO_C_SSL_MODE,client,NULL)\n#define BIO_set_ssl_renegotiate_bytes(b,num) \\\n       BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_BYTES,num,NULL);\n#define BIO_set_ssl_renegotiate_timeout(b,seconds) \\\n       BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT,seconds,NULL);\n#define BIO_get_num_renegotiates(b) \\\n       BIO_ctrl(b,BIO_C_SET_SSL_NUM_RENEGOTIATES,0,NULL);\n\nBIO *BIO_new_ssl(SSL_CTX *ctx,int client);\nBIO *BIO_new_ssl_connect(SSL_CTX *ctx);\nBIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx);\nint BIO_ssl_copy_session_id(BIO *to,BIO *from);\nvoid BIO_ssl_shutdown(BIO *bio);\n\n#define BIO_do_handshake(b)    BIO_ctrl(b,BIO_C_DO_STATE_MACHINE,0,NULL)\n</code></pre>"},{"location":"man3/BIO_f_ssl/#description","title":"DESCRIPTION","text":"<p>BIO_f_ssl() returns the SSL BIO method. This is a filter BIO which is a wrapper round the OpenSSL SSL routines adding a BIO \"flavour\" to SSL I/O. </p> <p>I/O performed on an SSL BIO communicates using the SSL protocol with the SSLs read and write BIOs. If an SSL connection is not established then an attempt is made to establish one on the first I/O call.</p> <p>If a BIO is appended to an SSL BIO using BIO_push() it is automatically used as the SSL BIOs read and write BIOs.</p> <p>Calling BIO_reset() on an SSL BIO closes down any current SSL connection by calling SSL_shutdown(). BIO_reset() is then sent to the next BIO in the chain: this will typically disconnect the underlying transport. The SSL BIO is then reset to the initial accept or connect state.</p> <p>If the close flag is set when an SSL BIO is freed then the internal SSL structure is also freed using SSL_free().</p> <p>BIO_set_ssl() sets the internal SSL pointer of BIO b to ssl using the close flag c.</p> <p>BIO_get_ssl() retrieves the SSL pointer of BIO b, it can then be manipulated using the standard SSL library functions.</p> <p>BIO_set_ssl_mode() sets the SSL BIO mode to client. If client is 1 client mode is set. If client is 0 server mode is set.</p> <p>BIO_set_ssl_renegotiate_bytes() sets the renegotiate byte count to num. When set after every num bytes of I/O (read and write)  the SSL session is automatically renegotiated. num must be at least 512 bytes.</p> <p>BIO_set_ssl_renegotiate_timeout() sets the renegotiate timeout to seconds. When the renegotiate timeout elapses the session is automatically renegotiated.</p> <p>BIO_get_num_renegotiates() returns the total number of session renegotiations due to I/O or timeout.</p> <p>BIO_new_ssl() allocates an SSL BIO using SSL_CTX ctx and using client mode if client is non zero.</p> <p>BIO_new_ssl_connect() creates a new BIO chain consisting of an SSL BIO (using ctx) followed by a connect BIO.</p> <p>BIO_new_buffer_ssl_connect() creates a new BIO chain consisting of a buffering BIO, an SSL BIO (using ctx) and a connect BIO.</p> <p>BIO_ssl_copy_session_id() copies an SSL session id between  BIO chains from and to. It does this by locating the SSL BIOs in each chain and calling SSL_copy_session_id() on the internal SSL pointer.</p> <p>BIO_ssl_shutdown() closes down an SSL connection on BIO chain bio. It does this by locating the SSL BIO in the chain and calling SSL_shutdown() on its internal SSL pointer.</p> <p>BIO_do_handshake() attempts to complete an SSL handshake on the supplied BIO and establish the SSL connection. It returns 1 if the connection was established successfully. A zero or negative value is returned if the connection could not be established, the call BIO_should_retry() should be used for non blocking connect BIOs to determine if the call should be retried. If an SSL connection has already been established this call has no effect.</p>"},{"location":"man3/BIO_f_ssl/#notes","title":"NOTES","text":"<p>SSL BIOs are exceptional in that if the underlying transport is non blocking they can still request a retry in exceptional circumstances. Specifically this will happen if a session renegotiation takes place during a BIO_read() operation, one case where this happens is when step up occurs.</p> <p>In OpenSSL 0.9.6 and later the SSL flag SSL_AUTO_RETRY can be set to disable this behaviour. That is when this flag is set an SSL BIO using a blocking transport will never request a retry.</p> <p>Since unknown BIO_ctrl() operations are sent through filter BIOs the servers name and port can be set using BIO_set_host() on the BIO returned by BIO_new_ssl_connect() without having to locate the connect BIO first.</p> <p>Applications do not have to call BIO_do_handshake() but may wish to do so to separate the handshake process from other I/O processing.</p>"},{"location":"man3/BIO_f_ssl/#return-values","title":"RETURN VALUES","text":"<p>TBA</p>"},{"location":"man3/BIO_f_ssl/#example","title":"EXAMPLE","text":"<p>This SSL/TLS client example, attempts to retrieve a page from an SSL/TLS web server. The I/O routines are identical to those of the unencrypted example in BIO_s_connect(3).</p> <pre><code>BIO *sbio, *out;\nint len;\nchar tmpbuf[1024];\nSSL_CTX *ctx;\nSSL *ssl;\n\nERR_load_crypto_strings();\nERR_load_SSL_strings();\nOpenSSL_add_all_algorithms();\n\n/* We would seed the PRNG here if the platform didn't\n * do it automatically\n */\n\nctx = SSL_CTX_new(SSLv23_client_method());\n\n/* We'd normally set some stuff like the verify paths and\n * mode here because as things stand this will connect to\n * any server whose certificate is signed by any CA.\n */\n\nsbio = BIO_new_ssl_connect(ctx);\n\nBIO_get_ssl(sbio, &amp;ssl);\n\nif(!ssl) {\n  fprintf(stderr, \"Can't locate SSL pointer\\n\");\n  /* whatever ... */\n}\n\n/* Don't want any retries */\nSSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\n\n/* We might want to do other things with ssl here */\n\nBIO_set_conn_hostname(sbio, \"localhost:https\");\n\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\nif(BIO_do_connect(sbio) &lt;= 0) {\n       fprintf(stderr, \"Error connecting to server\\n\");\n       ERR_print_errors_fp(stderr);\n       /* whatever ... */\n}\n\nif(BIO_do_handshake(sbio) &lt;= 0) {\n       fprintf(stderr, \"Error establishing SSL connection\\n\");\n       ERR_print_errors_fp(stderr);\n       /* whatever ... */\n}\n\n/* Could examine ssl here to get connection info */\n\nBIO_puts(sbio, \"GET / HTTP/1.0\\n\\n\");\nfor(;;) {      \n       len = BIO_read(sbio, tmpbuf, 1024);\n       if(len &lt;= 0) break;\n       BIO_write(out, tmpbuf, len);\n}\nBIO_free_all(sbio);\nBIO_free(out);\n</code></pre> <p>Here is a simple server example. It makes use of a buffering BIO to allow lines to be read from the SSL BIO using BIO_gets. It creates a pseudo web page containing the actual request from a client and also echoes the request to standard output.</p> <pre><code>BIO *sbio, *bbio, *acpt, *out;\nint len;\nchar tmpbuf[1024];\nSSL_CTX *ctx;\nSSL *ssl;\n\nERR_load_crypto_strings();\nERR_load_SSL_strings();\nOpenSSL_add_all_algorithms();\n\n/* Might seed PRNG here */\n\nctx = SSL_CTX_new(SSLv23_server_method());\n\nif (!SSL_CTX_use_certificate_file(ctx,\"server.pem\",SSL_FILETYPE_PEM)\n       || !SSL_CTX_use_PrivateKey_file(ctx,\"server.pem\",SSL_FILETYPE_PEM)\n       || !SSL_CTX_check_private_key(ctx)) {\n\n       fprintf(stderr, \"Error setting up SSL_CTX\\n\");\n       ERR_print_errors_fp(stderr);\n       return 0;\n}\n\n/* Might do other things here like setting verify locations and\n * DH and/or RSA temporary key callbacks\n */\n\n/* New SSL BIO setup as server */\nsbio=BIO_new_ssl(ctx,0);\n\nBIO_get_ssl(sbio, &amp;ssl);\n\nif(!ssl) {\n  fprintf(stderr, \"Can't locate SSL pointer\\n\");\n  /* whatever ... */\n}\n\n/* Don't want any retries */\nSSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\n\n/* Create the buffering BIO */\n\nbbio = BIO_new(BIO_f_buffer());\n\n/* Add to chain */\nsbio = BIO_push(bbio, sbio);\n\nacpt=BIO_new_accept(\"4433\");\n\n/* By doing this when a new connection is established\n * we automatically have sbio inserted into it. The\n * BIO chain is now 'swallowed' by the accept BIO and\n * will be freed when the accept BIO is freed. \n */\n\nBIO_set_accept_bios(acpt,sbio);\n\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\n\n/* Setup accept BIO */\nif(BIO_do_accept(acpt) &lt;= 0) {\n       fprintf(stderr, \"Error setting up accept BIO\\n\");\n       ERR_print_errors_fp(stderr);\n       return 0;\n}\n\n/* Now wait for incoming connection */\nif(BIO_do_accept(acpt) &lt;= 0) {\n       fprintf(stderr, \"Error in connection\\n\");\n       ERR_print_errors_fp(stderr);\n       return 0;\n}\n\n/* We only want one connection so remove and free\n * accept BIO\n */\n\nsbio = BIO_pop(acpt);\n\nBIO_free_all(acpt);\n\nif(BIO_do_handshake(sbio) &lt;= 0) {\n       fprintf(stderr, \"Error in SSL handshake\\n\");\n       ERR_print_errors_fp(stderr);\n       return 0;\n}\n\nBIO_puts(sbio, \"HTTP/1.0 200 OK\\r\\nContent-type: text/plain\\r\\n\\r\\n\");\nBIO_puts(sbio, \"\\r\\nConnection Established\\r\\nRequest headers:\\r\\n\");\nBIO_puts(sbio, \"--------------------------------------------------\\r\\n\");\n\nfor(;;) {\n       len = BIO_gets(sbio, tmpbuf, 1024);\n       if(len &lt;= 0) break;\n       BIO_write(sbio, tmpbuf, len);\n       BIO_write(out, tmpbuf, len);\n       /* Look for blank line signifying end of headers*/\n       if((tmpbuf[0] == '\\r') || (tmpbuf[0] == '\\n')) break;\n}\n\nBIO_puts(sbio, \"--------------------------------------------------\\r\\n\");\nBIO_puts(sbio, \"\\r\\n\");\n\n/* Since there is a buffering BIO present we had better flush it */\nBIO_flush(sbio);\n\nBIO_free_all(sbio);\n</code></pre>"},{"location":"man3/BIO_f_ssl/#bugs","title":"BUGS","text":"<p>In OpenSSL versions before 1.0.0 the BIO_pop() call was handled incorrectly, the I/O BIO reference count was incorrectly incremented (instead of decremented) and dissociated with the SSL BIO even if the SSL BIO was not explicitly being popped (e.g. a pop higher up the chain). Applications which included workarounds for this bug (e.g. freeing BIOs more than once) should be modified to handle this fix or they may free up an already freed BIO.</p>"},{"location":"man3/BIO_f_ssl/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_find_type/","title":"BIO_find_type","text":""},{"location":"man3/BIO_find_type/#name","title":"NAME","text":"<p>BIO_find_type, BIO_next, BIO_method_type - BIO chain traversal</p>"},{"location":"man3/BIO_find_type/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO *  BIO_find_type(BIO *b,int bio_type);\nBIO *  BIO_next(BIO *b);\n\n#define BIO_method_type(b)             ((b)-&gt;method-&gt;type)\n\n#define BIO_TYPE_NONE          0\n#define BIO_TYPE_MEM           (1|0x0400)\n#define BIO_TYPE_FILE          (2|0x0400)\n\n#define BIO_TYPE_FD            (4|0x0400|0x0100)\n#define BIO_TYPE_SOCKET                (5|0x0400|0x0100)\n#define BIO_TYPE_NULL          (6|0x0400)\n#define BIO_TYPE_SSL           (7|0x0200)\n#define BIO_TYPE_MD            (8|0x0200)\n#define BIO_TYPE_BUFFER                (9|0x0200)\n#define BIO_TYPE_CIPHER                (10|0x0200)\n#define BIO_TYPE_BASE64                (11|0x0200)\n#define BIO_TYPE_CONNECT       (12|0x0400|0x0100)\n#define BIO_TYPE_ACCEPT                (13|0x0400|0x0100)\n#define BIO_TYPE_PROXY_CLIENT  (14|0x0200)\n#define BIO_TYPE_PROXY_SERVER  (15|0x0200)\n#define BIO_TYPE_NBIO_TEST     (16|0x0200)\n#define BIO_TYPE_NULL_FILTER   (17|0x0200)\n#define BIO_TYPE_BER           (18|0x0200)\n#define BIO_TYPE_BIO           (19|0x0400)\n\n#define BIO_TYPE_DESCRIPTOR    0x0100\n#define BIO_TYPE_FILTER                0x0200\n#define BIO_TYPE_SOURCE_SINK   0x0400\n</code></pre>"},{"location":"man3/BIO_find_type/#description","title":"DESCRIPTION","text":"<p>The BIO_find_type() searches for a BIO of a given type in a chain, starting at BIO b. If type is a specific type (such as BIO_TYPE_MEM) then a search is made for a BIO of that type. If type is a general type (such as BIO_TYPE_SOURCE_SINK) then the next matching BIO of the given general type is searched for. BIO_find_type() returns the next matching BIO or NULL if none is found.</p> <p>Note: not all the BIO_TYPE_* types above have corresponding BIO implementations.</p> <p>BIO_next() returns the next BIO in a chain. It can be used to traverse all BIOs in a chain or used in conjunction with BIO_find_type() to find all BIOs of a certain type.</p> <p>BIO_method_type() returns the type of a BIO.</p>"},{"location":"man3/BIO_find_type/#return-values","title":"RETURN VALUES","text":"<p>BIO_find_type() returns a matching BIO or NULL for no match.</p> <p>BIO_next() returns the next BIO in a chain.</p> <p>BIO_method_type() returns the type of the BIO b.</p>"},{"location":"man3/BIO_find_type/#notes","title":"NOTES","text":"<p>BIO_next() was added to OpenSSL 0.9.6 to provide a 'clean' way to traverse a BIO chain or find multiple matches using BIO_find_type(). Previous versions had to use:</p> <pre><code>next = bio-&gt;next_bio;\n</code></pre>"},{"location":"man3/BIO_find_type/#bugs","title":"BUGS","text":"<p>BIO_find_type() in OpenSSL 0.9.5a and earlier could not be safely passed a NULL pointer for the b argument.</p>"},{"location":"man3/BIO_find_type/#example","title":"EXAMPLE","text":"<p>Traverse a chain looking for digest BIOs:</p> <pre><code>BIO *btmp;\nbtmp = in_bio; /* in_bio is chain to search through */\n\ndo {\n       btmp = BIO_find_type(btmp, BIO_TYPE_MD);\n       if(btmp == NULL) break; /* Not found */\n       /* btmp is a digest BIO, do something with it ...*/\n       ...\n\n       btmp = BIO_next(btmp);\n} while(btmp);\n</code></pre>"},{"location":"man3/BIO_find_type/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_new/","title":"BIO_new","text":""},{"location":"man3/BIO_new/#name","title":"NAME","text":"<p>BIO_new, BIO_set, BIO_free, BIO_vfree, BIO_free_all - BIO allocation and freeing functions</p>"},{"location":"man3/BIO_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO *  BIO_new(BIO_METHOD *type);\nint    BIO_set(BIO *a,BIO_METHOD *type);\nint    BIO_free(BIO *a);\nvoid   BIO_vfree(BIO *a);\nvoid   BIO_free_all(BIO *a);\n</code></pre>"},{"location":"man3/BIO_new/#description","title":"DESCRIPTION","text":"<p>The BIO_new() function returns a new BIO using method type.</p> <p>BIO_set() sets the method of an already existing BIO.</p> <p>BIO_free() frees up a single BIO, BIO_vfree() also frees up a single BIO but it does not return a value. Calling BIO_free() may also have some effect on the underlying I/O structure, for example it may close the file being referred to under certain circumstances. For more details see the individual BIO_METHOD descriptions.</p> <p>BIO_free_all() frees up an entire BIO chain, it does not halt if an error occurs freeing up an individual BIO in the chain.</p>"},{"location":"man3/BIO_new/#return-values","title":"RETURN VALUES","text":"<p>BIO_new() returns a newly created BIO or NULL if the call fails.</p> <p>BIO_set(), BIO_free() return 1 for success and 0 for failure.</p> <p>BIO_free_all() and BIO_vfree() do not return values.</p>"},{"location":"man3/BIO_new/#notes","title":"NOTES","text":"<p>Some BIOs (such as memory BIOs) can be used immediately after calling BIO_new(). Others (such as file BIOs) need some additional initialization, and frequently a utility function exists to create and initialize such BIOs.</p> <p>If BIO_free() is called on a BIO chain it will only free one BIO resulting in a memory leak.</p> <p>Calling BIO_free_all() a single BIO has the same effect as calling BIO_free() on it other than the discarded return value.</p> <p>Normally the type argument is supplied by a function which returns a pointer to a BIO_METHOD. There is a naming convention for such functions: a source/sink BIO is normally called BIO_s_*() and a filter BIO BIO_f_*();</p>"},{"location":"man3/BIO_new/#example","title":"EXAMPLE","text":"<p>Create a memory BIO:</p> <pre><code>BIO *mem = BIO_new(BIO_s_mem());\n</code></pre>"},{"location":"man3/BIO_new/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_new_CMS/","title":"BIO_new_CMS","text":""},{"location":"man3/BIO_new_CMS/#name","title":"NAME","text":"<pre><code>BIO_new_CMS - CMS streaming filter BIO\n</code></pre>"},{"location":"man3/BIO_new_CMS/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nBIO *BIO_new_CMS(BIO *out, CMS_ContentInfo *cms);\n</code></pre>"},{"location":"man3/BIO_new_CMS/#description","title":"DESCRIPTION","text":"<p>BIO_new_CMS() returns a streaming filter BIO chain based on cms. The output of the filter is written to out. Any data written to the chain is automatically translated to a BER format CMS structure of the appropriate type.</p>"},{"location":"man3/BIO_new_CMS/#notes","title":"NOTES","text":"<p>The chain returned by this function behaves like a standard filter BIO. It supports non blocking I/O. Content is processed and streamed on the fly and not all held in memory at once: so it is possible to encode very large structures. After all content has been written through the chain BIO_flush() must be called to finalise the structure.</p> <p>The CMS_STREAM flag must be included in the corresponding flags parameter of the cms creation function.</p> <p>If an application wishes to write additional data to out BIOs should be removed from the chain using BIO_pop() and freed with BIO_free() until out is reached. If no additional data needs to be written BIO_free_all() can be called to free up the whole chain.</p> <p>Any content written through the filter is used verbatim: no canonical translation is performed.</p> <p>It is possible to chain multiple BIOs to, for example, create a triple wrapped signed, enveloped, signed structure. In this case it is the applications responsibility to set the inner content type of any outer CMS_ContentInfo structures.</p> <p>Large numbers of small writes through the chain should be avoided as this will produce an output consisting of lots of OCTET STRING structures. Prepending a BIO_f_buffer() buffering BIO will prevent this.</p>"},{"location":"man3/BIO_new_CMS/#bugs","title":"BUGS","text":"<p>There is currently no corresponding inverse BIO: i.e. one which can decode a CMS structure on the fly.</p>"},{"location":"man3/BIO_new_CMS/#return-values","title":"RETURN VALUES","text":"<p>BIO_new_CMS() returns a BIO chain when successful or NULL if an error occurred. The error can be obtained from ERR_get_error(3).</p>"},{"location":"man3/BIO_new_CMS/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_sign(3), CMS_encrypt(3)</p>"},{"location":"man3/BIO_new_CMS/#history","title":"HISTORY","text":"<p>BIO_new_CMS() was added to OpenSSL 1.0.0</p>"},{"location":"man3/BIO_push/","title":"BIO_push","text":""},{"location":"man3/BIO_push/#name","title":"NAME","text":"<p>BIO_push, BIO_pop - add and remove BIOs from a chain.</p>"},{"location":"man3/BIO_push/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO *  BIO_push(BIO *b,BIO *append);\nBIO *  BIO_pop(BIO *b);\n</code></pre>"},{"location":"man3/BIO_push/#description","title":"DESCRIPTION","text":"<p>The BIO_push() function appends the BIO append to b, it returns b.</p> <p>BIO_pop() removes the BIO b from a chain and returns the next BIO in the chain, or NULL if there is no next BIO. The removed BIO then becomes a single BIO with no association with the original chain, it can thus be freed or attached to a different chain.</p>"},{"location":"man3/BIO_push/#notes","title":"NOTES","text":"<p>The names of these functions are perhaps a little misleading. BIO_push() joins two BIO chains whereas BIO_pop() deletes a single BIO from a chain, the deleted BIO does not need to be at the end of a chain.</p> <p>The process of calling BIO_push() and BIO_pop() on a BIO may have additional consequences (a control call is made to the affected BIOs) any effects will be noted in the descriptions of individual BIOs.</p>"},{"location":"man3/BIO_push/#examples","title":"EXAMPLES","text":"<p>For these examples suppose md1 and md2 are digest BIOs, b64 is a base64 BIO and f is a file BIO.</p> <p>If the call:</p> <pre><code>BIO_push(b64, f);\n</code></pre> <p>is made then the new chain will be b64-f. After making the calls</p> <pre><code>BIO_push(md2, b64);\nBIO_push(md1, md2);\n</code></pre> <p>the new chain is md1-md2-b64-f. Data written to md1 will be digested by md1 and md2, base64 encoded and written to f.</p> <p>It should be noted that reading causes data to pass in the reverse direction, that is data is read from f, base64 decoded and digested by md1 and md2. If the call:</p> <pre><code>BIO_pop(md2);\n</code></pre> <p>The call will return b64 and the new chain will be md1-b64-f data can be written to md1 as before.</p>"},{"location":"man3/BIO_push/#return-values","title":"RETURN VALUES","text":"<p>BIO_push() returns the end of the chain, b.</p> <p>BIO_pop() returns the next BIO in the chain, or NULL if there is no next BIO.</p>"},{"location":"man3/BIO_push/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_read/","title":"BIO_read","text":""},{"location":"man3/BIO_read/#name","title":"NAME","text":"<p>BIO_read, BIO_write, BIO_gets, BIO_puts - BIO I/O functions</p>"},{"location":"man3/BIO_read/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nint    BIO_read(BIO *b, void *buf, int len);\nint    BIO_gets(BIO *b, char *buf, int size);\nint    BIO_write(BIO *b, const void *buf, int len);\nint    BIO_puts(BIO *b, const char *buf);\n</code></pre>"},{"location":"man3/BIO_read/#description","title":"DESCRIPTION","text":"<p>BIO_read() attempts to read len bytes from BIO b and places the data in buf.</p> <p>BIO_gets() performs the BIOs \"gets\" operation and places the data in buf. Usually this operation will attempt to read a line of data from the BIO of maximum length len. There are exceptions to this however, for example BIO_gets() on a digest BIO will calculate and return the digest and other BIOs may not support BIO_gets() at all.</p> <p>BIO_write() attempts to write len bytes from buf to BIO b.</p> <p>BIO_puts() attempts to write a null terminated string buf to BIO b.</p>"},{"location":"man3/BIO_read/#return-values","title":"RETURN VALUES","text":"<p>All these functions return either the amount of data successfully read or written (if the return value is positive) or that no data was successfully read or written if the result is 0 or -1. If the return value is -2 then the operation is not implemented in the specific BIO type.</p>"},{"location":"man3/BIO_read/#notes","title":"NOTES","text":"<p>A 0 or -1 return is not necessarily an indication of an error. In particular when the source/sink is non-blocking or of a certain type it may merely be an indication that no data is currently available and that the application should retry the operation later.</p> <p>One technique sometimes used with blocking sockets is to use a system call (such as select(), poll() or equivalent) to determine when data is available and then call read() to read the data. The equivalent with BIOs (that is call select() on the underlying I/O structure and then call BIO_read() to read the data) should not be used because a single call to BIO_read() can cause several reads (and writes in the case of SSL BIOs) on the underlying I/O structure and may block as a result. Instead select() (or equivalent) should be combined with non blocking I/O so successive reads will request a retry instead of blocking.</p> <p>See BIO_should_retry(3) for details of how to determine the cause of a retry and other I/O issues.</p> <p>If the BIO_gets() function is not supported by a BIO then it possible to work around this by adding a buffering BIO BIO_f_buffer(3) to the chain.</p>"},{"location":"man3/BIO_read/#see-also","title":"SEE ALSO","text":"<p>BIO_should_retry(3)</p> <p>TBA</p>"},{"location":"man3/BIO_s_accept/","title":"BIO_s_accept","text":""},{"location":"man3/BIO_s_accept/#name","title":"NAME","text":"<p>BIO_s_accept, BIO_set_accept_port, BIO_get_accept_port, BIO_new_accept, BIO_set_nbio_accept, BIO_set_accept_bios, BIO_set_bind_mode, BIO_get_bind_mode, BIO_do_accept - accept BIO</p>"},{"location":"man3/BIO_s_accept/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO_METHOD *BIO_s_accept(void);\n\nlong BIO_set_accept_port(BIO *b, char *name);\nchar *BIO_get_accept_port(BIO *b);\n\nBIO *BIO_new_accept(char *host_port);\n\nlong BIO_set_nbio_accept(BIO *b, int n);\nlong BIO_set_accept_bios(BIO *b, char *bio);\n\nlong BIO_set_bind_mode(BIO *b, long mode);\nlong BIO_get_bind_mode(BIO *b, long dummy);\n\n#define BIO_BIND_NORMAL                0\n#define BIO_BIND_REUSEADDR_IF_UNUSED   1\n#define BIO_BIND_REUSEADDR             2\n\nint BIO_do_accept(BIO *b);\n</code></pre>"},{"location":"man3/BIO_s_accept/#description","title":"DESCRIPTION","text":"<p>BIO_s_accept() returns the accept BIO method. This is a wrapper round the platform's TCP/IP socket accept routines.</p> <p>Using accept BIOs, TCP/IP connections can be accepted and data transferred using only BIO routines. In this way any platform specific operations are hidden by the BIO abstraction.</p> <p>Read and write operations on an accept BIO will perform I/O on the underlying connection. If no connection is established and the port (see below) is set up properly then the BIO waits for an incoming connection.</p> <p>Accept BIOs support BIO_puts() but not BIO_gets().</p> <p>If the close flag is set on an accept BIO then any active connection on that chain is shutdown and the socket closed when the BIO is freed.</p> <p>Calling BIO_reset() on a accept BIO will close any active connection and reset the BIO into a state where it awaits another incoming connection.</p> <p>BIO_get_fd() and BIO_set_fd() can be called to retrieve or set the accept socket. See BIO_s_fd(3)</p> <p>BIO_set_accept_port() uses the string name to set the accept port. The port is represented as a string of the form \"host:port\", where \"host\" is the interface to use and \"port\" is the port. The host can be can be \"*\" which is interpreted as meaning any interface; \"port\" has the same syntax as the port specified in BIO_set_conn_port() for connect BIOs, that is it can be a numerical port string or a string to lookup using getservbyname() and a string table.</p> <p>BIO_new_accept() combines BIO_new() and BIO_set_accept_port() into a single call: that is it creates a new accept BIO with port host_port.</p> <p>BIO_set_nbio_accept() sets the accept socket to blocking mode (the default) if n is 0 or non blocking mode if n is 1.</p> <p>BIO_set_accept_bios() can be used to set a chain of BIOs which will be duplicated and prepended to the chain when an incoming connection is received. This is useful if, for example, a  buffering or SSL BIO is required for each connection. The chain of BIOs must not be freed after this call, they will be automatically freed when the accept BIO is freed.</p> <p>BIO_set_bind_mode() and BIO_get_bind_mode() set and retrieve the current bind mode. If BIO_BIND_NORMAL (the default) is set then another socket cannot be bound to the same port. If BIO_BIND_REUSEADDR is set then other sockets can bind to the same port. If BIO_BIND_REUSEADDR_IF_UNUSED is set then and attempt is first made to use BIO_BIN_NORMAL, if this fails and the port is not in use then a second attempt is made using BIO_BIND_REUSEADDR.</p> <p>BIO_do_accept() serves two functions. When it is first called, after the accept BIO has been setup, it will attempt to create the accept socket and bind an address to it. Second and subsequent calls to BIO_do_accept() will await an incoming connection, or request a retry in non blocking mode.</p>"},{"location":"man3/BIO_s_accept/#notes","title":"NOTES","text":"<p>When an accept BIO is at the end of a chain it will await an incoming connection before processing I/O calls. When an accept BIO is not at then end of a chain it passes I/O calls to the next BIO in the chain.</p> <p>When a connection is established a new socket BIO is created for the connection and appended to the chain. That is the chain is now accept-&gt;socket. This effectively means that attempting I/O on an initial accept socket will await an incoming connection then perform I/O on it.</p> <p>If any additional BIOs have been set using BIO_set_accept_bios() then they are placed between the socket and the accept BIO, that is the chain will be accept-&gt;otherbios-&gt;socket.</p> <p>If a server wishes to process multiple connections (as is normally the case) then the accept BIO must be made available for further incoming connections. This can be done by waiting for a connection and then calling:</p> <pre><code>connection = BIO_pop(accept);\n</code></pre> <p>After this call connection will contain a BIO for the recently established connection and accept will now be a single BIO again which can be used to await further incoming connections. If no further connections will be accepted the accept can be freed using BIO_free().</p> <p>If only a single connection will be processed it is possible to perform I/O using the accept BIO itself. This is often undesirable however because the accept BIO will still accept additional incoming connections. This can be resolved by using BIO_pop() (see above) and freeing up the accept BIO after the initial connection.</p> <p>If the underlying accept socket is non-blocking and BIO_do_accept() is called to await an incoming connection it is possible for BIO_should_io_special() with the reason BIO_RR_ACCEPT. If this happens then it is an indication that an accept attempt would block: the application should take appropriate action to wait until the underlying socket has accepted a connection and retry the call.</p> <p>BIO_set_accept_port(), BIO_get_accept_port(), BIO_set_nbio_accept(), BIO_set_accept_bios(), BIO_set_bind_mode(), BIO_get_bind_mode() and BIO_do_accept() are macros.</p>"},{"location":"man3/BIO_s_accept/#return-values","title":"RETURN VALUES","text":"<p>TBA</p>"},{"location":"man3/BIO_s_accept/#example","title":"EXAMPLE","text":"<p>This example accepts two connections on port 4444, sends messages down each and finally closes both down.</p> <pre><code>BIO *abio, *cbio, *cbio2;\nERR_load_crypto_strings();\nabio = BIO_new_accept(\"4444\");\n\n/* First call to BIO_accept() sets up accept BIO */\nif(BIO_do_accept(abio) &lt;= 0) {\n       fprintf(stderr, \"Error setting up accept\\n\");\n       ERR_print_errors_fp(stderr);\n       exit(0);                \n}\n\n/* Wait for incoming connection */\nif(BIO_do_accept(abio) &lt;= 0) {\n       fprintf(stderr, \"Error accepting connection\\n\");\n       ERR_print_errors_fp(stderr);\n       exit(0);                \n}\nfprintf(stderr, \"Connection 1 established\\n\");\n/* Retrieve BIO for connection */\ncbio = BIO_pop(abio);\nBIO_puts(cbio, \"Connection 1: Sending out Data on initial connection\\n\");\nfprintf(stderr, \"Sent out data on connection 1\\n\");\n/* Wait for another connection */\nif(BIO_do_accept(abio) &lt;= 0) {\n       fprintf(stderr, \"Error accepting connection\\n\");\n       ERR_print_errors_fp(stderr);\n       exit(0);                \n}\nfprintf(stderr, \"Connection 2 established\\n\");\n/* Close accept BIO to refuse further connections */\ncbio2 = BIO_pop(abio);\nBIO_free(abio);\nBIO_puts(cbio2, \"Connection 2: Sending out Data on second\\n\");\nfprintf(stderr, \"Sent out data on connection 2\\n\");\n\nBIO_puts(cbio, \"Connection 1: Second connection established\\n\");\n/* Close the two established connections */\nBIO_free(cbio);\nBIO_free(cbio2);\n</code></pre>"},{"location":"man3/BIO_s_accept/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_s_bio/","title":"BIO_s_bio","text":""},{"location":"man3/BIO_s_bio/#name","title":"NAME","text":"<p>BIO_s_bio, BIO_make_bio_pair, BIO_destroy_bio_pair, BIO_shutdown_wr,  BIO_set_write_buf_size, BIO_get_write_buf_size, BIO_new_bio_pair, BIO_get_write_guarantee, BIO_ctrl_get_write_guarantee, BIO_get_read_request, BIO_ctrl_get_read_request, BIO_ctrl_reset_read_request - BIO pair BIO</p>"},{"location":"man3/BIO_s_bio/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO_METHOD *BIO_s_bio(void);\n\n#define BIO_make_bio_pair(b1,b2)   (int)BIO_ctrl(b1,BIO_C_MAKE_BIO_PAIR,0,b2)\n#define BIO_destroy_bio_pair(b)    (int)BIO_ctrl(b,BIO_C_DESTROY_BIO_PAIR,0,NULL)\n\n#define BIO_shutdown_wr(b) (int)BIO_ctrl(b, BIO_C_SHUTDOWN_WR, 0, NULL)\n\n#define BIO_set_write_buf_size(b,size) (int)BIO_ctrl(b,BIO_C_SET_WRITE_BUF_SIZE,size,NULL)\n#define BIO_get_write_buf_size(b,size) (size_t)BIO_ctrl(b,BIO_C_GET_WRITE_BUF_SIZE,size,NULL)\n\nint BIO_new_bio_pair(BIO **bio1, size_t writebuf1, BIO **bio2, size_t writebuf2);\n\n#define BIO_get_write_guarantee(b) (int)BIO_ctrl(b,BIO_C_GET_WRITE_GUARANTEE,0,NULL)\nsize_t BIO_ctrl_get_write_guarantee(BIO *b);\n\n#define BIO_get_read_request(b)    (int)BIO_ctrl(b,BIO_C_GET_READ_REQUEST,0,NULL)\nsize_t BIO_ctrl_get_read_request(BIO *b);\n\nint BIO_ctrl_reset_read_request(BIO *b);\n</code></pre>"},{"location":"man3/BIO_s_bio/#description","title":"DESCRIPTION","text":"<p>BIO_s_bio() returns the method for a BIO pair. A BIO pair is a pair of source/sink BIOs where data written to either half of the pair is buffered and can be read from the other half. Both halves must usually by handled by the same application thread since no locking is done on the internal data structures.</p> <p>Since BIO chains typically end in a source/sink BIO it is possible to make this one half of a BIO pair and have all the data processed by the chain under application control.</p> <p>One typical use of BIO pairs is to place TLS/SSL I/O under application control, this can be used when the application wishes to use a non standard transport for TLS/SSL or the normal socket routines are inappropriate.</p> <p>Calls to BIO_read() will read data from the buffer or request a retry if no data is available.</p> <p>Calls to BIO_write() will place data in the buffer or request a retry if the buffer is full.</p> <p>The standard calls BIO_ctrl_pending() and BIO_ctrl_wpending() can be used to determine the amount of pending data in the read or write buffer.</p> <p>BIO_reset() clears any data in the write buffer.</p> <p>BIO_make_bio_pair() joins two separate BIOs into a connected pair.</p> <p>BIO_destroy_pair() destroys the association between two connected BIOs. Freeing up any half of the pair will automatically destroy the association.</p> <p>BIO_shutdown_wr() is used to close down a BIO b. After this call no further writes on BIO b are allowed (they will return an error). Reads on the other half of the pair will return any pending data or EOF when all pending data has been read. </p> <p>BIO_set_write_buf_size() sets the write buffer size of BIO b to size. If the size is not initialized a default value is used. This is currently 17K, sufficient for a maximum size TLS record.</p> <p>BIO_get_write_buf_size() returns the size of the write buffer.</p> <p>BIO_new_bio_pair() combines the calls to BIO_new(), BIO_make_bio_pair() and BIO_set_write_buf_size() to create a connected pair of BIOs bio1, bio2 with write buffer sizes writebuf1 and writebuf2. If either size is zero then the default size is used.  BIO_new_bio_pair() does not check whether bio1 or bio2 do point to some other BIO, the values are overwritten, BIO_free() is not called.</p> <p>BIO_get_write_guarantee() and BIO_ctrl_get_write_guarantee() return the maximum length of data that can be currently written to the BIO. Writes larger than this value will return a value from BIO_write() less than the amount requested or if the buffer is full request a retry. BIO_ctrl_get_write_guarantee() is a function whereas BIO_get_write_guarantee() is a macro.</p> <p>BIO_get_read_request() and BIO_ctrl_get_read_request() return the amount of data requested, or the buffer size if it is less, if the last read attempt at the other half of the BIO pair failed due to an empty buffer.  This can be used to determine how much data should be written to the BIO so the next read will succeed: this is most useful in TLS/SSL applications where the amount of data read is usually meaningful rather than just a buffer size. After a successful read this call will return zero.  It also will return zero once new data has been written satisfying the read request or part of it. Note that BIO_get_read_request() never returns an amount larger than that returned by BIO_get_write_guarantee().</p> <p>BIO_ctrl_reset_read_request() can also be used to reset the value returned by BIO_get_read_request() to zero.</p>"},{"location":"man3/BIO_s_bio/#notes","title":"NOTES","text":"<p>Both halves of a BIO pair should be freed. That is even if one half is implicit freed due to a BIO_free_all() or SSL_free() call the other half needs to be freed.</p> <p>When used in bidirectional applications (such as TLS/SSL) care should be taken to flush any data in the write buffer. This can be done by calling BIO_pending() on the other half of the pair and, if any data is pending, reading it and sending it to the underlying transport. This must be done before any normal processing (such as calling select() ) due to a request and BIO_should_read() being true.</p> <p>To see why this is important consider a case where a request is sent using BIO_write() and a response read with BIO_read(), this can occur during an TLS/SSL handshake for example. BIO_write() will succeed and place data in the write buffer. BIO_read() will initially fail and BIO_should_read() will be true. If the application then waits for data to be available on the underlying transport before flushing the write buffer it will never succeed because the request was never sent!</p> <p>BIO_eof() is true if no data is in the peer BIO and the peer BIO has been shutdown.</p>"},{"location":"man3/BIO_s_bio/#return-values","title":"RETURN VALUES","text":"<p>BIO_new_bio_pair() returns 1 on success, with the new BIOs available in bio1 and bio2, or 0 on failure, with NULL pointers stored into the locations for bio1 and bio2. Check the error stack for more information.</p> <p>[XXXXX: More return values need to be added here]</p>"},{"location":"man3/BIO_s_bio/#example","title":"EXAMPLE","text":"<p>The BIO pair can be used to have full control over the network access of an application. The application can call select() on the socket as required without having to go through the SSL-interface.</p> <pre><code>BIO *internal_bio, *network_bio;\n...\nBIO_new_bio_pair(internal_bio, 0, network_bio, 0);\nSSL_set_bio(ssl, internal_bio, internal_bio);\nSSL_operations();\n...\n\napplication |   TLS-engine\n   |        |\n   +----------&gt; SSL_operations()\n            |     /\\    ||\n            |     ||    \\/\n            |   BIO-pair (internal_bio)\n   +----------&lt; BIO-pair (network_bio)\n   |        |\n socket     |\n\n ...\n SSL_free(ssl);                /* implicitly frees internal_bio */\n BIO_free(network_bio);\n ...\n</code></pre> <p>As the BIO pair will only buffer the data and never directly access the connection, it behaves non-blocking and will return as soon as the write buffer is full or the read buffer is drained. Then the application has to flush the write buffer and/or fill the read buffer.</p> <p>Use the BIO_ctrl_pending(), to find out whether data is buffered in the BIO and must be transfered to the network. Use BIO_ctrl_get_read_request() to find out, how many bytes must be written into the buffer before the SSL_operation() can successfully be continued.</p>"},{"location":"man3/BIO_s_bio/#warning","title":"WARNING","text":"<p>As the data is buffered, SSL_operation() may return with a ERROR_SSL_WANT_READ condition, but there is still data in the write buffer. An application must not rely on the error value of SSL_operation() but must assure that the write buffer is always flushed first. Otherwise a deadlock may occur as the peer might be waiting for the data before being able to continue.</p>"},{"location":"man3/BIO_s_bio/#see-also","title":"SEE ALSO","text":"<p>SSL_set_bio(3), ssl(3), bio(3), BIO_should_retry(3), BIO_read(3)</p>"},{"location":"man3/BIO_s_connect/","title":"BIO_s_connect","text":""},{"location":"man3/BIO_s_connect/#name","title":"NAME","text":"<p>BIO_s_connect, BIO_new_connect, BIO_set_conn_hostname, BIO_set_conn_port, BIO_set_conn_ip, BIO_set_conn_int_port, BIO_get_conn_hostname, BIO_get_conn_port, BIO_get_conn_ip, BIO_get_conn_int_port, BIO_set_nbio, BIO_do_connect - connect BIO</p>"},{"location":"man3/BIO_s_connect/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO_METHOD * BIO_s_connect(void);\n\nBIO *BIO_new_connect(char *name);\n\nlong BIO_set_conn_hostname(BIO *b, char *name);\nlong BIO_set_conn_port(BIO *b, char *port);\nlong BIO_set_conn_ip(BIO *b, char *ip);\nlong BIO_set_conn_int_port(BIO *b, char *port);\nchar *BIO_get_conn_hostname(BIO *b);\nchar *BIO_get_conn_port(BIO *b);\nchar *BIO_get_conn_ip(BIO *b);\nlong BIO_get_conn_int_port(BIO *b);\n\nlong BIO_set_nbio(BIO *b, long n);\n\nint BIO_do_connect(BIO *b);\n</code></pre>"},{"location":"man3/BIO_s_connect/#description","title":"DESCRIPTION","text":"<p>BIO_s_connect() returns the connect BIO method. This is a wrapper round the platform's TCP/IP socket connection routines.</p> <p>Using connect BIOs, TCP/IP connections can be made and data transferred using only BIO routines. In this way any platform specific operations are hidden by the BIO abstraction.</p> <p>Read and write operations on a connect BIO will perform I/O on the underlying connection. If no connection is established and the port and hostname (see below) is set up properly then a connection is established first.</p> <p>Connect BIOs support BIO_puts() but not BIO_gets().</p> <p>If the close flag is set on a connect BIO then any active connection is shutdown and the socket closed when the BIO is freed.</p> <p>Calling BIO_reset() on a connect BIO will close any active connection and reset the BIO into a state where it can connect to the same host again.</p> <p>BIO_get_fd() places the underlying socket in c if it is not NULL, it also returns the socket . If c is not NULL it should be of type (int *).</p> <p>BIO_set_conn_hostname() uses the string name to set the hostname. The hostname can be an IP address. The hostname can also include the port in the form hostname:port . It is also acceptable to use the form \"hostname/any/other/path\" or \"hostname:port/any/other/path\".</p> <p>BIO_set_conn_port() sets the port to port. port can be the numerical form or a string such as \"http\". A string will be looked up first using getservbyname() on the host platform but if that fails a standard table of port names will be used. Currently the list is http, telnet, socks, https, ssl, ftp, gopher and wais.</p> <p>BIO_set_conn_ip() sets the IP address to ip using binary form, that is four bytes specifying the IP address in big-endian form.</p> <p>BIO_set_conn_int_port() sets the port using port. port should be of type (int *).</p> <p>BIO_get_conn_hostname() returns the hostname of the connect BIO or NULL if the BIO is initialized but no hostname is set. This return value is an internal pointer which should not be modified.</p> <p>BIO_get_conn_port() returns the port as a string.</p> <p>BIO_get_conn_ip() returns the IP address in binary form.</p> <p>BIO_get_conn_int_port() returns the port as an int.</p> <p>BIO_set_nbio() sets the non blocking I/O flag to n. If n is zero then blocking I/O is set. If n is 1 then non blocking I/O is set. Blocking I/O is the default. The call to BIO_set_nbio() should be made before the connection is established because  non blocking I/O is set during the connect process.</p> <p>BIO_new_connect() combines BIO_new() and BIO_set_conn_hostname() into a single call: that is it creates a new connect BIO with name.</p> <p>BIO_do_connect() attempts to connect the supplied BIO. It returns 1 if the connection was established successfully. A zero or negative value is returned if the connection could not be established, the call BIO_should_retry() should be used for non blocking connect BIOs to determine if the call should be retried.</p>"},{"location":"man3/BIO_s_connect/#notes","title":"NOTES","text":"<p>If blocking I/O is set then a non positive return value from any I/O call is caused by an error condition, although a zero return will normally mean that the connection was closed.</p> <p>If the port name is supplied as part of the host name then this will override any value set with BIO_set_conn_port(). This may be undesirable if the application does not wish to allow connection to arbitrary ports. This can be avoided by checking for the presence of the ':' character in the passed hostname and either indicating an error or truncating the string at that point.</p> <p>The values returned by BIO_get_conn_hostname(), BIO_get_conn_port(), BIO_get_conn_ip() and BIO_get_conn_int_port() are updated when a connection attempt is made. Before any connection attempt the values returned are those set by the application itself.</p> <p>Applications do not have to call BIO_do_connect() but may wish to do so to separate the connection process from other I/O processing.</p> <p>If non blocking I/O is set then retries will be requested as appropriate.</p> <p>It addition to BIO_should_read() and BIO_should_write() it is also possible for BIO_should_io_special() to be true during the initial connection process with the reason BIO_RR_CONNECT. If this is returned then this is an indication that a connection attempt would block, the application should then take appropriate action to wait until the underlying socket has connected and retry the call.</p> <p>BIO_set_conn_hostname(), BIO_set_conn_port(), BIO_set_conn_ip(), BIO_set_conn_int_port(), BIO_get_conn_hostname(), BIO_get_conn_port(), BIO_get_conn_ip(), BIO_get_conn_int_port(), BIO_set_nbio() and BIO_do_connect() are macros.</p>"},{"location":"man3/BIO_s_connect/#return-values","title":"RETURN VALUES","text":"<p>BIO_s_connect() returns the connect BIO method.</p> <p>BIO_get_fd() returns the socket or -1 if the BIO has not been initialized.</p> <p>BIO_set_conn_hostname(), BIO_set_conn_port(), BIO_set_conn_ip() and BIO_set_conn_int_port() always return 1.</p> <p>BIO_get_conn_hostname() returns the connected hostname or NULL is none was set.</p> <p>BIO_get_conn_port() returns a string representing the connected port or NULL if not set.</p> <p>BIO_get_conn_ip() returns a pointer to the connected IP address in binary form or all zeros if not set.</p> <p>BIO_get_conn_int_port() returns the connected port or 0 if none was set.</p> <p>BIO_set_nbio() always returns 1.</p> <p>BIO_do_connect() returns 1 if the connection was successfully established and 0 or -1 if the connection failed.</p>"},{"location":"man3/BIO_s_connect/#example","title":"EXAMPLE","text":"<p>This is example connects to a webserver on the local host and attempts to retrieve a page and copy the result to standard output.</p> <pre><code>BIO *cbio, *out;\nint len;\nchar tmpbuf[1024];\nERR_load_crypto_strings();\ncbio = BIO_new_connect(\"localhost:http\");\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\nif(BIO_do_connect(cbio) &lt;= 0) {\n       fprintf(stderr, \"Error connecting to server\\n\");\n       ERR_print_errors_fp(stderr);\n       /* whatever ... */\n       }\nBIO_puts(cbio, \"GET / HTTP/1.0\\n\\n\");\nfor(;;) {      \n       len = BIO_read(cbio, tmpbuf, 1024);\n       if(len &lt;= 0) break;\n       BIO_write(out, tmpbuf, len);\n}\nBIO_free(cbio);\nBIO_free(out);\n</code></pre>"},{"location":"man3/BIO_s_connect/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_s_fd/","title":"BIO_s_fd","text":""},{"location":"man3/BIO_s_fd/#name","title":"NAME","text":"<p>BIO_s_fd, BIO_set_fd, BIO_get_fd, BIO_new_fd - file descriptor BIO</p>"},{"location":"man3/BIO_s_fd/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO_METHOD *   BIO_s_fd(void);\n\n#define BIO_set_fd(b,fd,c)     BIO_int_ctrl(b,BIO_C_SET_FD,c,fd)\n#define BIO_get_fd(b,c)        BIO_ctrl(b,BIO_C_GET_FD,0,(char *)c)\n\nBIO *BIO_new_fd(int fd, int close_flag);\n</code></pre>"},{"location":"man3/BIO_s_fd/#description","title":"DESCRIPTION","text":"<p>BIO_s_fd() returns the file descriptor BIO method. This is a wrapper round the platforms file descriptor routines such as read() and write().</p> <p>BIO_read() and BIO_write() read or write the underlying descriptor. BIO_puts() is supported but BIO_gets() is not.</p> <p>If the close flag is set then then close() is called on the underlying file descriptor when the BIO is freed.</p> <p>BIO_reset() attempts to change the file pointer to the start of file using lseek(fd, 0, 0).</p> <p>BIO_seek() sets the file pointer to position ofs from start of file using lseek(fd, ofs, 0).</p> <p>BIO_tell() returns the current file position by calling lseek(fd, 0, 1).</p> <p>BIO_set_fd() sets the file descriptor of BIO b to fd and the close flag to c.</p> <p>BIO_get_fd() places the file descriptor in c if it is not NULL, it also returns the file descriptor. If c is not NULL it should be of type (int *).</p> <p>BIO_new_fd() returns a file descriptor BIO using fd and close_flag.</p>"},{"location":"man3/BIO_s_fd/#notes","title":"NOTES","text":"<p>The behaviour of BIO_read() and BIO_write() depends on the behavior of the platforms read() and write() calls on the descriptor. If the underlying  file descriptor is in a non blocking mode then the BIO will behave in the manner described in the BIO_read(3) and BIO_should_retry(3) manual pages.</p> <p>File descriptor BIOs should not be used for socket I/O. Use socket BIOs instead.</p>"},{"location":"man3/BIO_s_fd/#return-values","title":"RETURN VALUES","text":"<p>BIO_s_fd() returns the file descriptor BIO method.</p> <p>BIO_reset() returns zero for success and -1 if an error occurred. BIO_seek() and BIO_tell() return the current file position or -1 if an error occurred. These values reflect the underlying lseek() behaviour.</p> <p>BIO_set_fd() always returns 1.</p> <p>BIO_get_fd() returns the file descriptor or -1 if the BIO has not been initialized.</p> <p>BIO_new_fd() returns the newly allocated BIO or NULL is an error occurred.</p>"},{"location":"man3/BIO_s_fd/#example","title":"EXAMPLE","text":"<p>This is a file descriptor BIO version of \"Hello World\":</p> <pre><code>BIO *out;\nout = BIO_new_fd(fileno(stdout), BIO_NOCLOSE);\nBIO_printf(out, \"Hello World\\n\");\nBIO_free(out);\n</code></pre>"},{"location":"man3/BIO_s_fd/#see-also","title":"SEE ALSO","text":"<p>BIO_seek(3), BIO_tell(3), BIO_reset(3), BIO_read(3), BIO_write(3), BIO_puts(3), BIO_gets(3), BIO_printf(3), BIO_set_close(3), BIO_get_close(3)</p>"},{"location":"man3/BIO_s_file/","title":"BIO_s_file","text":""},{"location":"man3/BIO_s_file/#name","title":"NAME","text":"<p>BIO_s_file, BIO_new_file, BIO_new_fp, BIO_set_fp, BIO_get_fp, BIO_read_filename, BIO_write_filename, BIO_append_filename, BIO_rw_filename - FILE bio</p>"},{"location":"man3/BIO_s_file/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO_METHOD *   BIO_s_file(void);\nBIO *BIO_new_file(const char *filename, const char *mode);\nBIO *BIO_new_fp(FILE *stream, int flags);\n\nBIO_set_fp(BIO *b,FILE *fp, int flags);\nBIO_get_fp(BIO *b,FILE **fpp);\n\nint BIO_read_filename(BIO *b, char *name)\nint BIO_write_filename(BIO *b, char *name)\nint BIO_append_filename(BIO *b, char *name)\nint BIO_rw_filename(BIO *b, char *name)\n</code></pre>"},{"location":"man3/BIO_s_file/#description","title":"DESCRIPTION","text":"<p>BIO_s_file() returns the BIO file method. As its name implies it is a wrapper round the stdio FILE structure and it is a source/sink BIO.</p> <p>Calls to BIO_read() and BIO_write() read and write data to the underlying stream. BIO_gets() and BIO_puts() are supported on file BIOs.</p> <p>BIO_flush() on a file BIO calls the fflush() function on the wrapped stream.</p> <p>BIO_reset() attempts to change the file pointer to the start of file using fseek(stream, 0, 0).</p> <p>BIO_seek() sets the file pointer to position ofs from start of file using fseek(stream, ofs, 0).</p> <p>BIO_eof() calls feof().</p> <p>Setting the BIO_CLOSE flag calls fclose() on the stream when the BIO is freed.</p> <p>BIO_new_file() creates a new file BIO with mode mode the meaning of mode is the same as the stdio function fopen(). The BIO_CLOSE flag is set on the returned BIO.</p> <p>BIO_new_fp() creates a file BIO wrapping stream. Flags can be: BIO_CLOSE, BIO_NOCLOSE (the close flag) BIO_FP_TEXT (sets the underlying stream to text mode, default is binary: this only has any effect under Win32).</p> <p>BIO_set_fp() set the fp of a file BIO to fp. flags has the same meaning as in BIO_new_fp(), it is a macro.</p> <p>BIO_get_fp() retrieves the fp of a file BIO, it is a macro.</p> <p>BIO_seek() is a macro that sets the position pointer to offset bytes from the start of file.</p> <p>BIO_tell() returns the value of the position pointer.</p> <p>BIO_read_filename(), BIO_write_filename(), BIO_append_filename() and BIO_rw_filename() set the file BIO b to use file name for reading, writing, append or read write respectively.</p>"},{"location":"man3/BIO_s_file/#notes","title":"NOTES","text":"<p>When wrapping stdout, stdin or stderr the underlying stream should not normally be closed so the BIO_NOCLOSE flag should be set.</p> <p>Because the file BIO calls the underlying stdio functions any quirks in stdio behaviour will be mirrored by the corresponding BIO.</p> <p>On Windows BIO_new_files reserves for the filename argument to be UTF-8 encoded. In other words if you have to make it work in multi- lingual environment, encode file names in UTF-8.</p>"},{"location":"man3/BIO_s_file/#examples","title":"EXAMPLES","text":"<p>File BIO \"hello world\":</p> <pre><code>BIO *bio_out;\nbio_out = BIO_new_fp(stdout, BIO_NOCLOSE);\nBIO_printf(bio_out, \"Hello World\\n\");\n</code></pre> <p>Alternative technique:</p> <pre><code>BIO *bio_out;\nbio_out = BIO_new(BIO_s_file());\nif(bio_out == NULL) /* Error ... */\nif(!BIO_set_fp(bio_out, stdout, BIO_NOCLOSE)) /* Error ... */\nBIO_printf(bio_out, \"Hello World\\n\");\n</code></pre> <p>Write to a file:</p> <pre><code>BIO *out;\nout = BIO_new_file(\"filename.txt\", \"w\");\nif(!out) /* Error occurred */\nBIO_printf(out, \"Hello World\\n\");\nBIO_free(out);\n</code></pre> <p>Alternative technique:</p> <pre><code>BIO *out;\nout = BIO_new(BIO_s_file());\nif(out == NULL) /* Error ... */\nif(!BIO_write_filename(out, \"filename.txt\")) /* Error ... */\nBIO_printf(out, \"Hello World\\n\");\nBIO_free(out);\n</code></pre>"},{"location":"man3/BIO_s_file/#return-values","title":"RETURN VALUES","text":"<p>BIO_s_file() returns the file BIO method.</p> <p>BIO_new_file() and BIO_new_fp() return a file BIO or NULL if an error occurred.</p> <p>BIO_set_fp() and BIO_get_fp() return 1 for success or 0 for failure (although the current implementation never return 0).</p> <p>BIO_seek() returns the same value as the underlying fseek() function: 0 for success or -1 for failure.</p> <p>BIO_tell() returns the current file position.</p> <p>BIO_read_filename(), BIO_write_filename(),  BIO_append_filename() and BIO_rw_filename() return 1 for success or 0 for failure.</p>"},{"location":"man3/BIO_s_file/#bugs","title":"BUGS","text":"<p>BIO_reset() and BIO_seek() are implemented using fseek() on the underlying stream. The return value for fseek() is 0 for success or -1 if an error occurred this differs from other types of BIO which will typically return 1 for success and a non positive value if an error occurred.</p>"},{"location":"man3/BIO_s_file/#see-also","title":"SEE ALSO","text":"<p>BIO_seek(3), BIO_tell(3), BIO_reset(3), BIO_flush(3), BIO_read(3), BIO_write(3), BIO_puts(3), BIO_gets(3), BIO_printf(3), BIO_set_close(3), BIO_get_close(3)</p>"},{"location":"man3/BIO_s_mem/","title":"BIO_s_mem","text":""},{"location":"man3/BIO_s_mem/#name","title":"NAME","text":"<p>BIO_s_mem, BIO_set_mem_eof_return, BIO_get_mem_data, BIO_set_mem_buf, BIO_get_mem_ptr, BIO_new_mem_buf - memory BIO</p>"},{"location":"man3/BIO_s_mem/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO_METHOD *   BIO_s_mem(void);\n\nBIO_set_mem_eof_return(BIO *b,int v)\nlong BIO_get_mem_data(BIO *b, char **pp)\nBIO_set_mem_buf(BIO *b,BUF_MEM *bm,int c)\nBIO_get_mem_ptr(BIO *b,BUF_MEM **pp)\n\nBIO *BIO_new_mem_buf(const void *buf, int len);\n</code></pre>"},{"location":"man3/BIO_s_mem/#description","title":"DESCRIPTION","text":"<p>BIO_s_mem() return the memory BIO method function. </p> <p>A memory BIO is a source/sink BIO which uses memory for its I/O. Data written to a memory BIO is stored in a BUF_MEM structure which is extended as appropriate to accommodate the stored data.</p> <p>Any data written to a memory BIO can be recalled by reading from it. Unless the memory BIO is read only any data read from it is deleted from the BIO.</p> <p>Memory BIOs support BIO_gets() and BIO_puts().</p> <p>If the BIO_CLOSE flag is set when a memory BIO is freed then the underlying BUF_MEM structure is also freed.</p> <p>Calling BIO_reset() on a read write memory BIO clears any data in it. On a read only BIO it restores the BIO to its original state and the read only data can be read again.</p> <p>BIO_eof() is true if no data is in the BIO.</p> <p>BIO_ctrl_pending() returns the number of bytes currently stored.</p> <p>BIO_set_mem_eof_return() sets the behaviour of memory BIO b when it is empty. If the v is zero then an empty memory BIO will return EOF (that is it will return zero and BIO_should_retry(b) will be false. If v is non zero then it will return v when it is empty and it will set the read retry flag (that is BIO_read_retry(b) is true). To avoid ambiguity with a normal positive return value v should be set to a negative value, typically -1.</p> <p>BIO_get_mem_data() sets *pp to a pointer to the start of the memory BIOs data and returns the total amount of data available. It is implemented as a macro.</p> <p>BIO_set_mem_buf() sets the internal BUF_MEM structure to bm and sets the close flag to c, that is c should be either BIO_CLOSE or BIO_NOCLOSE. It is a macro.</p> <p>BIO_get_mem_ptr() places the underlying BUF_MEM structure in *pp. It is a macro.</p> <p>BIO_new_mem_buf() creates a memory BIO using len bytes of data at buf, if len is -1 then the buf is assumed to be nul terminated and its length is determined by strlen. The BIO is set to a read only state and as a result cannot be written to. This is useful when some data needs to be made available from a static area of memory in the form of a BIO. The supplied data is read directly from the supplied buffer: it is not copied first, so the supplied area of memory must be unchanged until the BIO is freed.</p>"},{"location":"man3/BIO_s_mem/#notes","title":"NOTES","text":"<p>Writes to memory BIOs will always succeed if memory is available: that is their size can grow indefinitely.</p> <p>Every read from a read write memory BIO will remove the data just read with an internal copy operation, if a BIO contains a lot of data and it is read in small chunks the operation can be very slow. The use of a read only memory BIO avoids this problem. If the BIO must be read write then adding a buffering BIO to the chain will speed up the process.</p>"},{"location":"man3/BIO_s_mem/#bugs","title":"BUGS","text":"<p>There should be an option to set the maximum size of a memory BIO.</p> <p>There should be a way to \"rewind\" a read write BIO without destroying its contents.</p> <p>The copying operation should not occur after every small read of a large BIO to improve efficiency.</p>"},{"location":"man3/BIO_s_mem/#example","title":"EXAMPLE","text":"<p>Create a memory BIO and write some data to it:</p> <pre><code>BIO *mem = BIO_new(BIO_s_mem());\nBIO_puts(mem, \"Hello World\\n\");\n</code></pre> <p>Create a read only memory BIO:</p> <pre><code>char data[] = \"Hello World\";\nBIO *mem;\nmem = BIO_new_mem_buf(data, -1);\n</code></pre> <p>Extract the BUF_MEM structure from a memory BIO and then free up the BIO:</p> <pre><code>BUF_MEM *bptr;\nBIO_get_mem_ptr(mem, &amp;bptr);\nBIO_set_close(mem, BIO_NOCLOSE); /* So BIO_free() leaves BUF_MEM alone */\nBIO_free(mem);\n</code></pre>"},{"location":"man3/BIO_s_mem/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_s_null/","title":"BIO_s_null","text":""},{"location":"man3/BIO_s_null/#name","title":"NAME","text":"<p>BIO_s_null - null data sink</p>"},{"location":"man3/BIO_s_null/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO_METHOD *   BIO_s_null(void);\n</code></pre>"},{"location":"man3/BIO_s_null/#description","title":"DESCRIPTION","text":"<p>BIO_s_null() returns the null sink BIO method. Data written to the null sink is discarded, reads return EOF.</p>"},{"location":"man3/BIO_s_null/#notes","title":"NOTES","text":"<p>A null sink BIO behaves in a similar manner to the Unix /dev/null device.</p> <p>A null bio can be placed on the end of a chain to discard any data passed through it.</p> <p>A null sink is useful if, for example, an application wishes to digest some data by writing through a digest bio but not send the digested data anywhere. Since a BIO chain must normally include a source/sink BIO this can be achieved by adding a null sink BIO to the end of the chain</p>"},{"location":"man3/BIO_s_null/#return-values","title":"RETURN VALUES","text":"<p>BIO_s_null() returns the null sink BIO method.</p>"},{"location":"man3/BIO_s_null/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_s_socket/","title":"BIO_s_socket","text":""},{"location":"man3/BIO_s_socket/#name","title":"NAME","text":"<p>BIO_s_socket, BIO_new_socket - socket BIO</p>"},{"location":"man3/BIO_s_socket/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\nBIO_METHOD *BIO_s_socket(void);\n\nlong BIO_set_fd(BIO *b, int fd, long close_flag);\nlong BIO_get_fd(BIO *b, int *c);\n\nBIO *BIO_new_socket(int sock, int close_flag);\n</code></pre>"},{"location":"man3/BIO_s_socket/#description","title":"DESCRIPTION","text":"<p>BIO_s_socket() returns the socket BIO method. This is a wrapper round the platform's socket routines.</p> <p>BIO_read() and BIO_write() read or write the underlying socket. BIO_puts() is supported but BIO_gets() is not.</p> <p>If the close flag is set then the socket is shut down and closed when the BIO is freed.</p> <p>BIO_set_fd() sets the socket of BIO b to fd and the close flag to close_flag.</p> <p>BIO_get_fd() places the socket in c if it is not NULL, it also returns the socket. If c is not NULL it should be of type (int *).</p> <p>BIO_new_socket() returns a socket BIO using sock and close_flag.</p>"},{"location":"man3/BIO_s_socket/#notes","title":"NOTES","text":"<p>Socket BIOs also support any relevant functionality of file descriptor BIOs.</p> <p>The reason for having separate file descriptor and socket BIOs is that on some platforms sockets are not file descriptors and use distinct I/O routines, Windows is one such platform. Any code mixing the two will not work on all platforms.</p> <p>BIO_set_fd() and BIO_get_fd() are macros.</p>"},{"location":"man3/BIO_s_socket/#return-values","title":"RETURN VALUES","text":"<p>BIO_s_socket() returns the socket BIO method.</p> <p>BIO_set_fd() always returns 1.</p> <p>BIO_get_fd() returns the socket or -1 if the BIO has not been initialized.</p> <p>BIO_new_socket() returns the newly allocated BIO or NULL is an error occurred.</p>"},{"location":"man3/BIO_s_socket/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_set_callback/","title":"BIO_set_callback","text":""},{"location":"man3/BIO_set_callback/#name","title":"NAME","text":"<p>BIO_set_callback, BIO_get_callback, BIO_set_callback_arg, BIO_get_callback_arg, BIO_debug_callback - BIO callback functions</p>"},{"location":"man3/BIO_set_callback/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\n#define BIO_set_callback(b,cb)         ((b)-&gt;callback=(cb))\n#define BIO_get_callback(b)            ((b)-&gt;callback)\n#define BIO_set_callback_arg(b,arg)    ((b)-&gt;cb_arg=(char *)(arg))\n#define BIO_get_callback_arg(b)                ((b)-&gt;cb_arg)\n\nlong BIO_debug_callback(BIO *bio,int cmd,const char *argp,int argi,\n       long argl,long ret);\n\ntypedef long (*callback)(BIO *b, int oper, const char *argp,\n                       int argi, long argl, long retvalue);\n</code></pre>"},{"location":"man3/BIO_set_callback/#description","title":"DESCRIPTION","text":"<p>BIO_set_callback() and BIO_get_callback() set and retrieve the BIO callback, they are both macros. The callback is called during most high level BIO operations. It can be used for debugging purposes to trace operations on a BIO or to modify its operation.</p> <p>BIO_set_callback_arg() and BIO_get_callback_arg() are macros which can be used to set and retrieve an argument for use in the callback.</p> <p>BIO_debug_callback() is a standard debugging callback which prints out information relating to each BIO operation. If the callback argument is set if is interpreted as a BIO to send the information to, otherwise stderr is used.</p> <p>callback() is the callback function itself. The meaning of each argument is described below.</p> <p>The BIO the callback is attached to is passed in b.</p> <p>oper is set to the operation being performed. For some operations the callback is called twice, once before and once after the actual operation, the latter case has oper or'ed with BIO_CB_RETURN.</p> <p>The meaning of the arguments argp, argi and argl depends on the value of oper, that is the operation being performed.</p> <p>retvalue is the return value that would be returned to the application if no callback were present. The actual value returned is the return value of the callback itself. In the case of callbacks called before the actual BIO operation 1 is placed in retvalue, if the return value is not positive it will be immediately returned to the application and the BIO operation will not be performed.</p> <p>The callback should normally simply return retvalue when it has finished processing, unless if specifically wishes to modify the value returned to the application.</p>"},{"location":"man3/BIO_set_callback/#callback-operations","title":"CALLBACK OPERATIONS","text":"<ul> <li> <p>BIO_free(b)</p> <p>callback(b, BIO_CB_FREE, NULL, 0L, 0L, 1L) is called before the free operation.</p> </li> <li> <p>BIO_read(b, out, outl)</p> <p>callback(b, BIO_CB_READ, out, outl, 0L, 1L) is called before the read and callback(b, BIO_CB_READ|BIO_CB_RETURN, out, outl, 0L, retvalue) after.</p> </li> <li> <p>BIO_write(b, in, inl)</p> <p>callback(b, BIO_CB_WRITE, in, inl, 0L, 1L) is called before the write and callback(b, BIO_CB_WRITE|BIO_CB_RETURN, in, inl, 0L, retvalue) after.</p> </li> <li> <p>BIO_gets(b, out, outl)</p> <p>callback(b, BIO_CB_GETS, out, outl, 0L, 1L) is called before the operation and callback(b, BIO_CB_GETS|BIO_CB_RETURN, out, outl, 0L, retvalue) after.</p> </li> <li> <p>BIO_puts(b, in)</p> <p>callback(b, BIO_CB_WRITE, in, 0, 0L, 1L) is called before the operation and callback(b, BIO_CB_WRITE|BIO_CB_RETURN, in, 0, 0L, retvalue) after.</p> </li> <li> <p>BIO_ctrl(BIO *b, int cmd, long larg, void *parg)</p> <p>callback(b,BIO_CB_CTRL,parg,cmd,larg,1L) is called before the call and callback(b,BIO_CB_CTRL|BIO_CB_RETURN,parg,cmd, larg,ret) after.</p> </li> </ul>"},{"location":"man3/BIO_set_callback/#example","title":"EXAMPLE","text":"<p>The BIO_debug_callback() function is a good example, its source is in crypto/bio/bio_cb.c</p>"},{"location":"man3/BIO_set_callback/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BIO_should_retry/","title":"BIO_should_retry","text":""},{"location":"man3/BIO_should_retry/#name","title":"NAME","text":"<p>BIO_should_retry, BIO_should_read, BIO_should_write, BIO_should_io_special, BIO_retry_type, BIO_should_retry, BIO_get_retry_BIO, BIO_get_retry_reason - BIO retry functions</p>"},{"location":"man3/BIO_should_retry/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n\n#define BIO_should_read(a)             ((a)-&gt;flags &amp; BIO_FLAGS_READ)\n#define BIO_should_write(a)            ((a)-&gt;flags &amp; BIO_FLAGS_WRITE)\n#define BIO_should_io_special(a)       ((a)-&gt;flags &amp; BIO_FLAGS_IO_SPECIAL)\n#define BIO_retry_type(a)              ((a)-&gt;flags &amp; BIO_FLAGS_RWS)\n#define BIO_should_retry(a)            ((a)-&gt;flags &amp; BIO_FLAGS_SHOULD_RETRY)\n\n#define BIO_FLAGS_READ         0x01\n#define BIO_FLAGS_WRITE        0x02\n#define BIO_FLAGS_IO_SPECIAL   0x04\n#define BIO_FLAGS_RWS (BIO_FLAGS_READ|BIO_FLAGS_WRITE|BIO_FLAGS_IO_SPECIAL)\n#define BIO_FLAGS_SHOULD_RETRY 0x08\n\nBIO *  BIO_get_retry_BIO(BIO *bio, int *reason);\nint    BIO_get_retry_reason(BIO *bio);\n</code></pre>"},{"location":"man3/BIO_should_retry/#description","title":"DESCRIPTION","text":"<p>These functions determine why a BIO is not able to read or write data. They will typically be called after a failed BIO_read() or BIO_write() call.</p> <p>BIO_should_retry() is true if the call that produced this condition should then be retried at a later time.</p> <p>If BIO_should_retry() is false then the cause is an error condition.</p> <p>BIO_should_read() is true if the cause of the condition is that a BIO needs to read data.</p> <p>BIO_should_write() is true if the cause of the condition is that a BIO needs to read data.</p> <p>BIO_should_io_special() is true if some \"special\" condition, that is a reason other than reading or writing is the cause of the condition.</p> <p>BIO_retry_type() returns a mask of the cause of a retry condition consisting of the values BIO_FLAGS_READ, BIO_FLAGS_WRITE, BIO_FLAGS_IO_SPECIAL though current BIO types will only set one of these.</p> <p>BIO_get_retry_BIO() determines the precise reason for the special condition, it returns the BIO that caused this condition and if  reason is not NULL it contains the reason code. The meaning of the reason code and the action that should be taken depends on the type of BIO that resulted in this condition.</p> <p>BIO_get_retry_reason() returns the reason for a special condition if passed the relevant BIO, for example as returned by BIO_get_retry_BIO().</p>"},{"location":"man3/BIO_should_retry/#notes","title":"NOTES","text":"<p>If BIO_should_retry() returns false then the precise \"error condition\" depends on the BIO type that caused it and the return code of the BIO operation. For example if a call to BIO_read() on a socket BIO returns 0 and BIO_should_retry() is false then the cause will be that the connection closed. A similar condition on a file BIO will mean that it has reached EOF. Some BIO types may place additional information on the error queue. For more details see the individual BIO type manual pages.</p> <p>If the underlying I/O structure is in a blocking mode almost all current BIO types will not request a retry, because the underlying I/O calls will not. If the application knows that the BIO type will never signal a retry then it need not call BIO_should_retry() after a failed BIO I/O call. This is typically done with file BIOs.</p> <p>SSL BIOs are the only current exception to this rule: they can request a retry even if the underlying I/O structure is blocking, if a handshake occurs during a call to BIO_read(). An application can retry the failed call immediately or avoid this situation by setting SSL_MODE_AUTO_RETRY on the underlying SSL structure.</p> <p>While an application may retry a failed non blocking call immediately this is likely to be very inefficient because the call will fail repeatedly until data can be processed or is available. An application will normally wait until the necessary condition is satisfied. How this is done depends on the underlying I/O structure.</p> <p>For example if the cause is ultimately a socket and BIO_should_read() is true then a call to select() may be made to wait until data is available and then retry the BIO operation. By combining the retry conditions of several non blocking BIOs in a single select() call it is possible to service several BIOs in a single thread, though the performance may be poor if SSL BIOs are present because long delays can occur during the initial handshake process. </p> <p>It is possible for a BIO to block indefinitely if the underlying I/O structure cannot process or return any data. This depends on the behaviour of the platforms I/O functions. This is often not desirable: one solution is to use non blocking I/O and use a timeout on the select() (or equivalent) call.</p>"},{"location":"man3/BIO_should_retry/#bugs","title":"BUGS","text":"<p>The OpenSSL ASN1 functions cannot gracefully deal with non blocking I/O: that is they cannot retry after a partial read or write. This is usually worked around by only passing the relevant data to ASN1 functions when the entire structure can be read or written.</p>"},{"location":"man3/BIO_should_retry/#see-also","title":"SEE ALSO","text":"<p>TBA</p>"},{"location":"man3/BN_BLINDING_new/","title":"BN_BLINDING_new","text":""},{"location":"man3/BN_BLINDING_new/#name","title":"NAME","text":"<p>BN_BLINDING_new, BN_BLINDING_free, BN_BLINDING_update, BN_BLINDING_convert,  BN_BLINDING_invert, BN_BLINDING_convert_ex, BN_BLINDING_invert_ex,  BN_BLINDING_get_thread_id, BN_BLINDING_set_thread_id, BN_BLINDING_thread_id, BN_BLINDING_get_flags, BN_BLINDING_set_flags, BN_BLINDING_create_param - blinding related BIGNUM functions.</p>"},{"location":"man3/BN_BLINDING_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nBN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai,\n       BIGNUM *mod);\nvoid BN_BLINDING_free(BN_BLINDING *b);\nint BN_BLINDING_update(BN_BLINDING *b,BN_CTX *ctx);\nint BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\nint BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\nint BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b,\n       BN_CTX *ctx);\nint BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b,\n       BN_CTX *ctx);\n#ifndef OPENSSL_NO_DEPRECATED\nunsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *);\nvoid BN_BLINDING_set_thread_id(BN_BLINDING *, unsigned long);\n#endif\nCRYPTO_THREADID *BN_BLINDING_thread_id(BN_BLINDING *);\nunsigned long BN_BLINDING_get_flags(const BN_BLINDING *);\nvoid BN_BLINDING_set_flags(BN_BLINDING *, unsigned long);\nBN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,\n       const BIGNUM *e, BIGNUM *m, BN_CTX *ctx,\n       int (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx),\n       BN_MONT_CTX *m_ctx);\n</code></pre>"},{"location":"man3/BN_BLINDING_new/#description","title":"DESCRIPTION","text":"<p>BN_BLINDING_new() allocates a new BN_BLINDING structure and copies the A and Ai values into the newly created BN_BLINDING object.</p> <p>BN_BLINDING_free() frees the BN_BLINDING structure.</p> <p>BN_BLINDING_update() updates the BN_BLINDING parameters by squaring the A and Ai or, after specific number of uses and if the necessary parameters are set, by re-creating the blinding parameters.</p> <p>BN_BLINDING_convert_ex() multiplies n with the blinding factor A. If r is not NULL a copy the inverse blinding factor Ai will be returned in r (this is useful if a RSA object is shared among several threads). BN_BLINDING_invert_ex() multiplies n with the inverse blinding factor Ai. If r is not NULL it will be used as the inverse blinding.</p> <p>BN_BLINDING_convert() and BN_BLINDING_invert() are wrapper functions for BN_BLINDING_convert_ex() and BN_BLINDING_invert_ex() with r set to NULL.</p> <p>BN_BLINDING_thread_id() provides access to the CRYPTO_THREADID object within the BN_BLINDING structure. This is to help users provide proper locking if needed for multi-threaded use. The \"thread id\" object of a newly allocated BN_BLINDING structure is initialised to the thread id in which BN_BLINDING_new() was called.</p> <p>BN_BLINDING_get_flags() returns the BN_BLINDING flags. Currently there are two supported flags: BN_BLINDING_NO_UPDATE and BN_BLINDING_NO_RECREATE. BN_BLINDING_NO_UPDATE inhibits the automatic update of the BN_BLINDING parameters after each use and BN_BLINDING_NO_RECREATE inhibits the automatic re-creation of the BN_BLINDING parameters after a fixed number of uses (currently 32). In newly allocated BN_BLINDING objects no flags are set. BN_BLINDING_set_flags() sets the BN_BLINDING parameters flags.</p> <p>BN_BLINDING_create_param() creates new BN_BLINDING parameters using the exponent e and the modulus m. bn_mod_exp and m_ctx can be used to pass special functions for exponentiation (normally BN_mod_exp_mont() and BN_MONT_CTX).</p>"},{"location":"man3/BN_BLINDING_new/#return-values","title":"RETURN VALUES","text":"<p>BN_BLINDING_new() returns the newly allocated BN_BLINDING structure or NULL in case of an error.</p> <p>BN_BLINDING_update(), BN_BLINDING_convert(), BN_BLINDING_invert(), BN_BLINDING_convert_ex() and BN_BLINDING_invert_ex() return 1 on success and 0 if an error occurred.</p> <p>BN_BLINDING_thread_id() returns a pointer to the thread id object within a BN_BLINDING object.</p> <p>BN_BLINDING_get_flags() returns the currently set BN_BLINDING flags (a unsigned long value).</p> <p>BN_BLINDING_create_param() returns the newly created BN_BLINDING  parameters or NULL on error.</p>"},{"location":"man3/BN_BLINDING_new/#see-also","title":"SEE ALSO","text":"<p>bn(3)</p>"},{"location":"man3/BN_BLINDING_new/#history","title":"HISTORY","text":"<p>BN_BLINDING_thread_id was first introduced in OpenSSL 1.0.0, and it deprecates BN_BLINDING_set_thread_id and BN_BLINDING_get_thread_id.</p> <p>BN_BLINDING_convert_ex, BN_BLINDIND_invert_ex, BN_BLINDING_get_thread_id, BN_BLINDING_set_thread_id, BN_BLINDING_set_flags, BN_BLINDING_get_flags and BN_BLINDING_create_param were first introduced in OpenSSL 0.9.8</p>"},{"location":"man3/BN_BLINDING_new/#author","title":"AUTHOR","text":"<p>Nils Larsch for the OpenSSL project (http://www.openssl.org).</p>"},{"location":"man3/BN_CTX_new/","title":"BN_CTX_new","text":""},{"location":"man3/BN_CTX_new/#name","title":"NAME","text":"<p>BN_CTX_new, BN_CTX_init, BN_CTX_free - allocate and free BN_CTX structures</p>"},{"location":"man3/BN_CTX_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nBN_CTX *BN_CTX_new(void);\n\nvoid BN_CTX_free(BN_CTX *c);\n</code></pre> <p>Deprecated:</p> <pre><code>void BN_CTX_init(BN_CTX *c);\n</code></pre>"},{"location":"man3/BN_CTX_new/#description","title":"DESCRIPTION","text":"<p>A BN_CTX is a structure that holds BIGNUM temporary variables used by library functions. Since dynamic memory allocation to create BIGNUMs is rather expensive when used in conjunction with repeated subroutine calls, the BN_CTX structure is used.</p> <p>BN_CTX_new() allocates and initializes a BN_CTX structure. </p> <p>BN_CTX_free() frees the components of the BN_CTX, and if it was created by BN_CTX_new(), also the structure itself. If BN_CTX_start(3) has been used on the BN_CTX, BN_CTX_end(3) must be called before the BN_CTX may be freed by BN_CTX_free().</p> <p>BN_CTX_init() (deprecated) initializes an existing uninitialized BN_CTX. This should not be used for new programs. Use BN_CTX_new() instead.</p>"},{"location":"man3/BN_CTX_new/#return-values","title":"RETURN VALUES","text":"<p>BN_CTX_new() returns a pointer to the BN_CTX. If the allocation fails, it returns NULL and sets an error code that can be obtained by ERR_get_error(3).</p> <p>BN_CTX_init() and BN_CTX_free() have no return values.</p>"},{"location":"man3/BN_CTX_new/#see-also","title":"SEE ALSO","text":"<p>bn(3), ERR_get_error(3), BN_add(3), BN_CTX_start(3)</p>"},{"location":"man3/BN_CTX_new/#history","title":"HISTORY","text":"<p>BN_CTX_new() and BN_CTX_free() are available in all versions on SSLeay and OpenSSL. BN_CTX_init() was added in SSLeay 0.9.1b.</p>"},{"location":"man3/BN_CTX_start/","title":"BN_CTX_start","text":""},{"location":"man3/BN_CTX_start/#name","title":"NAME","text":"<p>BN_CTX_start, BN_CTX_get, BN_CTX_end - use temporary BIGNUM variables</p>"},{"location":"man3/BN_CTX_start/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nvoid BN_CTX_start(BN_CTX *ctx);\n\nBIGNUM *BN_CTX_get(BN_CTX *ctx);\n\nvoid BN_CTX_end(BN_CTX *ctx);\n</code></pre>"},{"location":"man3/BN_CTX_start/#description","title":"DESCRIPTION","text":"<p>These functions are used to obtain temporary BIGNUM variables from a BN_CTX (which can been created by using BN_CTX_new(3)) in order to save the overhead of repeatedly creating and freeing BIGNUMs in functions that are called from inside a loop.</p> <p>A function must call BN_CTX_start() first. Then, BN_CTX_get() may be called repeatedly to obtain temporary BIGNUMs. All BN_CTX_get() calls must be made before calling any other functions that use the ctx as an argument.</p> <p>Finally, BN_CTX_end() must be called before returning from the function. When BN_CTX_end() is called, the BIGNUM pointers obtained from BN_CTX_get() become invalid.</p>"},{"location":"man3/BN_CTX_start/#return-values","title":"RETURN VALUES","text":"<p>BN_CTX_start() and BN_CTX_end() return no values.</p> <p>BN_CTX_get() returns a pointer to the BIGNUM, or NULL on error. Once BN_CTX_get() has failed, the subsequent calls will return NULL as well, so it is sufficient to check the return value of the last BN_CTX_get() call. In case of an error, an error code is set, which can be obtained by ERR_get_error(3).</p>"},{"location":"man3/BN_CTX_start/#see-also","title":"SEE ALSO","text":"<p>BN_CTX_new(3)</p>"},{"location":"man3/BN_CTX_start/#history","title":"HISTORY","text":"<p>BN_CTX_start(), BN_CTX_get() and BN_CTX_end() were added in OpenSSL 0.9.5.</p>"},{"location":"man3/BN_add/","title":"BN_add","text":""},{"location":"man3/BN_add/#name","title":"NAME","text":"<p>BN_add, BN_sub, BN_mul, BN_sqr, BN_div, BN_mod, BN_nnmod, BN_mod_add, BN_mod_sub, BN_mod_mul, BN_mod_sqr, BN_exp, BN_mod_exp, BN_gcd - arithmetic operations on BIGNUMs</p>"},{"location":"man3/BN_add/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nint BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n\nint BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n\nint BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\n\nint BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);\n\nint BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d,\n        BN_CTX *ctx);\n\nint BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n\nint BN_nnmod(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n\nint BN_mod_add(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n        BN_CTX *ctx);\n\nint BN_mod_sub(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n        BN_CTX *ctx);\n\nint BN_mod_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n        BN_CTX *ctx);\n\nint BN_mod_sqr(BIGNUM *r, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n\nint BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);\n\nint BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,\n        const BIGNUM *m, BN_CTX *ctx);\n\nint BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\n</code></pre>"},{"location":"man3/BN_add/#description","title":"DESCRIPTION","text":"<p>BN_add() adds a and b and places the result in r (<code>r=a+b</code>). r may be the same BIGNUM as a or b.</p> <p>BN_sub() subtracts b from a and places the result in r (<code>r=a-b</code>).</p> <p>BN_mul() multiplies a and b and places the result in r (<code>r=a*b</code>). r may be the same BIGNUM as a or b. For multiplication by powers of 2, use BN_lshift(3).</p> <p>BN_sqr() takes the square of a and places the result in r (<code>r=a^2</code>). r and a may be the same BIGNUM. This function is faster than BN_mul(r,a,a).</p> <p>BN_div() divides a by d and places the result in dv and the remainder in rem (<code>dv=a/d, rem=a%d</code>). Either of dv and rem may be NULL, in which case the respective value is not returned. The result is rounded towards zero; thus if a is negative, the remainder will be zero or negative. For division by powers of 2, use BN_rshift(3).</p> <p>BN_mod() corresponds to BN_div() with dv set to NULL.</p> <p>BN_nnmod() reduces a modulo m and places the non-negative remainder in r.</p> <p>BN_mod_add() adds a to b modulo m and places the non-negative result in r.</p> <p>BN_mod_sub() subtracts b from a modulo m and places the non-negative result in r.</p> <p>BN_mod_mul() multiplies a by b and finds the non-negative remainder respective to modulus m (<code>r=(a*b) mod m</code>). r may be the same BIGNUM as a or b. For more efficient algorithms for repeated computations using the same modulus, see BN_mod_mul_montgomery(3) and BN_mod_mul_reciprocal(3).</p> <p>BN_mod_sqr() takes the square of a modulo m and places the result in r.</p> <p>BN_exp() raises a to the p-th power and places the result in r (<code>r=a^p</code>). This function is faster than repeated applications of BN_mul().</p> <p>BN_mod_exp() computes a to the p-th power modulo m (<code>r=a^p % m</code>). This function uses less time and space than BN_exp(). Do not call this function when m is even and any of the parameters have the BN_FLG_CONSTTIME flag set.</p> <p>BN_gcd() computes the greatest common divisor of a and b and places the result in r. r may be the same BIGNUM as a or b.</p> <p>For all functions, ctx is a previously allocated BN_CTX used for temporary variables; see BN_CTX_new(3).</p> <p>Unless noted otherwise, the result BIGNUM must be different from the arguments.</p>"},{"location":"man3/BN_add/#return-values","title":"RETURN VALUES","text":"<p>For all functions, 1 is returned for success, 0 on error. The return value should always be checked (e.g., <code>if (!BN_add(r,a,b)) goto err;</code>). The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/BN_add/#see-also","title":"SEE ALSO","text":"<p>bn(3), ERR_get_error(3), BN_CTX_new(3), BN_add_word(3), BN_set_bit(3)</p>"},{"location":"man3/BN_add/#history","title":"HISTORY","text":"<p>BN_add(), BN_sub(), BN_sqr(), BN_div(), BN_mod(), BN_mod_mul(), BN_mod_exp() and BN_gcd() are available in all versions of SSLeay and OpenSSL. The ctx argument to BN_mul() was added in SSLeay 0.9.1b. BN_exp() appeared in SSLeay 0.9.0. BN_nnmod(), BN_mod_add(), BN_mod_sub(), and BN_mod_sqr() were added in OpenSSL 0.9.7.</p>"},{"location":"man3/BN_add_word/","title":"BN_add_word","text":""},{"location":"man3/BN_add_word/#name","title":"NAME","text":"<p>BN_add_word, BN_sub_word, BN_mul_word, BN_div_word, BN_mod_word - arithmetic functions on BIGNUMs with integers</p>"},{"location":"man3/BN_add_word/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nint BN_add_word(BIGNUM *a, BN_ULONG w);\n\nint BN_sub_word(BIGNUM *a, BN_ULONG w);\n\nint BN_mul_word(BIGNUM *a, BN_ULONG w);\n\nBN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w);\n\nBN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w);\n</code></pre>"},{"location":"man3/BN_add_word/#description","title":"DESCRIPTION","text":"<p>These functions perform arithmetic operations on BIGNUMs with unsigned integers. They are much more efficient than the normal BIGNUM arithmetic operations.</p> <p>BN_add_word() adds w to a (<code>a+=w</code>).</p> <p>BN_sub_word() subtracts w from a (<code>a-=w</code>).</p> <p>BN_mul_word() multiplies a and w (<code>a*=w</code>).</p> <p>BN_div_word() divides a by w (<code>a/=w</code>) and returns the remainder.</p> <p>BN_mod_word() returns the remainder of a divided by w (<code>a%w</code>).</p> <p>For BN_div_word() and BN_mod_word(), w must not be 0.</p>"},{"location":"man3/BN_add_word/#return-values","title":"RETURN VALUES","text":"<p>BN_add_word(), BN_sub_word() and BN_mul_word() return 1 for success, 0 on error. The error codes can be obtained by ERR_get_error(3).</p> <p>BN_mod_word() and BN_div_word() return a%w on success and (BN_ULONG)-1 if an error occurred.</p>"},{"location":"man3/BN_add_word/#see-also","title":"SEE ALSO","text":"<p>bn(3), ERR_get_error(3), BN_add(3)</p>"},{"location":"man3/BN_add_word/#history","title":"HISTORY","text":"<p>BN_add_word() and BN_mod_word() are available in all versions of SSLeay and OpenSSL. BN_div_word() was added in SSLeay 0.8, and BN_sub_word() and BN_mul_word() in SSLeay 0.9.0.</p> <p>Before 0.9.8a the return value for BN_div_word() and BN_mod_word() in case of an error was 0.</p>"},{"location":"man3/BN_bn2bin/","title":"BN_bn2bin","text":""},{"location":"man3/BN_bn2bin/#name","title":"NAME","text":"<p>BN_bn2bin, BN_bin2bn, BN_bn2hex, BN_bn2dec, BN_hex2bn, BN_dec2bn, BN_print, BN_print_fp, BN_bn2mpi, BN_mpi2bn - format conversions</p>"},{"location":"man3/BN_bn2bin/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nint BN_bn2bin(const BIGNUM *a, unsigned char *to);\nBIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);\n\nchar *BN_bn2hex(const BIGNUM *a);\nchar *BN_bn2dec(const BIGNUM *a);\nint BN_hex2bn(BIGNUM **a, const char *str);\nint BN_dec2bn(BIGNUM **a, const char *str);\n\nint BN_print(BIO *fp, const BIGNUM *a);\nint BN_print_fp(FILE *fp, const BIGNUM *a);\n\nint BN_bn2mpi(const BIGNUM *a, unsigned char *to);\nBIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret);\n</code></pre>"},{"location":"man3/BN_bn2bin/#description","title":"DESCRIPTION","text":"<p>BN_bn2bin() converts the absolute value of a into big-endian form and stores it at to. to must point to BN_num_bytes(a) bytes of memory.</p> <p>BN_bin2bn() converts the positive integer in big-endian form of length len at s into a BIGNUM and places it in ret. If ret is NULL, a new BIGNUM is created.</p> <p>BN_bn2hex() and BN_bn2dec() return printable strings containing the hexadecimal and decimal encoding of a respectively. For negative numbers, the string is prefaced with a leading '-'. The string must be freed later using OPENSSL_free().</p> <p>BN_hex2bn() converts the string str containing a hexadecimal number to a BIGNUM and stores it in **a. If *a is NULL, a new BIGNUM is created. If a is NULL, it only computes the number's length in hexadecimal digits. If the string starts with '-', the number is negative. A \"negative zero\" is converted to zero. BN_dec2bn() is the same using the decimal system.</p> <p>BN_print() and BN_print_fp() write the hexadecimal encoding of a, with a leading '-' for negative numbers, to the BIO or FILE fp.</p> <p>BN_bn2mpi() and BN_mpi2bn() convert BIGNUMs from and to a format that consists of the number's length in bytes represented as a 4-byte big-endian number, and the number itself in big-endian format, where the most significant bit signals a negative number (the representation of numbers with the MSB set is prefixed with null byte).</p> <p>BN_bn2mpi() stores the representation of a at to, where to must be large enough to hold the result. The size can be determined by calling BN_bn2mpi(a, NULL).</p> <p>BN_mpi2bn() converts the len bytes long representation at s to a BIGNUM and stores it at ret, or in a newly allocated BIGNUM if ret is NULL.</p>"},{"location":"man3/BN_bn2bin/#return-values","title":"RETURN VALUES","text":"<p>BN_bn2bin() returns the length of the big-endian number placed at to. BN_bin2bn() returns the BIGNUM, NULL on error.</p> <p>BN_bn2hex() and BN_bn2dec() return a null-terminated string, or NULL on error. BN_hex2bn() and BN_dec2bn() return the number of characters used in parsing, or 0 on error, in which case no new BIGNUM will be created.</p> <p>BN_print_fp() and BN_print() return 1 on success, 0 on write errors.</p> <p>BN_bn2mpi() returns the length of the representation. BN_mpi2bn() returns the BIGNUM, and NULL on error.</p> <p>The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/BN_bn2bin/#see-also","title":"SEE ALSO","text":"<p>bn(3), ERR_get_error(3), BN_zero(3), ASN1_INTEGER_to_BN(3), BN_num_bytes(3)</p>"},{"location":"man3/BN_bn2bin/#history","title":"HISTORY","text":"<p>BN_bn2bin(), BN_bin2bn(), BN_print_fp() and BN_print() are available in all versions of SSLeay and OpenSSL.</p> <p>BN_bn2hex(), BN_bn2dec(), BN_hex2bn(), BN_dec2bn(), BN_bn2mpi() and BN_mpi2bn() were added in SSLeay 0.9.0.</p>"},{"location":"man3/BN_cmp/","title":"BN_cmp","text":""},{"location":"man3/BN_cmp/#name","title":"NAME","text":"<p>BN_cmp, BN_ucmp, BN_is_zero, BN_is_one, BN_is_word, BN_is_odd - BIGNUM comparison and test functions</p>"},{"location":"man3/BN_cmp/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nint BN_cmp(BIGNUM *a, BIGNUM *b);\nint BN_ucmp(BIGNUM *a, BIGNUM *b);\n\nint BN_is_zero(BIGNUM *a);\nint BN_is_one(BIGNUM *a);\nint BN_is_word(BIGNUM *a, BN_ULONG w);\nint BN_is_odd(BIGNUM *a);\n</code></pre>"},{"location":"man3/BN_cmp/#description","title":"DESCRIPTION","text":"<p>BN_cmp() compares the numbers a and b. BN_ucmp() compares their absolute values.</p> <p>BN_is_zero(), BN_is_one() and BN_is_word() test if a equals 0, 1, or w respectively. BN_is_odd() tests if a is odd.</p> <p>BN_is_zero(), BN_is_one(), BN_is_word() and BN_is_odd() are macros.</p>"},{"location":"man3/BN_cmp/#return-values","title":"RETURN VALUES","text":"<p>BN_cmp() returns -1 if a &lt; b, 0 if a == b and 1 if a &gt; b. BN_ucmp() is the same using the absolute values of a and b.</p> <p>BN_is_zero(), BN_is_one() BN_is_word() and BN_is_odd() return 1 if the condition is true, 0 otherwise.</p>"},{"location":"man3/BN_cmp/#see-also","title":"SEE ALSO","text":"<p>bn(3)</p>"},{"location":"man3/BN_cmp/#history","title":"HISTORY","text":"<p>BN_cmp(), BN_ucmp(), BN_is_zero(), BN_is_one() and BN_is_word() are available in all versions of SSLeay and OpenSSL. BN_is_odd() was added in SSLeay 0.8.</p>"},{"location":"man3/BN_copy/","title":"BN_copy","text":""},{"location":"man3/BN_copy/#name","title":"NAME","text":"<p>BN_copy, BN_dup - copy BIGNUMs</p>"},{"location":"man3/BN_copy/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nBIGNUM *BN_copy(BIGNUM *to, const BIGNUM *from);\n\nBIGNUM *BN_dup(const BIGNUM *from);\n</code></pre>"},{"location":"man3/BN_copy/#description","title":"DESCRIPTION","text":"<p>BN_copy() copies from to to. BN_dup() creates a new BIGNUM containing the value from.</p>"},{"location":"man3/BN_copy/#return-values","title":"RETURN VALUES","text":"<p>BN_copy() returns to on success, NULL on error. BN_dup() returns the new BIGNUM, and NULL on error. The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/BN_copy/#see-also","title":"SEE ALSO","text":"<p>bn(3), ERR_get_error(3)</p>"},{"location":"man3/BN_copy/#history","title":"HISTORY","text":"<p>BN_copy() and BN_dup() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/BN_generate_prime/","title":"BN_generate_prime","text":""},{"location":"man3/BN_generate_prime/#name","title":"NAME","text":"<p>BN_generate_prime_ex, BN_is_prime_ex, BN_is_prime_fasttest_ex, BN_GENCB_call, BN_GENCB_set_old, BN_GENCB_set, BN_generate_prime, BN_is_prime, BN_is_prime_fasttest - generate primes and test for primality</p>"},{"location":"man3/BN_generate_prime/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nint BN_generate_prime_ex(BIGNUM *ret,int bits,int safe, const BIGNUM *add,\n    const BIGNUM *rem, BN_GENCB *cb);\n\nint BN_is_prime_ex(const BIGNUM *p,int nchecks, BN_CTX *ctx, BN_GENCB *cb);\n\nint BN_is_prime_fasttest_ex(const BIGNUM *p,int nchecks, BN_CTX *ctx,\n    int do_trial_division, BN_GENCB *cb);\n\nint BN_GENCB_call(BN_GENCB *cb, int a, int b);\n\n#define BN_GENCB_set_old(gencb, callback, cb_arg) ...\n\n#define BN_GENCB_set(gencb, callback, cb_arg) ...\n</code></pre> <p>Deprecated:</p> <pre><code>BIGNUM *BN_generate_prime(BIGNUM *ret, int num, int safe, BIGNUM *add,\n    BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);\n\nint BN_is_prime(const BIGNUM *a, int checks, void (*callback)(int, int, \n    void *), BN_CTX *ctx, void *cb_arg);\n\nint BN_is_prime_fasttest(const BIGNUM *a, int checks,\n    void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg,\n    int do_trial_division);\n</code></pre>"},{"location":"man3/BN_generate_prime/#description","title":"DESCRIPTION","text":"<p>BN_generate_prime_ex() generates a pseudo-random prime number of bit length bits. If ret is not NULL, it will be used to store the number.</p> <p>If cb is not NULL, it is used as follows:</p> <ul> <li>BN_GENCB_call(cb, 0, i) is called after generating the i-th potential prime number.</li> <li>While the number is being tested for primality, BN_GENCB_call(cb, 1, j) is called as described below.</li> <li>When a prime has been found, BN_GENCB_call(cb, 2, i) is called.</li> </ul> <p>The prime may have to fulfill additional requirements for use in Diffie-Hellman key exchange:</p> <p>If add is not NULL, the prime will fulfill the condition p % add == rem (p % add == 1 if rem == NULL) in order to suit a given generator.</p> <p>If safe is true, it will be a safe prime (i.e. a prime p so that (p-1)/2 is also prime).</p> <p>The PRNG must be seeded prior to calling BN_generate_prime_ex(). The prime number generation has a negligible error probability.</p> <p>BN_is_prime_ex() and BN_is_prime_fasttest_ex() test if the number p is prime.  The following tests are performed until one of them shows that p is composite; if p passes all these tests, it is considered prime.</p> <p>BN_is_prime_fasttest_ex(), when called with do_trial_division == 1, first attempts trial division by a number of small primes; if no divisors are found by this test and cb is not NULL, BN_GENCB_call(cb, 1, -1) is called. If do_trial_division == 0, this test is skipped.</p> <p>Both BN_is_prime_ex() and BN_is_prime_fasttest_ex() perform a Miller-Rabin probabilistic primality test with nchecks iterations. If nchecks == BN_prime_checks, a number of iterations is used that yields a false positive rate of at most 2^-64 for random input. The error rate depends on the size of the prime and goes down for bigger primes. The rate is 2^-80 starting at 308 bits, 2^-112 at 852 bits, 2^-128 at 1080 bits, 2^-192 at 3747 bits and 2^-256 at 6394 bits.</p> <p>When the source of the prime is not random or not trusted, the number of checks needs to be much higher to reach the same level of assurance: It should equal half of the targeted security level in bits (rounded up to the next integer if necessary). For instance, to reach the 128 bit security level, nchecks should be set to 64.</p> <p>If cb is not NULL, BN_GENCB_call(cb, 1, j) is called after the j-th iteration (j = 0, 1, ...). ctx is a pre-allocated BN_CTX (to save the overhead of allocating and freeing the structure in a loop), or NULL.</p> <p>BN_GENCB_call calls the callback function held in the BN_GENCB structure and passes the ints a and b as arguments. There are two types of BN_GENCB structure that are supported: \"new\" style and \"old\" style. New programs should prefer the \"new\" style, whilst the \"old\" style is provided for backwards compatibility purposes.</p> <p>For \"new\" style callbacks a BN_GENCB structure should be initialised with a call to BN_GENCB_set, where gencb is a BN_GENCB *, callback is of type int (*callback)(int, int, BN_GENCB *) and cb_arg is a void *. \"Old\" style callbacks are the same except they are initialised with a call to BN_GENCB_set_old and callback is of type void (*callback)(int, int, void *).</p> <p>A callback is invoked through a call to BN_GENCB_call. This will check the type of the callback and will invoke callback(a, b, gencb) for new style callbacks or callback(a, b, cb_arg) for old style.</p> <p>BN_generate_prime (deprecated) works in the same way as BN_generate_prime_ex but expects an old style callback function directly in the callback parameter, and an argument to pass to it in the cb_arg. Similarly BN_is_prime and BN_is_prime_fasttest are deprecated and can be compared to BN_is_prime_ex and BN_is_prime_fasttest_ex respectively.</p>"},{"location":"man3/BN_generate_prime/#return-values","title":"RETURN VALUES","text":"<p>BN_generate_prime_ex() return 1 on success or 0 on error.</p> <p>BN_is_prime_ex(), BN_is_prime_fasttest_ex(), BN_is_prime() and BN_is_prime_fasttest() return 0 if the number is composite, 1 if it is prime with an error probability of less than 0.25^nchecks, and -1 on error.</p> <p>BN_generate_prime() returns the prime number on success, NULL otherwise.</p> <p>Callback functions should return 1 on success or 0 on error.</p> <p>The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/BN_generate_prime/#see-also","title":"SEE ALSO","text":"<p>bn(3), ERR_get_error(3), rand(3)</p>"},{"location":"man3/BN_generate_prime/#history","title":"HISTORY","text":"<p>The cb_arg arguments to BN_generate_prime() and to BN_is_prime() were added in SSLeay 0.9.0. The ret argument to BN_generate_prime() was added in SSLeay 0.9.1. BN_is_prime_fasttest() was added in OpenSSL 0.9.5.</p>"},{"location":"man3/BN_mod_inverse/","title":"BN_mod_inverse","text":""},{"location":"man3/BN_mod_inverse/#name","title":"NAME","text":"<p>BN_mod_inverse - compute inverse modulo n</p>"},{"location":"man3/BN_mod_inverse/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nBIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n,\n          BN_CTX *ctx);\n</code></pre>"},{"location":"man3/BN_mod_inverse/#description","title":"DESCRIPTION","text":"<p>BN_mod_inverse() computes the inverse of a modulo n places the result in r (<code>(a*r)%n==1</code>). If r is NULL, a new BIGNUM is created.</p> <p>ctx is a previously allocated BN_CTX used for temporary variables. r may be the same BIGNUM as a or n.</p>"},{"location":"man3/BN_mod_inverse/#return-values","title":"RETURN VALUES","text":"<p>BN_mod_inverse() returns the BIGNUM containing the inverse, and NULL on error. The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/BN_mod_inverse/#see-also","title":"SEE ALSO","text":"<p>bn(3), ERR_get_error(3), BN_add(3)</p>"},{"location":"man3/BN_mod_inverse/#history","title":"HISTORY","text":"<p>BN_mod_inverse() is available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/BN_mod_mul_montgomery/","title":"BN_mod_mul_montgomery","text":""},{"location":"man3/BN_mod_mul_montgomery/#name","title":"NAME","text":"<p>BN_mod_mul_montgomery, BN_MONT_CTX_new, BN_MONT_CTX_init, BN_MONT_CTX_free, BN_MONT_CTX_set, BN_MONT_CTX_copy, BN_from_montgomery, BN_to_montgomery - Montgomery multiplication</p>"},{"location":"man3/BN_mod_mul_montgomery/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nBN_MONT_CTX *BN_MONT_CTX_new(void);\nvoid BN_MONT_CTX_init(BN_MONT_CTX *ctx);\nvoid BN_MONT_CTX_free(BN_MONT_CTX *mont);\n\nint BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx);\nBN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from);\n\nint BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n        BN_MONT_CTX *mont, BN_CTX *ctx);\n\nint BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,\n        BN_CTX *ctx);\n\nint BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,\n        BN_CTX *ctx);\n</code></pre>"},{"location":"man3/BN_mod_mul_montgomery/#description","title":"DESCRIPTION","text":"<p>These functions implement Montgomery multiplication. They are used automatically when BN_mod_exp(3) is called with suitable input, but they may be useful when several operations are to be performed using the same modulus.</p> <p>BN_MONT_CTX_new() allocates and initializes a BN_MONT_CTX structure. BN_MONT_CTX_init() initializes an existing uninitialized BN_MONT_CTX.</p> <p>BN_MONT_CTX_set() sets up the mont structure from the modulus m by precomputing its inverse and a value R.</p> <p>BN_MONT_CTX_copy() copies the BN_MONT_CTX from to to.</p> <p>BN_MONT_CTX_free() frees the components of the BN_MONT_CTX, and, if it was created by BN_MONT_CTX_new(), also the structure itself.</p> <p>BN_mod_mul_montgomery() computes Mont(a,b):=a*b*R^-1 and places the result in r.</p> <p>BN_from_montgomery() performs the Montgomery reduction r = a*R^-1.</p> <p>BN_to_montgomery() computes Mont(a,R^2), i.e. a*R. Note that a must be non-negative and smaller than the modulus.</p> <p>For all functions, ctx is a previously allocated BN_CTX used for temporary variables.</p> <p>The BN_MONT_CTX structure is defined as follows:</p> <pre><code>typedef struct bn_mont_ctx_st\n       {\n       int ri;         /* number of bits in R */\n       BIGNUM RR;      /* R^2 (used to convert to Montgomery form) */\n       BIGNUM N;       /* The modulus */\n       BIGNUM Ni;      /* R*(1/R mod N) - N*Ni = 1\n                        * (Ni is only stored for bignum algorithm) */\n       BN_ULONG n0;    /* least significant word of Ni */\n       int flags;\n       } BN_MONT_CTX;\n</code></pre> <p>BN_to_montgomery() is a macro.</p>"},{"location":"man3/BN_mod_mul_montgomery/#return-values","title":"RETURN VALUES","text":"<p>BN_MONT_CTX_new() returns the newly allocated BN_MONT_CTX, and NULL on error.</p> <p>BN_MONT_CTX_init() and BN_MONT_CTX_free() have no return values.</p> <p>For the other functions, 1 is returned for success, 0 on error. The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/BN_mod_mul_montgomery/#warning","title":"WARNING","text":"<p>The inputs must be reduced modulo m, otherwise the result will be outside the expected range.</p>"},{"location":"man3/BN_mod_mul_montgomery/#see-also","title":"SEE ALSO","text":"<p>bn(3), ERR_get_error(3), BN_add(3), BN_CTX_new(3)</p>"},{"location":"man3/BN_mod_mul_montgomery/#history","title":"HISTORY","text":"<p>BN_MONT_CTX_new(), BN_MONT_CTX_free(), BN_MONT_CTX_set(), BN_mod_mul_montgomery(), BN_from_montgomery() and BN_to_montgomery() are available in all versions of SSLeay and OpenSSL.</p> <p>BN_MONT_CTX_init() and BN_MONT_CTX_copy() were added in SSLeay 0.9.1b.</p>"},{"location":"man3/BN_mod_mul_reciprocal/","title":"BN_mod_mul_reciprocal","text":""},{"location":"man3/BN_mod_mul_reciprocal/#name","title":"NAME","text":"<p>BN_mod_mul_reciprocal,  BN_div_recp, BN_RECP_CTX_new, BN_RECP_CTX_init, BN_RECP_CTX_free, BN_RECP_CTX_set - modular multiplication using reciprocal</p>"},{"location":"man3/BN_mod_mul_reciprocal/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nBN_RECP_CTX *BN_RECP_CTX_new(void);\nvoid BN_RECP_CTX_init(BN_RECP_CTX *recp);\nvoid BN_RECP_CTX_free(BN_RECP_CTX *recp);\n\nint BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *m, BN_CTX *ctx);\n\nint BN_div_recp(BIGNUM *dv, BIGNUM *rem, BIGNUM *a, BN_RECP_CTX *recp,\n       BN_CTX *ctx);\n\nint BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n       BN_RECP_CTX *recp, BN_CTX *ctx);\n</code></pre>"},{"location":"man3/BN_mod_mul_reciprocal/#description","title":"DESCRIPTION","text":"<p>BN_mod_mul_reciprocal() can be used to perform an efficient BN_mod_mul(3) operation when the operation will be performed repeatedly with the same modulus. It computes r=(a*b)%m using recp=1/m, which is set as described below.  ctx is a previously allocated BN_CTX used for temporary variables.</p> <p>BN_RECP_CTX_new() allocates and initializes a BN_RECP structure. BN_RECP_CTX_init() initializes an existing uninitialized BN_RECP.</p> <p>BN_RECP_CTX_free() frees the components of the BN_RECP, and, if it was created by BN_RECP_CTX_new(), also the structure itself.</p> <p>BN_RECP_CTX_set() stores m in recp and sets it up for computing 1/m and shifting it left by BN_num_bits(m)+1 to make it an integer. The result and the number of bits it was shifted left will later be stored in recp.</p> <p>BN_div_recp() divides a by m using recp. It places the quotient in dv and the remainder in rem.</p> <p>The BN_RECP_CTX structure is defined as follows:</p> <pre><code>typedef struct bn_recp_ctx_st\n       {\n       BIGNUM N;       /* the divisor */\n       BIGNUM Nr;      /* the reciprocal */\n       int num_bits;\n       int shift;\n       int flags;\n       } BN_RECP_CTX;\n</code></pre> <p>It cannot be shared between threads.</p>"},{"location":"man3/BN_mod_mul_reciprocal/#return-values","title":"RETURN VALUES","text":"<p>BN_RECP_CTX_new() returns the newly allocated BN_RECP_CTX, and NULL on error.</p> <p>BN_RECP_CTX_init() and BN_RECP_CTX_free() have no return values.</p> <p>For the other functions, 1 is returned for success, 0 on error. The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/BN_mod_mul_reciprocal/#see-also","title":"SEE ALSO","text":"<p>bn(3), ERR_get_error(3), BN_add(3), BN_CTX_new(3)</p>"},{"location":"man3/BN_mod_mul_reciprocal/#history","title":"HISTORY","text":"<p>BN_RECP_CTX was added in SSLeay 0.9.0. Before that, the function BN_reciprocal() was used instead, and the BN_mod_mul_reciprocal() arguments were different.</p>"},{"location":"man3/BN_new/","title":"BN_new","text":""},{"location":"man3/BN_new/#name","title":"NAME","text":"<p>BN_new, BN_init, BN_clear, BN_free, BN_clear_free - allocate and free BIGNUMs</p>"},{"location":"man3/BN_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nBIGNUM *BN_new(void);\n\nvoid BN_init(BIGNUM *);\n\nvoid BN_clear(BIGNUM *a);\n\nvoid BN_free(BIGNUM *a);\n\nvoid BN_clear_free(BIGNUM *a);\n</code></pre>"},{"location":"man3/BN_new/#description","title":"DESCRIPTION","text":"<p>BN_new() allocates and initializes a BIGNUM structure. BN_init() initializes an existing uninitialized BIGNUM.</p> <p>BN_clear() is used to destroy sensitive data such as keys when they are no longer needed. It erases the memory used by a and sets it to the value 0.</p> <p>BN_free() frees the components of the BIGNUM, and if it was created by BN_new(), also the structure itself. BN_clear_free() additionally overwrites the data before the memory is returned to the system. If a is NULL, nothing is done.</p>"},{"location":"man3/BN_new/#return-values","title":"RETURN VALUES","text":"<p>BN_new() returns a pointer to the BIGNUM initialised to the value 0. If the allocation fails, it returns NULL and sets an error code that can be obtained by ERR_get_error(3).</p> <p>BN_init(), BN_clear(), BN_free() and BN_clear_free() have no return values.</p>"},{"location":"man3/BN_new/#see-also","title":"SEE ALSO","text":"<p>bn(3), ERR_get_error(3)</p>"},{"location":"man3/BN_new/#history","title":"HISTORY","text":"<p>BN_new(), BN_clear(), BN_free() and BN_clear_free() are available in all versions on SSLeay and OpenSSL.  BN_init() was added in SSLeay 0.9.1b.</p>"},{"location":"man3/BN_num_bytes/","title":"BN_num_bytes","text":""},{"location":"man3/BN_num_bytes/#name","title":"NAME","text":"<p>BN_num_bits, BN_num_bytes, BN_num_bits_word - get BIGNUM size</p>"},{"location":"man3/BN_num_bytes/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nint BN_num_bytes(const BIGNUM *a);\n\nint BN_num_bits(const BIGNUM *a);\n\nint BN_num_bits_word(BN_ULONG w);\n</code></pre>"},{"location":"man3/BN_num_bytes/#description","title":"DESCRIPTION","text":"<p>BN_num_bytes() returns the size of a BIGNUM in bytes.</p> <p>BN_num_bits_word() returns the number of significant bits in a word. If we take 0x00000432 as an example, it returns 11, not 16, not 32. Basically, except for a zero, it returns floor(log2(w))+1.</p> <p>BN_num_bits() returns the number of significant bits in a BIGNUM, following the same principle as BN_num_bits_word().</p> <p>BN_num_bytes() is a macro.</p>"},{"location":"man3/BN_num_bytes/#return-values","title":"RETURN VALUES","text":"<p>The size.</p>"},{"location":"man3/BN_num_bytes/#notes","title":"NOTES","text":"<p>Some have tried using BN_num_bits() on individual numbers in RSA keys, DH keys and DSA keys, and found that they don't always come up with the number of bits they expected (something like 512, 1024, 2048, ...).  This is because generating a number with some specific number of bits doesn't always set the highest bits, thereby making the number of significant bits a little lower.  If you want to know the \"key size\" of such a key, either use functions like RSA_size(), DH_size() and DSA_size(), or use BN_num_bytes() and multiply with 8 (although there's no real guarantee that will match the \"key size\", just a lot more probability).</p>"},{"location":"man3/BN_num_bytes/#see-also","title":"SEE ALSO","text":"<p>bn(3), DH_size(3), DSA_size(3), RSA_size(3)</p>"},{"location":"man3/BN_num_bytes/#history","title":"HISTORY","text":"<p>BN_num_bytes(), BN_num_bits() and BN_num_bits_word() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/BN_rand/","title":"BN_rand","text":""},{"location":"man3/BN_rand/#name","title":"NAME","text":"<p>BN_rand, BN_pseudo_rand, BN_rand_range, BN_pseudo_rand_range - generate pseudo-random number</p>"},{"location":"man3/BN_rand/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nint BN_rand(BIGNUM *rnd, int bits, int top, int bottom);\n\nint BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);\n\nint BN_rand_range(BIGNUM *rnd, BIGNUM *range);\n\nint BN_pseudo_rand_range(BIGNUM *rnd, BIGNUM *range);\n</code></pre>"},{"location":"man3/BN_rand/#description","title":"DESCRIPTION","text":"<p>BN_rand() generates a cryptographically strong pseudo-random number of bits in length and stores it in rnd. If bits is less than zero, or too small to accomodate the requirements specified by the top and bottom parameters, an error is returned. If top is -1, the most significant bit of the random number can be zero. If top is 0, it is set to 1, and if top is 1, the two most significant bits of the number will be set to 1, so that the product of two such random numbers will always have 2*bits length.  If bottom is true, the number will be odd. The value of bits must be zero or greater. If bits is 1 then top cannot also be 1.</p> <p>BN_pseudo_rand() does the same, but pseudo-random numbers generated by this function are not necessarily unpredictable. They can be used for non-cryptographic purposes and for certain purposes in cryptographic protocols, but usually not for key generation etc.</p> <p>BN_rand_range() generates a cryptographically strong pseudo-random number rnd in the range 0 &lt;= rnd &lt; range. BN_pseudo_rand_range() does the same, but is based on BN_pseudo_rand(), and hence numbers generated by it are not necessarily unpredictable.</p> <p>The PRNG must be seeded prior to calling BN_rand() or BN_rand_range().</p>"},{"location":"man3/BN_rand/#return-values","title":"RETURN VALUES","text":"<p>The functions return 1 on success, 0 on error. The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/BN_rand/#see-also","title":"SEE ALSO","text":"<p>bn(3), ERR_get_error(3), rand(3), RAND_add(3), RAND_bytes(3)</p>"},{"location":"man3/BN_rand/#history","title":"HISTORY","text":"<p>BN_rand() is available in all versions of SSLeay and OpenSSL. BN_pseudo_rand() was added in OpenSSL 0.9.5. The top == -1 case and the function BN_rand_range() were added in OpenSSL 0.9.6a. BN_pseudo_rand_range() was added in OpenSSL 0.9.6c.</p>"},{"location":"man3/BN_set_bit/","title":"BN_set_bit","text":""},{"location":"man3/BN_set_bit/#name","title":"NAME","text":"<p>BN_set_bit, BN_clear_bit, BN_is_bit_set, BN_mask_bits, BN_lshift, BN_lshift1, BN_rshift, BN_rshift1 - bit operations on BIGNUMs</p>"},{"location":"man3/BN_set_bit/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nint BN_set_bit(BIGNUM *a, int n);\nint BN_clear_bit(BIGNUM *a, int n);\n\nint BN_is_bit_set(const BIGNUM *a, int n);\n\nint BN_mask_bits(BIGNUM *a, int n);\n\nint BN_lshift(BIGNUM *r, const BIGNUM *a, int n);\nint BN_lshift1(BIGNUM *r, BIGNUM *a);\n\nint BN_rshift(BIGNUM *r, BIGNUM *a, int n);\nint BN_rshift1(BIGNUM *r, BIGNUM *a);\n</code></pre>"},{"location":"man3/BN_set_bit/#description","title":"DESCRIPTION","text":"<p>BN_set_bit() sets bit n in a to 1 (<code>a|=(1&lt;&lt;n)</code>). The number is expanded if necessary.</p> <p>BN_clear_bit() sets bit n in a to 0 (<code>a&amp;=~(1&lt;&lt;n)</code>). An error occurs if a is shorter than n bits.</p> <p>BN_is_bit_set() tests if bit n in a is set.</p> <p>BN_mask_bits() truncates a to an n bit number (<code>a&amp;=~((~0)&gt;&gt;n)</code>).  An error occurs if a already is shorter than n bits.</p> <p>BN_lshift() shifts a left by n bits and places the result in r (<code>r=a*2^n</code>). Note that n must be non-negative. BN_lshift1() shifts a left by one and places the result in r (<code>r=2*a</code>).</p> <p>BN_rshift() shifts a right by n bits and places the result in r (<code>r=a/2^n</code>). Note that n must be non-negative. BN_rshift1() shifts a right by one and places the result in r (<code>r=a/2</code>).</p> <p>For the shift functions, r and a may be the same variable.</p>"},{"location":"man3/BN_set_bit/#return-values","title":"RETURN VALUES","text":"<p>BN_is_bit_set() returns 1 if the bit is set, 0 otherwise.</p> <p>All other functions return 1 for success, 0 on error. The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/BN_set_bit/#see-also","title":"SEE ALSO","text":"<p>bn(3), BN_num_bytes(3), BN_add(3)</p>"},{"location":"man3/BN_set_bit/#history","title":"HISTORY","text":"<p>BN_set_bit(), BN_clear_bit(), BN_is_bit_set(), BN_mask_bits(), BN_lshift(), BN_lshift1(), BN_rshift(), and BN_rshift1() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/BN_swap/","title":"BN_swap","text":""},{"location":"man3/BN_swap/#name","title":"NAME","text":"<p>BN_swap - exchange BIGNUMs</p>"},{"location":"man3/BN_swap/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nvoid BN_swap(BIGNUM *a, BIGNUM *b);\n</code></pre>"},{"location":"man3/BN_swap/#description","title":"DESCRIPTION","text":"<p>BN_swap() exchanges the values of a and b.</p> <p>bn(3)</p>"},{"location":"man3/BN_swap/#history","title":"HISTORY","text":"<p>BN_swap was added in OpenSSL 0.9.7.</p>"},{"location":"man3/BN_zero/","title":"BN_zero","text":""},{"location":"man3/BN_zero/#name","title":"NAME","text":"<p>BN_zero, BN_one, BN_value_one, BN_set_word, BN_get_word - BIGNUM assignment operations</p>"},{"location":"man3/BN_zero/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nint BN_zero(BIGNUM *a);\nint BN_one(BIGNUM *a);\n\nconst BIGNUM *BN_value_one(void);\n\nint BN_set_word(BIGNUM *a, BN_ULONG w);\nBN_ULONG BN_get_word(BIGNUM *a);\n</code></pre>"},{"location":"man3/BN_zero/#description","title":"DESCRIPTION","text":"<p>BN_ULONG is a macro that will be an unsigned integral type optimied for the most efficient implementation on the local platform.</p> <p>BN_zero(), BN_one() and BN_set_word() set a to the values 0, 1 and w respectively.  BN_zero() and BN_one() are macros.</p> <p>BN_value_one() returns a BIGNUM constant of value 1. This constant is useful for use in comparisons and assignment.</p> <p>BN_get_word() returns a, if it can be represented as a BN_ULONG.</p>"},{"location":"man3/BN_zero/#return-values","title":"RETURN VALUES","text":"<p>BN_get_word() returns the value a, or all-bits-set if a cannot be represented as a BN_ULONG.</p> <p>BN_zero(), BN_one() and BN_set_word() return 1 on success, 0 otherwise. BN_value_one() returns the constant.</p>"},{"location":"man3/BN_zero/#bugs","title":"BUGS","text":"<p>If a BIGNUM is equal to the value of all-bits-set, it will collide with the error condition returned by BN_get_word() which uses that as an error value.</p> <p>BN_ULONG should probably be a typedef.</p>"},{"location":"man3/BN_zero/#see-also","title":"SEE ALSO","text":"<p>bn(3), BN_bn2bin(3)</p>"},{"location":"man3/BN_zero/#history","title":"HISTORY","text":"<p>BN_zero(), BN_one() and BN_set_word() are available in all versions of SSLeay and OpenSSL. BN_value_one() and BN_get_word() were added in SSLeay 0.8.</p> <p>BN_value_one() was changed to return a true const BIGNUM * in OpenSSL 0.9.7.</p>"},{"location":"man3/CMS_add0_cert/","title":"CMS_add0_cert","text":""},{"location":"man3/CMS_add0_cert/#name","title":"NAME","text":"<p>CMS_add0_cert, CMS_add1_cert, CMS_get1_certs, CMS_add0_crl, CMS_add1_crl, CMS_get1_crls, - CMS certificate and CRL utility functions</p>"},{"location":"man3/CMS_add0_cert/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nint CMS_add0_cert(CMS_ContentInfo *cms, X509 *cert);\nint CMS_add1_cert(CMS_ContentInfo *cms, X509 *cert);\nSTACK_OF(X509) *CMS_get1_certs(CMS_ContentInfo *cms);\n\nint CMS_add0_crl(CMS_ContentInfo *cms, X509_CRL *crl);\nint CMS_add1_crl(CMS_ContentInfo *cms, X509_CRL *crl);\nSTACK_OF(X509_CRL) *CMS_get1_crls(CMS_ContentInfo *cms);\n</code></pre>"},{"location":"man3/CMS_add0_cert/#description","title":"DESCRIPTION","text":"<p>CMS_add0_cert() and CMS_add1_cert() add certificate cert to cms. must be of type signed data or enveloped data. </p> <p>CMS_get1_certs() returns all certificates in cms.</p> <p>CMS_add0_crl() and CMS_add1_crl() add CRL crl to cms. CMS_get1_crls() returns any CRLs in cms.</p>"},{"location":"man3/CMS_add0_cert/#notes","title":"NOTES","text":"<p>The CMS_ContentInfo structure cms must be of type signed data or enveloped data or an error will be returned.</p> <p>For signed data certificates and CRLs are added to the certificates and crls fields of SignedData structure. For enveloped data they are added to OriginatorInfo.</p> <p>As the 0 implies CMS_add0_cert() adds cert internally to cms and it must not be freed up after the call as opposed to CMS_add1_cert() where cert must be freed up.</p> <p>The same certificate or CRL must not be added to the same cms structure more than once.</p>"},{"location":"man3/CMS_add0_cert/#return-values","title":"RETURN VALUES","text":"<p>CMS_add0_cert(), CMS_add1_cert() and CMS_add0_crl() and CMS_add1_crl() return 1 for success and 0 for failure. </p> <p>CMS_get1_certs() and CMS_get1_crls() return the STACK of certificates or CRLs or NULL if there are none or an error occurs. The only error which will occur in practice is if the cms type is invalid.</p>"},{"location":"man3/CMS_add0_cert/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_sign(3), CMS_encrypt(3)</p>"},{"location":"man3/CMS_add0_cert/#history","title":"HISTORY","text":"<p>CMS_add0_cert(), CMS_add1_cert(), CMS_get1_certs(), CMS_add0_crl() and CMS_get1_crls() were all first added to OpenSSL 0.9.8</p>"},{"location":"man3/CMS_add1_recipient_cert/","title":"CMS_add1_recipient_cert","text":""},{"location":"man3/CMS_add1_recipient_cert/#name","title":"NAME","text":"<pre><code>CMS_add1_recipient_cert, CMS_add0_recipient_key - add recipients to a CMS enveloped data structure\n</code></pre>"},{"location":"man3/CMS_add1_recipient_cert/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nCMS_RecipientInfo *CMS_add1_recipient_cert(CMS_ContentInfo *cms, X509 *recip, unsigned int flags);\n\nCMS_RecipientInfo *CMS_add0_recipient_key(CMS_ContentInfo *cms, int nid, unsigned char *key, size_t keylen, unsigned char *id, size_t idlen, ASN1_GENERALIZEDTIME *date, ASN1_OBJECT *otherTypeId, ASN1_TYPE *otherType);\n</code></pre>"},{"location":"man3/CMS_add1_recipient_cert/#description","title":"DESCRIPTION","text":"<p>CMS_add1_recipient_cert() adds recipient recip to CMS_ContentInfo enveloped data structure cms as a KeyTransRecipientInfo structure.</p> <p>CMS_add0_recipient_key() adds symmetric key key of length keylen using wrapping algorithm nid, identifier id of length idlen and optional values date, otherTypeId and otherType to CMS_ContentInfo enveloped data structure cms as a KEKRecipientInfo structure.</p> <p>The CMS_ContentInfo structure should be obtained from an initial call to CMS_encrypt() with the flag CMS_PARTIAL set.</p>"},{"location":"man3/CMS_add1_recipient_cert/#notes","title":"NOTES","text":"<p>The main purpose of this function is to provide finer control over a CMS enveloped data structure where the simpler CMS_encrypt() function defaults are not appropriate. For example if one or more KEKRecipientInfo structures need to be added. New attributes can also be added using the returned CMS_RecipientInfo structure and the CMS attribute utility functions.</p> <p>OpenSSL will by default identify recipient certificates using issuer name and serial number. If CMS_USE_KEYID is set it will use the subject key identifier value instead. An error occurs if all recipient certificates do not have a subject key identifier extension.</p> <p>Currently only AES based key wrapping algorithms are supported for nid, specifically: NID_id_aes128_wrap, NID_id_aes192_wrap and NID_id_aes256_wrap. If nid is set to NID_undef then an AES wrap algorithm will be used consistent with keylen.</p>"},{"location":"man3/CMS_add1_recipient_cert/#return-values","title":"RETURN VALUES","text":"<p>CMS_add1_recipient_cert() and CMS_add0_recipient_key() return an internal pointer to the CMS_RecipientInfo structure just added or NULL if an error occurs.</p>"},{"location":"man3/CMS_add1_recipient_cert/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_decrypt(3), CMS_final(3),</p>"},{"location":"man3/CMS_add1_recipient_cert/#history","title":"HISTORY","text":"<p>CMS_add1_recipient_cert() and CMS_add0_recipient_key() were added to OpenSSL 0.9.8</p>"},{"location":"man3/CMS_add1_signer/","title":"CMS_add1_signer","text":""},{"location":"man3/CMS_add1_signer/#name","title":"NAME","text":"<pre><code>CMS_add1_signer, CMS_SignerInfo_sign - add a signer to a CMS_ContentInfo signed data structure.\n</code></pre>"},{"location":"man3/CMS_add1_signer/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nCMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms, X509 *signcert, EVP_PKEY *pkey, const EVP_MD *md, unsigned int flags);\n\nint CMS_SignerInfo_sign(CMS_SignerInfo *si);\n</code></pre>"},{"location":"man3/CMS_add1_signer/#description","title":"DESCRIPTION","text":"<p>CMS_add1_signer() adds a signer with certificate signcert and private key pkey using message digest md to CMS_ContentInfo SignedData structure cms.</p> <p>The CMS_ContentInfo structure should be obtained from an initial call to CMS_sign() with the flag CMS_PARTIAL set or in the case or re-signing a valid CMS_ContentInfo SignedData structure.</p> <p>If the md parameter is NULL then the default digest for the public key algorithm will be used.</p> <p>Unless the CMS_REUSE_DIGEST flag is set the returned CMS_ContentInfo structure is not complete and must be finalized either by streaming (if applicable) or a call to CMS_final().</p> <p>The CMS_SignerInfo_sign() function will explicitly sign a CMS_SignerInfo structure, its main use is when CMS_REUSE_DIGEST and CMS_PARTIAL flags are both set.</p>"},{"location":"man3/CMS_add1_signer/#notes","title":"NOTES","text":"<p>The main purpose of CMS_add1_signer() is to provide finer control over a CMS signed data structure where the simpler CMS_sign() function defaults are not appropriate. For example if multiple signers or non default digest algorithms are needed. New attributes can also be added using the returned CMS_SignerInfo structure and the CMS attribute utility functions or the CMS signed receipt request functions.</p> <p>Any of the following flags (ored together) can be passed in the flags parameter.</p> <p>If CMS_REUSE_DIGEST is set then an attempt is made to copy the content digest value from the CMS_ContentInfo structure: to add a signer to an existing structure.  An error occurs if a matching digest value cannot be found to copy. The returned CMS_ContentInfo structure will be valid and finalized when this flag is set.</p> <p>If CMS_PARTIAL is set in addition to CMS_REUSE_DIGEST then the  CMS_SignerInfo structure will not be finalized so additional attributes can be added. In this case an explicit call to CMS_SignerInfo_sign() is needed to finalize it.</p> <p>If CMS_NOCERTS is set the signer's certificate will not be included in the CMS_ContentInfo structure, the signer's certificate must still be supplied in the signcert parameter though. This can reduce the size of the signature if the signers certificate can be obtained by other means: for example a previously signed message.</p> <p>The SignedData structure includes several CMS signedAttributes including the signing time, the CMS content type and the supported list of ciphers in an SMIMECapabilities attribute. If CMS_NOATTR is set then no signedAttributes will be used. If CMS_NOSMIMECAP is set then just the SMIMECapabilities are omitted.</p> <p>OpenSSL will by default identify signing certificates using issuer name and serial number. If CMS_USE_KEYID is set it will use the subject key identifier value instead. An error occurs if the signing certificate does not have a subject key identifier extension.</p> <p>If present the SMIMECapabilities attribute indicates support for the following algorithms in preference order: 256 bit AES, Gost R3411-94, Gost 28147-89, 192 bit AES, 128 bit AES, triple DES, 128 bit RC2, 64 bit RC2, DES and 40 bit RC2. If any of these algorithms is not available then it will not be included: for example the GOST algorithms will not be included if the GOST ENGINE is not loaded.</p> <p>CMS_add1_signer() returns an internal pointer to the CMS_SignerInfo structure just added, this can be used to set additional attributes  before it is finalized.</p>"},{"location":"man3/CMS_add1_signer/#return-values","title":"RETURN VALUES","text":"<p>CMS_add1_signer() returns an internal pointer to the CMS_SignerInfo structure just added or NULL if an error occurs.</p>"},{"location":"man3/CMS_add1_signer/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_sign(3), CMS_final(3),</p>"},{"location":"man3/CMS_add1_signer/#history","title":"HISTORY","text":"<p>CMS_add1_signer() was added to OpenSSL 0.9.8</p>"},{"location":"man3/CMS_compress/","title":"CMS_compress","text":""},{"location":"man3/CMS_compress/#name","title":"NAME","text":"<p>CMS_compress - create a CMS CompressedData structure</p>"},{"location":"man3/CMS_compress/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nCMS_ContentInfo *CMS_compress(BIO *in, int comp_nid, unsigned int flags);\n</code></pre>"},{"location":"man3/CMS_compress/#description","title":"DESCRIPTION","text":"<p>CMS_compress() creates and returns a CMS CompressedData structure. comp_nid is the compression algorithm to use or NID_undef to use the default algorithm (zlib compression). in is the content to be compressed. flags is an optional set of flags.</p>"},{"location":"man3/CMS_compress/#notes","title":"NOTES","text":"<p>The only currently supported compression algorithm is zlib using the NID NID_zlib_compression.</p> <p>If zlib support is not compiled into OpenSSL then CMS_compress() will return an error.</p> <p>If the CMS_TEXT flag is set MIME headers for type text/plain are prepended to the data.</p> <p>Normally the supplied content is translated into MIME canonical format (as required by the S/MIME specifications) if CMS_BINARY is set no translation occurs. This option should be used if the supplied data is in binary format otherwise the translation will corrupt it. If CMS_BINARY is set then CMS_TEXT is ignored.</p> <p>If the CMS_STREAM flag is set a partial CMS_ContentInfo structure is returned suitable for streaming I/O: no data is read from the BIO in.</p> <p>The compressed data is included in the CMS_ContentInfo structure, unless CMS_DETACHED is set in which case it is omitted. This is rarely used in practice and is not supported by SMIME_write_CMS().</p>"},{"location":"man3/CMS_compress/#notes_1","title":"NOTES","text":"<p>If the flag CMS_STREAM is set the returned CMS_ContentInfo structure is not complete and outputting its contents via a function that does not properly finalize the CMS_ContentInfo structure will give unpredictable results.</p> <p>Several functions including SMIME_write_CMS(), i2d_CMS_bio_stream(), PEM_write_bio_CMS_stream() finalize the structure. Alternatively finalization can be performed by obtaining the streaming ASN1 BIO directly using BIO_new_CMS().</p> <p>Additional compression parameters such as the zlib compression level cannot currently be set.</p>"},{"location":"man3/CMS_compress/#return-values","title":"RETURN VALUES","text":"<p>CMS_compress() returns either a CMS_ContentInfo structure or NULL if an error occurred. The error can be obtained from ERR_get_error(3).</p>"},{"location":"man3/CMS_compress/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_uncompress(3)</p>"},{"location":"man3/CMS_compress/#history","title":"HISTORY","text":"<p>CMS_compress() was added to OpenSSL 0.9.8 The CMS_STREAM flag was first supported in OpenSSL 1.0.0.</p>"},{"location":"man3/CMS_decrypt/","title":"CMS_decrypt","text":""},{"location":"man3/CMS_decrypt/#name","title":"NAME","text":"<pre><code>CMS_decrypt - decrypt content from a CMS envelopedData structure\n</code></pre>"},{"location":"man3/CMS_decrypt/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nint CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pkey, X509 *cert, BIO *dcont, BIO *out, unsigned int flags);\n</code></pre>"},{"location":"man3/CMS_decrypt/#description","title":"DESCRIPTION","text":"<p>CMS_decrypt() extracts and decrypts the content from a CMS EnvelopedData structure. pkey is the private key of the recipient, cert is the recipient's certificate, out is a BIO to write the content to and flags is an optional set of flags.</p> <p>The dcont parameter is used in the rare case where the encrypted content is detached. It will normally be set to NULL.</p>"},{"location":"man3/CMS_decrypt/#notes","title":"NOTES","text":"<p>OpenSSL_add_all_algorithms() (or equivalent) should be called before using this function or errors about unknown algorithms will occur.</p> <p>Although the recipients certificate is not needed to decrypt the data it is needed to locate the appropriate (of possible several) recipients in the CMS structure.</p> <p>If cert is set to NULL all possible recipients are tried. This case however is problematic. To thwart the MMA attack (Bleichenbacher's attack on PKCS #1 v1.5 RSA padding) all recipients are tried whether they succeed or not. If no recipient succeeds then a random symmetric key is used to decrypt the content: this will typically output garbage and may (but is not guaranteed to) ultimately return a padding error only. If CMS_decrypt() just returned an error when all recipient encrypted keys failed to decrypt an attacker could use this in a timing attack. If the special flag CMS_DEBUG_DECRYPT is set then the above behaviour is modified and an error is returned if no recipient encrypted key can be decrypted without generating a random content encryption key. Applications should use this flag with extreme caution especially in automated gateways as it can leave them open to attack.</p> <p>It is possible to determine the correct recipient key by other means (for example looking them up in a database) and setting them in the CMS structure in advance using the CMS utility functions such as CMS_set1_pkey(). In this case both cert and pkey should be set to NULL.</p> <p>To process KEKRecipientInfo types CMS_set1_key() or CMS_RecipientInfo_set0_key() and CMS_ReceipientInfo_decrypt() should be called before CMS_decrypt() and cert and pkey set to NULL.</p> <p>The following flags can be passed in the flags parameter.</p> <p>If the CMS_TEXT flag is set MIME headers for type text/plain are deleted from the content. If the content is not of type text/plain then an error is returned.</p>"},{"location":"man3/CMS_decrypt/#return-values","title":"RETURN VALUES","text":"<p>CMS_decrypt() returns either 1 for success or 0 for failure. The error can be obtained from ERR_get_error(3)</p>"},{"location":"man3/CMS_decrypt/#bugs","title":"BUGS","text":"<p>The lack of single pass processing and the need to hold all data in memory as mentioned in CMS_verify() also applies to CMS_decrypt().</p>"},{"location":"man3/CMS_decrypt/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_encrypt(3)</p>"},{"location":"man3/CMS_decrypt/#history","title":"HISTORY","text":"<p>CMS_decrypt() was added to OpenSSL 0.9.8</p>"},{"location":"man3/CMS_encrypt/","title":"CMS_encrypt","text":""},{"location":"man3/CMS_encrypt/#name","title":"NAME","text":"<pre><code>CMS_encrypt - create a CMS envelopedData structure\n</code></pre>"},{"location":"man3/CMS_encrypt/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nCMS_ContentInfo *CMS_encrypt(STACK_OF(X509) *certs, BIO *in, const EVP_CIPHER *cipher, unsigned int flags);\n</code></pre>"},{"location":"man3/CMS_encrypt/#description","title":"DESCRIPTION","text":"<p>CMS_encrypt() creates and returns a CMS EnvelopedData structure. certs is a list of recipient certificates. in is the content to be encrypted. cipher is the symmetric cipher to use. flags is an optional set of flags.</p>"},{"location":"man3/CMS_encrypt/#notes","title":"NOTES","text":"<p>Only certificates carrying RSA, Diffie-Hellman or EC keys are supported by this function.</p> <p>EVP_des_ede3_cbc() (triple DES) is the algorithm of choice for S/MIME use because most clients will support it.</p> <p>The algorithm passed in the cipher parameter must support ASN1 encoding of its parameters. </p> <p>Many browsers implement a \"sign and encrypt\" option which is simply an S/MIME envelopedData containing an S/MIME signed message. This can be readily produced by storing the S/MIME signed message in a memory BIO and passing it to CMS_encrypt().</p> <p>The following flags can be passed in the flags parameter.</p> <p>If the CMS_TEXT flag is set MIME headers for type text/plain are prepended to the data.</p> <p>Normally the supplied content is translated into MIME canonical format (as required by the S/MIME specifications) if CMS_BINARY is set no translation occurs. This option should be used if the supplied data is in binary format otherwise the translation will corrupt it. If CMS_BINARY is set then CMS_TEXT is ignored.</p> <p>OpenSSL will by default identify recipient certificates using issuer name and serial number. If CMS_USE_KEYID is set it will use the subject key identifier value instead. An error occurs if all recipient certificates do not have a subject key identifier extension.</p> <p>If the CMS_STREAM flag is set a partial CMS_ContentInfo structure is returned suitable for streaming I/O: no data is read from the BIO in.</p> <p>If the CMS_PARTIAL flag is set a partial CMS_ContentInfo structure is returned to which additional recipients and attributes can be added before finalization.</p> <p>The data being encrypted is included in the CMS_ContentInfo structure, unless CMS_DETACHED is set in which case it is omitted. This is rarely used in practice and is not supported by SMIME_write_CMS().</p>"},{"location":"man3/CMS_encrypt/#notes_1","title":"NOTES","text":"<p>If the flag CMS_STREAM is set the returned CMS_ContentInfo structure is not complete and outputting its contents via a function that does not properly finalize the CMS_ContentInfo structure will give unpredictable results.</p> <p>Several functions including SMIME_write_CMS(), i2d_CMS_bio_stream(), PEM_write_bio_CMS_stream() finalize the structure. Alternatively finalization can be performed by obtaining the streaming ASN1 BIO directly using BIO_new_CMS().</p> <p>The recipients specified in certs use a CMS KeyTransRecipientInfo info structure. KEKRecipientInfo is also supported using the flag CMS_PARTIAL and CMS_add0_recipient_key().</p> <p>The parameter certs may be NULL if CMS_PARTIAL is set and recipients added later using CMS_add1_recipient_cert() or CMS_add0_recipient_key().</p>"},{"location":"man3/CMS_encrypt/#return-values","title":"RETURN VALUES","text":"<p>CMS_encrypt() returns either a CMS_ContentInfo structure or NULL if an error occurred. The error can be obtained from ERR_get_error(3).</p>"},{"location":"man3/CMS_encrypt/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_decrypt(3)</p>"},{"location":"man3/CMS_encrypt/#history","title":"HISTORY","text":"<p>CMS_decrypt() was added to OpenSSL 0.9.8 The CMS_STREAM flag was first supported in OpenSSL 1.0.0.</p>"},{"location":"man3/CMS_final/","title":"CMS_final","text":""},{"location":"man3/CMS_final/#name","title":"NAME","text":"<pre><code>CMS_final - finalise a CMS_ContentInfo structure\n</code></pre>"},{"location":"man3/CMS_final/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nint CMS_final(CMS_ContentInfo *cms, BIO *data, BIO *dcont, unsigned int flags);\n</code></pre>"},{"location":"man3/CMS_final/#description","title":"DESCRIPTION","text":"<p>CMS_final() finalises the structure cms. It's purpose is to perform any operations necessary on cms (digest computation for example) and set the appropriate fields. The parameter data contains the content to be  processed. The dcont parameter contains a BIO to write content to after processing: this is only used with detached data and will usually be set to NULL.</p>"},{"location":"man3/CMS_final/#notes","title":"NOTES","text":"<p>This function will normally be called when the CMS_PARTIAL flag is used. It should only be used when streaming is not performed because the streaming I/O functions perform finalisation operations internally.</p>"},{"location":"man3/CMS_final/#return-values","title":"RETURN VALUES","text":"<p>CMS_final() returns 1 for success or 0 for failure.</p>"},{"location":"man3/CMS_final/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_sign(3), CMS_encrypt(3)</p>"},{"location":"man3/CMS_final/#history","title":"HISTORY","text":"<p>CMS_final() was added to OpenSSL 0.9.8</p>"},{"location":"man3/CMS_get0_RecipientInfos/","title":"CMS_get0_RecipientInfos","text":""},{"location":"man3/CMS_get0_RecipientInfos/#name","title":"NAME","text":"<p>CMS_get0_RecipientInfos, CMS_RecipientInfo_type, CMS_RecipientInfo_ktri_get0_signer_id,CMS_RecipientInfo_ktri_cert_cmp, CMS_RecipientInfo_set0_pkey, CMS_RecipientInfo_kekri_get0_id, CMS_RecipientInfo_kekri_id_cmp, CMS_RecipientInfo_set0_key, CMS_RecipientInfo_decrypt, CMS_RecipientInfo_encrypt - CMS envelopedData RecipientInfo routines</p>"},{"location":"man3/CMS_get0_RecipientInfos/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nSTACK_OF(CMS_RecipientInfo) *CMS_get0_RecipientInfos(CMS_ContentInfo *cms);\nint CMS_RecipientInfo_type(CMS_RecipientInfo *ri);\n\nint CMS_RecipientInfo_ktri_get0_signer_id(CMS_RecipientInfo *ri, ASN1_OCTET_STRING **keyid, X509_NAME **issuer, ASN1_INTEGER **sno);\nint CMS_RecipientInfo_ktri_cert_cmp(CMS_RecipientInfo *ri, X509 *cert);\nint CMS_RecipientInfo_set0_pkey(CMS_RecipientInfo *ri, EVP_PKEY *pkey);\n\nint CMS_RecipientInfo_kekri_get0_id(CMS_RecipientInfo *ri, X509_ALGOR **palg, ASN1_OCTET_STRING **pid, ASN1_GENERALIZEDTIME **pdate, ASN1_OBJECT **potherid, ASN1_TYPE **pothertype);\nint CMS_RecipientInfo_kekri_id_cmp(CMS_RecipientInfo *ri, const unsigned char *id, size_t idlen);\nint CMS_RecipientInfo_set0_key(CMS_RecipientInfo *ri, unsigned char *key, size_t keylen);\n\nint CMS_RecipientInfo_decrypt(CMS_ContentInfo *cms, CMS_RecipientInfo *ri);\nint CMS_RecipientInfo_encrypt(CMS_ContentInfo *cms, CMS_RecipientInfo *ri);\n</code></pre>"},{"location":"man3/CMS_get0_RecipientInfos/#description","title":"DESCRIPTION","text":"<p>The function CMS_get0_RecipientInfos() returns all the CMS_RecipientInfo structures associated with a CMS EnvelopedData structure.</p> <p>CMS_RecipientInfo_type() returns the type of CMS_RecipientInfo structure ri. It will currently return CMS_RECIPINFO_TRANS, CMS_RECIPINFO_AGREE, CMS_RECIPINFO_KEK, CMS_RECIPINFO_PASS, or CMS_RECIPINFO_OTHER.</p> <p>CMS_RecipientInfo_ktri_get0_signer_id() retrieves the certificate recipient identifier associated with a specific CMS_RecipientInfo structure ri, which must be of type CMS_RECIPINFO_TRANS. Either the keyidentifier will be set in keyid or both issuer name and serial number in issuer and sno. </p> <p>CMS_RecipientInfo_ktri_cert_cmp() compares the certificate cert against the CMS_RecipientInfo structure ri, which must be of type CMS_RECIPINFO_TRANS. It returns zero if the comparison is successful and non zero if not.</p> <p>CMS_RecipientInfo_set0_pkey() associates the private key pkey with the CMS_RecipientInfo structure ri, which must be of type CMS_RECIPINFO_TRANS.</p> <p>CMS_RecipientInfo_kekri_get0_id() retrieves the key information from the CMS_RecipientInfo structure ri which must be of type CMS_RECIPINFO_KEK.  Any of the remaining parameters can be NULL if the application is not interested in the value of a field. Where a field is optional and absent NULL will be written to the corresponding parameter. The keyEncryptionAlgorithm field is written to palg, the keyIdentifier field is written to pid, the date field if present is written to pdate, if the other field is present the components keyAttrId and keyAttr are written to parameters potherid and pothertype.</p> <p>CMS_RecipientInfo_kekri_id_cmp() compares the ID in the id and idlen parameters against the keyIdentifier CMS_RecipientInfo structure ri, which must be of type CMS_RECIPINFO_KEK.  It returns zero if the comparison is successful and non zero if not.</p> <p>CMS_RecipientInfo_set0_key() associates the symmetric key key of length keylen with the CMS_RecipientInfo structure ri, which must be of type CMS_RECIPINFO_KEK.</p> <p>CMS_RecipientInfo_decrypt() attempts to decrypt CMS_RecipientInfo structure ri in structure cms. A key must have been associated with the structure first.</p> <p>CMS_RecipientInfo_encrypt() attempts to encrypt CMS_RecipientInfo structure ri in structure cms. A key must have been associated with the structure first and the content encryption key must be available: for example by a previous call to CMS_RecipientInfo_decrypt().</p>"},{"location":"man3/CMS_get0_RecipientInfos/#notes","title":"NOTES","text":"<p>The main purpose of these functions is to enable an application to lookup recipient keys using any appropriate technique when the simpler method of CMS_decrypt() is not appropriate.</p> <p>In typical usage and application will retrieve all CMS_RecipientInfo structures using CMS_get0_RecipientInfos() and check the type of each using CMS_RecpientInfo_type(). Depending on the type the CMS_RecipientInfo structure can be ignored or its key identifier data retrieved using an appropriate function. Then if the corresponding secret or private key can be obtained by any appropriate means it can then associated with the structure and CMS_RecpientInfo_decrypt() called. If successful CMS_decrypt() can be called with a NULL key to decrypt the enveloped content.</p> <p>The CMS_RecipientInfo_encrypt() can be used to add a new recipient to an existing enveloped data structure. Typically an application will first decrypt an appropriate CMS_RecipientInfo structure to make the content encrypt key available, it will then add a new recipient using a function such as CMS_add1_recipient_cert() and finally encrypt the content encryption key using CMS_RecipientInfo_encrypt().</p>"},{"location":"man3/CMS_get0_RecipientInfos/#return-values","title":"RETURN VALUES","text":"<p>CMS_get0_RecipientInfos() returns all CMS_RecipientInfo structures, or NULL if an error occurs.</p> <p>CMS_RecipientInfo_ktri_get0_signer_id(), CMS_RecipientInfo_set0_pkey(), CMS_RecipientInfo_kekri_get0_id(), CMS_RecipientInfo_set0_key() and CMS_RecipientInfo_decrypt() return 1 for success or 0 if an error occurs. CMS_RecipientInfo_encrypt() return 1 for success or 0 if an error occurs.</p> <p>CMS_RecipientInfo_ktri_cert_cmp() and CMS_RecipientInfo_kekri_cmp() return 0 for a successful comparison and non zero otherwise.</p> <p>Any error can be obtained from ERR_get_error(3).</p>"},{"location":"man3/CMS_get0_RecipientInfos/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_decrypt(3)</p>"},{"location":"man3/CMS_get0_RecipientInfos/#history","title":"HISTORY","text":"<p>These functions were first was added to OpenSSL 0.9.8</p>"},{"location":"man3/CMS_get0_SignerInfos/","title":"CMS_get0_SignerInfos","text":""},{"location":"man3/CMS_get0_SignerInfos/#name","title":"NAME","text":"<p>CMS_get0_SignerInfos, CMS_SignerInfo_get0_signer_id, CMS_SignerInfo_get0_signature, CMS_SignerInfo_cert_cmp, CMS_set1_signer_cert - CMS signedData signer functions.</p>"},{"location":"man3/CMS_get0_SignerInfos/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nSTACK_OF(CMS_SignerInfo) *CMS_get0_SignerInfos(CMS_ContentInfo *cms);\n\nint CMS_SignerInfo_get0_signer_id(CMS_SignerInfo *si, ASN1_OCTET_STRING **keyid, X509_NAME **issuer, ASN1_INTEGER **sno);\nASN1_OCTET_STRING *CMS_SignerInfo_get0_signature(CMS_SignerInfo *si);\nint CMS_SignerInfo_cert_cmp(CMS_SignerInfo *si, X509 *cert);\nvoid CMS_SignerInfo_set1_signer_cert(CMS_SignerInfo *si, X509 *signer);\n</code></pre>"},{"location":"man3/CMS_get0_SignerInfos/#description","title":"DESCRIPTION","text":"<p>The function CMS_get0_SignerInfos() returns all the CMS_SignerInfo structures associated with a CMS signedData structure.</p> <p>CMS_SignerInfo_get0_signer_id() retrieves the certificate signer identifier associated with a specific CMS_SignerInfo structure si. Either the keyidentifier will be set in keyid or both issuer name and serial number in issuer and sno.</p> <p>CMS_SignerInfo_get0_signature() retrieves the signature associated with  si in a pointer to an ASN1_OCTET_STRING structure. This pointer returned corresponds to the internal signature value if si so it may be read or modified.</p> <p>CMS_SignerInfo_cert_cmp() compares the certificate cert against the signer identifier si. It returns zero if the comparison is successful and non zero if not.</p> <p>CMS_SignerInfo_set1_signer_cert() sets the signers certificate of si to signer.</p>"},{"location":"man3/CMS_get0_SignerInfos/#notes","title":"NOTES","text":"<p>The main purpose of these functions is to enable an application to lookup signers certificates using any appropriate technique when the simpler method of CMS_verify() is not appropriate.</p> <p>In typical usage and application will retrieve all CMS_SignerInfo structures using CMS_get0_SignerInfo() and retrieve the identifier information using CMS. It will then obtain the signer certificate by some unspecified means (or return and error if it cannot be found) and set it using CMS_SignerInfo_set1_signer_cert().</p> <p>Once all signer certificates have been set CMS_verify() can be used.</p> <p>Although CMS_get0_SignerInfos() can return NULL if an error occurs or if there are no signers this is not a problem in practice because the only error which can occur is if the cms structure is not of type signedData due to application error.</p>"},{"location":"man3/CMS_get0_SignerInfos/#return-values","title":"RETURN VALUES","text":"<p>CMS_get0_SignerInfos() returns all CMS_SignerInfo structures, or NULL there are no signers or an error occurs.</p> <p>CMS_SignerInfo_get0_signer_id() returns 1 for success and 0 for failure.</p> <p>CMS_SignerInfo_cert_cmp() returns 0 for a successful comparison and non zero otherwise.</p> <p>CMS_SignerInfo_set1_signer_cert() does not return a value.</p> <p>Any error can be obtained from ERR_get_error(3)</p>"},{"location":"man3/CMS_get0_SignerInfos/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_verify(3)</p>"},{"location":"man3/CMS_get0_SignerInfos/#history","title":"HISTORY","text":"<p>These functions were first was added to OpenSSL 0.9.8</p>"},{"location":"man3/CMS_get0_type/","title":"CMS_get0_type","text":""},{"location":"man3/CMS_get0_type/#name","title":"NAME","text":"<pre><code>CMS_get0_type, CMS_set1_eContentType, CMS_get0_eContentType, CMS_get0_content - get and set CMS content types and content\n</code></pre>"},{"location":"man3/CMS_get0_type/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nconst ASN1_OBJECT *CMS_get0_type(CMS_ContentInfo *cms);\nint CMS_set1_eContentType(CMS_ContentInfo *cms, const ASN1_OBJECT *oid);\nconst ASN1_OBJECT *CMS_get0_eContentType(CMS_ContentInfo *cms);\nASN1_OCTET_STRING **CMS_get0_content(CMS_ContentInfo *cms);\n</code></pre>"},{"location":"man3/CMS_get0_type/#description","title":"DESCRIPTION","text":"<p>CMS_get0_type() returns the content type of a CMS_ContentInfo structure as and ASN1_OBJECT pointer. An application can then decide how to process the CMS_ContentInfo structure based on this value.</p> <p>CMS_set1_eContentType() sets the embedded content type of a CMS_ContentInfo structure. It should be called with CMS functions with the CMS_PARTIAL flag and before the structure is finalised, otherwise the results are undefined.</p> <p>ASN1_OBJECT *CMS_get0_eContentType() returns a pointer to the embedded content type.</p> <p>CMS_get0_content() returns a pointer to the ASN1_OCTET_STRING pointer containing the embedded content.</p>"},{"location":"man3/CMS_get0_type/#notes","title":"NOTES","text":"<p>As the 0 implies CMS_get0_type(), CMS_get0_eContentType() and CMS_get0_content() return internal pointers which should not be freed up. CMS_set1_eContentType() copies the supplied OID and it should be freed up after use.</p> <p>The ASN1_OBJECT values returned can be converted to an integer NID value using OBJ_obj2nid(). For the currently supported content types the following values are returned:</p> <pre><code>NID_pkcs7_data\nNID_pkcs7_signed\nNID_pkcs7_digest\nNID_id_smime_ct_compressedData:\nNID_pkcs7_encrypted\nNID_pkcs7_enveloped\n</code></pre> <p>The return value of CMS_get0_content() is a pointer to the ASN1_OCTET_STRING content pointer. That means that for example:</p> <pre><code>ASN1_OCTET_STRING **pconf = CMS_get0_content(cms);\n</code></pre> <p>*pconf could be NULL if there is no embedded content. Applications can access, modify or create the embedded content in a CMS_ContentInfo structure using this function. Applications usually will not need to modify the embedded content as it is normally set by higher level functions.</p>"},{"location":"man3/CMS_get0_type/#return-values","title":"RETURN VALUES","text":"<p>CMS_get0_type() and CMS_get0_eContentType() return and ASN1_OBJECT structure.</p> <p>CMS_set1_eContentType() returns 1 for success or 0 if an error occurred.  The error can be obtained from ERR_get_error(3).</p>"},{"location":"man3/CMS_get0_type/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3)</p>"},{"location":"man3/CMS_get0_type/#history","title":"HISTORY","text":"<p>CMS_get0_type(), CMS_set1_eContentType() and CMS_get0_eContentType() were all first added to OpenSSL 0.9.8</p>"},{"location":"man3/CMS_get1_ReceiptRequest/","title":"CMS_get1_ReceiptRequest","text":""},{"location":"man3/CMS_get1_ReceiptRequest/#name","title":"NAME","text":"<pre><code>CMS_ReceiptRequest_create0, CMS_add1_ReceiptRequest, CMS_get1_ReceiptRequest, CMS_ReceiptRequest_get0_values - CMS signed receipt request functions.\n</code></pre>"},{"location":"man3/CMS_get1_ReceiptRequest/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nCMS_ReceiptRequest *CMS_ReceiptRequest_create0(unsigned char *id, int idlen, int allorfirst, STACK_OF(GENERAL_NAMES) *receiptList, STACK_OF(GENERAL_NAMES) *receiptsTo);\nint CMS_add1_ReceiptRequest(CMS_SignerInfo *si, CMS_ReceiptRequest *rr);\nint CMS_get1_ReceiptRequest(CMS_SignerInfo *si, CMS_ReceiptRequest **prr);\nvoid CMS_ReceiptRequest_get0_values(CMS_ReceiptRequest *rr, ASN1_STRING **pcid, int *pallorfirst, STACK_OF(GENERAL_NAMES) **plist, STACK_OF(GENERAL_NAMES) **prto);\n</code></pre>"},{"location":"man3/CMS_get1_ReceiptRequest/#description","title":"DESCRIPTION","text":"<p>CMS_ReceiptRequest_create0() creates a signed receipt request structure. The signedContentIdentifier field is set using id and idlen, or it is set to 32 bytes of pseudo random data if id is NULL. If receiptList is NULL the allOrFirstTier option in receiptsFrom is used and set to the value of the allorfirst parameter. If receiptList is not NULL the receiptList option in receiptsFrom is used. The receiptsTo parameter specifies the receiptsTo field value.</p> <p>The CMS_add1_ReceiptRequest() function adds a signed receipt request rr to SignerInfo structure si.</p> <p>int CMS_get1_ReceiptRequest() looks for a signed receipt request in si, if any is found it is decoded and written to prr.</p> <p>CMS_ReceiptRequest_get0_values() retrieves the values of a receipt request. The signedContentIdentifier is copied to pcid. If the allOrFirstTier option of receiptsFrom is used its value is copied to pallorfirst otherwise the receiptList field is copied to plist. The receiptsTo parameter is copied to prto.</p>"},{"location":"man3/CMS_get1_ReceiptRequest/#notes","title":"NOTES","text":"<p>For more details of the meaning of the fields see RFC2634.</p> <p>The contents of a signed receipt should only be considered meaningful if the corresponding CMS_ContentInfo structure can be successfully verified using CMS_verify().</p>"},{"location":"man3/CMS_get1_ReceiptRequest/#return-values","title":"RETURN VALUES","text":"<p>CMS_ReceiptRequest_create0() returns a signed receipt request structure or  NULL if an error occurred.</p> <p>CMS_add1_ReceiptRequest() returns 1 for success or 0 if an error occurred.</p> <p>CMS_get1_ReceiptRequest() returns 1 is a signed receipt request is found and decoded. It returns 0 if a signed receipt request is not present and -1 if it is present but malformed.</p>"},{"location":"man3/CMS_get1_ReceiptRequest/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_sign(3), CMS_sign_receipt(3), CMS_verify(3) CMS_verify_receipt(3)</p>"},{"location":"man3/CMS_get1_ReceiptRequest/#history","title":"HISTORY","text":"<p>CMS_ReceiptRequest_create0(), CMS_add1_ReceiptRequest(), CMS_get1_ReceiptRequest() and CMS_ReceiptRequest_get0_values() were added to OpenSSL 0.9.8</p>"},{"location":"man3/CMS_sign/","title":"CMS_sign","text":""},{"location":"man3/CMS_sign/#name","title":"NAME","text":"<pre><code>CMS_sign - create a CMS SignedData structure\n</code></pre>"},{"location":"man3/CMS_sign/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nCMS_ContentInfo *CMS_sign(X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs, BIO *data, unsigned int flags);\n</code></pre>"},{"location":"man3/CMS_sign/#description","title":"DESCRIPTION","text":"<p>CMS_sign() creates and returns a CMS SignedData structure. signcert is the certificate to sign with, pkey is the corresponding private key. certs is an optional additional set of certificates to include in the CMS structure (for example any intermediate CAs in the chain). Any or all of these parameters can be NULL, see NOTES below.</p> <p>The data to be signed is read from BIO data.</p> <p>flags is an optional set of flags.</p>"},{"location":"man3/CMS_sign/#notes","title":"NOTES","text":"<p>Any of the following flags (ored together) can be passed in the flags parameter.</p> <p>Many S/MIME clients expect the signed content to include valid MIME headers. If the CMS_TEXT flag is set MIME headers for type text/plain are prepended to the data.</p> <p>If CMS_NOCERTS is set the signer's certificate will not be included in the CMS_ContentInfo structure, the signer's certificate must still be supplied in the signcert parameter though. This can reduce the size of the signature if the signers certificate can be obtained by other means: for example a previously signed message.</p> <p>The data being signed is included in the CMS_ContentInfo structure, unless CMS_DETACHED is set in which case it is omitted. This is used for CMS_ContentInfo detached signatures which are used in S/MIME plaintext signed messages for example.</p> <p>Normally the supplied content is translated into MIME canonical format (as required by the S/MIME specifications) if CMS_BINARY is set no translation occurs. This option should be used if the supplied data is in binary format otherwise the translation will corrupt it.</p> <p>The SignedData structure includes several CMS signedAttributes including the signing time, the CMS content type and the supported list of ciphers in an SMIMECapabilities attribute. If CMS_NOATTR is set then no signedAttributes will be used. If CMS_NOSMIMECAP is set then just the SMIMECapabilities are omitted.</p> <p>If present the SMIMECapabilities attribute indicates support for the following algorithms in preference order: 256 bit AES, Gost R3411-94, Gost 28147-89, 192 bit AES, 128 bit AES, triple DES, 128 bit RC2, 64 bit RC2, DES and 40 bit RC2. If any of these algorithms is not available then it will not be included: for example the GOST algorithms will not be included if the GOST ENGINE is not loaded.</p> <p>OpenSSL will by default identify signing certificates using issuer name and serial number. If CMS_USE_KEYID is set it will use the subject key identifier value instead. An error occurs if the signing certificate does not have a subject key identifier extension.</p> <p>If the flags CMS_STREAM is set then the returned CMS_ContentInfo structure is just initialized ready to perform the signing operation. The signing is however not performed and the data to be signed is not read from the data parameter. Signing is deferred until after the data has been written. In this way data can be signed in a single pass.</p> <p>If the CMS_PARTIAL flag is set a partial CMS_ContentInfo structure is output to which additional signers and capabilities can be added before finalization.</p> <p>If the flag CMS_STREAM is set the returned CMS_ContentInfo structure is not complete and outputting its contents via a function that does not properly finalize the CMS_ContentInfo structure will give unpredictable results.</p> <p>Several functions including SMIME_write_CMS(), i2d_CMS_bio_stream(), PEM_write_bio_CMS_stream() finalize the structure. Alternatively finalization can be performed by obtaining the streaming ASN1 BIO directly using BIO_new_CMS().</p> <p>If a signer is specified it will use the default digest for the signing algorithm. This is SHA1 for both RSA and DSA keys.</p> <p>If signcert and pkey are NULL then a certificates only CMS structure is output.</p> <p>The function CMS_sign() is a basic CMS signing function whose output will be suitable for many purposes. For finer control of the output format the certs, signcert and pkey parameters can all be NULL and the CMS_PARTIAL flag set. Then one or more signers can be added using the function CMS_sign_add1_signer(), non default digests can be used and custom attributes added. CMS_final() must then be called to finalize the structure if streaming is not enabled. </p>"},{"location":"man3/CMS_sign/#bugs","title":"BUGS","text":"<p>Some attributes such as counter signatures are not supported.</p>"},{"location":"man3/CMS_sign/#return-values","title":"RETURN VALUES","text":"<p>CMS_sign() returns either a valid CMS_ContentInfo structure or NULL if an error occurred. The error can be obtained from ERR_get_error(3).</p>"},{"location":"man3/CMS_sign/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_verify(3)</p>"},{"location":"man3/CMS_sign/#history","title":"HISTORY","text":"<p>CMS_sign() was added to OpenSSL 0.9.8</p> <p>The CMS_STREAM flag is only supported for detached data in OpenSSL 0.9.8, it is supported for embedded data in OpenSSL 1.0.0 and later.</p>"},{"location":"man3/CMS_sign_receipt/","title":"CMS_sign_receipt","text":""},{"location":"man3/CMS_sign_receipt/#name","title":"NAME","text":"<pre><code>CMS_sign_receipt - create a CMS signed receipt\n</code></pre>"},{"location":"man3/CMS_sign_receipt/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nCMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si, X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs, unsigned int flags);\n</code></pre>"},{"location":"man3/CMS_sign_receipt/#description","title":"DESCRIPTION","text":"<p>CMS_sign_receipt() creates and returns a CMS signed receipt structure. si is the CMS_SignerInfo structure containing the signed receipt request. signcert is the certificate to sign with, pkey is the corresponding private key.  certs is an optional additional set of certificates to include in the CMS structure (for example any intermediate CAs in the chain).</p> <p>flags is an optional set of flags.</p>"},{"location":"man3/CMS_sign_receipt/#notes","title":"NOTES","text":"<p>This functions behaves in a similar way to CMS_sign() except the flag values CMS_DETACHED, CMS_BINARY, CMS_NOATTR, CMS_TEXT and CMS_STREAM are not supported since they do not make sense in the context of signed receipts.</p>"},{"location":"man3/CMS_sign_receipt/#return-values","title":"RETURN VALUES","text":"<p>CMS_sign_receipt() returns either a valid CMS_ContentInfo structure or NULL if an error occurred.  The error can be obtained from ERR_get_error(3).</p>"},{"location":"man3/CMS_sign_receipt/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_verify_receipt(3), CMS_sign(3)</p>"},{"location":"man3/CMS_sign_receipt/#history","title":"HISTORY","text":"<p>CMS_sign_receipt() was added to OpenSSL 0.9.8</p>"},{"location":"man3/CMS_uncompress/","title":"CMS_uncompress","text":""},{"location":"man3/CMS_uncompress/#name","title":"NAME","text":"<pre><code>CMS_uncompress - uncompress a CMS CompressedData structure\n</code></pre>"},{"location":"man3/CMS_uncompress/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nint CMS_uncompress(CMS_ContentInfo *cms, BIO *dcont, BIO *out, unsigned int flags);\n</code></pre>"},{"location":"man3/CMS_uncompress/#description","title":"DESCRIPTION","text":"<p>CMS_uncompress() extracts and uncompresses the content from a CMS CompressedData structure cms. data is a BIO to write the content to and flags is an optional set of flags.</p> <p>The dcont parameter is used in the rare case where the compressed content is detached. It will normally be set to NULL.</p>"},{"location":"man3/CMS_uncompress/#notes","title":"NOTES","text":"<p>The only currently supported compression algorithm is zlib: if the structure indicates the use of any other algorithm an error is returned.</p> <p>If zlib support is not compiled into OpenSSL then CMS_uncompress() will always return an error.</p> <p>The following flags can be passed in the flags parameter.</p> <p>If the CMS_TEXT flag is set MIME headers for type text/plain are deleted from the content. If the content is not of type text/plain then an error is returned.</p>"},{"location":"man3/CMS_uncompress/#return-values","title":"RETURN VALUES","text":"<p>CMS_uncompress() returns either 1 for success or 0 for failure. The error can be obtained from ERR_get_error(3)</p>"},{"location":"man3/CMS_uncompress/#bugs","title":"BUGS","text":"<p>The lack of single pass processing and the need to hold all data in memory as mentioned in CMS_verify() also applies to CMS_decompress().</p>"},{"location":"man3/CMS_uncompress/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_compress(3)</p>"},{"location":"man3/CMS_uncompress/#history","title":"HISTORY","text":"<p>CMS_uncompress() was added to OpenSSL 0.9.8</p>"},{"location":"man3/CMS_verify/","title":"CMS_verify","text":""},{"location":"man3/CMS_verify/#name","title":"NAME","text":"<p>CMS_verify, CMS_get0_signers - verify a CMS SignedData structure</p>"},{"location":"man3/CMS_verify/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nint CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs, X509_STORE *store, BIO *indata, BIO *out, unsigned int flags);\n\nSTACK_OF(X509) *CMS_get0_signers(CMS_ContentInfo *cms);\n</code></pre>"},{"location":"man3/CMS_verify/#description","title":"DESCRIPTION","text":"<p>CMS_verify() verifies a CMS SignedData structure. cms is the CMS_ContentInfo structure to verify. certs is a set of certificates in which to search for the signing certificate(s). store is a trusted certificate store used for chain verification. indata is the detached content if the content is not present in cms. The content is written to out if it is not NULL.</p> <p>flags is an optional set of flags, which can be used to modify the verify operation.</p> <p>CMS_get0_signers() retrieves the signing certificate(s) from cms, it must be called after a successful CMS_verify() operation.</p>"},{"location":"man3/CMS_verify/#verify-process","title":"VERIFY PROCESS","text":"<p>Normally the verify process proceeds as follows.</p> <p>Initially some sanity checks are performed on cms. The type of cms must be SignedData. There must be at least one signature on the data and if the content is detached indata cannot be NULL.</p> <p>An attempt is made to locate all the signing certificate(s), first looking in the certs parameter (if it is not NULL) and then looking in any certificates contained in the cms structure itself. If any signing certificate cannot be located the operation fails.</p> <p>Each signing certificate is chain verified using the smimesign purpose and the supplied trusted certificate store. Any internal certificates in the message are used as untrusted CAs. If CRL checking is enabled in store any internal CRLs are used in addition to attempting to look them up in store. If any chain verify fails an error code is returned.</p> <p>Finally the signed content is read (and written to out is it is not NULL) and the signature's checked.</p> <p>If all signature's verify correctly then the function is successful.</p> <p>Any of the following flags (ored together) can be passed in the flags parameter to change the default verify behaviour.</p> <p>If CMS_NOINTERN is set the certificates in the message itself are not searched when locating the signing certificate(s). This means that all the signing certificates must be in the certs parameter.</p> <p>If CMS_NOCRL is set and CRL checking is enabled in store then any CRLs in the message itself are ignored.</p> <p>If the CMS_TEXT flag is set MIME headers for type text/plain are deleted from the content. If the content is not of type text/plain then an error is returned.</p> <p>If CMS_NO_SIGNER_CERT_VERIFY is set the signing certificates are not verified.</p> <p>If CMS_NO_ATTR_VERIFY is set the signed attributes signature is not  verified.</p> <p>If CMS_NO_CONTENT_VERIFY is set then the content digest is not checked.</p>"},{"location":"man3/CMS_verify/#notes","title":"NOTES","text":"<p>One application of CMS_NOINTERN is to only accept messages signed by a small number of certificates. The acceptable certificates would be passed in the certs parameter. In this case if the signer is not one of the certificates supplied in certs then the verify will fail because the signer cannot be found.</p> <p>In some cases the standard techniques for looking up and validating certificates are not appropriate: for example an application may wish to  lookup certificates in a database or perform customised verification. This can be achieved by setting and verifying the signers certificates manually  using the signed data utility functions.</p> <p>Care should be taken when modifying the default verify behaviour, for example setting CMS_NO_CONTENT_VERIFY will totally disable all content verification  and any modified content will be considered valid. This combination is however useful if one merely wishes to write the content to out and its validity is not considered important.</p> <p>Chain verification should arguably be performed using the signing time rather than the current time. However since the signing time is supplied by the signer it cannot be trusted without additional evidence (such as a trusted timestamp).</p>"},{"location":"man3/CMS_verify/#return-values","title":"RETURN VALUES","text":"<p>CMS_verify() returns 1 for a successful verification and zero if an error occurred.</p> <p>CMS_get0_signers() returns all signers or NULL if an error occurred.</p> <p>The error can be obtained from ERR_get_error(3)</p>"},{"location":"man3/CMS_verify/#bugs","title":"BUGS","text":"<p>The trusted certificate store is not searched for the signing certificate, this is primarily due to the inadequacies of the current X509_STORE functionality.</p> <p>The lack of single pass processing means that the signed content must all be held in memory if it is not detached.</p>"},{"location":"man3/CMS_verify/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_sign(3)</p>"},{"location":"man3/CMS_verify/#history","title":"HISTORY","text":"<p>CMS_verify() was added to OpenSSL 0.9.8</p>"},{"location":"man3/CMS_verify_receipt/","title":"CMS_verify_receipt","text":""},{"location":"man3/CMS_verify_receipt/#name","title":"NAME","text":"<pre><code>CMS_verify_receipt - verify a CMS signed receipt\n</code></pre>"},{"location":"man3/CMS_verify_receipt/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nint CMS_verify_receipt(CMS_ContentInfo *rcms, CMS_ContentInfo *ocms, STACK_OF(X509) *certs, X509_STORE *store, unsigned int flags);\n</code></pre>"},{"location":"man3/CMS_verify_receipt/#description","title":"DESCRIPTION","text":"<p>CMS_verify_receipt() verifies a CMS signed receipt. rcms is the signed receipt to verify. ocms is the original SignedData structure containing the receipt request. certs is a set of certificates in which to search for the signing certificate. store is a trusted certificate store (used for chain verification). </p> <p>flags is an optional set of flags, which can be used to modify the verify operation.</p>"},{"location":"man3/CMS_verify_receipt/#notes","title":"NOTES","text":"<p>This functions behaves in a similar way to CMS_verify() except the flag values CMS_DETACHED, CMS_BINARY, CMS_TEXT and CMS_STREAM are not supported since they do not make sense in the context of signed receipts.</p>"},{"location":"man3/CMS_verify_receipt/#return-values","title":"RETURN VALUES","text":"<p>CMS_verify_receipt() returns 1 for a successful verification and zero if an error occurred.</p> <p>The error can be obtained from ERR_get_error(3)</p>"},{"location":"man3/CMS_verify_receipt/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_sign_receipt(3), CMS_verify(3),</p>"},{"location":"man3/CMS_verify_receipt/#history","title":"HISTORY","text":"<p>CMS_verify_receipt() was added to OpenSSL 0.9.8</p>"},{"location":"man3/CONF_modules_free/","title":"CONF_modules_free","text":""},{"location":"man3/CONF_modules_free/#name","title":"NAME","text":"<pre><code>CONF_modules_free, CONF_modules_finish, CONF_modules_unload -\nOpenSSL configuration cleanup functions\n</code></pre>"},{"location":"man3/CONF_modules_free/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/conf.h&gt;\n\nvoid CONF_modules_free(void);\nvoid CONF_modules_finish(void);\nvoid CONF_modules_unload(int all);\n</code></pre>"},{"location":"man3/CONF_modules_free/#description","title":"DESCRIPTION","text":"<p>CONF_modules_free() closes down and frees up all memory allocated by all configuration modules.</p> <p>CONF_modules_finish() calls each configuration modules finish handler to free up any configuration that module may have performed.</p> <p>CONF_modules_unload() finishes and unloads configuration modules. If all is set to 0 only modules loaded from DSOs will be unloads. If all is 1 all modules, including builtin modules will be unloaded.</p>"},{"location":"man3/CONF_modules_free/#notes","title":"NOTES","text":"<p>Normally applications will only call CONF_modules_free() at application to tidy up any configuration performed.</p>"},{"location":"man3/CONF_modules_free/#return-value","title":"RETURN VALUE","text":"<p>None of the functions return a value.</p>"},{"location":"man3/CONF_modules_free/#see-also","title":"SEE ALSO","text":"<p>conf(5), OPENSSL_config(3), CONF_modules_load_file(3)</p>"},{"location":"man3/CONF_modules_free/#history","title":"HISTORY","text":"<p>CONF_modules_free(), CONF_modules_unload(), and CONF_modules_finish() first appeared in OpenSSL 0.9.7.</p>"},{"location":"man3/CONF_modules_load_file/","title":"CONF_modules_load_file","text":""},{"location":"man3/CONF_modules_load_file/#name","title":"NAME","text":"<pre><code>CONF_modules_load_file, CONF_modules_load - OpenSSL configuration functions\n</code></pre>"},{"location":"man3/CONF_modules_load_file/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/conf.h&gt;\n\nint CONF_modules_load_file(const char *filename, const char *appname,\n                                       unsigned long flags);\nint CONF_modules_load(const CONF *cnf, const char *appname,\n                              unsigned long flags);\n</code></pre>"},{"location":"man3/CONF_modules_load_file/#description","title":"DESCRIPTION","text":"<p>The function CONF_modules_load_file() configures OpenSSL using file filename and application name appname. If filename is NULL the standard OpenSSL configuration file is used. If appname is NULL the standard OpenSSL application name openssl_conf is used. The behaviour can be cutomized using flags.</p> <p>CONF_modules_load() is idential to CONF_modules_load_file() except it reads configuration information from cnf.</p>"},{"location":"man3/CONF_modules_load_file/#notes","title":"NOTES","text":"<p>The following flags are currently recognized:</p> <p>CONF_MFLAGS_IGNORE_ERRORS if set errors returned by individual configuration modules are ignored. If not set the first module error is considered fatal and no further modules are loaded.</p> <p>Normally any modules errors will add error information to the error queue. If CONF_MFLAGS_SILENT is set no error information is added.</p> <p>If CONF_MFLAGS_NO_DSO is set configuration module loading from DSOs is disabled.</p> <p>CONF_MFLAGS_IGNORE_MISSING_FILE if set will make CONF_load_modules_file() ignore missing configuration files. Normally a missing configuration file return an error.</p> <p>CONF_MFLAGS_DEFAULT_SECTION if set and appname is not NULL will use the default section pointed to by openssl_conf if appname does not exist.</p> <p>Applications should call these functions after loading builtin modules using OPENSSL_load_builtin_modules(), any ENGINEs for example using ENGINE_load_builtin_engines(), any algorithms for example OPENSSL_add_all_algorithms() and (if the application uses libssl) SSL_library_init().</p> <p>By using CONF_modules_load_file() with appropriate flags an application can customise application configuration to best suit its needs. In some cases the use of a configuration file is optional and its absence is not an error: in this case CONF_MFLAGS_IGNORE_MISSING_FILE would be set.</p> <p>Errors during configuration may also be handled differently by different applications. For example in some cases an error may simply print out a warning message and the application continue. In other cases an application might consider a configuration file error as fatal and exit immediately.</p> <p>Applications can use the CONF_modules_load() function if they wish to load a configuration file themselves and have finer control over how errors are treated.</p>"},{"location":"man3/CONF_modules_load_file/#examples","title":"EXAMPLES","text":"<p>Load a configuration file and print out any errors and exit (missing file considered fatal):</p> <pre><code>if (CONF_modules_load_file(NULL, NULL, 0) &lt;= 0) {\n   fprintf(stderr, \"FATAL: error loading configuration file\\n\");\n   ERR_print_errors_fp(stderr);\n   exit(1);\n}\n</code></pre> <p>Load default configuration file using the section indicated by \"myapp\", tolerate missing files, but exit on other errors:</p> <pre><code>if (CONF_modules_load_file(NULL, \"myapp\",\n                           CONF_MFLAGS_IGNORE_MISSING_FILE) &lt;= 0) {\n   fprintf(stderr, \"FATAL: error loading configuration file\\n\");\n   ERR_print_errors_fp(stderr);\n   exit(1);\n}\n</code></pre> <p>Load custom configuration file and section, only print warnings on error, missing configuration file ignored:</p> <pre><code>if (CONF_modules_load_file(\"/something/app.cnf\", \"myapp\",\n                           CONF_MFLAGS_IGNORE_MISSING_FILE) &lt;= 0) {\n   fprintf(stderr, \"WARNING: error loading configuration file\\n\");\n   ERR_print_errors_fp(stderr);\n}\n</code></pre> <p>Load and parse configuration file manually, custom error handling:</p> <pre><code>FILE *fp;\nCONF *cnf = NULL;\nlong eline;\nfp = fopen(\"/somepath/app.cnf\", \"r\");\nif (fp == NULL) {\n   fprintf(stderr, \"Error opening configuration file\\n\");\n   /* Other missing configuration file behaviour */\n} else {\n   cnf = NCONF_new(NULL);\n   if (NCONF_load_fp(cnf, fp, &amp;eline) == 0) {\n       fprintf(stderr, \"Error on line %ld of configuration file\\n\", eline);\n       ERR_print_errors_fp(stderr);\n       /* Other malformed configuration file behaviour */\n   } else if (CONF_modules_load(cnf, \"appname\", 0) &lt;= 0) {\n     fprintf(stderr, \"Error configuring application\\n\");\n     ERR_print_errors_fp(stderr);\n     /* Other configuration error behaviour */\n   }\n   fclose(fp);\n   NCONF_free(cnf);\n }\n</code></pre>"},{"location":"man3/CONF_modules_load_file/#return-values","title":"RETURN VALUES","text":"<p>These functions return 1 for success and a zero or negative value for failure. If module errors are not ignored the return code will reflect the return value of the failing module (this will always be zero or negative).</p>"},{"location":"man3/CONF_modules_load_file/#see-also","title":"SEE ALSO","text":"<p>conf(5), OPENSSL_config(3), CONF_free(3), err(3)</p>"},{"location":"man3/CONF_modules_load_file/#history","title":"HISTORY","text":"<p>CONF_modules_load_file and CONF_modules_load first appeared in OpenSSL 0.9.7.</p>"},{"location":"man3/CRYPTO_set_ex_data/","title":"CRYPTO_set_ex_data","text":""},{"location":"man3/CRYPTO_set_ex_data/#name","title":"NAME","text":"<p>CRYPTO_set_ex_data, CRYPTO_get_ex_data - internal application specific data functions</p>"},{"location":"man3/CRYPTO_set_ex_data/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/crypto.h&gt;\n\nint CRYPTO_set_ex_data(CRYPTO_EX_DATA *r, int idx, void *arg);\n\nvoid *CRYPTO_get_ex_data(CRYPTO_EX_DATA *r, int idx);\n</code></pre>"},{"location":"man3/CRYPTO_set_ex_data/#description","title":"DESCRIPTION","text":"<p>Several OpenSSL structures can have application specific data attached to them. These functions are used internally by OpenSSL to manipulate application specific data attached to a specific structure.</p> <p>These functions should only be used by applications to manipulate CRYPTO_EX_DATA structures passed to the new_func(), free_func() and dup_func() callbacks: as passed to RSA_get_ex_new_index() for example.</p> <p>CRYPTO_set_ex_data() is used to set application specific data, the data is supplied in the arg parameter and its precise meaning is up to the application.</p> <p>CRYPTO_get_ex_data() is used to retrieve application specific data. The data is returned to the application, this will be the same value as supplied to a previous CRYPTO_set_ex_data() call.</p>"},{"location":"man3/CRYPTO_set_ex_data/#return-values","title":"RETURN VALUES","text":"<p>CRYPTO_set_ex_data() returns 1 on success or 0 on failure.</p> <p>CRYPTO_get_ex_data() returns the application data or 0 on failure. 0 may also be valid application data but currently it can only fail if given an invalid idx parameter.</p> <p>On failure an error code can be obtained from ERR_get_error(3).</p>"},{"location":"man3/CRYPTO_set_ex_data/#see-also","title":"SEE ALSO","text":"<p>RSA_get_ex_new_index(3), DSA_get_ex_new_index(3), DH_get_ex_new_index(3)</p>"},{"location":"man3/CRYPTO_set_ex_data/#history","title":"HISTORY","text":"<p>CRYPTO_set_ex_data() and CRYPTO_get_ex_data() have been available since SSLeay 0.9.0.</p>"},{"location":"man3/DH_generate_key/","title":"DH_generate_key","text":""},{"location":"man3/DH_generate_key/#name","title":"NAME","text":"<p>DH_generate_key, DH_compute_key - perform Diffie-Hellman key exchange</p>"},{"location":"man3/DH_generate_key/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dh.h&gt;\n\nint DH_generate_key(DH *dh);\n\nint DH_compute_key(unsigned char *key, BIGNUM *pub_key, DH *dh);\n</code></pre>"},{"location":"man3/DH_generate_key/#description","title":"DESCRIPTION","text":"<p>DH_generate_key() performs the first step of a Diffie-Hellman key exchange by generating private and public DH values. By calling DH_compute_key(), these are combined with the other party's public value to compute the shared key.</p> <p>DH_generate_key() expects dh to contain the shared parameters dh-&gt;p and dh-&gt;g. It generates a random private DH value unless dh-&gt;priv_key is already set, and computes the corresponding public value dh-&gt;pub_key, which can then be published.</p> <p>DH_compute_key() computes the shared secret from the private DH value in dh and the other party's public value in pub_key and stores it in key. key must point to DH_size(dh) bytes of memory.</p>"},{"location":"man3/DH_generate_key/#return-values","title":"RETURN VALUES","text":"<p>DH_generate_key() returns 1 on success, 0 otherwise.</p> <p>DH_compute_key() returns the size of the shared secret on success, -1 on error.</p> <p>The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/DH_generate_key/#see-also","title":"SEE ALSO","text":"<p>dh(3), ERR_get_error(3), rand(3), DH_size(3)</p>"},{"location":"man3/DH_generate_key/#history","title":"HISTORY","text":"<p>DH_generate_key() and DH_compute_key() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/DH_generate_parameters/","title":"DH_generate_parameters","text":""},{"location":"man3/DH_generate_parameters/#name","title":"NAME","text":"<p>DH_generate_parameters_ex, DH_generate_parameters, DH_check - generate and check Diffie-Hellman parameters</p>"},{"location":"man3/DH_generate_parameters/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dh.h&gt;\n\nint DH_generate_parameters_ex(DH *dh, int prime_len,int generator, BN_GENCB *cb);\n\nint DH_check(DH *dh, int *codes);\n</code></pre> <p>Deprecated:</p> <pre><code>DH *DH_generate_parameters(int prime_len, int generator,\n    void (*callback)(int, int, void *), void *cb_arg);\n</code></pre>"},{"location":"man3/DH_generate_parameters/#description","title":"DESCRIPTION","text":"<p>DH_generate_parameters_ex() generates Diffie-Hellman parameters that can be shared among a group of users, and stores them in the provided DH structure. The pseudo-random number generator must be seeded prior to calling DH_generate_parameters().</p> <p>prime_len is the length in bits of the safe prime to be generated. generator is a small number &gt; 1, typically 2 or 5. </p> <p>A callback function may be used to provide feedback about the progress of the key generation. If cb is not NULL, it will be called as described in BN_generate_prime(3) while a random prime number is generated, and when a prime has been found, BN_GENCB_call(cb, 3, 0) is called. See BN_generate_prime(3) for information on the BN_GENCB_call() function.</p> <p>DH_check() validates Diffie-Hellman parameters. It checks that p is a safe prime, and that g is a suitable generator. In the case of an error, the bit flags DH_CHECK_P_NOT_SAFE_PRIME or DH_NOT_SUITABLE_GENERATOR are set in *codes. DH_UNABLE_TO_CHECK_GENERATOR is set if the generator cannot be checked, i.e. it does not equal 2 or 5.</p>"},{"location":"man3/DH_generate_parameters/#return-values","title":"RETURN VALUES","text":"<p>DH_generate_parameters_ex() and DH_check() return 1 if the check could be performed, 0 otherwise.</p> <p>DH_generate_parameters() (deprecated) returns a pointer to the DH structure, or NULL if the parameter generation fails.</p> <p>The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/DH_generate_parameters/#notes","title":"NOTES","text":"<p>DH_generate_parameters_ex() and DH_generate_parameters() may run for several hours before finding a suitable prime.</p> <p>The parameters generated by DH_generate_parameters_ex() and DH_generate_parameters() are not to be used in signature schemes.</p>"},{"location":"man3/DH_generate_parameters/#bugs","title":"BUGS","text":"<p>If generator is not 2 or 5, dh-&gt;g=generator is not a usable generator.</p>"},{"location":"man3/DH_generate_parameters/#see-also","title":"SEE ALSO","text":"<p>dh(3), ERR_get_error(3), rand(3), DH_free(3)</p>"},{"location":"man3/DH_generate_parameters/#history","title":"HISTORY","text":"<p>DH_check() is available in all versions of SSLeay and OpenSSL. The cb_arg argument to DH_generate_parameters() was added in SSLeay 0.9.0.</p> <p>In versions before OpenSSL 0.9.5, DH_CHECK_P_NOT_STRONG_PRIME is used instead of DH_CHECK_P_NOT_SAFE_PRIME.</p>"},{"location":"man3/DH_get_ex_new_index/","title":"DH_get_ex_new_index","text":""},{"location":"man3/DH_get_ex_new_index/#name","title":"NAME","text":"<p>DH_get_ex_new_index, DH_set_ex_data, DH_get_ex_data - add application specific data to DH structures</p>"},{"location":"man3/DH_get_ex_new_index/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dh.h&gt;\n\nint DH_get_ex_new_index(long argl, void *argp,\n               CRYPTO_EX_new *new_func,\n               CRYPTO_EX_dup *dup_func,\n               CRYPTO_EX_free *free_func);\n\nint DH_set_ex_data(DH *d, int idx, void *arg);\n\nchar *DH_get_ex_data(DH *d, int idx);\n</code></pre>"},{"location":"man3/DH_get_ex_new_index/#description","title":"DESCRIPTION","text":"<p>These functions handle application specific data in DH structures. Their usage is identical to that of RSA_get_ex_new_index(), RSA_set_ex_data() and RSA_get_ex_data() as described in RSA_get_ex_new_index(3).</p>"},{"location":"man3/DH_get_ex_new_index/#see-also","title":"SEE ALSO","text":"<p>RSA_get_ex_new_index(3), dh(3)</p>"},{"location":"man3/DH_get_ex_new_index/#history","title":"HISTORY","text":"<p>DH_get_ex_new_index(), DH_set_ex_data() and DH_get_ex_data() are available since OpenSSL 0.9.5.</p>"},{"location":"man3/DH_new/","title":"DH_new","text":""},{"location":"man3/DH_new/#name","title":"NAME","text":"<p>DH_new, DH_free - allocate and free DH objects</p>"},{"location":"man3/DH_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dh.h&gt;\n\nDH* DH_new(void);\n\nvoid DH_free(DH *dh);\n</code></pre>"},{"location":"man3/DH_new/#description","title":"DESCRIPTION","text":"<p>DH_new() allocates and initializes a DH structure.</p> <p>DH_free() frees the DH structure and its components. The values are erased before the memory is returned to the system.</p>"},{"location":"man3/DH_new/#return-values","title":"RETURN VALUES","text":"<p>If the allocation fails, DH_new() returns NULL and sets an error code that can be obtained by ERR_get_error(3). Otherwise it returns a pointer to the newly allocated structure.</p> <p>DH_free() returns no value.</p>"},{"location":"man3/DH_new/#see-also","title":"SEE ALSO","text":"<p>dh(3), ERR_get_error(3), DH_generate_parameters(3), DH_generate_key(3)</p>"},{"location":"man3/DH_new/#history","title":"HISTORY","text":"<p>DH_new() and DH_free() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/DH_set_method/","title":"DH_set_method","text":""},{"location":"man3/DH_set_method/#name","title":"NAME","text":"<p>DH_set_default_method, DH_get_default_method, DH_set_method, DH_new_method, DH_OpenSSL - select DH method</p>"},{"location":"man3/DH_set_method/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dh.h&gt;\n#include &lt;openssl/engine.h&gt;\n\nvoid DH_set_default_method(const DH_METHOD *meth);\n\nconst DH_METHOD *DH_get_default_method(void);\n\nint DH_set_method(DH *dh, const DH_METHOD *meth);\n\nDH *DH_new_method(ENGINE *engine);\n\nconst DH_METHOD *DH_OpenSSL(void);\n</code></pre>"},{"location":"man3/DH_set_method/#description","title":"DESCRIPTION","text":"<p>A DH_METHOD specifies the functions that OpenSSL uses for Diffie-Hellman operations. By modifying the method, alternative implementations such as hardware accelerators may be used. IMPORTANT: See the NOTES section for important information about how these DH API functions are affected by the use of ENGINE API calls.</p> <p>Initially, the default DH_METHOD is the OpenSSL internal implementation, as returned by DH_OpenSSL().</p> <p>DH_set_default_method() makes meth the default method for all DH structures created later. NB: This is true only whilst no ENGINE has been set as a default for DH, so this function is no longer recommended.</p> <p>DH_get_default_method() returns a pointer to the current default DH_METHOD. However, the meaningfulness of this result is dependent on whether the ENGINE API is being used, so this function is no longer recommended.</p> <p>DH_set_method() selects meth to perform all operations using the key dh. This will replace the DH_METHOD used by the DH key and if the previous method was supplied by an ENGINE, the handle to that ENGINE will be released during the change. It is possible to have DH keys that only work with certain DH_METHOD implementations (eg. from an ENGINE module that supports embedded hardware-protected keys), and in such cases attempting to change the DH_METHOD for the key can have unexpected results.</p> <p>DH_new_method() allocates and initializes a DH structure so that engine will be used for the DH operations. If engine is NULL, the default ENGINE for DH operations is used, and if no default ENGINE is set, the DH_METHOD controlled by DH_set_default_method() is used.</p>"},{"location":"man3/DH_set_method/#the-dh_method-structure","title":"THE DH_METHOD STRUCTURE","text":"<pre><code>typedef struct dh_meth_st\n{\n    /* name of the implementation */\n       const char *name;\n\n    /* generate private and public DH values for key agreement */\n       int (*generate_key)(DH *dh);\n\n    /* compute shared secret */\n       int (*compute_key)(unsigned char *key, BIGNUM *pub_key, DH *dh);\n\n    /* compute r = a ^ p mod m (May be NULL for some implementations) */\n       int (*bn_mod_exp)(DH *dh, BIGNUM *r, BIGNUM *a, const BIGNUM *p,\n                               const BIGNUM *m, BN_CTX *ctx,\n                               BN_MONT_CTX *m_ctx);\n\n    /* called at DH_new */\n       int (*init)(DH *dh);\n\n    /* called at DH_free */\n       int (*finish)(DH *dh);\n\n       int flags;\n\n       char *app_data; /* ?? */\n\n} DH_METHOD;\n</code></pre>"},{"location":"man3/DH_set_method/#return-values","title":"RETURN VALUES","text":"<p>DH_OpenSSL() and DH_get_default_method() return pointers to the respective DH_METHODs.</p> <p>DH_set_default_method() returns no value.</p> <p>DH_set_method() returns non-zero if the provided meth was successfully set as the method for dh (including unloading the ENGINE handle if the previous method was supplied by an ENGINE).</p> <p>DH_new_method() returns NULL and sets an error code that can be obtained by ERR_get_error(3) if the allocation fails. Otherwise it returns a pointer to the newly allocated structure.</p>"},{"location":"man3/DH_set_method/#notes","title":"NOTES","text":"<p>As of version 0.9.7, DH_METHOD implementations are grouped together with other algorithmic APIs (eg. RSA_METHOD, EVP_CIPHER, etc) in ENGINE modules. If a default ENGINE is specified for DH functionality using an ENGINE API function, that will override any DH defaults set using the DH API (ie. DH_set_default_method()). For this reason, the ENGINE API is the recommended way to control default implementations for use in DH and other cryptographic algorithms.</p>"},{"location":"man3/DH_set_method/#see-also","title":"SEE ALSO","text":"<p>dh(3), DH_new(3)</p>"},{"location":"man3/DH_set_method/#history","title":"HISTORY","text":"<p>DH_set_default_method(), DH_get_default_method(), DH_set_method(), DH_new_method() and DH_OpenSSL() were added in OpenSSL 0.9.4.</p> <p>DH_set_default_openssl_method() and DH_get_default_openssl_method() replaced DH_set_default_method() and DH_get_default_method() respectively, and DH_set_method() and DH_new_method() were altered to use ENGINEs rather than DH_METHODs during development of the engine version of OpenSSL 0.9.6. For 0.9.7, the handling of defaults in the ENGINE API was restructured so that this change was reversed, and behaviour of the other functions resembled more closely the previous behaviour. The behaviour of defaults in the ENGINE API now transparently overrides the behaviour of defaults in the DH API without requiring changing these function prototypes.</p>"},{"location":"man3/DH_size/","title":"DH_size","text":""},{"location":"man3/DH_size/#name","title":"NAME","text":"<p>DH_size - get Diffie-Hellman prime size</p>"},{"location":"man3/DH_size/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dh.h&gt;\n\nint DH_size(DH *dh);\n</code></pre>"},{"location":"man3/DH_size/#description","title":"DESCRIPTION","text":"<p>This function returns the Diffie-Hellman size in bytes. It can be used to determine how much memory must be allocated for the shared secret computed by DH_compute_key().</p> <p>dh-&gt;p must not be NULL.</p>"},{"location":"man3/DH_size/#return-value","title":"RETURN VALUE","text":"<p>The size in bytes.</p>"},{"location":"man3/DH_size/#see-also","title":"SEE ALSO","text":"<p>dh(3), DH_generate_key(3)</p>"},{"location":"man3/DH_size/#history","title":"HISTORY","text":"<p>DH_size() is available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/DSA_SIG_new/","title":"DSA_SIG_new","text":""},{"location":"man3/DSA_SIG_new/#name","title":"NAME","text":"<p>DSA_SIG_new, DSA_SIG_free - allocate and free DSA signature objects</p>"},{"location":"man3/DSA_SIG_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dsa.h&gt;\n\nDSA_SIG *DSA_SIG_new(void);\n\nvoid   DSA_SIG_free(DSA_SIG *a);\n</code></pre>"},{"location":"man3/DSA_SIG_new/#description","title":"DESCRIPTION","text":"<p>DSA_SIG_new() allocates and initializes a DSA_SIG structure.</p> <p>DSA_SIG_free() frees the DSA_SIG structure and its components. The values are erased before the memory is returned to the system.</p>"},{"location":"man3/DSA_SIG_new/#return-values","title":"RETURN VALUES","text":"<p>If the allocation fails, DSA_SIG_new() returns NULL and sets an error code that can be obtained by ERR_get_error(3). Otherwise it returns a pointer to the newly allocated structure.</p> <p>DSA_SIG_free() returns no value.</p>"},{"location":"man3/DSA_SIG_new/#see-also","title":"SEE ALSO","text":"<p>dsa(3), ERR_get_error(3), DSA_do_sign(3)</p>"},{"location":"man3/DSA_SIG_new/#history","title":"HISTORY","text":"<p>DSA_SIG_new() and DSA_SIG_free() were added in OpenSSL 0.9.3.</p>"},{"location":"man3/DSA_do_sign/","title":"DSA_do_sign","text":""},{"location":"man3/DSA_do_sign/#name","title":"NAME","text":"<p>DSA_do_sign, DSA_do_verify - raw DSA signature operations</p>"},{"location":"man3/DSA_do_sign/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dsa.h&gt;\n\nDSA_SIG *DSA_do_sign(const unsigned char *dgst, int dlen, DSA *dsa);\n\nint DSA_do_verify(const unsigned char *dgst, int dgst_len,\n            DSA_SIG *sig, DSA *dsa);\n</code></pre>"},{"location":"man3/DSA_do_sign/#description","title":"DESCRIPTION","text":"<p>DSA_do_sign() computes a digital signature on the len byte message digest dgst using the private key dsa and returns it in a newly allocated DSA_SIG structure.</p> <p>DSA_sign_setup(3) may be used to precompute part of the signing operation for each signature in case signature generation is time-critical.</p> <p>DSA_do_verify() verifies that the signature sig matches a given message digest dgst of size len.  dsa is the signer's public key.</p>"},{"location":"man3/DSA_do_sign/#return-values","title":"RETURN VALUES","text":"<p>DSA_do_sign() returns the signature, NULL on error.  DSA_do_verify() returns 1 for a valid signature, 0 for an incorrect signature and -1 on error. The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/DSA_do_sign/#see-also","title":"SEE ALSO","text":"<p>dsa(3), ERR_get_error(3), rand(3), DSA_SIG_new(3), DSA_sign(3)</p>"},{"location":"man3/DSA_do_sign/#history","title":"HISTORY","text":"<p>DSA_do_sign() and DSA_do_verify() were added in OpenSSL 0.9.3.</p>"},{"location":"man3/DSA_dup_DH/","title":"DSA_dup_DH","text":""},{"location":"man3/DSA_dup_DH/#name","title":"NAME","text":"<p>DSA_dup_DH - create a DH structure out of DSA structure</p>"},{"location":"man3/DSA_dup_DH/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dsa.h&gt;\n\nDH * DSA_dup_DH(const DSA *r);\n</code></pre>"},{"location":"man3/DSA_dup_DH/#description","title":"DESCRIPTION","text":"<p>DSA_dup_DH() duplicates DSA parameters/keys as DH parameters/keys. q is lost during that conversion, but the resulting DH parameters contain its length.</p>"},{"location":"man3/DSA_dup_DH/#return-value","title":"RETURN VALUE","text":"<p>DSA_dup_DH() returns the new DH structure, and NULL on error. The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/DSA_dup_DH/#note","title":"NOTE","text":"<p>Be careful to avoid small subgroup attacks when using this.</p>"},{"location":"man3/DSA_dup_DH/#see-also","title":"SEE ALSO","text":"<p>dh(3), dsa(3), ERR_get_error(3)</p>"},{"location":"man3/DSA_dup_DH/#history","title":"HISTORY","text":"<p>DSA_dup_DH() was added in OpenSSL 0.9.4.</p>"},{"location":"man3/DSA_generate_key/","title":"DSA_generate_key","text":""},{"location":"man3/DSA_generate_key/#name","title":"NAME","text":"<p>DSA_generate_key - generate DSA key pair</p>"},{"location":"man3/DSA_generate_key/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dsa.h&gt;\n\nint DSA_generate_key(DSA *a);\n</code></pre>"},{"location":"man3/DSA_generate_key/#description","title":"DESCRIPTION","text":"<p>DSA_generate_key() expects a to contain DSA parameters. It generates a new key pair and stores it in a-&gt;pub_key and a-&gt;priv_key.</p> <p>The PRNG must be seeded prior to calling DSA_generate_key().</p>"},{"location":"man3/DSA_generate_key/#return-value","title":"RETURN VALUE","text":"<p>DSA_generate_key() returns 1 on success, 0 otherwise. The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/DSA_generate_key/#see-also","title":"SEE ALSO","text":"<p>dsa(3), ERR_get_error(3), rand(3), DSA_generate_parameters(3)</p>"},{"location":"man3/DSA_generate_key/#history","title":"HISTORY","text":"<p>DSA_generate_key() is available since SSLeay 0.8.</p>"},{"location":"man3/DSA_generate_parameters/","title":"DSA_generate_parameters","text":""},{"location":"man3/DSA_generate_parameters/#name","title":"NAME","text":"<p>DSA_generate_parameters_ex, DSA_generate_parameters - generate DSA parameters</p>"},{"location":"man3/DSA_generate_parameters/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dsa.h&gt;\n\nint DSA_generate_parameters_ex(DSA *dsa, int bits,\n               const unsigned char *seed,int seed_len,\n               int *counter_ret, unsigned long *h_ret, BN_GENCB *cb);\n</code></pre> <p>Deprecated:</p> <pre><code>DSA *DSA_generate_parameters(int bits, unsigned char *seed,\n               int seed_len, int *counter_ret, unsigned long *h_ret,\n               void (*callback)(int, int, void *), void *cb_arg);\n</code></pre>"},{"location":"man3/DSA_generate_parameters/#description","title":"DESCRIPTION","text":"<p>DSA_generate_parameters_ex() generates primes p and q and a generator g for use in the DSA and stores the result in dsa.</p> <p>bits is the length of the prime to be generated; the DSS allows a maximum of 1024 bits.</p> <p>If seed is NULL or seed_len &lt; 20, the primes will be generated at random. Otherwise, the seed is used to generate them. If the given seed does not yield a prime q, a new random seed is chosen.</p> <p>DSA_generate_parameters_ex() places the iteration count in *counter_ret and a counter used for finding a generator in *h_ret, unless these are NULL.</p> <p>A callback function may be used to provide feedback about the progress of the key generation. If cb is not NULL, it will be called as shown below. For information on the BN_GENCB structure and the BN_GENCB_call function discussed below, refer to BN_generate_prime(3).</p> <ul> <li>When a candidate for q is generated, BN_GENCB_call(cb, 0, m++) is called (m is 0 for the first candidate).</li> <li>When a candidate for q has passed a test by trial division, BN_GENCB_call(cb, 1, -1) is called. While a candidate for q is tested by Miller-Rabin primality tests, BN_GENCB_call(cb, 1, i) is called in the outer loop (once for each witness that confirms that the candidate may be prime); i is the loop counter (starting at 0).</li> <li>When a prime q has been found, BN_GENCB_call(cb, 2, 0) and BN_GENCB_call(cb, 3, 0) are called.</li> <li>Before a candidate for p (other than the first) is generated and tested, BN_GENCB_call(cb, 0, counter) is called.</li> <li>When a candidate for p has passed the test by trial division, BN_GENCB_call(cb, 1, -1) is called. While it is tested by the Miller-Rabin primality test, BN_GENCB_call(cb, 1, i) is called in the outer loop (once for each witness that confirms that the candidate may be prime). i is the loop counter (starting at 0).</li> <li>When p has been found, BN_GENCB_call(cb, 2, 1) is called.</li> <li>When the generator has been found, BN_GENCB_call(cb, 3, 1) is called.</li> </ul> <p>DSA_generate_parameters() (deprecated) works in much the same way as for DSA_generate_parameters_ex, except that no dsa parameter is passed and instead a newly allocated DSA structure is returned. Additionally \"old style\" callbacks are used instead of the newer BN_GENCB based approach. Refer to BN_generate_prime(3) for further information.</p>"},{"location":"man3/DSA_generate_parameters/#return-value","title":"RETURN VALUE","text":"<p>DSA_generate_parameters_ex() returns a 1 on success, or 0 otherwise.</p> <p>DSA_generate_parameters() returns a pointer to the DSA structure, or NULL if the parameter generation fails.</p> <p>The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/DSA_generate_parameters/#bugs","title":"BUGS","text":"<p>Seed lengths &gt; 20 are not supported.</p>"},{"location":"man3/DSA_generate_parameters/#see-also","title":"SEE ALSO","text":"<p>dsa(3), ERR_get_error(3), rand(3), DSA_free(3), BN_generate_prime(3)</p>"},{"location":"man3/DSA_generate_parameters/#history","title":"HISTORY","text":"<p>DSA_generate_parameters() appeared in SSLeay 0.8. The cb_arg argument was added in SSLeay 0.9.0. In versions up to OpenSSL 0.9.4, callback(1, ...) was called in the inner loop of the Miller-Rabin test whenever it reached the squaring step (the parameters to callback did not reveal how many witnesses had been tested); since OpenSSL 0.9.5, callback(1, ...) is called as in BN_is_prime(3), i.e. once for each witness.</p>"},{"location":"man3/DSA_get_ex_new_index/","title":"DSA_get_ex_new_index","text":""},{"location":"man3/DSA_get_ex_new_index/#name","title":"NAME","text":"<p>DSA_get_ex_new_index, DSA_set_ex_data, DSA_get_ex_data - add application specific data to DSA structures</p>"},{"location":"man3/DSA_get_ex_new_index/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dsa.h&gt;\n\nint DSA_get_ex_new_index(long argl, void *argp,\n               CRYPTO_EX_new *new_func,\n               CRYPTO_EX_dup *dup_func,\n               CRYPTO_EX_free *free_func);\n\nint DSA_set_ex_data(DSA *d, int idx, void *arg);\n\nchar *DSA_get_ex_data(DSA *d, int idx);\n</code></pre>"},{"location":"man3/DSA_get_ex_new_index/#description","title":"DESCRIPTION","text":"<p>These functions handle application specific data in DSA structures. Their usage is identical to that of RSA_get_ex_new_index(), RSA_set_ex_data() and RSA_get_ex_data() as described in RSA_get_ex_new_index(3).</p>"},{"location":"man3/DSA_get_ex_new_index/#see-also","title":"SEE ALSO","text":"<p>RSA_get_ex_new_index(3), dsa(3)</p>"},{"location":"man3/DSA_get_ex_new_index/#history","title":"HISTORY","text":"<p>DSA_get_ex_new_index(), DSA_set_ex_data() and DSA_get_ex_data() are available since OpenSSL 0.9.5.</p>"},{"location":"man3/DSA_new/","title":"DSA_new","text":""},{"location":"man3/DSA_new/#name","title":"NAME","text":"<p>DSA_new, DSA_free - allocate and free DSA objects</p>"},{"location":"man3/DSA_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dsa.h&gt;\n\nDSA* DSA_new(void);\n\nvoid DSA_free(DSA *dsa);\n</code></pre>"},{"location":"man3/DSA_new/#description","title":"DESCRIPTION","text":"<p>DSA_new() allocates and initializes a DSA structure. It is equivalent to calling DSA_new_method(NULL).</p> <p>DSA_free() frees the DSA structure and its components. The values are erased before the memory is returned to the system.</p>"},{"location":"man3/DSA_new/#return-values","title":"RETURN VALUES","text":"<p>If the allocation fails, DSA_new() returns NULL and sets an error code that can be obtained by ERR_get_error(3). Otherwise it returns a pointer to the newly allocated structure.</p> <p>DSA_free() returns no value.</p>"},{"location":"man3/DSA_new/#see-also","title":"SEE ALSO","text":"<p>dsa(3), ERR_get_error(3), DSA_generate_parameters(3), DSA_generate_key(3)</p>"},{"location":"man3/DSA_new/#history","title":"HISTORY","text":"<p>DSA_new() and DSA_free() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/DSA_set_method/","title":"DSA_set_method","text":""},{"location":"man3/DSA_set_method/#name","title":"NAME","text":"<p>DSA_set_default_method, DSA_get_default_method, DSA_set_method, DSA_new_method, DSA_OpenSSL - select DSA method</p>"},{"location":"man3/DSA_set_method/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dsa.h&gt;\n#include &lt;openssl/engine.h&gt;\n\nvoid DSA_set_default_method(const DSA_METHOD *meth);\n\nconst DSA_METHOD *DSA_get_default_method(void);\n\nint DSA_set_method(DSA *dsa, const DSA_METHOD *meth);\n\nDSA *DSA_new_method(ENGINE *engine);\n\nDSA_METHOD *DSA_OpenSSL(void);\n</code></pre>"},{"location":"man3/DSA_set_method/#description","title":"DESCRIPTION","text":"<p>A DSA_METHOD specifies the functions that OpenSSL uses for DSA operations. By modifying the method, alternative implementations such as hardware accelerators may be used. IMPORTANT: See the NOTES section for important information about how these DSA API functions are affected by the use of ENGINE API calls.</p> <p>Initially, the default DSA_METHOD is the OpenSSL internal implementation, as returned by DSA_OpenSSL().</p> <p>DSA_set_default_method() makes meth the default method for all DSA structures created later. NB: This is true only whilst no ENGINE has been set as a default for DSA, so this function is no longer recommended.</p> <p>DSA_get_default_method() returns a pointer to the current default DSA_METHOD. However, the meaningfulness of this result is dependent on whether the ENGINE API is being used, so this function is no longer  recommended.</p> <p>DSA_set_method() selects meth to perform all operations using the key rsa. This will replace the DSA_METHOD used by the DSA key and if the previous method was supplied by an ENGINE, the handle to that ENGINE will be released during the change. It is possible to have DSA keys that only work with certain DSA_METHOD implementations (eg. from an ENGINE module that supports embedded hardware-protected keys), and in such cases attempting to change the DSA_METHOD for the key can have unexpected results.</p> <p>DSA_new_method() allocates and initializes a DSA structure so that engine will be used for the DSA operations. If engine is NULL, the default engine for DSA operations is used, and if no default ENGINE is set, the DSA_METHOD controlled by DSA_set_default_method() is used.</p>"},{"location":"man3/DSA_set_method/#the-dsa_method-structure","title":"THE DSA_METHOD STRUCTURE","text":"<p>struct  {      /* name of the implementation */         const char *name;</p> <pre><code>    /* sign */\n       DSA_SIG *(*dsa_do_sign)(const unsigned char *dgst, int dlen,\n                                DSA *dsa);\n\n    /* pre-compute k^-1 and r */\n       int (*dsa_sign_setup)(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,\n                                BIGNUM **rp);\n\n    /* verify */\n       int (*dsa_do_verify)(const unsigned char *dgst, int dgst_len,\n                                DSA_SIG *sig, DSA *dsa);\n\n    /* compute rr = a1^p1 * a2^p2 mod m (May be NULL for some\n                                         implementations) */\n       int (*dsa_mod_exp)(DSA *dsa, BIGNUM *rr, BIGNUM *a1, BIGNUM *p1,\n                                BIGNUM *a2, BIGNUM *p2, BIGNUM *m,\n                                BN_CTX *ctx, BN_MONT_CTX *in_mont);\n\n    /* compute r = a ^ p mod m (May be NULL for some implementations) */\n       int (*bn_mod_exp)(DSA *dsa, BIGNUM *r, BIGNUM *a,\n                                const BIGNUM *p, const BIGNUM *m,\n                                BN_CTX *ctx, BN_MONT_CTX *m_ctx);\n\n    /* called at DSA_new */\n       int (*init)(DSA *DSA);\n\n    /* called at DSA_free */\n       int (*finish)(DSA *DSA);\n\n       int flags;\n\n       char *app_data; /* ?? */\n\n} DSA_METHOD;\n</code></pre>"},{"location":"man3/DSA_set_method/#return-values","title":"RETURN VALUES","text":"<p>DSA_OpenSSL() and DSA_get_default_method() return pointers to the respective DSA_METHODs.</p> <p>DSA_set_default_method() returns no value.</p> <p>DSA_set_method() returns non-zero if the provided meth was successfully set as the method for dsa (including unloading the ENGINE handle if the previous method was supplied by an ENGINE).</p> <p>DSA_new_method() returns NULL and sets an error code that can be obtained by ERR_get_error(3) if the allocation fails. Otherwise it returns a pointer to the newly allocated structure.</p>"},{"location":"man3/DSA_set_method/#notes","title":"NOTES","text":"<p>As of version 0.9.7, DSA_METHOD implementations are grouped together with other algorithmic APIs (eg. RSA_METHOD, EVP_CIPHER, etc) in ENGINE modules. If a default ENGINE is specified for DSA functionality using an ENGINE API function, that will override any DSA defaults set using the DSA API (ie. DSA_set_default_method()). For this reason, the ENGINE API is the recommended way to control default implementations for use in DSA and other cryptographic algorithms.</p>"},{"location":"man3/DSA_set_method/#see-also","title":"SEE ALSO","text":"<p>dsa(3), DSA_new(3)</p>"},{"location":"man3/DSA_set_method/#history","title":"HISTORY","text":"<p>DSA_set_default_method(), DSA_get_default_method(), DSA_set_method(), DSA_new_method() and DSA_OpenSSL() were added in OpenSSL 0.9.4.</p> <p>DSA_set_default_openssl_method() and DSA_get_default_openssl_method() replaced DSA_set_default_method() and DSA_get_default_method() respectively, and DSA_set_method() and DSA_new_method() were altered to use ENGINEs rather than DSA_METHODs during development of the engine version of OpenSSL 0.9.6. For 0.9.7, the handling of defaults in the ENGINE API was restructured so that this change was reversed, and behaviour of the other functions resembled more closely the previous behaviour. The behaviour of defaults in the ENGINE API now transparently overrides the behaviour of defaults in the DSA API without requiring changing these function prototypes.</p>"},{"location":"man3/DSA_sign/","title":"DSA_sign","text":""},{"location":"man3/DSA_sign/#name","title":"NAME","text":"<p>DSA_sign, DSA_sign_setup, DSA_verify - DSA signatures</p>"},{"location":"man3/DSA_sign/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dsa.h&gt;\n\nint    DSA_sign(int type, const unsigned char *dgst, int len,\n               unsigned char *sigret, unsigned int *siglen, DSA *dsa);\n\nint    DSA_sign_setup(DSA *dsa, BN_CTX *ctx, BIGNUM **kinvp,\n               BIGNUM **rp);\n\nint    DSA_verify(int type, const unsigned char *dgst, int len,\n               unsigned char *sigbuf, int siglen, DSA *dsa);\n</code></pre>"},{"location":"man3/DSA_sign/#description","title":"DESCRIPTION","text":"<p>DSA_sign() computes a digital signature on the len byte message digest dgst using the private key dsa and places its ASN.1 DER encoding at sigret. The length of the signature is places in *siglen. sigret must point to DSA_size(dsa) bytes of memory.</p> <p>DSA_sign_setup() may be used to precompute part of the signing operation in case signature generation is time-critical. It expects dsa to contain DSA parameters. It places the precomputed values in newly allocated BIGNUMs at *kinvp and *rp, after freeing the old ones unless *kinvp and *rp are NULL. These values may be passed to DSA_sign() in dsa-&gt;kinv and dsa-&gt;r. ctx is a pre-allocated BN_CTX or NULL. The precomputed values from DSA_sign_setup() MUST NOT be used for more than one signature: using the same dsa-&gt;kinv and dsa-&gt;r pair twice under the same private key on different plaintexts will result in permanently exposing the DSA private key.</p> <p>DSA_verify() verifies that the signature sigbuf of size siglen matches a given message digest dgst of size len. dsa is the signer's public key.</p> <p>The type parameter is ignored.</p> <p>The PRNG must be seeded before DSA_sign() (or DSA_sign_setup()) is called.</p>"},{"location":"man3/DSA_sign/#return-values","title":"RETURN VALUES","text":"<p>DSA_sign() and DSA_sign_setup() return 1 on success, 0 on error. DSA_verify() returns 1 for a valid signature, 0 for an incorrect signature and -1 on error. The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/DSA_sign/#conforming-to","title":"CONFORMING TO","text":"<p>US Federal Information Processing Standard FIPS 186 (Digital Signature Standard, DSS), ANSI X9.30</p>"},{"location":"man3/DSA_sign/#see-also","title":"SEE ALSO","text":"<p>dsa(3), ERR_get_error(3), rand(3), DSA_do_sign(3)</p>"},{"location":"man3/DSA_sign/#history","title":"HISTORY","text":"<p>DSA_sign() and DSA_verify() are available in all versions of SSLeay. DSA_sign_setup() was added in SSLeay 0.8.</p>"},{"location":"man3/DSA_size/","title":"DSA_size","text":""},{"location":"man3/DSA_size/#name","title":"NAME","text":"<p>DSA_size - get DSA signature size</p>"},{"location":"man3/DSA_size/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dsa.h&gt;\n\nint DSA_size(const DSA *dsa);\n</code></pre>"},{"location":"man3/DSA_size/#description","title":"DESCRIPTION","text":"<p>This function returns the size of an ASN.1 encoded DSA signature in bytes. It can be used to determine how much memory must be allocated for a DSA signature.</p> <p>dsa-&gt;q must not be NULL.</p>"},{"location":"man3/DSA_size/#return-value","title":"RETURN VALUE","text":"<p>The size in bytes.</p>"},{"location":"man3/DSA_size/#see-also","title":"SEE ALSO","text":"<p>dsa(3), DSA_sign(3)</p>"},{"location":"man3/DSA_size/#history","title":"HISTORY","text":"<p>DSA_size() is available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/EC_GFp_simple_method/","title":"EC_GFp_simple_method","text":""},{"location":"man3/EC_GFp_simple_method/#name","title":"NAME","text":"<p>EC_GFp_simple_method, EC_GFp_mont_method, EC_GFp_nist_method, EC_GFp_nistp224_method, EC_GFp_nistp256_method, EC_GFp_nistp521_method, EC_GF2m_simple_method, EC_METHOD_get_field_type - Functions for obtaining EC_METHOD objects.</p>"},{"location":"man3/EC_GFp_simple_method/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ec.h&gt;\n\nconst EC_METHOD *EC_GFp_simple_method(void);\nconst EC_METHOD *EC_GFp_mont_method(void);\nconst EC_METHOD *EC_GFp_nist_method(void);\nconst EC_METHOD *EC_GFp_nistp224_method(void);\nconst EC_METHOD *EC_GFp_nistp256_method(void);\nconst EC_METHOD *EC_GFp_nistp521_method(void);\n\nconst EC_METHOD *EC_GF2m_simple_method(void);\n\nint EC_METHOD_get_field_type(const EC_METHOD *meth);\n</code></pre>"},{"location":"man3/EC_GFp_simple_method/#description","title":"DESCRIPTION","text":"<p>The Elliptic Curve library provides a number of different implementations through a single common interface. When constructing a curve using EC_GROUP_new (see EC_GROUP_new(3)) an implementation method must be provided. The functions described here all return a const pointer to an EC_METHOD structure that can be passed to EC_GROUP_NEW. It is important that the correct implementation type for the form of curve selected is used.</p> <p>For F2^m curves there is only one implementation choice, i.e. EC_GF2_simple_method.</p> <p>For Fp curves the lowest common denominator implementation is the EC_GFp_simple_method implementation. All other implementations are based on this one. EC_GFp_mont_method builds on EC_GFp_simple_method but adds the use of montgomery multiplication (see BN_mod_mul_montgomery(3)). EC_GFp_nist_method offers an implementation optimised for use with NIST recommended curves (NIST curves are available through EC_GROUP_new_by_curve_name as described in EC_GROUP_new(3)).</p> <p>The functions EC_GFp_nistp224_method, EC_GFp_nistp256_method and EC_GFp_nistp521_method offer 64 bit optimised implementations for the NIST P224, P256 and P521 curves respectively. Note, however, that these implementations are not available on all platforms.</p> <p>EC_METHOD_get_field_type identifies what type of field the EC_METHOD structure supports, which will be either F2^m or Fp. If the field type is Fp then the value NID_X9_62_prime_field is returned. If the field type is F2^m then the value NID_X9_62_characteristic_two_field is returned. These values are defined in the obj_mac.h header file.</p>"},{"location":"man3/EC_GFp_simple_method/#return-values","title":"RETURN VALUES","text":"<p>All EC_GFp* functions and EC_GF2m_simple_method always return a const pointer to an EC_METHOD structure.</p> <p>EC_METHOD_get_field_type returns an integer that identifies the type of field the EC_METHOD structure supports.</p>"},{"location":"man3/EC_GFp_simple_method/#see-also","title":"SEE ALSO","text":"<p>crypto(3), ec(3), EC_GROUP_new(3), EC_GROUP_copy(3), EC_POINT_new(3), EC_POINT_add(3), EC_KEY_new(3), d2i_ECPKParameters(3), BN_mod_mul_montgomery(3)</p>"},{"location":"man3/EC_GROUP_copy/","title":"EC_GROUP_copy","text":""},{"location":"man3/EC_GROUP_copy/#name","title":"NAME","text":"<p>EC_GROUP_copy, EC_GROUP_dup, EC_GROUP_method_of, EC_GROUP_set_generator, EC_GROUP_get0_generator, EC_GROUP_get_order, EC_GROUP_get_cofactor, EC_GROUP_set_curve_name, EC_GROUP_get_curve_name, EC_GROUP_set_asn1_flag, EC_GROUP_get_asn1_flag, EC_GROUP_set_point_conversion_form, EC_GROUP_get_point_conversion_form, EC_GROUP_get0_seed, EC_GROUP_get_seed_len, EC_GROUP_set_seed, EC_GROUP_get_degree, EC_GROUP_check, EC_GROUP_check_discriminant, EC_GROUP_cmp, EC_GROUP_get_basis_type, EC_GROUP_get_trinomial_basis, EC_GROUP_get_pentanomial_basis - Functions for manipulating EC_GROUP objects.</p>"},{"location":"man3/EC_GROUP_copy/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ec.h&gt;\n#include &lt;openssl/bn.h&gt;\n\nint EC_GROUP_copy(EC_GROUP *dst, const EC_GROUP *src);\nEC_GROUP *EC_GROUP_dup(const EC_GROUP *src);\n\nconst EC_METHOD *EC_GROUP_method_of(const EC_GROUP *group);\n\nint EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator, const BIGNUM *order, const BIGNUM *cofactor);\nconst EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group);\n\nint EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx);\nint EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor, BN_CTX *ctx);\n\nvoid EC_GROUP_set_curve_name(EC_GROUP *group, int nid);\nint EC_GROUP_get_curve_name(const EC_GROUP *group);\n\nvoid EC_GROUP_set_asn1_flag(EC_GROUP *group, int flag);\nint EC_GROUP_get_asn1_flag(const EC_GROUP *group);\n\nvoid EC_GROUP_set_point_conversion_form(EC_GROUP *group, point_conversion_form_t form);\npoint_conversion_form_t EC_GROUP_get_point_conversion_form(const EC_GROUP *);\n\nunsigned char *EC_GROUP_get0_seed(const EC_GROUP *x);\nsize_t EC_GROUP_get_seed_len(const EC_GROUP *);\nsize_t EC_GROUP_set_seed(EC_GROUP *, const unsigned char *, size_t len);\n\nint EC_GROUP_get_degree(const EC_GROUP *group);\n\nint EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx);\n\nint EC_GROUP_check_discriminant(const EC_GROUP *group, BN_CTX *ctx);\n\nint EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx);\n\nint EC_GROUP_get_basis_type(const EC_GROUP *);\nint EC_GROUP_get_trinomial_basis(const EC_GROUP *, unsigned int *k);\nint EC_GROUP_get_pentanomial_basis(const EC_GROUP *, unsigned int *k1, \n       unsigned int *k2, unsigned int *k3);\n</code></pre>"},{"location":"man3/EC_GROUP_copy/#description","title":"DESCRIPTION","text":"<p>EC_GROUP_copy copies the curve src into dst. Both src and dst must use the same EC_METHOD.</p> <p>EC_GROUP_dup creates a new EC_GROUP object and copies the content from src to the newly created EC_GROUP object.</p> <p>EC_GROUP_method_of obtains the EC_METHOD of group.</p> <p>EC_GROUP_set_generator sets curve paramaters that must be agreed by all participants using the curve. These paramaters include the generator, the order and the cofactor. The generator is a well defined point on the curve chosen for cryptographic operations. Integers used for point multiplications will be between 0 and n-1 where n is the order. The order multipied by the cofactor gives the number of points on the curve.</p> <p>EC_GROUP_get0_generator returns the generator for the identified group.</p> <p>The functions EC_GROUP_get_order and EC_GROUP_get_cofactor populate the provided order and cofactor parameters with the respective order and cofactors for the group.</p> <p>The functions EC_GROUP_set_curve_name and EC_GROUP_get_curve_name, set and get the NID for the curve respectively (see EC_GROUP_new(3)). If a curve does not have a NID associated with it, then EC_GROUP_get_curve_name will return 0.</p> <p>The asn1_flag value on a curve is used to determine whether there is a specific ASN1 OID to describe the curve or not. If the asn1_flag is 1 then this is a named curve with an associated ASN1 OID. If not then asn1_flag is 0. The functions EC_GROUP_get_asn1_flag and EC_GROUP_set_asn1_flag get and set the status of the asn1_flag for the curve. If set then the curve_name must also be set.</p> <p>The point_coversion_form for a curve controls how EC_POINT data is encoded as ASN1 as defined in X9.62 (ECDSA). point_conversion_form_t is an enum defined as follows: </p> <pre><code>typedef enum {\n       /** the point is encoded as z||x, where the octet z specifies \n        *   which solution of the quadratic equation y is  */\n       POINT_CONVERSION_COMPRESSED = 2,\n       /** the point is encoded as z||x||y, where z is the octet 0x02  */\n       POINT_CONVERSION_UNCOMPRESSED = 4,\n       /** the point is encoded as z||x||y, where the octet z specifies\n        *  which solution of the quadratic equation y is  */\n       POINT_CONVERSION_HYBRID = 6\n} point_conversion_form_t;\n</code></pre> <p>For POINT_CONVERSION_UNCOMPRESSED the point is encoded as an octet signifying the UNCOMPRESSED form has been used followed by the octets for x, followed by the octets for y.</p> <p>For any given x co-ordinate for a point on a curve it is possible to derive two possible y values. For POINT_CONVERSION_COMPRESSED the point is encoded as an octet signifying that the COMPRESSED form has been used AND which of the two possible solutions for y has been used, followed by the octets for x. </p> <p>For POINT_CONVERSION_HYBRID the point is encoded as an octet signifying the HYBRID form has been used AND which of the two possible solutions for y has been used, followed by the octets for x, followed by the octets for y.</p> <p>The functions EC_GROUP_set_point_conversion_form and EC_GROUP_get_point_conversion_form set and get the point_conversion_form for the curve respectively.</p> <p>ANSI X9.62 (ECDSA standard) defines a method of generating the curve parameter b from a random number. This provides advantages in that a parameter obtained in this way is highly unlikely to be susceptible to special purpose attacks, or have any trapdoors in it. If the seed is present for a curve then the b parameter was generated in a verifiable fashion using that seed. The OpenSSL EC library does not use this seed value but does enable you to inspect it using EC_GROUP_get0_seed. This returns a pointer to a memory block containing the seed that was used. The length of the memory block can be obtained using EC_GROUP_get_seed_len. A number of the builtin curves within the library provide seed values that can be obtained. It is also possible to set a custom seed using EC_GROUP_set_seed and passing a pointer to a memory block, along with the length of the seed. Again, the EC library will not use this seed value, although it will be preserved in any ASN1 based communications.</p> <p>EC_GROUP_get_degree gets the degree of the field. For Fp fields this will be the number of bits in p.  For F2^m fields this will be the value m.</p> <p>The function EC_GROUP_check_discriminant calculates the discriminant for the curve and verifies that it is valid. For a curve defined over Fp the discriminant is given by the formula 4*a^3 + 27*b^2 whilst for F2^m curves the discriminant is simply b. In either case for the curve to be valid the discriminant must be non zero.</p> <p>The function EC_GROUP_check performs a number of checks on a curve to verify that it is valid. Checks performed include verifying that the discriminant is non zero; that a generator has been defined; that the generator is on the curve and has the correct order.</p> <p>EC_GROUP_cmp compares a and b to determine whether they represent the same curve or not.</p> <p>The functions EC_GROUP_get_basis_type, EC_GROUP_get_trinomial_basis and EC_GROUP_get_pentanomial_basis should only be called for curves defined over an F2^m field. Addition and multiplication operations within an F2^m field are performed using an irreducible polynomial function f(x). This function is either a trinomial of the form:</p> <p>f(x) = x^m + x^k + 1 with m &gt; k &gt;= 1</p> <p>or a pentanomial of the form:</p> <p>f(x) = x^m + x^k3 + x^k2 + x^k1 + 1 with m &gt; k3 &gt; k2 &gt; k1 &gt;= 1</p> <p>The function EC_GROUP_get_basis_type returns a NID identifying whether a trinomial or pentanomial is in use for the field. The function EC_GROUP_get_trinomial_basis must only be called where f(x) is of the trinomial form, and returns the value of k. Similary the function EC_GROUP_get_pentanomial_basis must only be called where f(x) is of the pentanomial form, and returns the values of k1, k2 and k3 respectively.</p>"},{"location":"man3/EC_GROUP_copy/#return-values","title":"RETURN VALUES","text":"<p>The following functions return 1 on success or 0 on error: EC_GROUP_copy, EC_GROUP_set_generator, EC_GROUP_check, EC_GROUP_check_discriminant, EC_GROUP_get_trinomial_basis and EC_GROUP_get_pentanomial_basis.</p> <p>EC_GROUP_dup returns a pointer to the duplicated curve, or NULL on error.</p> <p>EC_GROUP_method_of returns the EC_METHOD implementation in use for the given curve or NULL on error.</p> <p>EC_GROUP_get0_generator returns the generator for the given curve or NULL on error.</p> <p>EC_GROUP_get_order, EC_GROUP_get_cofactor, EC_GROUP_get_curve_name, EC_GROUP_get_asn1_flag, EC_GROUP_get_point_conversion_form and EC_GROUP_get_degree return the order, cofactor, curve name (NID), ASN1 flag, point_conversion_form and degree for the specified curve respectively. If there is no curve name associated with a curve then EC_GROUP_get_curve_name will return 0.</p> <p>EC_GROUP_get0_seed returns a pointer to the seed that was used to generate the parameter b, or NULL if the seed is not specified. EC_GROUP_get_seed_len returns the length of the seed or 0 if the seed is not specified.</p> <p>EC_GROUP_set_seed returns the length of the seed that has been set. If the supplied seed is NULL, or the supplied seed length is 0, the return value will be 1. On error 0 is returned.</p> <p>EC_GROUP_cmp returns 0 if the curves are equal, 1 if they are not equal, or -1 on error.</p> <p>EC_GROUP_get_basis_type returns the values NID_X9_62_tpBasis or NID_X9_62_ppBasis (as defined in &lt;openssl/obj_mac.h&gt;) for a trinomial or pentanomial respectively. Alternatively in the event of an error a 0 is returned.</p>"},{"location":"man3/EC_GROUP_copy/#see-also","title":"SEE ALSO","text":"<p>crypto(3), ec(3), EC_GROUP_new(3), EC_POINT_new(3), EC_POINT_add(3), EC_KEY_new(3), EC_GFp_simple_method(3), d2i_ECPKParameters(3)</p>"},{"location":"man3/EC_GROUP_new/","title":"EC_GROUP_new","text":""},{"location":"man3/EC_GROUP_new/#name","title":"NAME","text":"<p>EC_GROUP_new, EC_GROUP_free, EC_GROUP_clear_free, EC_GROUP_new_curve_GFp, EC_GROUP_new_curve_GF2m, EC_GROUP_new_by_curve_name, EC_GROUP_set_curve_GFp, EC_GROUP_get_curve_GFp, EC_GROUP_set_curve_GF2m, EC_GROUP_get_curve_GF2m, EC_get_builtin_curves - Functions for creating and destroying EC_GROUP objects.</p>"},{"location":"man3/EC_GROUP_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ec.h&gt;\n#include &lt;openssl/bn.h&gt;\n\nEC_GROUP *EC_GROUP_new(const EC_METHOD *meth);\nvoid EC_GROUP_free(EC_GROUP *group);\nvoid EC_GROUP_clear_free(EC_GROUP *group);\n\nEC_GROUP *EC_GROUP_new_curve_GFp(const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);\nEC_GROUP *EC_GROUP_new_curve_GF2m(const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);\nEC_GROUP *EC_GROUP_new_by_curve_name(int nid);\n\nint EC_GROUP_set_curve_GFp(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);\nint EC_GROUP_get_curve_GFp(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\nint EC_GROUP_set_curve_GF2m(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);\nint EC_GROUP_get_curve_GF2m(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\n\nsize_t EC_get_builtin_curves(EC_builtin_curve *r, size_t nitems);\n</code></pre>"},{"location":"man3/EC_GROUP_new/#description","title":"DESCRIPTION","text":"<p>Within the library there are two forms of elliptic curve that are of interest. The first form is those defined over the prime field Fp. The elements of Fp are the integers 0 to p-1, where p is a prime number. This gives us a revised elliptic curve equation as follows:</p> <p>y^2 mod p = x^3 +ax + b mod p</p> <p>The second form is those defined over a binary field F2^m where the elements of the field are integers of length at most m bits. For this form the elliptic curve equation is modified to:</p> <p>y^2 + xy = x^3 + ax^2 + b (where b != 0)</p> <p>Operations in a binary field are performed relative to an irreducible polynomial. All such curves with OpenSSL use a trinomial or a pentanomial for this parameter.</p> <p>A new curve can be constructed by calling EC_GROUP_new, using the implementation provided by meth (see EC_GFp_simple_method(3)). It is then necessary to call either EC_GROUP_set_curve_GFp or EC_GROUP_set_curve_GF2m as appropriate to create a curve defined over Fp or over F2^m respectively. </p> <p>EC_GROUP_set_curve_GFp sets the curve parameters p, a and b for a curve over Fp stored in group. EC_group_get_curve_GFp obtains the previously set curve parameters.</p> <p>EC_GROUP_set_curve_GF2m sets the equivalent curve parameters for a curve over F2^m. In this case p represents the irreducible polybnomial - each bit represents a term in the polynomial. Therefore there will either be three or five bits set dependant on whether the polynomial is a trinomial or a pentanomial. EC_group_get_curve_GF2m obtains the previously set curve parameters.</p> <p>The functions EC_GROUP_new_curve_GFp and EC_GROUP_new_curve_GF2m are shortcuts for calling EC_GROUP_new and the appropriate EC_group_set_curve function. An appropriate default implementation method will be used.</p> <p>Whilst the library can be used to create any curve using the functions described above, there are also a number of predefined curves that are available. In order to obtain a list of all of the predefined curves, call the function EC_get_builtin_curves. The parameter r should be an array of EC_builtin_curve structures of size nitems. The function will populate the r array with information about the builtin curves. If nitems is less than the total number of curves available, then the first nitems curves will be returned. Otherwise the total number of curves will be provided. The return value is the total number of curves available (whether that number has been populated in r or not). Passing a NULL r, or setting nitems to 0 will do nothing other than return the total number of curves available. The EC_builtin_curve structure is defined as follows:</p> <pre><code>typedef struct { \n       int nid;\n       const char *comment;\n       } EC_builtin_curve;\n</code></pre> <p>Each EC_builtin_curve item has a unique integer id (nid), and a human readable comment string describing the curve.</p> <p>In order to construct a builtin curve use the function EC_GROUP_new_by_curve_name and provide the nid of the curve to be constructed.</p> <p>EC_GROUP_free frees the memory associated with the EC_GROUP.</p> <p>EC_GROUP_clear_free destroys any sensitive data held within the EC_GROUP and then frees its memory.</p>"},{"location":"man3/EC_GROUP_new/#return-values","title":"RETURN VALUES","text":"<p>All EC_GROUP_new* functions return a pointer to the newly constructed group, or NULL on error.</p> <p>EC_get_builtin_curves returns the number of builtin curves that are available.</p> <p>EC_GROUP_set_curve_GFp, EC_GROUP_get_curve_GFp, EC_GROUP_set_curve_GF2m, EC_GROUP_get_curve_GF2m return 1 on success or 0 on error.</p>"},{"location":"man3/EC_GROUP_new/#see-also","title":"SEE ALSO","text":"<p>crypto(3), ec(3), EC_GROUP_copy(3), EC_POINT_new(3), EC_POINT_add(3), EC_KEY_new(3), EC_GFp_simple_method(3), d2i_ECPKParameters(3)</p>"},{"location":"man3/EC_KEY_new/","title":"EC_KEY_new","text":""},{"location":"man3/EC_KEY_new/#name","title":"NAME","text":"<p>EC_KEY_new, EC_KEY_get_flags, EC_KEY_set_flags, EC_KEY_clear_flags, EC_KEY_new_by_curve_name, EC_KEY_free, EC_KEY_copy, EC_KEY_dup, EC_KEY_up_ref, EC_KEY_get0_group, EC_KEY_set_group, EC_KEY_get0_private_key, EC_KEY_set_private_key, EC_KEY_get0_public_key, EC_KEY_set_public_key, EC_KEY_get_enc_flags, EC_KEY_set_enc_flags, EC_KEY_get_conv_form, EC_KEY_set_conv_form, EC_KEY_get_key_method_data, EC_KEY_insert_key_method_data, EC_KEY_set_asn1_flag, EC_KEY_precompute_mult, EC_KEY_generate_key, EC_KEY_check_key, EC_KEY_set_public_key_affine_coordinates - Functions for creating, destroying and manipulating EC_KEY objects.</p>"},{"location":"man3/EC_KEY_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ec.h&gt;\n#include &lt;openssl/bn.h&gt;\n\nEC_KEY *EC_KEY_new(void);\nint EC_KEY_get_flags(const EC_KEY *key);\nvoid EC_KEY_set_flags(EC_KEY *key, int flags);\nvoid EC_KEY_clear_flags(EC_KEY *key, int flags);\nEC_KEY *EC_KEY_new_by_curve_name(int nid);\nvoid EC_KEY_free(EC_KEY *key);\nEC_KEY *EC_KEY_copy(EC_KEY *dst, const EC_KEY *src);\nEC_KEY *EC_KEY_dup(const EC_KEY *src);\nint EC_KEY_up_ref(EC_KEY *key);\nconst EC_GROUP *EC_KEY_get0_group(const EC_KEY *key);\nint EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group);\nconst BIGNUM *EC_KEY_get0_private_key(const EC_KEY *key);\nint EC_KEY_set_private_key(EC_KEY *key, const BIGNUM *prv);\nconst EC_POINT *EC_KEY_get0_public_key(const EC_KEY *key);\nint EC_KEY_set_public_key(EC_KEY *key, const EC_POINT *pub);\npoint_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *key);\nvoid EC_KEY_set_conv_form(EC_KEY *eckey, point_conversion_form_t cform);\nvoid *EC_KEY_get_key_method_data(EC_KEY *key, \n       void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *));\nvoid EC_KEY_insert_key_method_data(EC_KEY *key, void *data,\n       void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *));\nvoid EC_KEY_set_asn1_flag(EC_KEY *eckey, int asn1_flag);\nint EC_KEY_precompute_mult(EC_KEY *key, BN_CTX *ctx);\nint EC_KEY_generate_key(EC_KEY *key);\nint EC_KEY_check_key(const EC_KEY *key);\nint EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x, BIGNUM *y);\n</code></pre>"},{"location":"man3/EC_KEY_new/#description","title":"DESCRIPTION","text":"<p>An EC_KEY represents a public key and (optionaly) an associated private key. A new EC_KEY (with no associated curve) can be constructed by calling EC_KEY_new. The reference count for the newly created EC_KEY is initially set to 1. A curve can be associated with the EC_KEY by calling EC_KEY_set_group.</p> <p>Alternatively a new EC_KEY can be constructed by calling EC_KEY_new_by_curve_name and supplying the nid of the associated curve. Refer to EC_GROUP_new(3) for a description of curve names. This function simply wraps calls to EC_KEY_new and  EC_GROUP_new_by_curve_name.</p> <p>Calling EC_KEY_free decrements the reference count for the EC_KEY object, and if it has dropped to zero then frees the memory associated with it.</p> <p>EC_KEY_copy copies the contents of the EC_KEY in src into dest.</p> <p>EC_KEY_dup creates a new EC_KEY object and copies ec_key into it.</p> <p>EC_KEY_up_ref increments the reference count associated with the EC_KEY object.</p> <p>EC_KEY_generate_key generates a new public and private key for the supplied eckey object. eckey must have an EC_GROUP object associated with it before calling this function. The private key is a random integer (0 &lt; priv_key &lt; order, where order is the order of the EC_GROUP object). The public key is an EC_POINT on the curve calculated by multiplying the generator for the curve by the private key.</p> <p>EC_KEY_check_key performs various sanity checks on the EC_KEY object to confirm that it is valid.</p> <p>EC_KEY_set_public_key_affine_coordinates sets the public key for key based on its affine co-ordinates, i.e. it constructs an EC_POINT object based on the supplied x and y values and sets the public key to be this EC_POINT. It will also performs certain sanity checks on the key to confirm that it is valid.</p> <p>The functions EC_KEY_get0_group, EC_KEY_set_group, EC_KEY_get0_private_key, EC_KEY_set_private_key, EC_KEY_get0_public_key, and EC_KEY_set_public_key get and set the EC_GROUP object, the private key and the EC_POINT public key for the key respectively.</p> <p>The functions EC_KEY_get_conv_form and EC_KEY_set_conv_form get and set the point_conversion_form for the key. For a description of point_conversion_forms please refer to EC_POINT_new(3).</p> <p>EC_KEY_insert_key_method_data and EC_KEY_get_key_method_data enable the caller to associate arbitrary additional data specific to the elliptic curve scheme being used with the EC_KEY object. This data is treated as a \"black box\" by the ec library. The data to be stored by EC_KEY_insert_key_method_data is provided in the data parameter, which must have associated functions for duplicating, freeing and \"clear_freeing\" the data item. If a subsequent EC_KEY_get_key_method_data call is issued, the functions for duplicating, freeing and \"clear_freeing\" the data item must be provided again, and they must be the same as they were when the data item was inserted.</p> <p>EC_KEY_set_flags sets the flags in the flags parameter on the EC_KEY object. Any flags that are already set are left set. The currently defined standard flags are EC_FLAG_NON_FIPS_ALLOW and EC_FLAG_FIPS_CHECKED. In addition there is the flag EC_FLAG_COFACTOR_ECDH which is specific to ECDH and is defined in ecdh.h. EC_KEY_get_flags returns the current flags that are set for this EC_KEY. EC_KEY_clear_flags clears the flags indicated by the flags parameter. All other flags are left in their existing state.</p> <p>EC_KEY_set_asn1_flag sets the asn1_flag on the underlying EC_GROUP object (if set). Refer to EC_GROUP_copy(3) for further information on the asn1_flag.</p> <p>EC_KEY_precompute_mult stores multiples of the underlying EC_GROUP generator for faster point multiplication. See also EC_POINT_add(3).</p>"},{"location":"man3/EC_KEY_new/#return-values","title":"RETURN VALUES","text":"<p>EC_KEY_new, EC_KEY_new_by_curve_name and EC_KEY_dup return a pointer to the newly created EC_KEY object, or NULL on error.</p> <p>EC_KEY_get_flags returns the flags associated with the EC_KEY object as an integer.</p> <p>EC_KEY_copy returns a pointer to the destination key, or NULL on error.</p> <p>EC_KEY_up_ref, EC_KEY_set_group, EC_KEY_set_private_key, EC_KEY_set_public_key, EC_KEY_precompute_mult, EC_KEY_generate_key, EC_KEY_check_key and EC_KEY_set_public_key_affine_coordinates return 1 on success or 0 on error.</p> <p>EC_KEY_get0_group returns the EC_GROUP associated with the EC_KEY.</p> <p>EC_KEY_get0_private_key returns the private key associated with the EC_KEY.</p> <p>EC_KEY_get_conv_form return the point_conversion_form for the EC_KEY.</p>"},{"location":"man3/EC_KEY_new/#see-also","title":"SEE ALSO","text":"<p>crypto(3), ec(3), EC_GROUP_new(3), EC_GROUP_copy(3), EC_POINT_new(3), EC_POINT_add(3), EC_GFp_simple_method(3), d2i_ECPKParameters(3)</p>"},{"location":"man3/EC_POINT_add/","title":"EC_POINT_add","text":""},{"location":"man3/EC_POINT_add/#name","title":"NAME","text":"<p>EC_POINT_add, EC_POINT_dbl, EC_POINT_invert, EC_POINT_is_at_infinity, EC_POINT_is_on_curve, EC_POINT_cmp, EC_POINT_make_affine, EC_POINTs_make_affine, EC_POINTs_mul, EC_POINT_mul, EC_GROUP_precompute_mult, EC_GROUP_have_precompute_mult - Functions for performing mathematical operations and tests on EC_POINT objects.</p>"},{"location":"man3/EC_POINT_add/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ec.h&gt;\n#include &lt;openssl/bn.h&gt;\n\nint EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx);\nint EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, BN_CTX *ctx);\nint EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx);\nint EC_POINT_is_at_infinity(const EC_GROUP *group, const EC_POINT *p);\nint EC_POINT_is_on_curve(const EC_GROUP *group, const EC_POINT *point, BN_CTX *ctx);\nint EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx);\nint EC_POINT_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx);\nint EC_POINTs_make_affine(const EC_GROUP *group, size_t num, EC_POINT *points[], BN_CTX *ctx);\nint EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n, size_t num, const EC_POINT *p[], const BIGNUM *m[], BN_CTX *ctx);\nint EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n, const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);\nint EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx);\nint EC_GROUP_have_precompute_mult(const EC_GROUP *group);\n</code></pre>"},{"location":"man3/EC_POINT_add/#description","title":"DESCRIPTION","text":"<p>EC_POINT_add adds the two points a and b and places the result in r. Similarly EC_POINT_dbl doubles the point a and places the result in r. In both cases it is valid for r to be one of a or b.</p> <p>EC_POINT_invert calculates the inverse of the supplied point a. The result is placed back in a.</p> <p>The function EC_POINT_is_at_infinity tests whether the supplied point is at infinity or not.</p> <p>EC_POINT_is_on_curve tests whether the supplied point is on the curve or not.</p> <p>EC_POINT_cmp compares the two supplied points and tests whether or not they are equal.</p> <p>The functions EC_POINT_make_affine and EC_POINTs_make_affine force the internal representation of the EC_POINT(s) into the affine co-ordinate system. In the case of EC_POINTs_make_affine the value num provides the number of points in the array points to be forced.</p> <p>EC_POINT_mul calculates the value generator * n + q * m and stores the result in r. The value n may be NULL in which case the result is just q * m.</p> <p>EC_POINTs_mul calculates the value generator * n + q[0] * m[0] + ... + q[num-1] * m[num-1]. As for EC_POINT_mul the value n may be NULL.</p> <p>The function EC_GROUP_precompute_mult stores multiples of the generator for faster point multiplication, whilst EC_GROUP_have_precompute_mult tests whether precomputation has already been done. See EC_GROUP_copy(3) for information about the generator.</p>"},{"location":"man3/EC_POINT_add/#return-values","title":"RETURN VALUES","text":"<p>The following functions return 1 on success or 0 on error: EC_POINT_add, EC_POINT_dbl, EC_POINT_invert, EC_POINT_make_affine, EC_POINTs_make_affine, EC_POINTs_make_affine, EC_POINT_mul, EC_POINTs_mul and EC_GROUP_precompute_mult.</p> <p>EC_POINT_is_at_infinity returns 1 if the point is at infinity, or 0 otherwise.</p> <p>EC_POINT_is_on_curve returns 1 if the point is on the curve, 0 if not, or -1 on error.</p> <p>EC_POINT_cmp returns 1 if the points are not equal, 0 if they are, or -1 on error.</p> <p>EC_GROUP_have_precompute_mult return 1 if a precomputation has been done, or 0 if not.</p>"},{"location":"man3/EC_POINT_add/#see-also","title":"SEE ALSO","text":"<p>crypto(3), ec(3), EC_GROUP_new(3), EC_GROUP_copy(3), EC_POINT_new(3), EC_KEY_new(3), EC_GFp_simple_method(3), d2i_ECPKParameters(3)</p>"},{"location":"man3/EC_POINT_new/","title":"EC_POINT_new","text":""},{"location":"man3/EC_POINT_new/#name","title":"NAME","text":"<p>EC_POINT_new, EC_POINT_free, EC_POINT_clear_free, EC_POINT_copy, EC_POINT_dup, EC_POINT_method_of, EC_POINT_set_to_infinity, EC_POINT_set_Jprojective_coordinates, EC_POINT_get_Jprojective_coordinates_GFp, EC_POINT_set_affine_coordinates_GFp, EC_POINT_get_affine_coordinates_GFp, EC_POINT_set_compressed_coordinates_GFp, EC_POINT_set_affine_coordinates_GF2m, EC_POINT_get_affine_coordinates_GF2m, EC_POINT_set_compressed_coordinates_GF2m, EC_POINT_point2oct, EC_POINT_oct2point, EC_POINT_point2bn, EC_POINT_bn2point, EC_POINT_point2hex, EC_POINT_hex2point - Functions for creating, destroying and manipulating EC_POINT objects.</p>"},{"location":"man3/EC_POINT_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ec.h&gt;\n#include &lt;openssl/bn.h&gt;\n\nEC_POINT *EC_POINT_new(const EC_GROUP *group);\nvoid EC_POINT_free(EC_POINT *point);\nvoid EC_POINT_clear_free(EC_POINT *point);\nint EC_POINT_copy(EC_POINT *dst, const EC_POINT *src);\nEC_POINT *EC_POINT_dup(const EC_POINT *src, const EC_GROUP *group);\nconst EC_METHOD *EC_POINT_method_of(const EC_POINT *point);\nint EC_POINT_set_to_infinity(const EC_GROUP *group, EC_POINT *point);\nint EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,\n       const BIGNUM *x, const BIGNUM *y, const BIGNUM *z, BN_CTX *ctx);\nint EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group,\n       const EC_POINT *p, BIGNUM *x, BIGNUM *y, BIGNUM *z, BN_CTX *ctx);\nint EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,\n       const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx);\nint EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *group,\n       const EC_POINT *p, BIGNUM *x, BIGNUM *y, BN_CTX *ctx);\nint EC_POINT_set_compressed_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,\n       const BIGNUM *x, int y_bit, BN_CTX *ctx);\nint EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group, EC_POINT *p,\n       const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx);\nint EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *group,\n       const EC_POINT *p, BIGNUM *x, BIGNUM *y, BN_CTX *ctx);\nint EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *group, EC_POINT *p,\n       const BIGNUM *x, int y_bit, BN_CTX *ctx);\nsize_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *p,\n       point_conversion_form_t form,\n       unsigned char *buf, size_t len, BN_CTX *ctx);\nint EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *p,\n       const unsigned char *buf, size_t len, BN_CTX *ctx);\nBIGNUM *EC_POINT_point2bn(const EC_GROUP *, const EC_POINT *,\n       point_conversion_form_t form, BIGNUM *, BN_CTX *);\nEC_POINT *EC_POINT_bn2point(const EC_GROUP *, const BIGNUM *,\n       EC_POINT *, BN_CTX *);\nchar *EC_POINT_point2hex(const EC_GROUP *, const EC_POINT *,\n       point_conversion_form_t form, BN_CTX *);\nEC_POINT *EC_POINT_hex2point(const EC_GROUP *, const char *,\n       EC_POINT *, BN_CTX *);\n</code></pre>"},{"location":"man3/EC_POINT_new/#description","title":"DESCRIPTION","text":"<p>An EC_POINT represents a point on a curve. A new point is constructed by calling the function EC_POINT_new and providing the group object that the point relates to.</p> <p>EC_POINT_free frees the memory associated with the EC_POINT.</p> <p>EC_POINT_clear_free destroys any sensitive data held within the EC_POINT and then frees its memory.</p> <p>EC_POINT_copy copies the point src into dst. Both src and dst must use the same EC_METHOD.</p> <p>EC_POINT_dup creates a new EC_POINT object and copies the content from src to the newly created EC_POINT object.</p> <p>EC_POINT_method_of obtains the EC_METHOD associated with point.</p> <p>A valid point on a curve is the special point at  infinity. A point is set to be at infinity by calling EC_POINT_set_to_infinity.</p> <p>The affine co-ordinates for a point describe a point in terms of its x and y position. The functions EC_POINT_set_affine_coordinates_GFp and EC_POINT_set_affine_coordinates_GF2m set the x and y co-ordinates for the point p defined over the curve given in group.</p> <p>As well as the affine co-ordinates, a point can alternatively be described in terms of its Jacobian projective co-ordinates (for Fp curves only). Jacobian projective co-ordinates are expressed as three values x, y and z. Working in this co-ordinate system provides more efficient point multiplication operations. A mapping exists between Jacobian projective co-ordinates and affine co-ordinates. A Jacobian projective co-ordinate (x, y, z) can be written as an affine co-ordinate as (x/(z^2), y/(z^3)). Conversion to Jacobian projective to affine co-ordinates is simple. The co-ordinate (x, y) is mapped to (x, y, 1). To set or get the projective co-ordinates use EC_POINT_set_Jprojective_coordinates_GFp and EC_POINT_get_Jprojective_coordinates_GFp respectively.</p> <p>Points can also be described in terms of their compressed co-ordinates. For a point (x, y), for any given value for x such that the point is on the curve there will only ever be two possible values for y. Therefore a point can be set using the EC_POINT_set_compressed_coordinates_GFp and EC_POINT_set_compressed_coordinates_GF2m functions where x is the x co-ordinate and y_bit is a value 0 or 1 to identify which of the two possible values for y should be used.</p> <p>In addition EC_POINTs can be converted to and from various external representations. Supported representations are octet strings, BIGNUMs and hexadecimal. Octet strings are stored in a buffer along with an associated buffer length. A point held in a BIGNUM is calculated by converting the point to an octet string and then converting that octet string into a BIGNUM integer. Points in hexadecimal format are stored in a NULL terminated character string where each character is one of the printable values 0-9 or A-F (or a-f).</p> <p>The functions EC_POINT_point2oct, EC_POINT_oct2point, EC_POINT_point2bn, EC_POINT_bn2point, EC_POINT_point2hex and EC_POINT_hex2point convert from and to EC_POINTs for the formats: octet string, BIGNUM and hexadecimal respectively.</p> <p>The function EC_POINT_point2oct must be supplied with a buffer long enough to store the octet string. The return value provides the number of octets stored. Calling the function with a NULL buffer will not perform the conversion but will still return the required buffer length.</p> <p>The function EC_POINT_point2hex will allocate sufficient memory to store the hexadecimal string. It is the caller's responsibility to free this memory with a subsequent call to OPENSSL_free().</p>"},{"location":"man3/EC_POINT_new/#return-values","title":"RETURN VALUES","text":"<p>EC_POINT_new and EC_POINT_dup return the newly allocated EC_POINT or NULL on error.</p> <p>The following functions return 1 on success or 0 on error: EC_POINT_copy, EC_POINT_set_to_infinity, EC_POINT_set_Jprojective_coordinates_GFp, EC_POINT_get_Jprojective_coordinates_GFp, EC_POINT_set_affine_coordinates_GFp, EC_POINT_get_affine_coordinates_GFp, EC_POINT_set_compressed_coordinates_GFp, EC_POINT_set_affine_coordinates_GF2m, EC_POINT_get_affine_coordinates_GF2m, EC_POINT_set_compressed_coordinates_GF2m and EC_POINT_oct2point.</p> <p>EC_POINT_method_of returns the EC_METHOD associated with the supplied EC_POINT.</p> <p>EC_POINT_point2oct returns the length of the required buffer, or 0 on error.</p> <p>EC_POINT_point2bn returns the pointer to the BIGNUM supplied, or NULL on error.</p> <p>EC_POINT_bn2point returns the pointer to the EC_POINT supplied, or NULL on error.</p> <p>EC_POINT_point2hex returns a pointer to the hex string, or NULL on error.</p> <p>EC_POINT_hex2point returns the pointer to the EC_POINT supplied, or NULL on error.</p>"},{"location":"man3/EC_POINT_new/#see-also","title":"SEE ALSO","text":"<p>crypto(3), ec(3), EC_GROUP_new(3), EC_GROUP_copy(3), EC_POINT_add(3), EC_KEY_new(3), EC_GFp_simple_method(3), d2i_ECPKParameters(3)</p>"},{"location":"man3/ERR_GET_LIB/","title":"ERR_GET_LIB","text":""},{"location":"man3/ERR_GET_LIB/#name","title":"NAME","text":"<p>ERR_GET_LIB, ERR_GET_FUNC, ERR_GET_REASON - get library, function and reason code</p>"},{"location":"man3/ERR_GET_LIB/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/err.h&gt;\n\nint ERR_GET_LIB(unsigned long e);\n\nint ERR_GET_FUNC(unsigned long e);\n\nint ERR_GET_REASON(unsigned long e);\n</code></pre>"},{"location":"man3/ERR_GET_LIB/#description","title":"DESCRIPTION","text":"<p>The error code returned by ERR_get_error() consists of a library number, function code and reason code. ERR_GET_LIB(), ERR_GET_FUNC() and ERR_GET_REASON() can be used to extract these.</p> <p>The library number and function code describe where the error occurred, the reason code is the information about what went wrong.</p> <p>Each sub-library of OpenSSL has a unique library number; function and reason codes are unique within each sub-library.  Note that different libraries may use the same value to signal different functions and reasons.</p> <p>ERR_R_... reason codes such as ERR_R_MALLOC_FAILURE are globally unique. However, when checking for sub-library specific reason codes, be sure to also compare the library number.</p> <p>ERR_GET_LIB(), ERR_GET_FUNC() and ERR_GET_REASON() are macros.</p>"},{"location":"man3/ERR_GET_LIB/#return-values","title":"RETURN VALUES","text":"<p>The library number, function code and reason code respectively.</p>"},{"location":"man3/ERR_GET_LIB/#see-also","title":"SEE ALSO","text":"<p>err(3), ERR_get_error(3)</p>"},{"location":"man3/ERR_GET_LIB/#history","title":"HISTORY","text":"<p>ERR_GET_LIB(), ERR_GET_FUNC() and ERR_GET_REASON() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/ERR_clear_error/","title":"ERR_clear_error","text":""},{"location":"man3/ERR_clear_error/#name","title":"NAME","text":"<p>ERR_clear_error - clear the error queue</p>"},{"location":"man3/ERR_clear_error/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/err.h&gt;\n\nvoid ERR_clear_error(void);\n</code></pre>"},{"location":"man3/ERR_clear_error/#description","title":"DESCRIPTION","text":"<p>ERR_clear_error() empties the current thread's error queue.</p>"},{"location":"man3/ERR_clear_error/#return-values","title":"RETURN VALUES","text":"<p>ERR_clear_error() has no return value.</p>"},{"location":"man3/ERR_clear_error/#see-also","title":"SEE ALSO","text":"<p>err(3), ERR_get_error(3)</p>"},{"location":"man3/ERR_clear_error/#history","title":"HISTORY","text":"<p>ERR_clear_error() is available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/ERR_error_string/","title":"ERR_error_string","text":""},{"location":"man3/ERR_error_string/#name","title":"NAME","text":"<p>ERR_error_string, ERR_error_string_n, ERR_lib_error_string, ERR_func_error_string, ERR_reason_error_string - obtain human-readable error message</p>"},{"location":"man3/ERR_error_string/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/err.h&gt;\n\nchar *ERR_error_string(unsigned long e, char *buf);\nvoid ERR_error_string_n(unsigned long e, char *buf, size_t len);\n\nconst char *ERR_lib_error_string(unsigned long e);\nconst char *ERR_func_error_string(unsigned long e);\nconst char *ERR_reason_error_string(unsigned long e);\n</code></pre>"},{"location":"man3/ERR_error_string/#description","title":"DESCRIPTION","text":"<p>ERR_error_string() generates a human-readable string representing the error code e, and places it at buf. buf must be at least 120 bytes long. If buf is NULL, the error string is placed in a static buffer. ERR_error_string_n() is a variant of ERR_error_string() that writes at most len characters (including the terminating 0) and truncates the string if necessary. For ERR_error_string_n(), buf may not be NULL.</p> <p>The string will have the following format:</p> <pre><code>error:[error code]:[library name]:[function name]:[reason string]\n</code></pre> <p>error code is an 8 digit hexadecimal number, library name, function name and reason string are ASCII text.</p> <p>ERR_lib_error_string(), ERR_func_error_string() and ERR_reason_error_string() return the library name, function name and reason string respectively.</p> <p>The OpenSSL error strings should be loaded by calling ERR_load_crypto_strings(3) or, for SSL applications, SSL_load_error_strings(3) first. If there is no text string registered for the given error code, the error string will contain the numeric code.</p> <p>ERR_print_errors(3) can be used to print all error codes currently in the queue.</p>"},{"location":"man3/ERR_error_string/#return-values","title":"RETURN VALUES","text":"<p>ERR_error_string() returns a pointer to a static buffer containing the string if buf == NULL, buf otherwise.</p> <p>ERR_lib_error_string(), ERR_func_error_string() and ERR_reason_error_string() return the strings, and NULL if none is registered for the error code.</p>"},{"location":"man3/ERR_error_string/#see-also","title":"SEE ALSO","text":"<p>err(3), ERR_get_error(3), ERR_load_crypto_strings(3), SSL_load_error_strings(3) ERR_print_errors(3)</p>"},{"location":"man3/ERR_error_string/#history","title":"HISTORY","text":"<p>ERR_error_string() is available in all versions of SSLeay and OpenSSL. ERR_error_string_n() was added in OpenSSL 0.9.6.</p>"},{"location":"man3/ERR_get_error/","title":"ERR_get_error","text":""},{"location":"man3/ERR_get_error/#name","title":"NAME","text":"<p>ERR_get_error, ERR_peek_error, ERR_peek_last_error, ERR_get_error_line, ERR_peek_error_line, ERR_peek_last_error_line, ERR_get_error_line_data, ERR_peek_error_line_data, ERR_peek_last_error_line_data - obtain error code and data</p>"},{"location":"man3/ERR_get_error/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/err.h&gt;\n\nunsigned long ERR_get_error(void);\nunsigned long ERR_peek_error(void);\nunsigned long ERR_peek_last_error(void);\n\nunsigned long ERR_get_error_line(const char **file, int *line);\nunsigned long ERR_peek_error_line(const char **file, int *line);\nunsigned long ERR_peek_last_error_line(const char **file, int *line);\n\nunsigned long ERR_get_error_line_data(const char **file, int *line,\n        const char **data, int *flags);\nunsigned long ERR_peek_error_line_data(const char **file, int *line,\n        const char **data, int *flags);\nunsigned long ERR_peek_last_error_line_data(const char **file, int *line,\n        const char **data, int *flags);\n</code></pre>"},{"location":"man3/ERR_get_error/#description","title":"DESCRIPTION","text":"<p>ERR_get_error() returns the earliest error code from the thread's error queue and removes the entry. This function can be called repeatedly until there are no more error codes to return.</p> <p>ERR_peek_error() returns the earliest error code from the thread's error queue without modifying it.</p> <p>ERR_peek_last_error() returns the latest error code from the thread's error queue without modifying it.</p> <p>See ERR_GET_LIB(3) for obtaining information about location and reason of the error, and ERR_error_string(3) for human-readable error messages.</p> <p>ERR_get_error_line(), ERR_peek_error_line() and ERR_peek_last_error_line() are the same as the above, but they additionally store the file name and line number where the error occurred in *file and *line, unless these are NULL.</p> <p>ERR_get_error_line_data(), ERR_peek_error_line_data() and ERR_peek_last_error_line_data() store additional data and flags associated with the error code in *data and *flags, unless these are NULL. *data contains a string if *flags&amp;ERR_TXT_STRING is true.</p> <p>An application MUST NOT free the *data pointer (or any other pointers returned by these functions) with OPENSSL_free() as freeing is handled automatically by the error library.</p>"},{"location":"man3/ERR_get_error/#return-values","title":"RETURN VALUES","text":"<p>The error code, or 0 if there is no error in the queue.</p>"},{"location":"man3/ERR_get_error/#see-also","title":"SEE ALSO","text":"<p>err(3), ERR_error_string(3), ERR_GET_LIB(3)</p>"},{"location":"man3/ERR_get_error/#history","title":"HISTORY","text":"<p>ERR_get_error(), ERR_peek_error(), ERR_get_error_line() and ERR_peek_error_line() are available in all versions of SSLeay and OpenSSL. ERR_get_error_line_data() and ERR_peek_error_line_data() were added in SSLeay 0.9.0. ERR_peek_last_error(), ERR_peek_last_error_line() and ERR_peek_last_error_line_data() were added in OpenSSL 0.9.7.</p>"},{"location":"man3/ERR_load_crypto_strings/","title":"ERR_load_crypto_strings","text":""},{"location":"man3/ERR_load_crypto_strings/#name","title":"NAME","text":"<p>ERR_load_crypto_strings, SSL_load_error_strings, ERR_free_strings - load and free error strings</p>"},{"location":"man3/ERR_load_crypto_strings/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/err.h&gt;\n\nvoid ERR_load_crypto_strings(void);\nvoid ERR_free_strings(void);\n\n#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_load_error_strings(void);\n</code></pre>"},{"location":"man3/ERR_load_crypto_strings/#description","title":"DESCRIPTION","text":"<p>ERR_load_crypto_strings() registers the error strings for all libcrypto functions. SSL_load_error_strings() does the same, but also registers the libssl error strings.</p> <p>One of these functions should be called before generating textual error messages. However, this is not required when memory usage is an issue.</p> <p>ERR_free_strings() frees all previously loaded error strings.</p>"},{"location":"man3/ERR_load_crypto_strings/#return-values","title":"RETURN VALUES","text":"<p>ERR_load_crypto_strings(), SSL_load_error_strings() and ERR_free_strings() return no values.</p>"},{"location":"man3/ERR_load_crypto_strings/#see-also","title":"SEE ALSO","text":"<p>err(3), ERR_error_string(3)</p>"},{"location":"man3/ERR_load_crypto_strings/#history","title":"HISTORY","text":"<p>ERR_load_error_strings(), SSL_load_error_strings() and ERR_free_strings() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/ERR_load_strings/","title":"ERR_load_strings","text":""},{"location":"man3/ERR_load_strings/#name","title":"NAME","text":"<p>ERR_load_strings, ERR_PACK, ERR_get_next_error_library - load arbitrary error strings</p>"},{"location":"man3/ERR_load_strings/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/err.h&gt;\n\nvoid ERR_load_strings(int lib, ERR_STRING_DATA str[]);\n\nint ERR_get_next_error_library(void);\n\nunsigned long ERR_PACK(int lib, int func, int reason);\n</code></pre>"},{"location":"man3/ERR_load_strings/#description","title":"DESCRIPTION","text":"<p>ERR_load_strings() registers error strings for library number lib.</p> <p>str is an array of error string data:</p> <pre><code>typedef struct ERR_string_data_st\n{\n       unsigned long error;\n       char *string;\n} ERR_STRING_DATA;\n</code></pre> <p>The error code is generated from the library number and a function and reason code: error = ERR_PACK(lib, func, reason). ERR_PACK() is a macro.</p> <p>The last entry in the array is {0,0}.</p> <p>ERR_get_next_error_library() can be used to assign library numbers to user libraries at runtime.</p>"},{"location":"man3/ERR_load_strings/#return-value","title":"RETURN VALUE","text":"<p>ERR_load_strings() returns no value. ERR_PACK() return the error code. ERR_get_next_error_library() returns a new library number.</p>"},{"location":"man3/ERR_load_strings/#see-also","title":"SEE ALSO","text":"<p>err(3), ERR_load_strings(3)</p>"},{"location":"man3/ERR_load_strings/#history","title":"HISTORY","text":"<p>ERR_load_error_strings() and ERR_PACK() are available in all versions of SSLeay and OpenSSL. ERR_get_next_error_library() was added in SSLeay 0.9.0.</p>"},{"location":"man3/ERR_print_errors/","title":"ERR_print_errors","text":""},{"location":"man3/ERR_print_errors/#name","title":"NAME","text":"<p>ERR_print_errors, ERR_print_errors_fp - print error messages</p>"},{"location":"man3/ERR_print_errors/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/err.h&gt;\n\nvoid ERR_print_errors(BIO *bp);\nvoid ERR_print_errors_fp(FILE *fp);\n</code></pre>"},{"location":"man3/ERR_print_errors/#description","title":"DESCRIPTION","text":"<p>ERR_print_errors() is a convenience function that prints the error strings for all errors that OpenSSL has recorded to bp, thus emptying the error queue.</p> <p>ERR_print_errors_fp() is the same, except that the output goes to a FILE.</p> <p>The error strings will have the following format:</p> <pre><code>[pid]:error:[error code]:[library name]:[function name]:[reason string]:[file name]:[line]:[optional text message]\n</code></pre> <p>error code is an 8 digit hexadecimal number. library name, function name and reason string are ASCII text, as is optional text message if one was set for the respective error code.</p> <p>If there is no text string registered for the given error code, the error string will contain the numeric code.</p>"},{"location":"man3/ERR_print_errors/#return-values","title":"RETURN VALUES","text":"<p>ERR_print_errors() and ERR_print_errors_fp() return no values.</p>"},{"location":"man3/ERR_print_errors/#see-also","title":"SEE ALSO","text":"<p>err(3), ERR_error_string(3), ERR_get_error(3), ERR_load_crypto_strings(3), SSL_load_error_strings(3)</p>"},{"location":"man3/ERR_print_errors/#history","title":"HISTORY","text":"<p>ERR_print_errors() and ERR_print_errors_fp() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/ERR_put_error/","title":"ERR_put_error","text":""},{"location":"man3/ERR_put_error/#name","title":"NAME","text":"<p>ERR_put_error, ERR_add_error_data - record an error</p>"},{"location":"man3/ERR_put_error/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/err.h&gt;\n\nvoid ERR_put_error(int lib, int func, int reason, const char *file,\n        int line);\n\nvoid ERR_add_error_data(int num, ...);\n</code></pre>"},{"location":"man3/ERR_put_error/#description","title":"DESCRIPTION","text":"<p>ERR_put_error() adds an error code to the thread's error queue. It signals that the error of reason code reason occurred in function func of library lib, in line number line of file. This function is usually called by a macro.</p> <p>ERR_add_error_data() associates the concatenation of its num string arguments with the error code added last.</p> <p>ERR_load_strings(3) can be used to register error strings so that the application can a generate human-readable error messages for the error code.</p>"},{"location":"man3/ERR_put_error/#return-values","title":"RETURN VALUES","text":"<p>ERR_put_error() and ERR_add_error_data() return no values.</p>"},{"location":"man3/ERR_put_error/#see-also","title":"SEE ALSO","text":"<p>err(3), ERR_load_strings(3)</p>"},{"location":"man3/ERR_put_error/#history","title":"HISTORY","text":"<p>ERR_put_error() is available in all versions of SSLeay and OpenSSL. ERR_add_error_data() was added in SSLeay 0.9.0.</p>"},{"location":"man3/ERR_remove_state/","title":"ERR_remove_state","text":""},{"location":"man3/ERR_remove_state/#name","title":"NAME","text":"<p>ERR_remove_thread_state, ERR_remove_state - free a thread's error queue</p>"},{"location":"man3/ERR_remove_state/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/err.h&gt;\n\nvoid ERR_remove_thread_state(const CRYPTO_THREADID *tid);\n</code></pre> <p>Deprecated:</p> <pre><code>void ERR_remove_state(unsigned long pid);\n</code></pre>"},{"location":"man3/ERR_remove_state/#description","title":"DESCRIPTION","text":"<p>ERR_remove_thread_state() frees the error queue associated with thread tid. If tid == NULL, the current thread will have its error queue removed.</p> <p>Since error queue data structures are allocated automatically for new threads, they must be freed when threads are terminated in order to avoid memory leaks.</p> <p>ERR_remove_state is deprecated and has been replaced by ERR_remove_thread_state. Since threads in OpenSSL are no longer identified by unsigned long values any argument to this function is ignored. Calling ERR_remove_state is equivalent to ERR_remove_thread_state(NULL).</p>"},{"location":"man3/ERR_remove_state/#return-value","title":"RETURN VALUE","text":"<p>ERR_remove_thread_state and ERR_remove_state() return no value.</p>"},{"location":"man3/ERR_remove_state/#see-also","title":"SEE ALSO","text":"<p>err(3)</p>"},{"location":"man3/ERR_remove_state/#history","title":"HISTORY","text":"<p>ERR_remove_state() is available in all versions of SSLeay and OpenSSL. It was deprecated in OpenSSL 1.0.0 when ERR_remove_thread_state was introduced and thread IDs were introduced to identify threads instead of 'unsigned long'. </p>"},{"location":"man3/ERR_set_mark/","title":"ERR_set_mark","text":""},{"location":"man3/ERR_set_mark/#name","title":"NAME","text":"<p>ERR_set_mark, ERR_pop_to_mark - set marks and pop errors until mark</p>"},{"location":"man3/ERR_set_mark/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/err.h&gt;\n\nint ERR_set_mark(void);\n\nint ERR_pop_to_mark(void);\n</code></pre>"},{"location":"man3/ERR_set_mark/#description","title":"DESCRIPTION","text":"<p>ERR_set_mark() sets a mark on the current topmost error record if there is one.</p> <p>ERR_pop_to_mark() will pop the top of the error stack until a mark is found. The mark is then removed.  If there is no mark, the whole stack is removed.</p>"},{"location":"man3/ERR_set_mark/#return-values","title":"RETURN VALUES","text":"<p>ERR_set_mark() returns 0 if the error stack is empty, otherwise 1.</p> <p>ERR_pop_to_mark() returns 0 if there was no mark in the error stack, which implies that the stack became empty, otherwise 1.</p>"},{"location":"man3/ERR_set_mark/#see-also","title":"SEE ALSO","text":"<p>err(3)</p>"},{"location":"man3/ERR_set_mark/#history","title":"HISTORY","text":"<p>ERR_set_mark() and ERR_pop_to_mark() were added in OpenSSL 0.9.8.</p>"},{"location":"man3/EVP_BytesToKey/","title":"EVP_BytesToKey","text":""},{"location":"man3/EVP_BytesToKey/#name","title":"NAME","text":"<p>EVP_BytesToKey - password based encryption routine</p>"},{"location":"man3/EVP_BytesToKey/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_BytesToKey(const EVP_CIPHER *type,const EVP_MD *md,\n                      const unsigned char *salt,\n                      const unsigned char *data, int datal, int count,\n                      unsigned char *key,unsigned char *iv);\n</code></pre>"},{"location":"man3/EVP_BytesToKey/#description","title":"DESCRIPTION","text":"<p>EVP_BytesToKey() derives a key and IV from various parameters. type is the cipher to derive the key and IV for. md is the message digest to use. The salt parameter is used as a salt in the derivation: it should point to an 8 byte buffer or NULL if no salt is used. data is a buffer containing datal bytes which is used to derive the keying data. count is the iteration count to use. The derived key and IV will be written to key and iv respectively.</p>"},{"location":"man3/EVP_BytesToKey/#notes","title":"NOTES","text":"<p>A typical application of this function is to derive keying material for an encryption algorithm from a password in the data parameter.</p> <p>Increasing the count parameter slows down the algorithm which makes it harder for an attacker to peform a brute force attack using a large number of candidate passwords.</p> <p>If the total key and IV length is less than the digest length and MD5 is used then the derivation algorithm is compatible with PKCS#5 v1.5 otherwise a non standard extension is used to derive the extra data.</p> <p>Newer applications should use a more modern algorithm such as PBKDF2 as defined in PKCS#5v2.1 and provided by PKCS5_PBKDF2_HMAC.</p>"},{"location":"man3/EVP_BytesToKey/#key-derivation-algorithm","title":"KEY DERIVATION ALGORITHM","text":"<p>The key and IV is derived by concatenating D_1, D_2, etc until enough data is available for the key and IV. D_i is defined as:</p> <pre><code>    D_i = HASH^count(D_(i-1) || data || salt)\n</code></pre> <p>where || denotes concatentaion, D_0 is empty, HASH is the digest algorithm in use, HASH^1(data) is simply HASH(data), HASH^2(data) is HASH(HASH(data)) and so on.</p> <p>The initial bytes are used for the key and the subsequent bytes for the IV.</p>"},{"location":"man3/EVP_BytesToKey/#return-values","title":"RETURN VALUES","text":"<p>If data is NULL, then EVP_BytesToKey() returns the number of bytes needed to store the derived key. Otherwise, EVP_BytesToKey() returns the size of the derived key in bytes, or 0 on error.</p>"},{"location":"man3/EVP_BytesToKey/#see-also","title":"SEE ALSO","text":"<p>evp(3), rand(3), EVP_EncryptInit(3)</p>"},{"location":"man3/EVP_BytesToKey/#history","title":"HISTORY","text":""},{"location":"man3/EVP_DigestInit/","title":"EVP_DigestInit","text":""},{"location":"man3/EVP_DigestInit/#name","title":"NAME","text":"<p>EVP_MD_CTX_init, EVP_MD_CTX_create, EVP_DigestInit_ex, EVP_DigestUpdate, EVP_DigestFinal_ex, EVP_MD_CTX_cleanup, EVP_MD_CTX_destroy, EVP_MAX_MD_SIZE, EVP_MD_CTX_copy_ex, EVP_DigestInit, EVP_DigestFinal, EVP_MD_CTX_copy, EVP_MD_type, EVP_MD_pkey_type, EVP_MD_size, EVP_MD_block_size, EVP_MD_CTX_md, EVP_MD_CTX_size, EVP_MD_CTX_block_size, EVP_MD_CTX_type, EVP_md_null, EVP_md2, EVP_md5, EVP_sha, EVP_sha1, EVP_sha224, EVP_sha256, EVP_sha384, EVP_sha512, EVP_dss, EVP_dss1, EVP_mdc2, EVP_ripemd160, EVP_get_digestbyname, EVP_get_digestbynid, EVP_get_digestbyobj - EVP digest routines</p>"},{"location":"man3/EVP_DigestInit/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nvoid EVP_MD_CTX_init(EVP_MD_CTX *ctx);\nEVP_MD_CTX *EVP_MD_CTX_create(void);\n\nint EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\nint EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);\nint EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md,\n       unsigned int *s);\n\nint EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);\nvoid EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);\n\nint EVP_MD_CTX_copy_ex(EVP_MD_CTX *out,const EVP_MD_CTX *in);\n\nint EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);\nint EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md,\n       unsigned int *s);\n\nint EVP_MD_CTX_copy(EVP_MD_CTX *out,EVP_MD_CTX *in);\n\n#define EVP_MAX_MD_SIZE 64     /* SHA512 */\n\nint EVP_MD_type(const EVP_MD *md);\nint EVP_MD_pkey_type(const EVP_MD *md);        \nint EVP_MD_size(const EVP_MD *md);\nint EVP_MD_block_size(const EVP_MD *md);\n\nconst EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);\n#define EVP_MD_CTX_size(e)             EVP_MD_size(EVP_MD_CTX_md(e))\n#define EVP_MD_CTX_block_size(e)       EVP_MD_block_size((e)-&gt;digest)\n#define EVP_MD_CTX_type(e)             EVP_MD_type((e)-&gt;digest)\n\nconst EVP_MD *EVP_md_null(void);\nconst EVP_MD *EVP_md2(void);\nconst EVP_MD *EVP_md5(void);\nconst EVP_MD *EVP_sha(void);\nconst EVP_MD *EVP_sha1(void);\nconst EVP_MD *EVP_dss(void);\nconst EVP_MD *EVP_dss1(void);\nconst EVP_MD *EVP_mdc2(void);\nconst EVP_MD *EVP_ripemd160(void);\n\nconst EVP_MD *EVP_sha224(void);\nconst EVP_MD *EVP_sha256(void);\nconst EVP_MD *EVP_sha384(void);\nconst EVP_MD *EVP_sha512(void);\n\nconst EVP_MD *EVP_get_digestbyname(const char *name);\n#define EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a))\n#define EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a))\n</code></pre>"},{"location":"man3/EVP_DigestInit/#description","title":"DESCRIPTION","text":"<p>The EVP digest routines are a high level interface to message digests.</p> <p>EVP_MD_CTX_init() initializes digest context ctx.</p> <p>EVP_MD_CTX_create() allocates, initializes and returns a digest context.</p> <p>EVP_DigestInit_ex() sets up digest context ctx to use a digest type from ENGINE impl. ctx must be initialized before calling this function. type will typically be supplied by a functionsuch as EVP_sha1(). If impl is NULL then the default implementation of digest type is used.</p> <p>EVP_DigestUpdate() hashes cnt bytes of data at d into the digest context ctx. This function can be called several times on the same ctx to hash additional data.</p> <p>EVP_DigestFinal_ex() retrieves the digest value from ctx and places it in md. If the s parameter is not NULL then the number of bytes of data written (i.e. the length of the digest) will be written to the integer at s, at most EVP_MAX_MD_SIZE bytes will be written. After calling EVP_DigestFinal_ex() no additional calls to EVP_DigestUpdate() can be made, but EVP_DigestInit_ex() can be called to initialize a new digest operation.</p> <p>EVP_MD_CTX_cleanup() cleans up digest context ctx, it should be called after a digest context is no longer needed.</p> <p>EVP_MD_CTX_destroy() cleans up digest context ctx and frees up the space allocated to it, it should be called only on a context created using EVP_MD_CTX_create().</p> <p>EVP_MD_CTX_copy_ex() can be used to copy the message digest state from in to out. This is useful if large amounts of data are to be hashed which only differ in the last few bytes. out must be initialized before calling this function.</p> <p>EVP_DigestInit() behaves in the same way as EVP_DigestInit_ex() except the passed context ctx does not have to be initialized, and it always uses the default digest implementation.</p> <p>EVP_DigestFinal() is similar to EVP_DigestFinal_ex() except the digest context ctx is automatically cleaned up.</p> <p>EVP_MD_CTX_copy() is similar to EVP_MD_CTX_copy_ex() except the destination out does not have to be initialized.</p> <p>EVP_MD_size() and EVP_MD_CTX_size() return the size of the message digest when passed an EVP_MD or an EVP_MD_CTX structure, i.e. the size of the hash.</p> <p>EVP_MD_block_size() and EVP_MD_CTX_block_size() return the block size of the message digest when passed an EVP_MD or an EVP_MD_CTX structure.</p> <p>EVP_MD_type() and EVP_MD_CTX_type() return the NID of the OBJECT IDENTIFIER representing the given message digest when passed an EVP_MD structure. For example EVP_MD_type(EVP_sha1()) returns NID_sha1. This function is normally used when setting ASN1 OIDs.</p> <p>EVP_MD_CTX_md() returns the EVP_MD structure corresponding to the passed EVP_MD_CTX.</p> <p>EVP_MD_pkey_type() returns the NID of the public key signing algorithm associated with this digest. For example EVP_sha1() is associated with RSA so this will return NID_sha1WithRSAEncryption. Since digests and signature algorithms are no longer linked this function is only retained for compatibility reasons.</p> <p>EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_sha224(), EVP_sha256(), EVP_sha384(), EVP_sha512(), EVP_mdc2() and EVP_ripemd160() return EVP_MD structures for the MD2, MD5, SHA, SHA1, SHA224, SHA256, SHA384, SHA512, MDC2 and RIPEMD160 digest algorithms respectively.</p> <p>EVP_dss() and EVP_dss1() return EVP_MD structures for SHA and SHA1 digest algorithms but using DSS (DSA) for the signature algorithm. Note: there is no need to use these pseudo-digests in OpenSSL 1.0.0 and later, they are however retained for compatibility.</p> <p>EVP_md_null() is a \"null\" message digest that does nothing: i.e. the hash it returns is of zero length.</p> <p>EVP_get_digestbyname(), EVP_get_digestbynid() and EVP_get_digestbyobj() return an EVP_MD structure when passed a digest name, a digest NID or an ASN1_OBJECT structure respectively. The digest table must be initialized using, for example, OpenSSL_add_all_digests() for these functions to work.</p>"},{"location":"man3/EVP_DigestInit/#return-values","title":"RETURN VALUES","text":"<p>EVP_DigestInit_ex(), EVP_DigestUpdate() and EVP_DigestFinal_ex() return 1 for success and 0 for failure.</p> <p>EVP_MD_CTX_copy_ex() returns 1 if successful or 0 for failure.</p> <p>EVP_MD_type(), EVP_MD_pkey_type() and EVP_MD_type() return the NID of the corresponding OBJECT IDENTIFIER or NID_undef if none exists.</p> <p>EVP_MD_size(), EVP_MD_block_size(), EVP_MD_CTX_size() and EVP_MD_CTX_block_size() return the digest or block size in bytes.</p> <p>EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_dss(), EVP_dss1(), EVP_mdc2() and EVP_ripemd160() return pointers to the corresponding EVP_MD structures.</p> <p>EVP_get_digestbyname(), EVP_get_digestbynid() and EVP_get_digestbyobj() return either an EVP_MD structure or NULL if an error occurs.</p>"},{"location":"man3/EVP_DigestInit/#notes","title":"NOTES","text":"<p>The EVP interface to message digests should almost always be used in preference to the low level interfaces. This is because the code then becomes transparent to the digest used and much more flexible.</p> <p>New applications should use the SHA2 digest algorithms such as SHA256. The other digest algorithms are still in common use.</p> <p>For most applications the impl parameter to EVP_DigestInit_ex() will be set to NULL to use the default digest implementation.</p> <p>The functions EVP_DigestInit(), EVP_DigestFinal() and EVP_MD_CTX_copy() are obsolete but are retained to maintain compatibility with existing code. New applications should use EVP_DigestInit_ex(), EVP_DigestFinal_ex() and EVP_MD_CTX_copy_ex() because they can efficiently reuse a digest context instead of initializing and cleaning it up on each call and allow non default implementations of digests to be specified.</p> <p>In OpenSSL 0.9.7 and later if digest contexts are not cleaned up after use memory leaks will occur.</p> <p>Stack allocation of EVP_MD_CTX structures is common, for example:</p> <pre><code>EVP_MD_CTX mctx;\nEVP_MD_CTX_init(&amp;mctx);\n</code></pre> <p>This will cause binary compatibility issues if the size of EVP_MD_CTX structure changes (this will only happen with a major release of OpenSSL). Applications wishing to avoid this should use EVP_MD_CTX_create() instead:</p> <pre><code>EVP_MD_CTX *mctx;\nmctx = EVP_MD_CTX_create();\n</code></pre>"},{"location":"man3/EVP_DigestInit/#example","title":"EXAMPLE","text":"<p>This example digests the data \"Test Message\\n\" and \"Hello World\\n\", using the digest name passed on the command line.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;openssl/evp.h&gt;\n\nmain(int argc, char *argv[])\n{\nEVP_MD_CTX *mdctx;\nconst EVP_MD *md;\nchar mess1[] = \"Test Message\\n\";\nchar mess2[] = \"Hello World\\n\";\nunsigned char md_value[EVP_MAX_MD_SIZE];\nint md_len, i;\n\nOpenSSL_add_all_digests();\n\nif(!argv[1]) {\n       printf(\"Usage: mdtest digestname\\n\");\n       exit(1);\n}\n\nmd = EVP_get_digestbyname(argv[1]);\n\nif(!md) {\n       printf(\"Unknown message digest %s\\n\", argv[1]);\n       exit(1);\n}\n\nmdctx = EVP_MD_CTX_create();\nEVP_DigestInit_ex(mdctx, md, NULL);\nEVP_DigestUpdate(mdctx, mess1, strlen(mess1));\nEVP_DigestUpdate(mdctx, mess2, strlen(mess2));\nEVP_DigestFinal_ex(mdctx, md_value, &amp;md_len);\nEVP_MD_CTX_destroy(mdctx);\n\nprintf(\"Digest is: \");\nfor(i = 0; i &lt; md_len; i++)\n       printf(\"%02x\", md_value[i]);\nprintf(\"\\n\");\n\n/* Call this once before exit. */\nEVP_cleanup();\nexit(0);\n}\n</code></pre>"},{"location":"man3/EVP_DigestInit/#see-also","title":"SEE ALSO","text":"<p>dgst(1), evp(3)</p>"},{"location":"man3/EVP_DigestInit/#history","title":"HISTORY","text":"<p>EVP_DigestInit(), EVP_DigestUpdate() and EVP_DigestFinal() are available in all versions of SSLeay and OpenSSL.</p> <p>EVP_MD_CTX_init(), EVP_MD_CTX_create(), EVP_MD_CTX_copy_ex(), EVP_MD_CTX_cleanup(), EVP_MD_CTX_destroy(), EVP_DigestInit_ex() and EVP_DigestFinal_ex() were added in OpenSSL 0.9.7.</p> <p>EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_dss(), EVP_dss1(), EVP_mdc2() and EVP_ripemd160() were changed to return truly const EVP_MD * in OpenSSL 0.9.7.</p> <p>The link between digests and signing algorithms was fixed in OpenSSL 1.0 and later, so now EVP_sha1() can be used with RSA and DSA; there is no need to use EVP_dss1() any more.</p> <p>OpenSSL 1.0 and later does not include the MD2 digest algorithm in the default configuration due to its security weaknesses.</p>"},{"location":"man3/EVP_DigestSignInit/","title":"EVP_DigestSignInit","text":""},{"location":"man3/EVP_DigestSignInit/#name","title":"NAME","text":"<p>EVP_DigestSignInit, EVP_DigestSignUpdate, EVP_DigestSignFinal - EVP signing functions</p>"},{"location":"man3/EVP_DigestSignInit/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n                       const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);\nint EVP_DigestSignUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);\nint EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sig, size_t *siglen);\n</code></pre>"},{"location":"man3/EVP_DigestSignInit/#description","title":"DESCRIPTION","text":"<p>The EVP signature routines are a high level interface to digital signatures.</p> <p>EVP_DigestSignInit() sets up signing context ctx to use digest type from ENGINE impl and private key pkey. ctx must be initialized with EVP_MD_CTX_init() before calling this function. If pctx is not NULL, the EVP_PKEY_CTX of the signing operation will be written to *pctx: this can be used to set alternative signing options. Note that any existing value in *pctx is overwritten. The EVP_PKEY_CTX value returned must not be freed directly by the application (it will be freed automatically when the EVP_MD_CTX is freed). The digest type may be NULL if the signing algorithm supports it.</p> <p>EVP_DigestSignUpdate() hashes cnt bytes of data at d into the signature context ctx. This function can be called several times on the same ctx to include additional data. This function is currently implemented usig a macro.</p> <p>EVP_DigestSignFinal() signs the data in ctx places the signature in sig. If sig is NULL then the maximum size of the output buffer is written to the siglen parameter. If sig is not NULL then before the call the siglen parameter should contain the length of the sig buffer, if the call is successful the signature is written to sig and the amount of data written to siglen.</p>"},{"location":"man3/EVP_DigestSignInit/#return-values","title":"RETURN VALUES","text":"<p>EVP_DigestSignInit() EVP_DigestSignUpdate() and EVP_DigestSignaFinal() return 1 for success and 0 or a negative value for failure. In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</p> <p>The error codes can be obtained from ERR_get_error(3).</p>"},{"location":"man3/EVP_DigestSignInit/#notes","title":"NOTES","text":"<p>The EVP interface to digital signatures should almost always be used in preference to the low level interfaces. This is because the code then becomes transparent to the algorithm used and much more flexible.</p> <p>In previous versions of OpenSSL there was a link between message digest types and public key algorithms. This meant that \"clone\" digests such as EVP_dss1() needed to be used to sign using SHA1 and DSA. This is no longer necessary and the use of clone digest is now discouraged.</p> <p>For some key types and parameters the random number generator must be seeded or the operation will fail. </p> <p>The call to EVP_DigestSignFinal() internally finalizes a copy of the digest context. This means that calls to EVP_DigestSignUpdate() and EVP_DigestSignFinal() can be called later to digest and sign additional data.</p> <p>Since only a copy of the digest context is ever finalized the context must be cleaned up after use by calling EVP_MD_CTX_cleanup() or a memory leak will occur.</p> <p>The use of EVP_PKEY_size() with these functions is discouraged because some signature operations may have a signature length which depends on the parameters set. As a result EVP_PKEY_size() would have to return a value which indicates the maximum possible signature for any set of parameters.</p>"},{"location":"man3/EVP_DigestSignInit/#see-also","title":"SEE ALSO","text":"<p>EVP_DigestVerifyInit(3), EVP_DigestInit(3), err(3), evp(3), hmac(3), md2(3), md5(3), mdc2(3), ripemd(3), sha(3), dgst(1)</p>"},{"location":"man3/EVP_DigestSignInit/#history","title":"HISTORY","text":"<p>EVP_DigestSignInit(), EVP_DigestSignUpdate() and EVP_DigestSignFinal()  were first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_DigestVerifyInit/","title":"EVP_DigestVerifyInit","text":""},{"location":"man3/EVP_DigestVerifyInit/#name","title":"NAME","text":"<p>EVP_DigestVerifyInit, EVP_DigestVerifyUpdate, EVP_DigestVerifyFinal - EVP signature verification functions</p>"},{"location":"man3/EVP_DigestVerifyInit/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n                       const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);\nint EVP_DigestVerifyUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);\nint EVP_DigestVerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sig, size_t siglen);\n</code></pre>"},{"location":"man3/EVP_DigestVerifyInit/#description","title":"DESCRIPTION","text":"<p>The EVP signature routines are a high level interface to digital signatures.</p> <p>EVP_DigestVerifyInit() sets up verification context ctx to use digest type from ENGINE impl and public key pkey. ctx must be initialized with EVP_MD_CTX_init() before calling this function. If pctx is not NULL, the EVP_PKEY_CTX of the verification operation will be written to *pctx: this can be used to set alternative verification options. Note that any existing value in *pctx is overwritten. The EVP_PKEY_CTX value returned must not be freed directly by the application (it will be freed automatically when the EVP_MD_CTX is freed).</p> <p>EVP_DigestVerifyUpdate() hashes cnt bytes of data at d into the verification context ctx. This function can be called several times on the same ctx to include additional data. This function is currently implemented using a macro.</p> <p>EVP_DigestVerifyFinal() verifies the data in ctx against the signature in sig of length siglen.</p>"},{"location":"man3/EVP_DigestVerifyInit/#return-values","title":"RETURN VALUES","text":"<p>EVP_DigestVerifyInit() and EVP_DigestVerifyUpdate() return 1 for success and 0 or a negative value for failure. In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</p> <p>EVP_DigestVerifyFinal() returns 1 for success; any other value indicates failure.  A return value of zero indicates that the signature did not verify successfully (that is, tbs did not match the original data or the signature had an invalid form), while other values indicate a more serious error (and sometimes also indicate an invalid signature form).</p> <p>The error codes can be obtained from ERR_get_error(3).</p>"},{"location":"man3/EVP_DigestVerifyInit/#notes","title":"NOTES","text":"<p>The EVP interface to digital signatures should almost always be used in preference to the low level interfaces. This is because the code then becomes transparent to the algorithm used and much more flexible.</p> <p>In previous versions of OpenSSL there was a link between message digest types and public key algorithms. This meant that \"clone\" digests such as EVP_dss1() needed to be used to sign using SHA1 and DSA. This is no longer necessary and the use of clone digest is now discouraged.</p> <p>For some key types and parameters the random number generator must be seeded or the operation will fail. </p> <p>The call to EVP_DigestVerifyFinal() internally finalizes a copy of the digest context. This means that EVP_VerifyUpdate() and EVP_VerifyFinal() can be called later to digest and verify additional data.</p> <p>Since only a copy of the digest context is ever finalized the context must be cleaned up after use by calling EVP_MD_CTX_cleanup() or a memory leak will occur.</p>"},{"location":"man3/EVP_DigestVerifyInit/#see-also","title":"SEE ALSO","text":"<p>EVP_DigestSignInit(3), EVP_DigestInit(3), err(3), evp(3), hmac(3), md2(3), md5(3), mdc2(3), ripemd(3), sha(3), dgst(1)</p>"},{"location":"man3/EVP_DigestVerifyInit/#history","title":"HISTORY","text":"<p>EVP_DigestVerifyInit(), EVP_DigestVerifyUpdate() and EVP_DigestVerifyFinal()  were first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_EncodeInit/","title":"EVP_EncodeInit","text":""},{"location":"man3/EVP_EncodeInit/#name","title":"NAME","text":"<p>EVP_EncodeInit, EVP_EncodeUpdate, EVP_EncodeFinal, EVP_EncodeBlock, EVP_DecodeInit, EVP_DecodeUpdate, EVP_DecodeFinal, EVP_DecodeBlock - EVP base 64 encode/decode routines</p>"},{"location":"man3/EVP_EncodeInit/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nvoid EVP_EncodeInit(EVP_ENCODE_CTX *ctx);\nvoid EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl);\nvoid EVP_EncodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl);\nint EVP_EncodeBlock(unsigned char *t, const unsigned char *f, int n);\n\nvoid EVP_DecodeInit(EVP_ENCODE_CTX *ctx);\nint EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n                     const unsigned char *in, int inl);\nint EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned\n                    char *out, int *outl);\nint EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n);\n</code></pre>"},{"location":"man3/EVP_EncodeInit/#description","title":"DESCRIPTION","text":"<p>The EVP encode routines provide a high level interface to base 64 encoding and decoding. Base 64 encoding converts binary data into a printable form that uses the characters A-Z, a-z, 0-9, \"+\" and \"/\" to represent the data. For every 3 bytes of binary data provided 4 bytes of base 64 encoded data will be produced plus some occasional newlines (see below). If the input data length is not a multiple of 3 then the output data will be padded at the end using the \"=\" character.</p> <p>Encoding of binary data is performed in blocks of 48 input bytes (or less for the final block). For each 48 byte input block encoded 64 bytes of base 64 data is output plus an additional newline character (i.e. 65 bytes in total). The final block (which may be less than 48 bytes) will output 4 bytes for every 3 bytes of input. If the data length is not divisible by 3 then a full 4 bytes is still output for the final 1 or 2 bytes of input. Similarly a newline character will also be output.</p> <p>EVP_EncodeInit() initialises ctx for the start of a new encoding operation.</p> <p>EVP_EncodeUpdate() encode inl bytes of data found in the buffer pointed to by in. The output is stored in the buffer out and the number of bytes output is stored in *outl. It is the caller's responsibility to ensure that the buffer at out is sufficiently large to accommodate the output data. Only full blocks of data (48 bytes) will be immediately processed and output by this function. Any remainder is held in the ctx object and will be processed by a subsequent call to EVP_EncodeUpdate() or EVP_EncodeFinal(). To calculate the required size of the output buffer add together the value of inl with the amount of unprocessed data held in ctx and divide the result by 48 (ignore any remainder). This gives the number of blocks of data that will be processed. Ensure the output buffer contains 65 bytes of storage for each block, plus an additional byte for a NUL terminator. EVP_EncodeUpdate() may be called repeatedly to process large amounts of input data. In the event of an error EVP_EncodeUpdate() will set *outl to 0.</p> <p>EVP_EncodeFinal() must be called at the end of an encoding operation. It will process any partial block of data remaining in the ctx object. The output data will be stored in out and the length of the data written will be stored in *outl. It is the caller's responsibility to ensure that out is sufficiently large to accommodate the output data which will never be more than 65 bytes plus an additional NUL terminator (i.e. 66 bytes in total).</p> <p>EVP_EncodeBlock() encodes a full block of input data in f and of length dlen and stores it in t. For every 3 bytes of input provided 4 bytes of output data will be produced. If dlen is not divisible by 3 then the block is encoded as a final block of data and the output is padded such that it is always divisible by 4. Additionally a NUL terminator character will be added. For example if 16 bytes of input data is provided then 24 bytes of encoded data is created plus 1 byte for a NUL terminator (i.e. 25 bytes in total). The length of the data generated without the NUL terminator is returned from the function.</p> <p>EVP_DecodeInit() initialises ctx for the start of a new decoding operation.</p> <p>EVP_DecodeUpdate() decodes inl characters of data found in the buffer pointed to by in. The output is stored in the buffer out and the number of bytes output is stored in *outl. It is the caller's responsibility to ensure that the buffer at out is sufficiently large to accommodate the output data. This function will attempt to decode as much data as possible in 4 byte chunks. Any whitespace, newline or carriage return characters are ignored. Any partial chunk of unprocessed data (1, 2 or 3 bytes) that remains at the end will be held in the ctx object and processed by a subsequent call to EVP_DecodeUpdate(). If any illegal base 64 characters are encountered or if the base 64 padding character \"=\" is encountered in the middle of the data then the function returns -1 to indicate an error. A return value of 0 or 1 indicates successful processing of the data. A return value of 0 additionally indicates that the last input data characters processed included the base 64 padding character \"=\" and therefore no more non-padding character data is expected to be processed. For every 4 valid base 64 bytes processed (ignoring whitespace, carriage returns and line feeds), 3 bytes of binary output data will be produced (or less at the end of the data where the padding character \"=\" has been used).</p> <p>EVP_DecodeFinal() must be called at the end of a decoding operation. If there is any unprocessed data still in ctx then the input data must not have been a multiple of 4 and therefore an error has occurred. The function will return -1 in this case. Otherwise the function returns 1 on success.</p> <p>EVP_DecodeBlock() will decode the block of n characters of base 64 data contained in f and store the result in t. Any leading whitespace will be trimmed as will any trailing whitespace, newlines, carriage returns or EOF characters. After such trimming the length of the data in f must be divisbile by 4. For every 4 input bytes exactly 3 output bytes will be produced. The output will be padded with 0 bits if necessary to ensure that the output is always 3 bytes for every 4 input bytes. This function will return the length of the data decoded or -1 on error.</p>"},{"location":"man3/EVP_EncodeInit/#return-values","title":"RETURN VALUES","text":"<p>EVP_EncodeBlock() returns the number of bytes encoded excluding the NUL terminator.</p> <p>EVP_DecodeUpdate() returns -1 on error and 0 or 1 on success. If 0 is returned then no more non-padding base 64 characters are expected.</p> <p>EVP_DecodeFinal() returns -1 on error or 1 on success.</p> <p>EVP_DecodeBlock() returns the length of the data decoded or -1 on error.</p>"},{"location":"man3/EVP_EncodeInit/#see-also","title":"SEE ALSO","text":"<p>evp(3)</p>"},{"location":"man3/EVP_EncryptInit/","title":"EVP_EncryptInit","text":""},{"location":"man3/EVP_EncryptInit/#name","title":"NAME","text":"<p>EVP_CIPHER_CTX_init, EVP_EncryptInit_ex, EVP_EncryptUpdate, EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate, EVP_DecryptFinal_ex, EVP_CipherInit_ex, EVP_CipherUpdate, EVP_CipherFinal_ex, EVP_CIPHER_CTX_set_key_length, EVP_CIPHER_CTX_ctrl, EVP_CIPHER_CTX_cleanup, EVP_EncryptInit, EVP_EncryptFinal, EVP_DecryptInit, EVP_DecryptFinal, EVP_CipherInit, EVP_CipherFinal, EVP_get_cipherbyname, EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_nid, EVP_CIPHER_block_size, EVP_CIPHER_key_length, EVP_CIPHER_iv_length, EVP_CIPHER_flags, EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher, EVP_CIPHER_CTX_nid, EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length, EVP_CIPHER_CTX_iv_length, EVP_CIPHER_CTX_get_app_data, EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_flags, EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param, EVP_CIPHER_CTX_set_padding,  EVP_enc_null, EVP_des_cbc, EVP_des_ecb, EVP_des_cfb, EVP_des_ofb, EVP_des_ede_cbc, EVP_des_ede, EVP_des_ede_ofb, EVP_des_ede_cfb, EVP_des_ede3_cbc, EVP_des_ede3, EVP_des_ede3_ofb, EVP_des_ede3_cfb, EVP_desx_cbc, EVP_rc4, EVP_rc4_40, EVP_rc4_hmac_md5, EVP_idea_cbc, EVP_idea_ecb, EVP_idea_cfb, EVP_idea_ofb, EVP_rc2_cbc, EVP_rc2_ecb, EVP_rc2_cfb, EVP_rc2_ofb, EVP_rc2_40_cbc, EVP_rc2_64_cbc, EVP_bf_cbc, EVP_bf_ecb, EVP_bf_cfb, EVP_bf_ofb, EVP_cast5_cbc, EVP_cast5_ecb, EVP_cast5_cfb, EVP_cast5_ofb, EVP_rc5_32_12_16_cbc, EVP_rc5_32_12_16_ecb, EVP_rc5_32_12_16_cfb, EVP_rc5_32_12_16_ofb,  EVP_aes_128_gcm, EVP_aes_192_gcm, EVP_aes_256_gcm, EVP_aes_128_ccm, EVP_aes_192_ccm, EVP_aes_256_ccm, EVP_aes_128_cbc_hmac_sha1, EVP_aes_256_cbc_hmac_sha1, EVP_aes_128_cbc_hmac_sha256, EVP_aes_256_cbc_hmac_sha256 - EVP cipher routines</p>"},{"location":"man3/EVP_EncryptInit/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nvoid EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);\n\nint EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n        ENGINE *impl, const unsigned char *key, const unsigned char *iv);\nint EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n        int *outl, const unsigned char *in, int inl);\nint EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,\n        int *outl);\n\nint EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n        ENGINE *impl, const unsigned char *key, const unsigned char *iv);\nint EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n        int *outl, const unsigned char *in, int inl);\nint EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n        int *outl);\n\nint EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n        ENGINE *impl, const unsigned char *key, const unsigned char *iv, int enc);\nint EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n        int *outl, const unsigned char *in, int inl);\nint EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n        int *outl);\n\nint EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n        const unsigned char *key, const unsigned char *iv);\nint EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n        int *outl);\n\nint EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n        const unsigned char *key, const unsigned char *iv);\nint EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n        int *outl);\n\nint EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n        const unsigned char *key, const unsigned char *iv, int enc);\nint EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n        int *outl);\n\nint EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);\nint EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);\nint EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);\nint EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);\n\nconst EVP_CIPHER *EVP_get_cipherbyname(const char *name);\n#define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))\n#define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))\n\n#define EVP_CIPHER_nid(e)              ((e)-&gt;nid)\n#define EVP_CIPHER_block_size(e)       ((e)-&gt;block_size)\n#define EVP_CIPHER_key_length(e)       ((e)-&gt;key_len)\n#define EVP_CIPHER_iv_length(e)                ((e)-&gt;iv_len)\n#define EVP_CIPHER_flags(e)            ((e)-&gt;flags)\n#define EVP_CIPHER_mode(e)             ((e)-&gt;flags) &amp; EVP_CIPH_MODE)\nint EVP_CIPHER_type(const EVP_CIPHER *ctx);\n\n#define EVP_CIPHER_CTX_cipher(e)       ((e)-&gt;cipher)\n#define EVP_CIPHER_CTX_nid(e)          ((e)-&gt;cipher-&gt;nid)\n#define EVP_CIPHER_CTX_block_size(e)   ((e)-&gt;cipher-&gt;block_size)\n#define EVP_CIPHER_CTX_key_length(e)   ((e)-&gt;key_len)\n#define EVP_CIPHER_CTX_iv_length(e)    ((e)-&gt;cipher-&gt;iv_len)\n#define EVP_CIPHER_CTX_get_app_data(e) ((e)-&gt;app_data)\n#define EVP_CIPHER_CTX_set_app_data(e,d) ((e)-&gt;app_data=(char *)(d))\n#define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))\n#define EVP_CIPHER_CTX_flags(e)                ((e)-&gt;cipher-&gt;flags)\n#define EVP_CIPHER_CTX_mode(e)         ((e)-&gt;cipher-&gt;flags &amp; EVP_CIPH_MODE)\n\nint EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\nint EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n</code></pre>"},{"location":"man3/EVP_EncryptInit/#description","title":"DESCRIPTION","text":"<p>The EVP cipher routines are a high level interface to certain symmetric ciphers.</p> <p>EVP_CIPHER_CTX_init() initializes cipher contex ctx.</p> <p>EVP_EncryptInit_ex() sets up cipher context ctx for encryption with cipher type from ENGINE impl. ctx must be initialized before calling this function. type is normally supplied by a function such as EVP_aes_256_cbc(). If impl is NULL then the default implementation is used. key is the symmetric key to use and iv is the IV to use (if necessary), the actual number of bytes used for the key and IV depends on the cipher. It is possible to set all parameters to NULL except type in an initial call and supply the remaining parameters in subsequent calls, all of which have type set to NULL. This is done when the default cipher parameters are not appropriate.</p> <p>EVP_EncryptUpdate() encrypts inl bytes from the buffer in and writes the encrypted version to out. This function can be called multiple times to encrypt successive blocks of data. The amount of data written depends on the block alignment of the encrypted data: as a result the amount of data written may be anything from zero bytes to (inl + cipher_block_size - 1) so out should contain sufficient room. The actual number of bytes written is placed in outl.</p> <p>If padding is enabled (the default) then EVP_EncryptFinal_ex() encrypts the \"final\" data, that is any data that remains in a partial block. It uses standard block padding (aka PKCS padding). The encrypted final data is written to out which should have sufficient space for one cipher block. The number of bytes written is placed in outl. After this function is called the encryption operation is finished and no further calls to EVP_EncryptUpdate() should be made.</p> <p>If padding is disabled then EVP_EncryptFinal_ex() will not encrypt any more data and it will return an error if any data remains in a partial block: that is if the total data length is not a multiple of the block size. </p> <p>EVP_DecryptInit_ex(), EVP_DecryptUpdate() and EVP_DecryptFinal_ex() are the corresponding decryption operations. EVP_DecryptFinal() will return an error code if padding is enabled and the final block is not correctly formatted. The parameters and restrictions are identical to the encryption operations except that if padding is enabled the decrypted data buffer out passed to EVP_DecryptUpdate() should have sufficient room for (inl + cipher_block_size) bytes unless the cipher block size is 1 in which case inl bytes is sufficient.</p> <p>EVP_CipherInit_ex(), EVP_CipherUpdate() and EVP_CipherFinal_ex() are functions that can be used for decryption or encryption. The operation performed depends on the value of the enc parameter. It should be set to 1 for encryption, 0 for decryption and -1 to leave the value unchanged (the actual value of 'enc' being supplied in a previous call).</p> <p>EVP_CIPHER_CTX_cleanup() clears all information from a cipher context and free up any allocated memory associate with it. It should be called after all operations using a cipher are complete so sensitive information does not remain in memory.</p> <p>EVP_EncryptInit(), EVP_DecryptInit() and EVP_CipherInit() behave in a similar way to EVP_EncryptInit_ex(), EVP_DecryptInit_ex and EVP_CipherInit_ex() except the ctx parameter does not need to be initialized and they always use the default cipher implementation.</p> <p>EVP_EncryptFinal(), EVP_DecryptFinal() and EVP_CipherFinal() are identical to EVP_EncryptFinal_ex(), EVP_DecryptFinal_ex() and EVP_CipherFinal_ex(). In previous releases they also cleaned up the ctx, but this is no longer done and EVP_CIPHER_CTX_clean() must be called to free any context resources.</p> <p>EVP_get_cipherbyname(), EVP_get_cipherbynid() and EVP_get_cipherbyobj() return an EVP_CIPHER structure when passed a cipher name, a NID or an ASN1_OBJECT structure.</p> <p>EVP_CIPHER_nid() and EVP_CIPHER_CTX_nid() return the NID of a cipher when passed an EVP_CIPHER or EVP_CIPHER_CTX structure.  The actual NID value is an internal value which may not have a corresponding OBJECT IDENTIFIER.</p> <p>EVP_CIPHER_CTX_set_padding() enables or disables padding. By default encryption operations are padded using standard block padding and the padding is checked and removed when decrypting. If the pad parameter is zero then no padding is performed, the total amount of data encrypted or decrypted must then be a multiple of the block size or an error will occur.</p> <p>EVP_CIPHER_key_length() and EVP_CIPHER_CTX_key_length() return the key length of a cipher when passed an EVP_CIPHER or EVP_CIPHER_CTX structure. The constant EVP_MAX_KEY_LENGTH is the maximum key length for all ciphers. Note: although EVP_CIPHER_key_length() is fixed for a given cipher, the value of EVP_CIPHER_CTX_key_length() may be different for variable key length ciphers.</p> <p>EVP_CIPHER_CTX_set_key_length() sets the key length of the cipher ctx. If the cipher is a fixed length cipher then attempting to set the key length to any value other than the fixed value is an error.</p> <p>EVP_CIPHER_iv_length() and EVP_CIPHER_CTX_iv_length() return the IV length of a cipher when passed an EVP_CIPHER or EVP_CIPHER_CTX. It will return zero if the cipher does not use an IV.  The constant EVP_MAX_IV_LENGTH is the maximum IV length for all ciphers.</p> <p>EVP_CIPHER_block_size() and EVP_CIPHER_CTX_block_size() return the block size of a cipher when passed an EVP_CIPHER or EVP_CIPHER_CTX structure. The constant EVP_MAX_IV_LENGTH is also the maximum block length for all ciphers.</p> <p>EVP_CIPHER_type() and EVP_CIPHER_CTX_type() return the type of the passed cipher or context. This \"type\" is the actual NID of the cipher OBJECT IDENTIFIER as such it ignores the cipher parameters and 40 bit RC2 and 128 bit RC2 have the same NID. If the cipher does not have an object identifier or does not have ASN1 support this function will return NID_undef.</p> <p>EVP_CIPHER_CTX_cipher() returns the EVP_CIPHER structure when passed an EVP_CIPHER_CTX structure.</p> <p>EVP_CIPHER_mode() and EVP_CIPHER_CTX_mode() return the block cipher mode: EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE or EVP_CIPH_OFB_MODE. If the cipher is a stream cipher then EVP_CIPH_STREAM_CIPHER is returned.</p> <p>EVP_CIPHER_param_to_asn1() sets the AlgorithmIdentifier \"parameter\" based on the passed cipher. This will typically include any parameters and an IV. The cipher IV (if any) must be set when this call is made. This call should be made before the cipher is actually \"used\" (before any EVP_EncryptUpdate(), EVP_DecryptUpdate() calls for example). This function may fail if the cipher does not have any ASN1 support.</p> <p>EVP_CIPHER_asn1_to_param() sets the cipher parameters based on an ASN1 AlgorithmIdentifier \"parameter\". The precise effect depends on the cipher In the case of RC2, for example, it will set the IV and effective key length. This function should be called after the base cipher type is set but before the key is set. For example EVP_CipherInit() will be called with the IV and key set to NULL, EVP_CIPHER_asn1_to_param() will be called and finally EVP_CipherInit() again with all parameters except the key set to NULL. It is possible for this function to fail if the cipher does not have any ASN1 support or the parameters cannot be set (for example the RC2 effective key length is not supported.</p> <p>EVP_CIPHER_CTX_ctrl() allows various cipher specific parameters to be determined and set.</p>"},{"location":"man3/EVP_EncryptInit/#return-values","title":"RETURN VALUES","text":"<p>EVP_EncryptInit_ex(), EVP_EncryptUpdate() and EVP_EncryptFinal_ex() return 1 for success and 0 for failure.</p> <p>EVP_DecryptInit_ex() and EVP_DecryptUpdate() return 1 for success and 0 for failure. EVP_DecryptFinal_ex() returns 0 if the decrypt failed or 1 for success.</p> <p>EVP_CipherInit_ex() and EVP_CipherUpdate() return 1 for success and 0 for failure. EVP_CipherFinal_ex() returns 0 for a decryption failure or 1 for success.</p> <p>EVP_CIPHER_CTX_cleanup() returns 1 for success and 0 for failure.</p> <p>EVP_get_cipherbyname(), EVP_get_cipherbynid() and EVP_get_cipherbyobj() return an EVP_CIPHER structure or NULL on error.</p> <p>EVP_CIPHER_nid() and EVP_CIPHER_CTX_nid() return a NID.</p> <p>EVP_CIPHER_block_size() and EVP_CIPHER_CTX_block_size() return the block size.</p> <p>EVP_CIPHER_key_length() and EVP_CIPHER_CTX_key_length() return the key length.</p> <p>EVP_CIPHER_CTX_set_padding() always returns 1.</p> <p>EVP_CIPHER_iv_length() and EVP_CIPHER_CTX_iv_length() return the IV length or zero if the cipher does not use an IV.</p> <p>EVP_CIPHER_type() and EVP_CIPHER_CTX_type() return the NID of the cipher's OBJECT IDENTIFIER or NID_undef if it has no defined OBJECT IDENTIFIER.</p> <p>EVP_CIPHER_CTX_cipher() returns an EVP_CIPHER structure.</p> <p>EVP_CIPHER_param_to_asn1() and EVP_CIPHER_asn1_to_param() return 1 for  success or zero for failure.</p>"},{"location":"man3/EVP_EncryptInit/#cipher-listing","title":"CIPHER LISTING","text":"<p>All algorithms have a fixed key length unless otherwise stated.</p> <ul> <li> <p>EVP_enc_null()</p> <p>Null cipher: does nothing.</p> </li> <li> <p>EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)</p> <p>DES in CBC, ECB, CFB and OFB modes respectively. </p> </li> <li> <p>EVP_des_ede_cbc(void), EVP_des_ede(), EVP_des_ede_ofb(void),  EVP_des_ede_cfb(void)</p> <p>Two key triple DES in CBC, ECB, CFB and OFB modes respectively.</p> </li> <li> <p>EVP_des_ede3_cbc(void), EVP_des_ede3(), EVP_des_ede3_ofb(void),  EVP_des_ede3_cfb(void)</p> <p>Three key triple DES in CBC, ECB, CFB and OFB modes respectively.</p> </li> <li> <p>EVP_desx_cbc(void)</p> <p>DESX algorithm in CBC mode.</p> </li> <li> <p>EVP_rc4(void)</p> <p>RC4 stream cipher. This is a variable key length cipher with default key length 128 bits.</p> </li> <li> <p>EVP_rc4_40(void)</p> <p>RC4 stream cipher with 40 bit key length. This is obsolete and new code should use EVP_rc4() and the EVP_CIPHER_CTX_set_key_length() function.</p> </li> <li> <p>EVP_idea_cbc() EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void), EVP_idea_cbc(void)</p> <p>IDEA encryption algorithm in CBC, ECB, CFB and OFB modes respectively.</p> </li> <li> <p>EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void)</p> <p>RC2 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key length cipher with an additional parameter called \"effective key bits\" or \"effective key length\". By default both are set to 128 bits.</p> </li> <li> <p>EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)</p> <p>RC2 algorithm in CBC mode with a default key length and effective key length of 40 and 64 bits. These are obsolete and new code should use EVP_rc2_cbc(), EVP_CIPHER_CTX_set_key_length() and EVP_CIPHER_CTX_ctrl() to set the key length and effective key length.</p> </li> <li> <p>EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void);</p> <p>Blowfish encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key length cipher.</p> </li> <li> <p>EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void), EVP_cast5_ofb(void)</p> <p>CAST encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key length cipher.</p> </li> <li> <p>EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)</p> <p>RC5 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key length cipher with an additional \"number of rounds\" parameter. By default the key length is set to 128 bits and 12 rounds.</p> </li> <li> <p>EVP_aes_128_gcm(void), EVP_aes_192_gcm(void), EVP_aes_256_gcm(void)</p> <p>AES Galois Counter Mode (GCM) for 128, 192 and 256 bit keys respectively. These ciphers require additional control operations to function correctly: see \"GCM mode\" section below for details.</p> </li> <li> <p>EVP_aes_128_ccm(void), EVP_aes_192_ccm(void), EVP_aes_256_ccm(void)</p> <p>AES Counter with CBC-MAC Mode (CCM) for 128, 192 and 256 bit keys respectively. These ciphers require additional control operations to function correctly: see CCM mode section below for details.</p> </li> </ul>"},{"location":"man3/EVP_EncryptInit/#gcm-mode","title":"GCM Mode","text":"<p>For GCM mode ciphers the behaviour of the EVP interface is subtly altered and several GCM specific ctrl operations are supported.</p> <p>To specify any additional authenticated data (AAD) a call to EVP_CipherUpdate(), EVP_EncryptUpdate() or EVP_DecryptUpdate() should be made with the output  parameter out set to NULL.</p> <p>When decrypting the return value of EVP_DecryptFinal() or EVP_CipherFinal() indicates if the operation was successful. If it does not indicate success the authentication operation has failed and any output data MUST NOT be used as it is corrupted.</p> <p>The following ctrls are supported in GCM mode:</p> <pre><code>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, ivlen, NULL);\n</code></pre> <p>Sets the GCM IV length: this call can only be made before specifying an IV. If not called a default IV length is used (96 bits for AES).</p> <pre><code>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, taglen, tag);\n</code></pre> <p>Writes taglen bytes of the tag value to the buffer indicated by tag. This call can only be made when encrypting data and after all data has been processed (e.g. after an EVP_EncryptFinal() call).</p> <pre><code>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, taglen, tag);\n</code></pre> <p>Sets the expected tag to taglen bytes from tag. This call is only legal when decrypting data.</p>"},{"location":"man3/EVP_EncryptInit/#ccm-mode","title":"CCM Mode","text":"<p>The behaviour of CCM mode ciphers is similar to CCM mode but with a few additional requirements and different ctrl values.</p> <p>Like GCM mode any additional authenticated data (AAD) is passed by calling EVP_CipherUpdate(), EVP_EncryptUpdate() or EVP_DecryptUpdate() with the output  parameter out set to NULL. Additionally the total plaintext or ciphertext length MUST be passed to EVP_CipherUpdate(), EVP_EncryptUpdate() or EVP_DecryptUpdate() with the output and input parameters (in and out)  set to NULL and the length passed in the inl parameter.</p> <p>The following ctrls are supported in CCM mode:</p> <pre><code>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_TAG, taglen, tag);\n</code></pre> <p>This call is made to set the expected CCM tag value when decrypting or the length of the tag (with the tag parameter set to NULL) when encrypting. The tag length is often referred to as M. If not set a default value is used (12 for AES).</p> <pre><code>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_L, ivlen, NULL);\n</code></pre> <p>Sets the CCM L value. If not set a default is used (8 for AES).</p> <pre><code>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_IVLEN, ivlen, NULL);\n</code></pre> <p>Sets the CCM nonce (IV) length: this call can only be made before specifying an nonce value. The nonce length is given by 15 - L so it is 7 by default for AES.</p>"},{"location":"man3/EVP_EncryptInit/#notes","title":"NOTES","text":"<p>Where possible the EVP interface to symmetric ciphers should be used in preference to the low level interfaces. This is because the code then becomes transparent to the cipher used and much more flexible. Additionally, the EVP interface will ensure the use of platform specific cryptographic acceleration such as AES-NI (the low level interfaces do not provide the guarantee).</p> <p>PKCS padding works by adding n padding bytes of value n to make the total  length of the encrypted data a multiple of the block size. Padding is always added so if the data is already a multiple of the block size n will equal the block size. For example if the block size is 8 and 11 bytes are to be encrypted then 5 padding bytes of value 5 will be added.</p> <p>When decrypting the final block is checked to see if it has the correct form.</p> <p>Although the decryption operation can produce an error if padding is enabled, it is not a strong test that the input data or key is correct. A random block has better than 1 in 256 chance of being of the correct format and problems with the input data earlier on will not produce a final decrypt error.</p> <p>If padding is disabled then the decryption operation will always succeed if the total amount of data decrypted is a multiple of the block size.</p> <p>The functions EVP_EncryptInit(), EVP_EncryptFinal(), EVP_DecryptInit(), EVP_CipherInit() and EVP_CipherFinal() are obsolete but are retained for compatibility with existing code. New code should use EVP_EncryptInit_ex(), EVP_EncryptFinal_ex(), EVP_DecryptInit_ex(), EVP_DecryptFinal_ex(), EVP_CipherInit_ex() and EVP_CipherFinal_ex() because they can reuse an existing context without allocating and freeing it up on each call.</p>"},{"location":"man3/EVP_EncryptInit/#bugs","title":"BUGS","text":"<p>For RC5 the number of rounds can currently only be set to 8, 12 or 16. This is a limitation of the current RC5 code rather than the EVP interface.</p> <p>EVP_MAX_KEY_LENGTH and EVP_MAX_IV_LENGTH only refer to the internal ciphers with default key lengths. If custom ciphers exceed these values the results are unpredictable. This is because it has become standard practice to define a  generic key as a fixed unsigned char array containing EVP_MAX_KEY_LENGTH bytes.</p> <p>The ASN1 code is incomplete (and sometimes inaccurate) it has only been tested for certain common S/MIME ciphers (RC2, DES, triple DES) in CBC mode.</p>"},{"location":"man3/EVP_EncryptInit/#examples","title":"EXAMPLES","text":"<p>Encrypt a string using IDEA:</p> <pre><code>int do_crypt(char *outfile)\n       {\n       unsigned char outbuf[1024];\n       int outlen, tmplen;\n       /* Bogus key and IV: we'd normally set these from\n        * another source.\n        */\n       unsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n       unsigned char iv[] = {1,2,3,4,5,6,7,8};\n       char intext[] = \"Some Crypto Text\";\n       EVP_CIPHER_CTX ctx;\n       FILE *out;\n\n       EVP_CIPHER_CTX_init(&amp;ctx);\n       EVP_EncryptInit_ex(&amp;ctx, EVP_idea_cbc(), NULL, key, iv);\n\n       if(!EVP_EncryptUpdate(&amp;ctx, outbuf, &amp;outlen, intext, strlen(intext)))\n               {\n               /* Error */\n               return 0;\n               }\n       /* Buffer passed to EVP_EncryptFinal() must be after data just\n        * encrypted to avoid overwriting it.\n        */\n       if(!EVP_EncryptFinal_ex(&amp;ctx, outbuf + outlen, &amp;tmplen))\n               {\n               /* Error */\n               return 0;\n               }\n       outlen += tmplen;\n       EVP_CIPHER_CTX_cleanup(&amp;ctx);\n       /* Need binary mode for fopen because encrypted data is\n        * binary data. Also cannot use strlen() on it because\n        * it wont be null terminated and may contain embedded\n        * nulls.\n        */\n       out = fopen(outfile, \"wb\");\n       fwrite(outbuf, 1, outlen, out);\n       fclose(out);\n       return 1;\n       }\n</code></pre> <p>The ciphertext from the above example can be decrypted using the openssl utility with the command line (shown on two lines for clarity):</p> <pre><code>openssl idea -d &lt;filename\n         -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708\n</code></pre> <p>General encryption and decryption function example using FILE I/O and AES128 with a 128-bit key:</p> <pre><code>int do_crypt(FILE *in, FILE *out, int do_encrypt)\n       {\n       /* Allow enough space in output buffer for additional block */\n       unsigned char inbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];\n       int inlen, outlen;\n       EVP_CIPHER_CTX ctx;\n       /* Bogus key and IV: we'd normally set these from\n        * another source.\n        */\n       unsigned char key[] = \"0123456789abcdeF\";\n       unsigned char iv[] = \"1234567887654321\";\n\n       /* Don't set key or IV right away; we want to check lengths */\n       EVP_CIPHER_CTX_init(&amp;ctx);\n       EVP_CipherInit_ex(&amp;ctx, EVP_aes_128_cbc(), NULL, NULL, NULL,\n               do_encrypt);\n       OPENSSL_assert(EVP_CIPHER_CTX_key_length(&amp;ctx) == 16);\n       OPENSSL_assert(EVP_CIPHER_CTX_iv_length(&amp;ctx) == 16);\n\n       /* Now we can set key and IV */\n       EVP_CipherInit_ex(&amp;ctx, NULL, NULL, key, iv, do_encrypt);\n\n       for(;;) \n               {\n               inlen = fread(inbuf, 1, 1024, in);\n               if(inlen &lt;= 0) break;\n               if(!EVP_CipherUpdate(&amp;ctx, outbuf, &amp;outlen, inbuf, inlen))\n                       {\n                       /* Error */\n                       EVP_CIPHER_CTX_cleanup(&amp;ctx);\n                       return 0;\n                       }\n               fwrite(outbuf, 1, outlen, out);\n               }\n       if(!EVP_CipherFinal_ex(&amp;ctx, outbuf, &amp;outlen))\n               {\n               /* Error */\n               EVP_CIPHER_CTX_cleanup(&amp;ctx);\n               return 0;\n               }\n       fwrite(outbuf, 1, outlen, out);\n\n       EVP_CIPHER_CTX_cleanup(&amp;ctx);\n       return 1;\n       }\n</code></pre>"},{"location":"man3/EVP_EncryptInit/#see-also","title":"SEE ALSO","text":"<p>evp(3)</p>"},{"location":"man3/EVP_EncryptInit/#history","title":"HISTORY","text":"<p>EVP_CIPHER_CTX_init(), EVP_EncryptInit_ex(), EVP_EncryptFinal_ex(), EVP_DecryptInit_ex(), EVP_DecryptFinal_ex(), EVP_CipherInit_ex(), EVP_CipherFinal_ex() and EVP_CIPHER_CTX_set_padding() appeared in OpenSSL 0.9.7.</p> <p>IDEA appeared in OpenSSL 0.9.7 but was often disabled due to patent concerns; the last patents expired in 2012.</p>"},{"location":"man3/EVP_OpenInit/","title":"EVP_OpenInit","text":""},{"location":"man3/EVP_OpenInit/#name","title":"NAME","text":"<p>EVP_OpenInit, EVP_OpenUpdate, EVP_OpenFinal - EVP envelope decryption</p>"},{"location":"man3/EVP_OpenInit/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_OpenInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type,unsigned char *ek,\n               int ekl,unsigned char *iv,EVP_PKEY *priv);\nint EVP_OpenUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n        int *outl, unsigned char *in, int inl);\nint EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n        int *outl);\n</code></pre>"},{"location":"man3/EVP_OpenInit/#description","title":"DESCRIPTION","text":"<p>The EVP envelope routines are a high level interface to envelope decryption. They decrypt a public key encrypted symmetric key and then decrypt data using it.</p> <p>EVP_OpenInit() initializes a cipher context ctx for decryption with cipher type. It decrypts the encrypted symmetric key of length ekl bytes passed in the ek parameter using the private key priv. The IV is supplied in the iv parameter.</p> <p>EVP_OpenUpdate() and EVP_OpenFinal() have exactly the same properties as the EVP_DecryptUpdate() and EVP_DecryptFinal() routines, as  documented on the EVP_EncryptInit(3) manual page.</p>"},{"location":"man3/EVP_OpenInit/#notes","title":"NOTES","text":"<p>It is possible to call EVP_OpenInit() twice in the same way as EVP_DecryptInit(). The first call should have priv set to NULL and (after setting any cipher parameters) it should be called again with type set to NULL.</p> <p>If the cipher passed in the type parameter is a variable length cipher then the key length will be set to the value of the recovered key length. If the cipher is a fixed length cipher then the recovered key length must match the fixed cipher length.</p>"},{"location":"man3/EVP_OpenInit/#return-values","title":"RETURN VALUES","text":"<p>EVP_OpenInit() returns 0 on error or a non zero integer (actually the recovered secret key size) if successful.</p> <p>EVP_OpenUpdate() returns 1 for success or 0 for failure.</p> <p>EVP_OpenFinal() returns 0 if the decrypt failed or 1 for success.</p>"},{"location":"man3/EVP_OpenInit/#see-also","title":"SEE ALSO","text":"<p>evp(3), rand(3), EVP_EncryptInit(3), EVP_SealInit(3)</p>"},{"location":"man3/EVP_OpenInit/#history","title":"HISTORY","text":""},{"location":"man3/EVP_PKEY_CTX_ctrl/","title":"EVP_PKEY_CTX_ctrl","text":""},{"location":"man3/EVP_PKEY_CTX_ctrl/#name","title":"NAME","text":"<p>EVP_PKEY_CTX_ctrl, EVP_PKEY_CTX_ctrl_str, EVP_PKEY_get_default_digest_nid, EVP_PKEY_CTX_set_signature_md, EVP_PKEY_CTX_set_rsa_padding, EVP_PKEY_CTX_set_rsa_pss_saltlen, EVP_PKEY_CTX_set_rsa_rsa_keygen_bits, EVP_PKEY_CTX_set_rsa_keygen_pubexp, EVP_PKEY_CTX_set_dsa_paramgen_bits, EVP_PKEY_CTX_set_dh_paramgen_prime_len, EVP_PKEY_CTX_set_dh_paramgen_generator, EVP_PKEY_CTX_set_ec_paramgen_curve_nid - algorithm specific control operations</p>"},{"location":"man3/EVP_PKEY_CTX_ctrl/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,\n                               int cmd, int p1, void *p2);\nint EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,\n                                               const char *value);\n\nint EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);\n\n#include &lt;openssl/rsa.h&gt;\n\nint EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);\n\nint EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *ctx, int pad);\nint EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int len);\nint EVP_PKEY_CTX_set_rsa_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int mbits);\nint EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx, BIGNUM *pubexp);\n\n#include &lt;openssl/dsa.h&gt;\nint EVP_PKEY_CTX_set_dsa_paramgen_bits(EVP_PKEY_CTX *ctx, int nbits);\n\n#include &lt;openssl/dh.h&gt;\nint EVP_PKEY_CTX_set_dh_paramgen_prime_len(EVP_PKEY_CTX *ctx, int len);\nint EVP_PKEY_CTX_set_dh_paramgen_generator(EVP_PKEY_CTX *ctx, int gen);\n\n#include &lt;openssl/ec.h&gt;\nint EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX *ctx, int nid);\n</code></pre>"},{"location":"man3/EVP_PKEY_CTX_ctrl/#description","title":"DESCRIPTION","text":"<p>The function EVP_PKEY_CTX_ctrl() sends a control operation to the context ctx. The key type used must match keytype if it is not -1. The parameter optype is a mask indicating which operations the control can be applied to. The control command is indicated in cmd and any additional arguments in p1 and p2.</p> <p>Applications will not normally call EVP_PKEY_CTX_ctrl() directly but will instead call one of the algorithm specific macros below.</p> <p>The function EVP_PKEY_CTX_ctrl_str() allows an application to send an algorithm specific control operation to a context ctx in string form. This is intended to be used for options specified on the command line or in text files. The commands supported are documented in the openssl utility command line pages for the option -pkeyopt which is supported by the pkeyutl, genpkey and req commands.</p> <p>All the remaining \"functions\" are implemented as macros.</p> <p>The EVP_PKEY_CTX_set_signature_md() macro sets the message digest type used in a signature. It can be used with any public key algorithm supporting signature operations.</p> <p>The macro EVP_PKEY_CTX_set_rsa_padding() sets the RSA padding mode for ctx. The pad parameter can take the value RSA_PKCS1_PADDING for PKCS#1 padding, RSA_SSLV23_PADDING for SSLv23 padding, RSA_NO_PADDING for no padding, RSA_PKCS1_OAEP_PADDING for OAEP padding (encrypt and decrypt only), RSA_X931_PADDING for X9.31 padding (signature operations only) and  RSA_PKCS1_PSS_PADDING (sign and verify only).</p> <p>Two RSA padding modes behave differently if EVP_PKEY_CTX_set_signature_md() is used. If this macro is called for PKCS#1 padding the plaintext buffer is an actual digest value and is encapsulated in a DigestInfo structure according to PKCS#1 when signing and this structure is expected (and stripped off) when verifying. If this control is not used with RSA and PKCS#1 padding then the supplied data is used directly and not encapsulated. In the case of X9.31 padding for RSA the algorithm identifier byte is added or checked and removed if this control is called. If it is not called then the first byte of the plaintext buffer is expected to be the algorithm identifier byte.</p> <p>The EVP_PKEY_CTX_set_rsa_pss_saltlen() macro sets the RSA PSS salt length to len as its name implies it is only supported for PSS padding.  Two special values are supported: -1 sets the salt length to the digest length. When signing -2 sets the salt length to the maximum permissible value. When verifying -2 causes the salt length to be automatically determined based on the PSS block structure. If this macro is not called a salt length value of -2 is used by default.</p> <p>The EVP_PKEY_CTX_set_rsa_rsa_keygen_bits() macro sets the RSA key length for RSA key genration to bits. If not specified 1024 bits is used.</p> <p>The EVP_PKEY_CTX_set_rsa_keygen_pubexp() macro sets the public exponent value for RSA key generation to pubexp currently it should be an odd integer. The pubexp pointer is used internally by this function so it should not be  modified or free after the call. If this macro is not called then 65537 is used.</p> <p>The macro EVP_PKEY_CTX_set_dsa_paramgen_bits() sets the number of bits used for DSA parameter generation to bits. If not specified 1024 is used.</p> <p>The macro EVP_PKEY_CTX_set_dh_paramgen_prime_len() sets the length of the DH prime parameter p for DH parameter generation. If this macro is not called then 1024 is used.</p> <p>The EVP_PKEY_CTX_set_dh_paramgen_generator() macro sets DH generator to gen for DH parameter generation. If not specified 2 is used.</p> <p>The EVP_PKEY_CTX_set_ec_paramgen_curve_nid() sets the EC curve for EC parameter generation to nid. For EC parameter generation this macro must be called or an error occurs because there is no default curve.</p>"},{"location":"man3/EVP_PKEY_CTX_ctrl/#return-values","title":"RETURN VALUES","text":"<p>EVP_PKEY_CTX_ctrl() and its macros return a positive value for success and 0 or a negative value for failure. In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</p>"},{"location":"man3/EVP_PKEY_CTX_ctrl/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_CTX_new(3), EVP_PKEY_encrypt(3), EVP_PKEY_decrypt(3), EVP_PKEY_sign(3), EVP_PKEY_verify(3), EVP_PKEY_verify_recover(3), EVP_PKEY_derive(3) EVP_PKEY_keygen(3) </p>"},{"location":"man3/EVP_PKEY_CTX_ctrl/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_PKEY_CTX_new/","title":"EVP_PKEY_CTX_new","text":""},{"location":"man3/EVP_PKEY_CTX_new/#name","title":"NAME","text":"<p>EVP_PKEY_CTX_new, EVP_PKEY_CTX_new_id, EVP_PKEY_CTX_dup, EVP_PKEY_CTX_free - public key algorithm context functions.</p>"},{"location":"man3/EVP_PKEY_CTX_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nEVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);\nEVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);\nEVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx);\nvoid EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);\n</code></pre>"},{"location":"man3/EVP_PKEY_CTX_new/#description","title":"DESCRIPTION","text":"<p>The EVP_PKEY_CTX_new() function allocates public key algorithm context using the algorithm specified in pkey and ENGINE e.</p> <p>The EVP_PKEY_CTX_new_id() function allocates public key algorithm context using the algorithm specified by id and ENGINE e. It is normally used when no EVP_PKEY structure is associated with the operations, for example during parameter generation of key genration for some algorithms.</p> <p>EVP_PKEY_CTX_dup() duplicates the context ctx.</p> <p>EVP_PKEY_CTX_free() frees up the context ctx.</p>"},{"location":"man3/EVP_PKEY_CTX_new/#notes","title":"NOTES","text":"<p>The EVP_PKEY_CTX structure is an opaque public key algorithm context used by the OpenSSL high level public key API. Contexts MUST NOT be shared between threads: that is it is not permissible to use the same context simultaneously in two threads.</p>"},{"location":"man3/EVP_PKEY_CTX_new/#return-values","title":"RETURN VALUES","text":"<p>EVP_PKEY_CTX_new(), EVP_PKEY_CTX_new_id(), EVP_PKEY_CTX_dup() returns either the newly allocated EVP_PKEY_CTX structure of NULL if an error occurred.</p> <p>EVP_PKEY_CTX_free() does not return a value.</p>"},{"location":"man3/EVP_PKEY_CTX_new/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_new(3)</p>"},{"location":"man3/EVP_PKEY_CTX_new/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_PKEY_cmp/","title":"EVP_PKEY_cmp","text":""},{"location":"man3/EVP_PKEY_cmp/#name","title":"NAME","text":"<p>EVP_PKEY_copy_parameters, EVP_PKEY_missing_parameters, EVP_PKEY_cmp_parameters, EVP_PKEY_cmp - public key parameter and comparison functions</p>"},{"location":"man3/EVP_PKEY_cmp/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);\nint EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from);\n\nint EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b);\nint EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b);\n</code></pre>"},{"location":"man3/EVP_PKEY_cmp/#description","title":"DESCRIPTION","text":"<p>The function EVP_PKEY_missing_parameters() returns 1 if the public key parameters of pkey are missing and 0 if they are present or the algorithm doesn't use parameters.</p> <p>The function EVP_PKEY_copy_parameters() copies the parameters from key from to key to. An error is returned if the parameters are missing in from or present in both from and to and mismatch. If the parameters in from and to are both present and match this function has no effect.</p> <p>The function EVP_PKEY_cmp_parameters() compares the parameters of keys a and b.</p> <p>The function EVP_PKEY_cmp() compares the public key components and paramters (if present) of keys a and b.</p>"},{"location":"man3/EVP_PKEY_cmp/#notes","title":"NOTES","text":"<p>The main purpose of the functions EVP_PKEY_missing_parameters() and EVP_PKEY_copy_parameters() is to handle public keys in certificates where the parameters are sometimes omitted from a public key if they are inherited from the CA that signed it.</p> <p>Since OpenSSL private keys contain public key components too the function EVP_PKEY_cmp() can also be used to determine if a private key matches a public key.</p>"},{"location":"man3/EVP_PKEY_cmp/#return-values","title":"RETURN VALUES","text":"<p>The function EVP_PKEY_missing_parameters() returns 1 if the public key parameters of pkey are missing and 0 if they are present or the algorithm doesn't use parameters.</p> <p>These functions EVP_PKEY_copy_parameters() returns 1 for success and 0 for failure.</p> <p>The function EVP_PKEY_cmp_parameters() and EVP_PKEY_cmp() return 1 if the keys match, 0 if they don't match, -1 if the key types are different and -2 if the operation is not supported.</p>"},{"location":"man3/EVP_PKEY_cmp/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_CTX_new(3), EVP_PKEY_keygen(3) </p>"},{"location":"man3/EVP_PKEY_decrypt/","title":"EVP_PKEY_decrypt","text":""},{"location":"man3/EVP_PKEY_decrypt/#name","title":"NAME","text":"<p>EVP_PKEY_decrypt_init, EVP_PKEY_decrypt - decrypt using a public key algorithm</p>"},{"location":"man3/EVP_PKEY_decrypt/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,\n                       unsigned char *out, size_t *outlen,\n                       const unsigned char *in, size_t inlen);\n</code></pre>"},{"location":"man3/EVP_PKEY_decrypt/#description","title":"DESCRIPTION","text":"<p>The EVP_PKEY_decrypt_init() function initializes a public key algorithm context using key pkey for a decryption operation.</p> <p>The EVP_PKEY_decrypt() function performs a public key decryption operation using ctx. The data to be decrypted is specified using the in and inlen parameters. If out is NULL then the maximum size of the output buffer is written to the outlen parameter. If out is not NULL then before the call the outlen parameter should contain the length of the out buffer, if the call is successful the decrypted data is written to out and the amount of data written to outlen.</p>"},{"location":"man3/EVP_PKEY_decrypt/#notes","title":"NOTES","text":"<p>After the call to EVP_PKEY_decrypt_init() algorithm specific control operations can be performed to set any appropriate parameters for the operation.</p> <p>The function EVP_PKEY_decrypt() can be called more than once on the same context if several operations are performed using the same parameters.</p>"},{"location":"man3/EVP_PKEY_decrypt/#return-values","title":"RETURN VALUES","text":"<p>EVP_PKEY_decrypt_init() and EVP_PKEY_decrypt() return 1 for success and 0 or a negative value for failure. In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</p>"},{"location":"man3/EVP_PKEY_decrypt/#example","title":"EXAMPLE","text":"<p>Decrypt data using OAEP (for RSA keys):</p> <pre><code>#include &lt;openssl/evp.h&gt;\n#include &lt;openssl/rsa.h&gt;\n\nEVP_PKEY_CTX *ctx;\nunsigned char *out, *in;\nsize_t outlen, inlen; \nEVP_PKEY *key;\n/* NB: assumes key in, inlen are already set up\n * and that key is an RSA private key\n */\nctx = EVP_PKEY_CTX_new(key);\nif (!ctx)\n       /* Error occurred */\nif (EVP_PKEY_decrypt_init(ctx) &lt;= 0)\n       /* Error */\nif (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) &lt;= 0)\n       /* Error */\n\n/* Determine buffer length */\nif (EVP_PKEY_decrypt(ctx, NULL, &amp;outlen, in, inlen) &lt;= 0)\n       /* Error */\n\nout = OPENSSL_malloc(outlen);\n\nif (!out)\n       /* malloc failure */\n\nif (EVP_PKEY_decrypt(ctx, out, &amp;outlen, in, inlen) &lt;= 0)\n       /* Error */\n\n/* Decrypted data is outlen bytes written to buffer out */\n</code></pre>"},{"location":"man3/EVP_PKEY_decrypt/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_CTX_new(3), EVP_PKEY_encrypt(3), EVP_PKEY_sign(3), EVP_PKEY_verify(3), EVP_PKEY_verify_recover(3), EVP_PKEY_derive(3) </p>"},{"location":"man3/EVP_PKEY_decrypt/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_PKEY_derive/","title":"EVP_PKEY_derive","text":""},{"location":"man3/EVP_PKEY_derive/#name","title":"NAME","text":"<p>EVP_PKEY_derive_init, EVP_PKEY_derive_set_peer, EVP_PKEY_derive - derive public key algorithm shared secret.</p>"},{"location":"man3/EVP_PKEY_derive/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);\nint EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);\n</code></pre>"},{"location":"man3/EVP_PKEY_derive/#description","title":"DESCRIPTION","text":"<p>The EVP_PKEY_derive_init() function initializes a public key algorithm context using key pkey for shared secret derivation.</p> <p>The EVP_PKEY_derive_set_peer() function sets the peer key: this will normally be a public key.</p> <p>The EVP_PKEY_derive() derives a shared secret using ctx. If key is NULL then the maximum size of the output buffer is written to the keylen parameter. If key is not NULL then before the call the keylen parameter should contain the length of the key buffer, if the call is successful the shared secret is written to key and the amount of data written to keylen.</p>"},{"location":"man3/EVP_PKEY_derive/#notes","title":"NOTES","text":"<p>After the call to EVP_PKEY_derive_init() algorithm specific control operations can be performed to set any appropriate parameters for the operation.</p> <p>The function EVP_PKEY_derive() can be called more than once on the same context if several operations are performed using the same parameters.</p>"},{"location":"man3/EVP_PKEY_derive/#return-values","title":"RETURN VALUES","text":"<p>EVP_PKEY_derive_init() and EVP_PKEY_derive() return 1 for success and 0 or a negative value for failure. In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</p>"},{"location":"man3/EVP_PKEY_derive/#example","title":"EXAMPLE","text":"<p>Derive shared secret (for example DH or EC keys):</p> <pre><code>#include &lt;openssl/evp.h&gt;\n#include &lt;openssl/rsa.h&gt;\n\nEVP_PKEY_CTX *ctx;\nunsigned char *skey;\nsize_t skeylen;\nEVP_PKEY *pkey, *peerkey;\n/* NB: assumes pkey, peerkey have been already set up */\n\nctx = EVP_PKEY_CTX_new(pkey);\nif (!ctx)\n       /* Error occurred */\nif (EVP_PKEY_derive_init(ctx) &lt;= 0)\n       /* Error */\nif (EVP_PKEY_derive_set_peer(ctx, peerkey) &lt;= 0)\n       /* Error */\n\n/* Determine buffer length */\nif (EVP_PKEY_derive(ctx, NULL, &amp;skeylen) &lt;= 0)\n       /* Error */\n\nskey = OPENSSL_malloc(skeylen);\n\nif (!skey)\n       /* malloc failure */\n\nif (EVP_PKEY_derive(ctx, skey, &amp;skeylen) &lt;= 0)\n       /* Error */\n\n/* Shared secret is skey bytes written to buffer skey */\n</code></pre>"},{"location":"man3/EVP_PKEY_derive/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_CTX_new(3), EVP_PKEY_encrypt(3), EVP_PKEY_decrypt(3), EVP_PKEY_sign(3), EVP_PKEY_verify(3), EVP_PKEY_verify_recover(3),</p>"},{"location":"man3/EVP_PKEY_derive/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_PKEY_encrypt/","title":"EVP_PKEY_encrypt","text":""},{"location":"man3/EVP_PKEY_encrypt/#name","title":"NAME","text":"<p>EVP_PKEY_encrypt_init, EVP_PKEY_encrypt - encrypt using a public key algorithm</p>"},{"location":"man3/EVP_PKEY_encrypt/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,\n                       unsigned char *out, size_t *outlen,\n                       const unsigned char *in, size_t inlen);\n</code></pre>"},{"location":"man3/EVP_PKEY_encrypt/#description","title":"DESCRIPTION","text":"<p>The EVP_PKEY_encrypt_init() function initializes a public key algorithm context using key pkey for an encryption operation.</p> <p>The EVP_PKEY_encrypt() function performs a public key encryption operation using ctx. The data to be encrypted is specified using the in and inlen parameters. If out is NULL then the maximum size of the output buffer is written to the outlen parameter. If out is not NULL then before the call the outlen parameter should contain the length of the out buffer, if the call is successful the encrypted data is written to out and the amount of data written to outlen.</p>"},{"location":"man3/EVP_PKEY_encrypt/#notes","title":"NOTES","text":"<p>After the call to EVP_PKEY_encrypt_init() algorithm specific control operations can be performed to set any appropriate parameters for the operation.</p> <p>The function EVP_PKEY_encrypt() can be called more than once on the same context if several operations are performed using the same parameters.</p>"},{"location":"man3/EVP_PKEY_encrypt/#return-values","title":"RETURN VALUES","text":"<p>EVP_PKEY_encrypt_init() and EVP_PKEY_encrypt() return 1 for success and 0 or a negative value for failure. In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</p>"},{"location":"man3/EVP_PKEY_encrypt/#example","title":"EXAMPLE","text":"<p>Encrypt data using OAEP (for RSA keys). See also PEM_read_PUBKEY(3) or d2i_X509(3) for means to load a public key. You may also simply set 'eng = NULL;' to start with the default OpenSSL RSA implementation:</p> <pre><code>#include &lt;openssl/evp.h&gt;\n#include &lt;openssl/rsa.h&gt;\n#include &lt;openssl/engine.h&gt;\n\nEVP_PKEY_CTX *ctx;\nENGINE *eng;\nunsigned char *out, *in;\nsize_t outlen, inlen; \nEVP_PKEY *key;\n/* NB: assumes eng, key, in, inlen are already set up,\n * and that key is an RSA public key\n */\nctx = EVP_PKEY_CTX_new(key,eng);\nif (!ctx)\n       /* Error occurred */\nif (EVP_PKEY_encrypt_init(ctx) &lt;= 0)\n       /* Error */\nif (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) &lt;= 0)\n       /* Error */\n\n/* Determine buffer length */\nif (EVP_PKEY_encrypt(ctx, NULL, &amp;outlen, in, inlen) &lt;= 0)\n       /* Error */\n\nout = OPENSSL_malloc(outlen);\n\nif (!out)\n       /* malloc failure */\n\nif (EVP_PKEY_encrypt(ctx, out, &amp;outlen, in, inlen) &lt;= 0)\n       /* Error */\n\n/* Encrypted data is outlen bytes written to buffer out */\n</code></pre>"},{"location":"man3/EVP_PKEY_encrypt/#see-also","title":"SEE ALSO","text":"<p>d2i_X509(3), engine(3), EVP_PKEY_CTX_new(3), EVP_PKEY_decrypt(3), EVP_PKEY_sign(3), EVP_PKEY_verify(3), EVP_PKEY_verify_recover(3), EVP_PKEY_derive(3) </p>"},{"location":"man3/EVP_PKEY_encrypt/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_PKEY_get_default_digest/","title":"EVP_PKEY_get_default_digest","text":""},{"location":"man3/EVP_PKEY_get_default_digest/#name","title":"NAME","text":"<p>EVP_PKEY_get_default_digest_nid - get default signature digest</p>"},{"location":"man3/EVP_PKEY_get_default_digest/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\nint EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);\n</code></pre>"},{"location":"man3/EVP_PKEY_get_default_digest/#description","title":"DESCRIPTION","text":"<p>The EVP_PKEY_get_default_digest_nid() function sets pnid to the default message digest NID for the public key signature operations associated with key pkey.</p>"},{"location":"man3/EVP_PKEY_get_default_digest/#notes","title":"NOTES","text":"<p>For all current standard OpenSSL public key algorithms SHA1 is returned.</p>"},{"location":"man3/EVP_PKEY_get_default_digest/#return-values","title":"RETURN VALUES","text":"<p>The EVP_PKEY_get_default_digest_nid() function returns 1 if the message digest is advisory (that is other digests can be used) and 2 if it is mandatory (other digests can not be used).  It returns 0 or a negative value for failure. In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</p>"},{"location":"man3/EVP_PKEY_get_default_digest/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_CTX_new(3), EVP_PKEY_sign(3), EVP_PKEY_verify(3), EVP_PKEY_verify_recover(3),</p>"},{"location":"man3/EVP_PKEY_get_default_digest/#history","title":"HISTORY","text":"<p>This function was first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_PKEY_keygen/","title":"EVP_PKEY_keygen","text":""},{"location":"man3/EVP_PKEY_keygen/#name","title":"NAME","text":"<p>EVP_PKEY_keygen_init, EVP_PKEY_keygen, EVP_PKEY_paramgen_init, EVP_PKEY_paramgen, EVP_PKEY_CTX_set_cb, EVP_PKEY_CTX_get_cb, EVP_PKEY_CTX_get_keygen_info, EVP_PKEVP_PKEY_CTX_set_app_data, EVP_PKEY_CTX_get_app_data - key and parameter generation functions</p>"},{"location":"man3/EVP_PKEY_keygen/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\nint EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\n\ntypedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);\n\nvoid EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);\nEVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);\n\nint EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);\n\nvoid EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);\nvoid *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);\n</code></pre>"},{"location":"man3/EVP_PKEY_keygen/#description","title":"DESCRIPTION","text":"<p>The EVP_PKEY_keygen_init() function initializes a public key algorithm context using key pkey for a key genration operation.</p> <p>The EVP_PKEY_keygen() function performs a key generation operation, the  generated key is written to ppkey.</p> <p>The functions EVP_PKEY_paramgen_init() and EVP_PKEY_paramgen() are similar except parameters are generated.</p> <p>The function EVP_PKEY_set_cb() sets the key or parameter generation callback to cb. The function EVP_PKEY_CTX_get_cb() returns the key or parameter generation callback.</p> <p>The function EVP_PKEY_CTX_get_keygen_info() returns parameters associated with the generation operation. If idx is -1 the total number of parameters available is returned. Any non negative value returns the value of that parameter. EVP_PKEY_CTX_gen_keygen_info() with a non-negative value for idx should only be called within the generation callback.</p> <p>If the callback returns 0 then the key genration operation is aborted and an error occurs. This might occur during a time consuming operation where a user clicks on a \"cancel\" button.</p> <p>The functions EVP_PKEY_CTX_set_app_data() and EVP_PKEY_CTX_get_app_data() set and retrieve an opaque pointer. This can be used to set some application defined value which can be retrieved in the callback: for example a handle which is used to update a \"progress dialog\".</p>"},{"location":"man3/EVP_PKEY_keygen/#notes","title":"NOTES","text":"<p>After the call to EVP_PKEY_keygen_init() or EVP_PKEY_paramgen_init() algorithm specific control operations can be performed to set any appropriate parameters for the operation.</p> <p>The functions EVP_PKEY_keygen() and EVP_PKEY_paramgen() can be called more than once on the same context if several operations are performed using the same parameters.</p> <p>The meaning of the parameters passed to the callback will depend on the algorithm and the specifiic implementation of the algorithm. Some might not give any useful information at all during key or parameter generation. Others might not even call the callback.</p> <p>The operation performed by key or parameter generation depends on the algorithm used. In some cases (e.g. EC with a supplied named curve) the \"generation\" option merely sets the appropriate fields in an EVP_PKEY structure.</p> <p>In OpenSSL an EVP_PKEY structure containing a private key also contains the public key components and parameters (if any). An OpenSSL private key is equivalent to what some libraries call a \"key pair\". A private key can be used in functions which require the use of a public key or parameters.</p>"},{"location":"man3/EVP_PKEY_keygen/#return-values","title":"RETURN VALUES","text":"<p>EVP_PKEY_keygen_init(), EVP_PKEY_paramgen_init(), EVP_PKEY_keygen() and EVP_PKEY_paramgen() return 1 for success and 0 or a negative value for failure. In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</p>"},{"location":"man3/EVP_PKEY_keygen/#examples","title":"EXAMPLES","text":"<p>Generate a 2048 bit RSA key:</p> <pre><code>#include &lt;openssl/evp.h&gt;\n#include &lt;openssl/rsa.h&gt;\n\nEVP_PKEY_CTX *ctx;\nEVP_PKEY *pkey = NULL;\nctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);\nif (!ctx)\n       /* Error occurred */\nif (EVP_PKEY_keygen_init(ctx) &lt;= 0)\n       /* Error */\nif (EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048) &lt;= 0)\n       /* Error */\n\n/* Generate key */\nif (EVP_PKEY_keygen(ctx, &amp;pkey) &lt;= 0)\n       /* Error */\n</code></pre> <p>Generate a key from a set of parameters:</p> <pre><code>#include &lt;openssl/evp.h&gt;\n#include &lt;openssl/rsa.h&gt;\n\nEVP_PKEY_CTX *ctx;\nEVP_PKEY *pkey = NULL, *param;\n/* Assumed param is set up already */\nctx = EVP_PKEY_CTX_new(param);\nif (!ctx)\n       /* Error occurred */\nif (EVP_PKEY_keygen_init(ctx) &lt;= 0)\n       /* Error */\n\n/* Generate key */\nif (EVP_PKEY_keygen(ctx, &amp;pkey) &lt;= 0)\n       /* Error */\n</code></pre> <p>Example of generation callback for OpenSSL public key implementations:</p> <pre><code>/* Application data is a BIO to output status to */\n\nEVP_PKEY_CTX_set_app_data(ctx, status_bio);\n\nstatic int genpkey_cb(EVP_PKEY_CTX *ctx)\n       {\n       char c='*';\n       BIO *b = EVP_PKEY_CTX_get_app_data(ctx);\n       int p;\n       p = EVP_PKEY_CTX_get_keygen_info(ctx, 0);\n       if (p == 0) c='.';\n       if (p == 1) c='+';\n       if (p == 2) c='*';\n       if (p == 3) c='\\n';\n       BIO_write(b,&amp;c,1);\n       (void)BIO_flush(b);\n       return 1;\n       }\n</code></pre>"},{"location":"man3/EVP_PKEY_keygen/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_CTX_new(3), EVP_PKEY_encrypt(3), EVP_PKEY_decrypt(3), EVP_PKEY_sign(3), EVP_PKEY_verify(3), EVP_PKEY_verify_recover(3), EVP_PKEY_derive(3) </p>"},{"location":"man3/EVP_PKEY_keygen/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_PKEY_meth_new/","title":"EVP_PKEY_meth_new","text":""},{"location":"man3/EVP_PKEY_meth_new/#name","title":"NAME","text":"<p>EVP_PKEY_meth_new, EVP_PKEY_meth_free, EVP_PKEY_meth_copy, EVP_PKEY_meth_find, EVP_PKEY_meth_add0, EVP_PKEY_METHOD, EVP_PKEY_meth_set_init, EVP_PKEY_meth_set_copy, EVP_PKEY_meth_set_cleanup, EVP_PKEY_meth_set_paramgen, EVP_PKEY_meth_set_keygen, EVP_PKEY_meth_set_sign, EVP_PKEY_meth_set_verify, EVP_PKEY_meth_set_verify_recover, EVP_PKEY_meth_set_signctx, EVP_PKEY_meth_set_verifyctx, EVP_PKEY_meth_set_encrypt, EVP_PKEY_meth_set_decrypt, EVP_PKEY_meth_set_derive, EVP_PKEY_meth_set_ctrl, EVP_PKEY_meth_get_init, EVP_PKEY_meth_get_copy, EVP_PKEY_meth_get_cleanup, EVP_PKEY_meth_get_paramgen, EVP_PKEY_meth_get_keygen, EVP_PKEY_meth_get_sign, EVP_PKEY_meth_get_verify, EVP_PKEY_meth_get_verify_recover, EVP_PKEY_meth_get_signctx, EVP_PKEY_meth_get_verifyctx, EVP_PKEY_meth_get_encrypt, EVP_PKEY_meth_get_decrypt, EVP_PKEY_meth_get_derive, EVP_PKEY_meth_get_ctrl - manipulating EVP_PKEY_METHOD structure</p>"},{"location":"man3/EVP_PKEY_meth_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\ntypedef struct evp_pkey_method_st EVP_PKEY_METHOD;\n\nEVP_PKEY_METHOD *EVP_PKEY_meth_new(int id, int flags);\nvoid EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth);\nvoid EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src);\nconst EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type);\nint EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth);\n\nvoid EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth,\n                            int (*init) (EVP_PKEY_CTX *ctx));\nvoid EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth,\n                            int (*copy) (EVP_PKEY_CTX *dst,\n                                         EVP_PKEY_CTX *src));\nvoid EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth,\n                               void (*cleanup) (EVP_PKEY_CTX *ctx));\nvoid EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth,\n                                int (*paramgen_init) (EVP_PKEY_CTX *ctx),\n                                int (*paramgen) (EVP_PKEY_CTX *ctx,\n                                                 EVP_PKEY *pkey));\nvoid EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth,\n                              int (*keygen_init) (EVP_PKEY_CTX *ctx),\n                              int (*keygen) (EVP_PKEY_CTX *ctx,\n                                             EVP_PKEY *pkey));\nvoid EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth,\n                            int (*sign_init) (EVP_PKEY_CTX *ctx),\n                            int (*sign) (EVP_PKEY_CTX *ctx,\n                                         unsigned char *sig, size_t *siglen,\n                                         const unsigned char *tbs,\n                                         size_t tbslen));\nvoid EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth,\n                              int (*verify_init) (EVP_PKEY_CTX *ctx),\n                              int (*verify) (EVP_PKEY_CTX *ctx,\n                                             const unsigned char *sig,\n                                             size_t siglen,\n                                             const unsigned char *tbs,\n                                             size_t tbslen));\nvoid EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth,\n                                      int (*verify_recover_init) (EVP_PKEY_CTX\n                                                                  *ctx),\n                                      int (*verify_recover) (EVP_PKEY_CTX\n                                                             *ctx,\n                                                             unsigned char\n                                                             *sig,\n                                                             size_t *siglen,\n                                                             const unsigned\n                                                             char *tbs,\n                                                             size_t tbslen));\nvoid EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth,\n                               int (*signctx_init) (EVP_PKEY_CTX *ctx,\n                                                    EVP_MD_CTX *mctx),\n                               int (*signctx) (EVP_PKEY_CTX *ctx,\n                                               unsigned char *sig,\n                                               size_t *siglen,\n                                               EVP_MD_CTX *mctx));\nvoid EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,\n                                 int (*verifyctx_init) (EVP_PKEY_CTX *ctx,\n                                                        EVP_MD_CTX *mctx),\n                                 int (*verifyctx) (EVP_PKEY_CTX *ctx,\n                                                   const unsigned char *sig,\n                                                   int siglen,\n                                                   EVP_MD_CTX *mctx));\nvoid EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth,\n                               int (*encrypt_init) (EVP_PKEY_CTX *ctx),\n                               int (*encryptfn) (EVP_PKEY_CTX *ctx,\n                                                 unsigned char *out,\n                                                 size_t *outlen,\n                                                 const unsigned char *in,\n                                                 size_t inlen));\nvoid EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth,\n                               int (*decrypt_init) (EVP_PKEY_CTX *ctx),\n                               int (*decrypt) (EVP_PKEY_CTX *ctx,\n                                               unsigned char *out,\n                                               size_t *outlen,\n                                               const unsigned char *in,\n                                               size_t inlen));\nvoid EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth,\n                              int (*derive_init) (EVP_PKEY_CTX *ctx),\n                              int (*derive) (EVP_PKEY_CTX *ctx,\n                                             unsigned char *key,\n                                             size_t *keylen));\nvoid EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth,\n                            int (*ctrl) (EVP_PKEY_CTX *ctx, int type, int p1,\n                                         void *p2),\n                            int (*ctrl_str) (EVP_PKEY_CTX *ctx,\n                                             const char *type,\n                                             const char *value));\n\nvoid EVP_PKEY_meth_get_init(EVP_PKEY_METHOD *pmeth,\n                            int (**pinit) (EVP_PKEY_CTX *ctx));\nvoid EVP_PKEY_meth_get_copy(EVP_PKEY_METHOD *pmeth,\n                            int (**pcopy) (EVP_PKEY_CTX *dst,\n                                           EVP_PKEY_CTX *src));\nvoid EVP_PKEY_meth_get_cleanup(EVP_PKEY_METHOD *pmeth,\n                               void (**pcleanup) (EVP_PKEY_CTX *ctx));\nvoid EVP_PKEY_meth_get_paramgen(EVP_PKEY_METHOD *pmeth,\n                                int (**pparamgen_init) (EVP_PKEY_CTX *ctx),\n                                int (**pparamgen) (EVP_PKEY_CTX *ctx,\n                                                   EVP_PKEY *pkey));\nvoid EVP_PKEY_meth_get_keygen(EVP_PKEY_METHOD *pmeth,\n                              int (**pkeygen_init) (EVP_PKEY_CTX *ctx),\n                              int (**pkeygen) (EVP_PKEY_CTX *ctx,\n                                               EVP_PKEY *pkey));\nvoid EVP_PKEY_meth_get_sign(EVP_PKEY_METHOD *pmeth,\n                            int (**psign_init) (EVP_PKEY_CTX *ctx),\n                            int (**psign) (EVP_PKEY_CTX *ctx,\n                                           unsigned char *sig, size_t *siglen,\n                                           const unsigned char *tbs,\n                                           size_t tbslen));\nvoid EVP_PKEY_meth_get_verify(EVP_PKEY_METHOD *pmeth,\n                              int (**pverify_init) (EVP_PKEY_CTX *ctx),\n                              int (**pverify) (EVP_PKEY_CTX *ctx,\n                                               const unsigned char *sig,\n                                               size_t siglen,\n                                               const unsigned char *tbs,\n                                               size_t tbslen));\nvoid EVP_PKEY_meth_get_verify_recover(EVP_PKEY_METHOD *pmeth,\n                                      int (**pverify_recover_init) (EVP_PKEY_CTX\n                                                                    *ctx),\n                                      int (**pverify_recover) (EVP_PKEY_CTX\n                                                               *ctx,\n                                                               unsigned char\n                                                               *sig,\n                                                               size_t *siglen,\n                                                               const unsigned\n                                                               char *tbs,\n                                                               size_t tbslen));\nvoid EVP_PKEY_meth_get_signctx(EVP_PKEY_METHOD *pmeth,\n                               int (**psignctx_init) (EVP_PKEY_CTX *ctx,\n                                                      EVP_MD_CTX *mctx),\n                               int (**psignctx) (EVP_PKEY_CTX *ctx,\n                                                 unsigned char *sig,\n                                                 size_t *siglen,\n                                                 EVP_MD_CTX *mctx));\nvoid EVP_PKEY_meth_get_verifyctx(EVP_PKEY_METHOD *pmeth,\n                                 int (**pverifyctx_init) (EVP_PKEY_CTX *ctx,\n                                                          EVP_MD_CTX *mctx),\n                                 int (**pverifyctx) (EVP_PKEY_CTX *ctx,\n                                                     const unsigned char *sig,\n                                                     int siglen,\n                                                     EVP_MD_CTX *mctx));\nvoid EVP_PKEY_meth_get_encrypt(EVP_PKEY_METHOD *pmeth,\n                               int (**pencrypt_init) (EVP_PKEY_CTX *ctx),\n                               int (**pencryptfn) (EVP_PKEY_CTX *ctx,\n                                                   unsigned char *out,\n                                                   size_t *outlen,\n                                                   const unsigned char *in,\n                                                   size_t inlen));\nvoid EVP_PKEY_meth_get_decrypt(EVP_PKEY_METHOD *pmeth,\n                               int (**pdecrypt_init) (EVP_PKEY_CTX *ctx),\n                               int (**pdecrypt) (EVP_PKEY_CTX *ctx,\n                                                 unsigned char *out,\n                                                 size_t *outlen,\n                                                 const unsigned char *in,\n                                                 size_t inlen));\nvoid EVP_PKEY_meth_get_derive(EVP_PKEY_METHOD *pmeth,\n                              int (**pderive_init) (EVP_PKEY_CTX *ctx),\n                              int (**pderive) (EVP_PKEY_CTX *ctx,\n                                               unsigned char *key,\n                                               size_t *keylen));\nvoid EVP_PKEY_meth_get_ctrl(EVP_PKEY_METHOD *pmeth,\n                            int (**pctrl) (EVP_PKEY_CTX *ctx, int type, int p1,\n                                           void *p2),\n                            int (**pctrl_str) (EVP_PKEY_CTX *ctx,\n                                               const char *type,\n                                               const char *value));\n</code></pre>"},{"location":"man3/EVP_PKEY_meth_new/#description","title":"DESCRIPTION","text":"<p>EVP_PKEY_METHOD is a structure which holds a set of methods for a specific public key cryptographic algorithm. Those methods are usually used to perform different jobs, such as generating a key, signing or verifying, encrypting or decrypting, etc.</p> <p>There are two places where the EVP_PKEY_METHOD objects are stored: one is a built-in static array representing the standard methods for different algorithms, and the other one is a stack of user-defined application-specific methods, which can be manipulated by using EVP_PKEY_meth_add0(3).</p> <p>The EVP_PKEY_METHOD objects are usually referenced by EVP_PKEY_CTX objects.</p>"},{"location":"man3/EVP_PKEY_meth_new/#methods","title":"Methods","text":"<p>The methods are the underlying implementations of a particular public key algorithm present by the EVP_PKEY_CTX object.</p> <pre><code>int (*init) (EVP_PKEY_CTX *ctx);\nint (*copy) (EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src);\nvoid (*cleanup) (EVP_PKEY_CTX *ctx);\n</code></pre> <p>The init() method is called to initialize algorithm-specific data when a new EVP_PKEY_CTX is created. As opposed to init(), the cleanup() method is called when an EVP_PKEY_CTX is freed. The copy() method is called when an EVP_PKEY_CTX is being duplicated. Refer to EVP_PKEY_CTX_new(3), EVP_PKEY_CTX_new_id(3), EVP_PKEY_CTX_free(3) and EVP_PKEY_CTX_dup(3).</p> <pre><code>int (*paramgen_init) (EVP_PKEY_CTX *ctx);\nint (*paramgen) (EVP_PKEY_CTX *ctx, EVP_PKEY *pkey);\n</code></pre> <p>The paramgen_init() and paramgen() methods deal with key parameter generation. They are called by EVP_PKEY_paramgen_init(3) and EVP_PKEY_paramgen(3) to handle the parameter generation process.</p> <pre><code>int (*keygen_init) (EVP_PKEY_CTX *ctx);\nint (*keygen) (EVP_PKEY_CTX *ctx, EVP_PKEY *pkey);\n</code></pre> <p>The keygen_init() and keygen() methods are used to generate the actual key for the specified algorithm. They are called by EVP_PKEY_keygen_init(3) and EVP_PKEY_keygen(3).</p> <pre><code>int (*sign_init) (EVP_PKEY_CTX *ctx);\nint (*sign) (EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,\n             const unsigned char *tbs, size_t tbslen);\n</code></pre> <p>The sign_init() and sign() methods are used to generate the signature of a piece of data using a private key. They are called by EVP_PKEY_sign_init(3) and EVP_PKEY_sign(3).</p> <pre><code>int (*verify_init) (EVP_PKEY_CTX *ctx);\nint (*verify) (EVP_PKEY_CTX *ctx,\n               const unsigned char *sig, size_t siglen,\n               const unsigned char *tbs, size_t tbslen);\n</code></pre> <p>The verify_init() and verify() methods are used to verify whether a signature is valid. They are called by EVP_PKEY_verify_init(3) and EVP_PKEY_verify(3).</p> <pre><code>int (*verify_recover_init) (EVP_PKEY_CTX *ctx);\nint (*verify_recover) (EVP_PKEY_CTX *ctx,\n                       unsigned char *rout, size_t *routlen,\n                       const unsigned char *sig, size_t siglen);\n</code></pre> <p>The verify_recover_init() and verify_recover() methods are used to verify a signature and then recover the digest from the signature (for instance, a signature that was generated by RSA signing algorithm). They are called by EVP_PKEY_verify_recover_init(3) and EVP_PKEY_verify_recover(3).</p> <pre><code>int (*signctx_init) (EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx);\nint (*signctx) (EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,\n                EVP_MD_CTX *mctx);\n</code></pre> <p>The signctx_init() and signctx() methods are used to sign a digest present by a EVP_MD_CTX object. They are called by the EVP_DigestSign functions. See EVP_DigestSignInit(3) for detail.</p> <pre><code>int (*verifyctx_init) (EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx);\nint (*verifyctx) (EVP_PKEY_CTX *ctx, const unsigned char *sig, int siglen,\n                  EVP_MD_CTX *mctx);\n</code></pre> <p>The verifyctx_init() and verifyctx() methods are used to verify a signature against the data in a EVP_MD_CTX object. They are called by the various EVP_DigestVerify functions. See EVP_DigestVerifyInit(3) for detail.</p> <pre><code>int (*encrypt_init) (EVP_PKEY_CTX *ctx);\nint (*encrypt) (EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,\n                const unsigned char *in, size_t inlen);\n</code></pre> <p>The encrypt_init() and encrypt() methods are used to encrypt a piece of data. They are called by EVP_PKEY_encrypt_init(3) and EVP_PKEY_encrypt(3).</p> <pre><code>int (*decrypt_init) (EVP_PKEY_CTX *ctx);\nint (*decrypt) (EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,\n                const unsigned char *in, size_t inlen);\n</code></pre> <p>The decrypt_init() and decrypt() methods are used to decrypt a piece of data. They are called by EVP_PKEY_decrypt_init(3) and EVP_PKEY_decrypt(3).</p> <pre><code>int (*derive_init) (EVP_PKEY_CTX *ctx);\nint (*derive) (EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);\n</code></pre> <p>The derive_init() and derive() methods are used to derive the shared secret from a public key algorithm (for instance, the DH algorithm). They are called by EVP_PKEY_derive_init(3) and EVP_PKEY_derive(3).</p> <pre><code>int (*ctrl) (EVP_PKEY_CTX *ctx, int type, int p1, void *p2);\nint (*ctrl_str) (EVP_PKEY_CTX *ctx, const char *type, const char *value);\n</code></pre> <p>The ctrl() and ctrl_str() methods are used to adjust algorithm-specific settings. See EVP_PKEY_CTX_ctrl(3) and related functions for detail.</p> <pre><code>int (*digestsign) (EVP_MD_CTX *ctx, unsigned char *sig, size_t *siglen,\n                   const unsigned char *tbs, size_t tbslen);\nint (*digestverify) (EVP_MD_CTX *ctx, const unsigned char *sig,\n                     size_t siglen, const unsigned char *tbs,\n                     size_t tbslen);\n</code></pre> <p>The digestsign() and digestverify() methods are used to generate or verify a signature in a one-shot mode. They could be called by EVP_DigetSign(3) and EVP_DigestVerify(3).</p>"},{"location":"man3/EVP_PKEY_meth_new/#functions","title":"Functions","text":"<p>EVP_PKEY_meth_new() creates and returns a new EVP_PKEY_METHOD object, and associates the given id and flags. The following flags are supported:</p> <pre><code>EVP_PKEY_FLAG_AUTOARGLEN\nEVP_PKEY_FLAG_SIGCTX_CUSTOM\n</code></pre> <p>If an EVP_PKEY_METHOD is set with the EVP_PKEY_FLAG_AUTOARGLEN flag, the maximum size of the output buffer will be automatically calculated or checked in corresponding EVP methods by the EVP framework. Thus the implementations of these methods don't need to care about handling the case of returning output buffer size by themselves. For details on the output buffer size, refer to EVP_PKEY_sign(3).</p> <p>The EVP_PKEY_FLAG_SIGCTX_CUSTOM is used to indicate the signctx() method of an EVP_PKEY_METHOD is always called by the EVP framework while doing a digest signing operation by calling EVP_DigestSignFinal(3).</p> <p>EVP_PKEY_meth_free() frees an existing EVP_PKEY_METHOD pointed by pmeth.</p> <p>EVP_PKEY_meth_copy() copies an EVP_PKEY_METHOD object from src to dst.</p> <p>EVP_PKEY_meth_find() finds an EVP_PKEY_METHOD object with the id. This function first searches through the user-defined method objects and then the built-in objects.</p> <p>EVP_PKEY_meth_add0() adds pmeth to the user defined stack of methods.</p> <p>The EVP_PKEY_meth_set functions set the corresponding fields of EVP_PKEY_METHOD structure with the arguments passed.</p> <p>The EVP_PKEY_meth_get functions get the corresponding fields of EVP_PKEY_METHOD structure to the arguments provided.</p>"},{"location":"man3/EVP_PKEY_meth_new/#return-values","title":"RETURN VALUES","text":"<p>EVP_PKEY_meth_new() returns a pointer to a new EVP_PKEY_METHOD object or returns NULL on error.</p> <p>EVP_PKEY_meth_free() and EVP_PKEY_meth_copy() do not return values.</p> <p>EVP_PKEY_meth_find() returns a pointer to the found EVP_PKEY_METHOD object or returns NULL if not found.</p> <p>EVP_PKEY_meth_add0() returns 1 if method is added successfully or 0 if an error occurred.</p> <p>All EVP_PKEY_meth_set and EVP_PKEY_meth_get functions have no return values. For the 'get' functions, function pointers are returned by arguments.</p>"},{"location":"man3/EVP_PKEY_meth_new/#copyright","title":"COPYRIGHT","text":"<p>Copyright 2017 The OpenSSL Project Authors. All Rights Reserved.</p> <p>Licensed under the OpenSSL license (the \"License\").  You may not use this file except in compliance with the License.  You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html.</p>"},{"location":"man3/EVP_PKEY_new/","title":"EVP_PKEY_new","text":""},{"location":"man3/EVP_PKEY_new/#name","title":"NAME","text":"<p>EVP_PKEY_new, EVP_PKEY_free - private key allocation functions.</p>"},{"location":"man3/EVP_PKEY_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nEVP_PKEY *EVP_PKEY_new(void);\nvoid EVP_PKEY_free(EVP_PKEY *key);\n</code></pre>"},{"location":"man3/EVP_PKEY_new/#description","title":"DESCRIPTION","text":"<p>The EVP_PKEY_new() function allocates an empty EVP_PKEY  structure which is used by OpenSSL to store private keys.</p> <p>EVP_PKEY_free() frees up the private key key.</p>"},{"location":"man3/EVP_PKEY_new/#notes","title":"NOTES","text":"<p>The EVP_PKEY structure is used by various OpenSSL functions which require a general private key without reference to any particular algorithm.</p> <p>The structure returned by EVP_PKEY_new() is empty. To add a private key to this empty structure the functions described in EVP_PKEY_set1_RSA(3) should be used.</p>"},{"location":"man3/EVP_PKEY_new/#return-values","title":"RETURN VALUES","text":"<p>EVP_PKEY_new() returns either the newly allocated EVP_PKEY structure of NULL if an error occurred.</p> <p>EVP_PKEY_free() does not return a value.</p>"},{"location":"man3/EVP_PKEY_new/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_set1_RSA(3)</p>"},{"location":"man3/EVP_PKEY_new/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/EVP_PKEY_print_private/","title":"EVP_PKEY_print_private","text":""},{"location":"man3/EVP_PKEY_print_private/#name","title":"NAME","text":"<p>EVP_PKEY_print_public, EVP_PKEY_print_private, EVP_PKEY_print_params - public key algorithm printing routines.</p>"},{"location":"man3/EVP_PKEY_print_private/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,\n                               int indent, ASN1_PCTX *pctx);\nint EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,\n                               int indent, ASN1_PCTX *pctx);\nint EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,\n                               int indent, ASN1_PCTX *pctx);\n</code></pre>"},{"location":"man3/EVP_PKEY_print_private/#description","title":"DESCRIPTION","text":"<p>The functions EVP_PKEY_print_public(), EVP_PKEY_print_private() and EVP_PKEY_print_params() print out the public, private or parameter components of key pkey respectively. The key is sent to BIO out in human readable form. The parameter indent indicated how far the printout should be indented.</p> <p>The pctx parameter allows the print output to be finely tuned by using ASN1 printing options. If pctx is set to NULL then default values will be used.</p>"},{"location":"man3/EVP_PKEY_print_private/#notes","title":"NOTES","text":"<p>Currently no public key algorithms include any options in the pctx parameter  parameter.</p> <p>If the key does not include all the components indicated by the function then only those contained in the key will be printed. For example passing a public key to EVP_PKEY_print_private() will only print the public components.</p>"},{"location":"man3/EVP_PKEY_print_private/#return-values","title":"RETURN VALUES","text":"<p>These functions all return 1 for success and 0 or a negative value for failure. In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</p>"},{"location":"man3/EVP_PKEY_print_private/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_CTX_new(3), EVP_PKEY_keygen(3) </p>"},{"location":"man3/EVP_PKEY_print_private/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_PKEY_set1_RSA/","title":"EVP_PKEY_set1_RSA","text":""},{"location":"man3/EVP_PKEY_set1_RSA/#name","title":"NAME","text":"<p>EVP_PKEY_set1_RSA, EVP_PKEY_set1_DSA, EVP_PKEY_set1_DH, EVP_PKEY_set1_EC_KEY, EVP_PKEY_get1_RSA, EVP_PKEY_get1_DSA, EVP_PKEY_get1_DH, EVP_PKEY_get1_EC_KEY, EVP_PKEY_assign_RSA, EVP_PKEY_assign_DSA, EVP_PKEY_assign_DH, EVP_PKEY_assign_EC_KEY, EVP_PKEY_type - EVP_PKEY assignment functions.</p>"},{"location":"man3/EVP_PKEY_set1_RSA/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_PKEY_set1_RSA(EVP_PKEY *pkey,RSA *key);\nint EVP_PKEY_set1_DSA(EVP_PKEY *pkey,DSA *key);\nint EVP_PKEY_set1_DH(EVP_PKEY *pkey,DH *key);\nint EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey,EC_KEY *key);\n\nRSA *EVP_PKEY_get1_RSA(EVP_PKEY *pkey);\nDSA *EVP_PKEY_get1_DSA(EVP_PKEY *pkey);\nDH *EVP_PKEY_get1_DH(EVP_PKEY *pkey);\nEC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);\n\nint EVP_PKEY_assign_RSA(EVP_PKEY *pkey,RSA *key);\nint EVP_PKEY_assign_DSA(EVP_PKEY *pkey,DSA *key);\nint EVP_PKEY_assign_DH(EVP_PKEY *pkey,DH *key);\nint EVP_PKEY_assign_EC_KEY(EVP_PKEY *pkey,EC_KEY *key);\n\nint EVP_PKEY_type(int type);\n</code></pre>"},{"location":"man3/EVP_PKEY_set1_RSA/#description","title":"DESCRIPTION","text":"<p>EVP_PKEY_set1_RSA(), EVP_PKEY_set1_DSA(), EVP_PKEY_set1_DH() and EVP_PKEY_set1_EC_KEY() set the key referenced by pkey to key.</p> <p>EVP_PKEY_get1_RSA(), EVP_PKEY_get1_DSA(), EVP_PKEY_get1_DH() and EVP_PKEY_get1_EC_KEY() return the referenced key in pkey or NULL if the key is not of the correct type.</p> <p>EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH() and EVP_PKEY_assign_EC_KEY() also set the referenced key to key however these use the supplied key internally and so key will be freed when the parent pkey is freed.</p> <p>EVP_PKEY_type() returns the type of key corresponding to the value type. The type of a key can be obtained with EVP_PKEY_type(pkey-&gt;type). The return value will be EVP_PKEY_RSA, EVP_PKEY_DSA, EVP_PKEY_DH or EVP_PKEY_EC for the corresponding key types or NID_undef if the key type is unassigned.</p>"},{"location":"man3/EVP_PKEY_set1_RSA/#notes","title":"NOTES","text":"<p>In accordance with the OpenSSL naming convention the key obtained from or assigned to the pkey using the 1 functions must be freed as well as pkey.</p> <p>EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH() and EVP_PKEY_assign_EC_KEY() are implemented as macros.</p>"},{"location":"man3/EVP_PKEY_set1_RSA/#return-values","title":"RETURN VALUES","text":"<p>EVP_PKEY_set1_RSA(), EVP_PKEY_set1_DSA(), EVP_PKEY_set1_DH() and EVP_PKEY_set1_EC_KEY() return 1 for success or 0 for failure.</p> <p>EVP_PKEY_get1_RSA(), EVP_PKEY_get1_DSA(), EVP_PKEY_get1_DH() and EVP_PKEY_get1_EC_KEY() return the referenced key or NULL if  an error occurred.</p> <p>EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH() and EVP_PKEY_assign_EC_KEY() return 1 for success and 0 for failure.</p>"},{"location":"man3/EVP_PKEY_set1_RSA/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_new(3)</p>"},{"location":"man3/EVP_PKEY_set1_RSA/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/EVP_PKEY_sign/","title":"EVP_PKEY_sign","text":""},{"location":"man3/EVP_PKEY_sign/#name","title":"NAME","text":"<p>EVP_PKEY_sign_init, EVP_PKEY_sign - sign using a public key algorithm</p>"},{"location":"man3/EVP_PKEY_sign/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_sign(EVP_PKEY_CTX *ctx,\n                       unsigned char *sig, size_t *siglen,\n                       const unsigned char *tbs, size_t tbslen);\n</code></pre>"},{"location":"man3/EVP_PKEY_sign/#description","title":"DESCRIPTION","text":"<p>The EVP_PKEY_sign_init() function initializes a public key algorithm context using key pkey for a signing operation.</p> <p>The EVP_PKEY_sign() function performs a public key signing operation using ctx. The data to be signed is specified using the tbs and tbslen parameters. If sig is NULL then the maximum size of the output buffer is written to the siglen parameter. If sig is not NULL then before the call the siglen parameter should contain the length of the sig buffer, if the call is successful the signature is written to sig and the amount of data written to siglen.</p>"},{"location":"man3/EVP_PKEY_sign/#notes","title":"NOTES","text":"<p>EVP_PKEY_sign() does not hash the data to be signed, and therefore is normally used to sign digests. For signing arbitrary messages, see the EVP_DigestSignInit(3) and EVP_SignInit(3) signing interfaces instead.</p> <p>After the call to EVP_PKEY_sign_init() algorithm specific control operations can be performed to set any appropriate parameters for the operation (see EVP_PKEY_CTX_ctrl(3)).</p> <p>The function EVP_PKEY_sign() can be called more than once on the same context if several operations are performed using the same parameters.</p>"},{"location":"man3/EVP_PKEY_sign/#return-values","title":"RETURN VALUES","text":"<p>EVP_PKEY_sign_init() and EVP_PKEY_sign() return 1 for success and 0 or a negative value for failure. In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</p>"},{"location":"man3/EVP_PKEY_sign/#example","title":"EXAMPLE","text":"<p>Sign data using RSA with PKCS#1 padding and SHA256 digest:</p> <pre><code>#include &lt;openssl/evp.h&gt;\n#include &lt;openssl/rsa.h&gt;\n\nEVP_PKEY_CTX *ctx;\n/* md is a SHA-256 digest in this example. */\nunsigned char *md, *sig;\nsize_t mdlen = 32, siglen;\nEVP_PKEY *signing_key;\n\n/*\n * NB: assumes signing_key and md are set up before the next\n * step. signing_key must be an RSA private key and md must\n * point to the SHA-256 digest to be signed.\n */\nctx = EVP_PKEY_CTX_new(signing_key, NULL /* no engine */);\nif (!ctx)\n       /* Error occurred */\nif (EVP_PKEY_sign_init(ctx) &lt;= 0)\n       /* Error */\nif (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) &lt;= 0)\n       /* Error */\nif (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) &lt;= 0)\n       /* Error */\n\n/* Determine buffer length */\nif (EVP_PKEY_sign(ctx, NULL, &amp;siglen, md, mdlen) &lt;= 0)\n       /* Error */\n\nsig = OPENSSL_malloc(siglen);\n\nif (!sig)\n       /* malloc failure */\n\nif (EVP_PKEY_sign(ctx, sig, &amp;siglen, md, mdlen) &lt;= 0)\n       /* Error */\n\n/* Signature is siglen bytes written to buffer sig */\n</code></pre>"},{"location":"man3/EVP_PKEY_sign/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_CTX_new(3), EVP_PKEY_CTX_ctrl(3), EVP_PKEY_encrypt(3), EVP_PKEY_decrypt(3), EVP_PKEY_verify(3), EVP_PKEY_verify_recover(3), EVP_PKEY_derive(3) </p>"},{"location":"man3/EVP_PKEY_sign/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_PKEY_verify/","title":"EVP_PKEY_verify","text":""},{"location":"man3/EVP_PKEY_verify/#name","title":"NAME","text":"<p>EVP_PKEY_verify_init, EVP_PKEY_verify - signature verification using a public key algorithm</p>"},{"location":"man3/EVP_PKEY_verify/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_verify(EVP_PKEY_CTX *ctx,\n                       const unsigned char *sig, size_t siglen,\n                       const unsigned char *tbs, size_t tbslen);\n</code></pre>"},{"location":"man3/EVP_PKEY_verify/#description","title":"DESCRIPTION","text":"<p>The EVP_PKEY_verify_init() function initializes a public key algorithm context using key pkey for a signature verification operation.</p> <p>The EVP_PKEY_verify() function performs a public key verification operation using ctx. The signature is specified using the sig and siglen parameters. The verified data (i.e. the data believed originally signed) is specified using the tbs and tbslen parameters.</p>"},{"location":"man3/EVP_PKEY_verify/#notes","title":"NOTES","text":"<p>After the call to EVP_PKEY_verify_init() algorithm specific control operations can be performed to set any appropriate parameters for the operation.</p> <p>The function EVP_PKEY_verify() can be called more than once on the same context if several operations are performed using the same parameters.</p>"},{"location":"man3/EVP_PKEY_verify/#return-values","title":"RETURN VALUES","text":"<p>EVP_PKEY_verify_init() and EVP_PKEY_verify() return 1 if the verification was successful and 0 if it failed. Unlike other functions the return value 0 from EVP_PKEY_verify() only indicates that the signature did not not verify successfully (that is tbs did not match the original data or the signature was of invalid form) it is not an indication of a more serious error.</p> <p>A negative value indicates an error other that signature verification failure. In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</p>"},{"location":"man3/EVP_PKEY_verify/#example","title":"EXAMPLE","text":"<p>Verify signature using PKCS#1 and SHA256 digest:</p> <pre><code>#include &lt;openssl/evp.h&gt;\n#include &lt;openssl/rsa.h&gt;\n\nEVP_PKEY_CTX *ctx;\nunsigned char *md, *sig;\nsize_t mdlen, siglen; \nEVP_PKEY *verify_key;\n/* NB: assumes verify_key, sig, siglen md and mdlen are already set up\n * and that verify_key is an RSA public key\n */\nctx = EVP_PKEY_CTX_new(verify_key);\nif (!ctx)\n       /* Error occurred */\nif (EVP_PKEY_verify_init(ctx) &lt;= 0)\n       /* Error */\nif (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) &lt;= 0)\n       /* Error */\nif (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) &lt;= 0)\n       /* Error */\n\n/* Perform operation */\nret = EVP_PKEY_verify(ctx, sig, siglen, md, mdlen);\n\n/* ret == 1 indicates success, 0 verify failure and &lt; 0 for some\n * other error.\n */\n</code></pre>"},{"location":"man3/EVP_PKEY_verify/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_CTX_new(3), EVP_PKEY_encrypt(3), EVP_PKEY_decrypt(3), EVP_PKEY_sign(3), EVP_PKEY_verify_recover(3), EVP_PKEY_derive(3) </p>"},{"location":"man3/EVP_PKEY_verify/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_PKEY_verify_recover/","title":"EVP_PKEY_verify_recover","text":""},{"location":"man3/EVP_PKEY_verify_recover/#name","title":"NAME","text":"<p>EVP_PKEY_verify_recover_init, EVP_PKEY_verify_recover - recover signature using a public key algorithm</p>"},{"location":"man3/EVP_PKEY_verify_recover/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);\nint EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,\n                       unsigned char *rout, size_t *routlen,\n                       const unsigned char *sig, size_t siglen);\n</code></pre>"},{"location":"man3/EVP_PKEY_verify_recover/#description","title":"DESCRIPTION","text":"<p>The EVP_PKEY_verify_recover_init() function initializes a public key algorithm context using key pkey for a verify recover operation.</p> <p>The EVP_PKEY_verify_recover() function recovers signed data using ctx. The signature is specified using the sig and siglen parameters. If rout is NULL then the maximum size of the output buffer is written to the routlen parameter. If rout is not NULL then before the call the routlen parameter should contain the length of the rout buffer, if the call is successful recovered data is written to rout and the amount of data written to routlen.</p>"},{"location":"man3/EVP_PKEY_verify_recover/#notes","title":"NOTES","text":"<p>Normally an application is only interested in whether a signature verification operation is successful in those cases the EVP_verify() function should be  used.</p> <p>Sometimes however it is useful to obtain the data originally signed using a signing operation. Only certain public key algorithms can recover a signature in this way (for example RSA in PKCS padding mode).</p> <p>After the call to EVP_PKEY_verify_recover_init() algorithm specific control operations can be performed to set any appropriate parameters for the operation.</p> <p>The function EVP_PKEY_verify_recover() can be called more than once on the same context if several operations are performed using the same parameters.</p>"},{"location":"man3/EVP_PKEY_verify_recover/#return-values","title":"RETURN VALUES","text":"<p>EVP_PKEY_verify_recover_init() and EVP_PKEY_verify_recover() return 1 for success and 0 or a negative value for failure. In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</p>"},{"location":"man3/EVP_PKEY_verify_recover/#example","title":"EXAMPLE","text":"<p>Recover digest originally signed using PKCS#1 and SHA256 digest:</p> <pre><code>#include &lt;openssl/evp.h&gt;\n#include &lt;openssl/rsa.h&gt;\n\nEVP_PKEY_CTX *ctx;\nunsigned char *rout, *sig;\nsize_t routlen, siglen; \nEVP_PKEY *verify_key;\n/* NB: assumes verify_key, sig and siglen are already set up\n * and that verify_key is an RSA public key\n */\nctx = EVP_PKEY_CTX_new(verify_key);\nif (!ctx)\n       /* Error occurred */\nif (EVP_PKEY_verify_recover_init(ctx) &lt;= 0)\n       /* Error */\nif (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) &lt;= 0)\n       /* Error */\nif (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) &lt;= 0)\n       /* Error */\n\n/* Determine buffer length */\nif (EVP_PKEY_verify_recover(ctx, NULL, &amp;routlen, sig, siglen) &lt;= 0)\n       /* Error */\n\nrout = OPENSSL_malloc(routlen);\n\nif (!rout)\n       /* malloc failure */\n\nif (EVP_PKEY_verify_recover(ctx, rout, &amp;routlen, sig, siglen) &lt;= 0)\n       /* Error */\n\n/* Recovered data is routlen bytes written to buffer rout */\n</code></pre>"},{"location":"man3/EVP_PKEY_verify_recover/#see-also","title":"SEE ALSO","text":"<p>EVP_PKEY_CTX_new(3), EVP_PKEY_encrypt(3), EVP_PKEY_decrypt(3), EVP_PKEY_sign(3), EVP_PKEY_verify(3), EVP_PKEY_derive(3) </p>"},{"location":"man3/EVP_PKEY_verify_recover/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.0.</p>"},{"location":"man3/EVP_SealInit/","title":"EVP_SealInit","text":""},{"location":"man3/EVP_SealInit/#name","title":"NAME","text":"<p>EVP_SealInit, EVP_SealUpdate, EVP_SealFinal - EVP envelope encryption</p>"},{"location":"man3/EVP_SealInit/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n                 unsigned char **ek, int *ekl, unsigned char *iv,\n                 EVP_PKEY **pubk, int npubk);\nint EVP_SealUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n        int *outl, unsigned char *in, int inl);\nint EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n        int *outl);\n</code></pre>"},{"location":"man3/EVP_SealInit/#description","title":"DESCRIPTION","text":"<p>The EVP envelope routines are a high level interface to envelope encryption. They generate a random key and IV (if required) then \"envelope\" it by using public key encryption. Data can then be encrypted using this key.</p> <p>EVP_SealInit() initializes a cipher context ctx for encryption with cipher type using a random secret key and IV. type is normally supplied by a function such as EVP_aes_256_cbc(). The secret key is encrypted using one or more public keys, this allows the same encrypted data to be decrypted using any of the corresponding private keys. ek is an array of buffers where the public key encrypted secret key will be written, each buffer must contain enough room for the corresponding encrypted key: that is ek[i] must have room for EVP_PKEY_size(pubk[i]) bytes. The actual size of each encrypted secret key is written to the array ekl. pubk is an array of npubk public keys.</p> <p>The iv parameter is a buffer where the generated IV is written to. It must contain enough room for the corresponding cipher's IV, as determined by (for example) EVP_CIPHER_iv_length(type).</p> <p>If the cipher does not require an IV then the iv parameter is ignored and can be NULL.</p> <p>EVP_SealUpdate() and EVP_SealFinal() have exactly the same properties as the EVP_EncryptUpdate() and EVP_EncryptFinal() routines, as  documented on the EVP_EncryptInit(3) manual page. </p>"},{"location":"man3/EVP_SealInit/#return-values","title":"RETURN VALUES","text":"<p>EVP_SealInit() returns 0 on error or npubk if successful.</p> <p>EVP_SealUpdate() and EVP_SealFinal() return 1 for success and 0 for failure.</p>"},{"location":"man3/EVP_SealInit/#notes","title":"NOTES","text":"<p>Because a random secret key is generated the random number generator must be seeded before calling EVP_SealInit().</p> <p>The public key must be RSA because it is the only OpenSSL public key algorithm that supports key transport.</p> <p>Envelope encryption is the usual method of using public key encryption on large amounts of data, this is because public key encryption is slow but symmetric encryption is fast. So symmetric encryption is used for bulk encryption and the small random symmetric key used is transferred using public key encryption.</p> <p>It is possible to call EVP_SealInit() twice in the same way as EVP_EncryptInit(). The first call should have npubk set to 0 and (after setting any cipher parameters) it should be called again with type set to NULL.</p>"},{"location":"man3/EVP_SealInit/#see-also","title":"SEE ALSO","text":"<p>evp(3), rand(3), EVP_EncryptInit(3), EVP_OpenInit(3)</p>"},{"location":"man3/EVP_SealInit/#history","title":"HISTORY","text":"<p>EVP_SealFinal() did not return a value before OpenSSL 0.9.7.</p>"},{"location":"man3/EVP_SignInit/","title":"EVP_SignInit","text":""},{"location":"man3/EVP_SignInit/#name","title":"NAME","text":"<p>EVP_SignInit, EVP_SignInit_ex, EVP_SignUpdate, EVP_SignFinal - EVP signing functions</p>"},{"location":"man3/EVP_SignInit/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_SignInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\nint EVP_SignUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);\nint EVP_SignFinal(EVP_MD_CTX *ctx,unsigned char *sig,unsigned int *s, EVP_PKEY *pkey);\n\nvoid EVP_SignInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n\nint EVP_PKEY_size(EVP_PKEY *pkey);\n</code></pre>"},{"location":"man3/EVP_SignInit/#description","title":"DESCRIPTION","text":"<p>The EVP signature routines are a high level interface to digital signatures.</p> <p>EVP_SignInit_ex() sets up signing context ctx to use digest type from ENGINE impl. ctx must be initialized with EVP_MD_CTX_init() before calling this function.</p> <p>EVP_SignUpdate() hashes cnt bytes of data at d into the signature context ctx. This function can be called several times on the same ctx to include additional data.</p> <p>EVP_SignFinal() signs the data in ctx using the private key pkey and places the signature in sig. sig must be at least EVP_PKEY_size(pkey) bytes in size. s is an OUT paramter, and not used as an IN parameter. The number of bytes of data written (i.e. the length of the signature) will be written to the integer at s, at most EVP_PKEY_size(pkey) bytes will be written.</p> <p>EVP_SignInit() initializes a signing context ctx to use the default implementation of digest type.</p> <p>EVP_PKEY_size() returns the maximum size of a signature in bytes. The actual signature returned by EVP_SignFinal() may be smaller.</p>"},{"location":"man3/EVP_SignInit/#return-values","title":"RETURN VALUES","text":"<p>EVP_SignInit_ex(), EVP_SignUpdate() and EVP_SignFinal() return 1 for success and 0 for failure.</p> <p>EVP_PKEY_size() returns the maximum size of a signature in bytes.</p> <p>The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/EVP_SignInit/#notes","title":"NOTES","text":"<p>The EVP interface to digital signatures should almost always be used in preference to the low level interfaces. This is because the code then becomes transparent to the algorithm used and much more flexible.</p> <p>Due to the link between message digests and public key algorithms the correct digest algorithm must be used with the correct public key type. A list of algorithms and associated public key algorithms appears in  EVP_DigestInit(3).</p> <p>When signing with DSA private keys the random number generator must be seeded or the operation will fail. The random number generator does not need to be seeded for RSA signatures.</p> <p>The call to EVP_SignFinal() internally finalizes a copy of the digest context. This means that calls to EVP_SignUpdate() and EVP_SignFinal() can be called later to digest and sign additional data.</p> <p>Since only a copy of the digest context is ever finalized the context must be cleaned up after use by calling EVP_MD_CTX_cleanup() or a memory leak will occur.</p>"},{"location":"man3/EVP_SignInit/#bugs","title":"BUGS","text":"<p>Older versions of this documentation wrongly stated that calls to  EVP_SignUpdate() could not be made after calling EVP_SignFinal().</p> <p>Since the private key is passed in the call to EVP_SignFinal() any error relating to the private key (for example an unsuitable key and digest combination) will not be indicated until after potentially large amounts of data have been passed through EVP_SignUpdate().</p> <p>It is not possible to change the signing parameters using these function.</p> <p>The previous two bugs are fixed in the newer EVP_SignDigest*() function.</p>"},{"location":"man3/EVP_SignInit/#see-also","title":"SEE ALSO","text":"<p>EVP_VerifyInit(3), EVP_DigestInit(3), err(3), evp(3), hmac(3), md2(3), md5(3), mdc2(3), ripemd(3), sha(3), dgst(1)</p>"},{"location":"man3/EVP_SignInit/#history","title":"HISTORY","text":"<p>EVP_SignInit(), EVP_SignUpdate() and EVP_SignFinal() are available in all versions of SSLeay and OpenSSL.</p> <p>EVP_SignInit_ex() was added in OpenSSL 0.9.7.</p>"},{"location":"man3/EVP_VerifyInit/","title":"EVP_VerifyInit","text":""},{"location":"man3/EVP_VerifyInit/#name","title":"NAME","text":"<p>EVP_VerifyInit, EVP_VerifyUpdate, EVP_VerifyFinal - EVP signature verification functions</p>"},{"location":"man3/EVP_VerifyInit/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nint EVP_VerifyInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\nint EVP_VerifyUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);\nint EVP_VerifyFinal(EVP_MD_CTX *ctx,unsigned char *sigbuf, unsigned int siglen,EVP_PKEY *pkey);\n\nint EVP_VerifyInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n</code></pre>"},{"location":"man3/EVP_VerifyInit/#description","title":"DESCRIPTION","text":"<p>The EVP signature verification routines are a high level interface to digital signatures.</p> <p>EVP_VerifyInit_ex() sets up verification context ctx to use digest type from ENGINE impl. ctx must be initialized by calling EVP_MD_CTX_init() before calling this function.</p> <p>EVP_VerifyUpdate() hashes cnt bytes of data at d into the verification context ctx. This function can be called several times on the same ctx to include additional data.</p> <p>EVP_VerifyFinal() verifies the data in ctx using the public key pkey and against the siglen bytes at sigbuf.</p> <p>EVP_VerifyInit() initializes verification context ctx to use the default implementation of digest type.</p>"},{"location":"man3/EVP_VerifyInit/#return-values","title":"RETURN VALUES","text":"<p>EVP_VerifyInit_ex() and EVP_VerifyUpdate() return 1 for success and 0 for failure.</p> <p>EVP_VerifyFinal() returns 1 for a correct signature, 0 for failure and -1 if some other error occurred.</p> <p>The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/EVP_VerifyInit/#notes","title":"NOTES","text":"<p>The EVP interface to digital signatures should almost always be used in preference to the low level interfaces. This is because the code then becomes transparent to the algorithm used and much more flexible.</p> <p>Due to the link between message digests and public key algorithms the correct digest algorithm must be used with the correct public key type. A list of algorithms and associated public key algorithms appears in  EVP_DigestInit(3).</p> <p>The call to EVP_VerifyFinal() internally finalizes a copy of the digest context. This means that calls to EVP_VerifyUpdate() and EVP_VerifyFinal() can be called later to digest and verify additional data.</p> <p>Since only a copy of the digest context is ever finalized the context must be cleaned up after use by calling EVP_MD_CTX_cleanup() or a memory leak will occur.</p>"},{"location":"man3/EVP_VerifyInit/#bugs","title":"BUGS","text":"<p>Older versions of this documentation wrongly stated that calls to  EVP_VerifyUpdate() could not be made after calling EVP_VerifyFinal().</p> <p>Since the public key is passed in the call to EVP_SignFinal() any error relating to the private key (for example an unsuitable key and digest combination) will not be indicated until after potentially large amounts of data have been passed through EVP_SignUpdate().</p> <p>It is not possible to change the signing parameters using these function.</p> <p>The previous two bugs are fixed in the newer EVP_VerifyDigest*() function.</p>"},{"location":"man3/EVP_VerifyInit/#see-also","title":"SEE ALSO","text":"<p>evp(3), EVP_SignInit(3), EVP_DigestInit(3), err(3), evp(3), hmac(3), md2(3), md5(3), mdc2(3), ripemd(3), sha(3), dgst(1)</p>"},{"location":"man3/EVP_VerifyInit/#history","title":"HISTORY","text":"<p>EVP_VerifyInit(), EVP_VerifyUpdate() and EVP_VerifyFinal() are available in all versions of SSLeay and OpenSSL.</p> <p>EVP_VerifyInit_ex() was added in OpenSSL 0.9.7</p>"},{"location":"man3/OBJ_nid2obj/","title":"OBJ_nid2obj","text":""},{"location":"man3/OBJ_nid2obj/#name","title":"NAME","text":"<p>OBJ_nid2obj, OBJ_nid2ln, OBJ_nid2sn, OBJ_obj2nid, OBJ_txt2nid, OBJ_ln2nid, OBJ_sn2nid, OBJ_cmp, OBJ_dup, OBJ_txt2obj, OBJ_obj2txt, OBJ_create, OBJ_cleanup - ASN1 object utility functions</p>"},{"location":"man3/OBJ_nid2obj/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/objects.h&gt;\n\nASN1_OBJECT * OBJ_nid2obj(int n);\nconst char *  OBJ_nid2ln(int n);\nconst char *  OBJ_nid2sn(int n);\n\nint OBJ_obj2nid(const ASN1_OBJECT *o);\nint OBJ_ln2nid(const char *ln);\nint OBJ_sn2nid(const char *sn);\n\nint OBJ_txt2nid(const char *s);\n\nASN1_OBJECT * OBJ_txt2obj(const char *s, int no_name);\nint OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name);\n\nint OBJ_cmp(const ASN1_OBJECT *a,const ASN1_OBJECT *b);\nASN1_OBJECT * OBJ_dup(const ASN1_OBJECT *o);\n\nint OBJ_create(const char *oid,const char *sn,const char *ln);\nvoid OBJ_cleanup(void);\n</code></pre>"},{"location":"man3/OBJ_nid2obj/#description","title":"DESCRIPTION","text":"<p>The ASN1 object utility functions process ASN1_OBJECT structures which are a representation of the ASN1 OBJECT IDENTIFIER (OID) type. For convenience, OIDs are usually represented in source code as numeric identifiers, or NIDs.  OpenSSL has an internal table of OIDs that are generated when the library is built, and their corresponding NIDs are available as defined constants.  For the functions below, application code should treat all returned values -- OIDs, NIDs, or names -- as constants.</p> <p>OBJ_nid2obj(), OBJ_nid2ln() and OBJ_nid2sn() convert the NID n to  an ASN1_OBJECT structure, its long name and its short name respectively, or NULL if an error occurred.</p> <p>OBJ_obj2nid(), OBJ_ln2nid(), OBJ_sn2nid() return the corresponding NID for the object o, the long name &lt;ln&gt; or the short name &lt;sn&gt; respectively or NID_undef if an error occurred.</p> <p>OBJ_txt2nid() returns NID corresponding to text string &lt;s&gt;. s can be a long name, a short name or the numerical respresentation of an object.</p> <p>OBJ_txt2obj() converts the text string s into an ASN1_OBJECT structure. If no_name is 0 then long names and short names will be interpreted as well as numerical forms. If no_name is 1 only the numerical form is acceptable.</p> <p>OBJ_obj2txt() converts the ASN1_OBJECT a into a textual representation. The representation is written as a null terminated string to buf at most buf_len bytes are written, truncating the result if necessary. The total amount of space required is returned. If no_name is 0 then if the object has a long or short name then that will be used, otherwise the numerical form will be used. If no_name is 1 then the numerical form will always be used.</p> <p>OBJ_cmp() compares a to b. If the two are identical 0 is returned.</p> <p>OBJ_dup() returns a copy of o.</p> <p>OBJ_create() adds a new object to the internal table. oid is the  numerical form of the object, sn the short name and ln the long name. A new NID is returned for the created object.</p> <p>OBJ_cleanup() cleans up OpenSSLs internal object table: this should be called before an application exits if any new objects were added using OBJ_create().</p>"},{"location":"man3/OBJ_nid2obj/#notes","title":"NOTES","text":"<p>Objects in OpenSSL can have a short name, a long name and a numerical identifier (NID) associated with them. A standard set of objects is represented in an internal table. The appropriate values are defined in the header file objects.h.</p> <p>For example the OID for commonName has the following definitions:</p> <pre><code>#define SN_commonName                   \"CN\"\n#define LN_commonName                   \"commonName\"\n#define NID_commonName                  13\n</code></pre> <p>New objects can be added by calling OBJ_create().</p> <p>Table objects have certain advantages over other objects: for example their NIDs can be used in a C language switch statement. They are also static constant structures which are shared: that is there is only a single constant structure for each table object.</p> <p>Objects which are not in the table have the NID value NID_undef.</p> <p>Objects do not need to be in the internal tables to be processed, the functions OBJ_txt2obj() and OBJ_obj2txt() can process the numerical form of an OID.</p> <p>Some objects are used to represent algorithms which do not have a corresponding ASN.1 OBJECT IDENTIFIER encoding (for example no OID currently exists for a particular algorithm). As a result they cannot be encoded or decoded as part of ASN.1 structures. Applications can determine if there is a corresponding OBJECT IDENTIFIER by checking OBJ_length() is not zero.</p> <p>These functions cannot return const because an ASN1_OBJECT can represent both an internal, constant, OID and a dynamically-created one. The latter cannot be constant because it needs to be freed after use.</p>"},{"location":"man3/OBJ_nid2obj/#examples","title":"EXAMPLES","text":"<p>Create an object for commonName:</p> <pre><code>ASN1_OBJECT *o;\no = OBJ_nid2obj(NID_commonName);\n</code></pre> <p>Check if an object is commonName</p> <pre><code>if (OBJ_obj2nid(obj) == NID_commonName)\n       /* Do something */\n</code></pre> <p>Create a new NID and initialize an object from it:</p> <pre><code>int new_nid;\nASN1_OBJECT *obj;\n\nnew_nid = OBJ_create(\"1.2.3.4\", \"NewOID\", \"New Object Identifier\");\n\nobj = OBJ_nid2obj(new_nid);\n</code></pre> <p>Create a new object directly:</p> <pre><code>obj = OBJ_txt2obj(\"1.2.3.4\", 1);\n</code></pre>"},{"location":"man3/OBJ_nid2obj/#bugs","title":"BUGS","text":"<p>OBJ_obj2txt() is awkward and messy to use: it doesn't follow the  convention of other OpenSSL functions where the buffer can be set to NULL to determine the amount of data that should be written. Instead buf must point to a valid buffer and buf_len should be set to a positive value. A buffer length of 80 should be more than enough to handle any OID encountered in practice.</p>"},{"location":"man3/OBJ_nid2obj/#return-values","title":"RETURN VALUES","text":"<p>OBJ_nid2obj() returns an ASN1_OBJECT structure or NULL is an error occurred. It returns a pointer to an internal table and does not allocate memory; ASN1_OBJECT_free() will have no effect.</p> <p>OBJ_nid2ln() and OBJ_nid2sn() returns a valid string or NULL on error.</p> <p>OBJ_obj2nid(), OBJ_ln2nid(), OBJ_sn2nid() and OBJ_txt2nid() return a NID or NID_undef on error.</p>"},{"location":"man3/OBJ_nid2obj/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3)</p>"},{"location":"man3/OBJ_nid2obj/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/OPENSSL_Applink/","title":"OPENSSL_Applink","text":""},{"location":"man3/OPENSSL_Applink/#name","title":"NAME","text":"<p>OPENSSL_Applink - glue between OpenSSL BIO and Win32 compiler run-time</p>"},{"location":"man3/OPENSSL_Applink/#synopsis","title":"SYNOPSIS","text":"<pre><code>__declspec(dllexport) void **OPENSSL_Applink();\n</code></pre>"},{"location":"man3/OPENSSL_Applink/#description","title":"DESCRIPTION","text":"<p>OPENSSL_Applink is application-side interface which provides a glue between OpenSSL BIO layer and Win32 compiler run-time environment. Even though it appears at application side, it's essentially OpenSSL private interface. For this reason application developers are not expected to implement it, but to compile provided module with compiler of their choice and link it into the target application. The referred module is available as &lt;openssl&gt;/ms/applink.c.</p>"},{"location":"man3/OPENSSL_VERSION_NUMBER/","title":"OPENSSL_VERSION_NUMBER","text":""},{"location":"man3/OPENSSL_VERSION_NUMBER/#name","title":"NAME","text":"<p>OPENSSL_VERSION_NUMBER, OPENSSL_VERSION_TEXT, SSLeay, SSLeay_version - get OpenSSL version number</p>"},{"location":"man3/OPENSSL_VERSION_NUMBER/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/opensslv.h&gt;\n#define OPENSSL_VERSION_NUMBER 0xnnnnnnnnnL\n#define OPENSSL_VERSION_TEXT \"OpenSSL x.y.z xx XXX xxxx\"\n\n#include &lt;openssl/crypto.h&gt;\nlong SSLeay(void);\nconst char *SSLeay_version(int t);\n</code></pre>"},{"location":"man3/OPENSSL_VERSION_NUMBER/#description","title":"DESCRIPTION","text":"<p>OPENSSL_VERSION_NUMBER is a numeric release version identifier:</p> <pre><code>MNNFFPPS: major minor fix patch status\n</code></pre> <p>The status nibble has one of the values 0 for development, 1 to e for betas 1 to 14, and f for release.</p> <p>for example</p> <pre><code>0x000906000 == 0.9.6 dev\n0x000906023 == 0.9.6b beta 3\n0x00090605f == 0.9.6e release\n</code></pre> <p>Versions prior to 0.9.3 have identifiers &lt; 0x0930. Versions between 0.9.3 and 0.9.5 had a version identifier with this interpretation:</p> <pre><code>MMNNFFRBB major minor fix final beta/patch\n</code></pre> <p>for example</p> <pre><code>0x000904100 == 0.9.4 release\n0x000905000 == 0.9.5 dev\n</code></pre> <p>Version 0.9.5a had an interim interpretation that is like the current one, except the patch level got the highest bit set, to keep continuity.  The number was therefore 0x0090581f.</p> <p>For backward compatibility, SSLEAY_VERSION_NUMBER is also defined.</p> <p>OPENSSL_VERSION_TEXT is the text variant of the version number and the release date.  For example, \"OpenSSL 1.0.1a 15 Oct 2015\".</p> <p>SSLeay() returns this number. The return value can be compared to the macro to make sure that the correct version of the library has been loaded, especially when using DLLs on Windows systems.</p> <p>SSLeay_version() returns different strings depending on t:</p> <ul> <li> <p>SSLEAY_VERSION</p> <p>The text variant of the version number and the release date.  For example, \"OpenSSL 0.9.5a 1 Apr 2000\".</p> </li> <li> <p>SSLEAY_CFLAGS</p> <p>The compiler flags set for the compilation process in the form \"compiler: ...\"  if available or \"compiler: information not available\" otherwise.</p> </li> <li> <p>SSLEAY_BUILT_ON</p> <p>The date of the build process in the form \"built on: ...\" if available or \"built on: date not available\" otherwise.</p> </li> <li> <p>SSLEAY_PLATFORM</p> <p>The \"Configure\" target of the library build in the form \"platform: ...\" if available or \"platform: information not available\" otherwise.</p> </li> <li> <p>SSLEAY_DIR</p> <p>The \"OPENSSLDIR\" setting of the library build in the form \"OPENSSLDIR: \"...\"\" if available or \"OPENSSLDIR: N/A\" otherwise.</p> </li> </ul> <p>For an unknown t, the text \"not available\" is returned.</p>"},{"location":"man3/OPENSSL_VERSION_NUMBER/#return-value","title":"RETURN VALUE","text":"<p>The version number.</p>"},{"location":"man3/OPENSSL_VERSION_NUMBER/#see-also","title":"SEE ALSO","text":"<p>crypto(3)</p>"},{"location":"man3/OPENSSL_VERSION_NUMBER/#history","title":"HISTORY","text":"<p>SSLeay() and SSLEAY_VERSION_NUMBER are available in all versions of SSLeay and OpenSSL. OPENSSL_VERSION_NUMBER is available in all versions of OpenSSL. SSLEAY_DIR was added in OpenSSL 0.9.7.</p>"},{"location":"man3/OPENSSL_config/","title":"OPENSSL_config","text":""},{"location":"man3/OPENSSL_config/#name","title":"NAME","text":"<p>OPENSSL_config, OPENSSL_no_config - simple OpenSSL configuration functions</p>"},{"location":"man3/OPENSSL_config/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/conf.h&gt;\n\nvoid OPENSSL_config(const char *appname);\nvoid OPENSSL_no_config(void);\n</code></pre>"},{"location":"man3/OPENSSL_config/#description","title":"DESCRIPTION","text":"<p>OPENSSL_config() configures OpenSSL using the standard openssl.cnf and reads from the application section appname. If appname is NULL then the default section, openssl_conf, will be used. Errors are silently ignored. Multiple calls have no effect.</p> <p>OPENSSL_no_config() disables configuration. If called before OPENSSL_config() no configuration takes place.</p>"},{"location":"man3/OPENSSL_config/#notes","title":"NOTES","text":"<p>The OPENSSL_config() function is designed to be a very simple \"call it and forget it\" function. It is however much better than nothing. Applications which need finer control over their configuration functionality should use the configuration functions such as CONF_modules_load() directly. This function is deprecated and its use should be avoided. Applications should instead call CONF_modules_load() during initialization (that is before starting any threads).</p> <p>There are several reasons why calling the OpenSSL configuration routines is advisable. For example new ENGINE functionality was added to OpenSSL 0.9.7. In OpenSSL 0.9.7 control functions can be supported by ENGINEs, this can be used (among other things) to load dynamic ENGINEs from shared libraries (DSOs). However very few applications currently support the control interface and so very few can load and use dynamic ENGINEs. Equally in future more sophisticated ENGINEs will require certain control operations to customize them. If an application calls OPENSSL_config() it doesn't need to know or care about ENGINE control operations because they can be performed by editing a configuration file.</p> <p>Applications should free up configuration at application closedown by calling CONF_modules_free().</p>"},{"location":"man3/OPENSSL_config/#return-values","title":"RETURN VALUES","text":"<p>Neither OPENSSL_config() nor OPENSSL_no_config() return a value.</p>"},{"location":"man3/OPENSSL_config/#see-also","title":"SEE ALSO","text":"<p>conf(5), CONF_load_modules_file(3), CONF_modules_free(3)</p>"},{"location":"man3/OPENSSL_config/#history","title":"HISTORY","text":"<p>OPENSSL_config() and OPENSSL_no_config() first appeared in OpenSSL 0.9.7</p>"},{"location":"man3/OPENSSL_ia32cap/","title":"OPENSSL_ia32cap","text":""},{"location":"man3/OPENSSL_ia32cap/#name","title":"NAME","text":"<p>OPENSSL_ia32cap, OPENSSL_ia32cap_loc - the IA-32 processor capabilities vector</p>"},{"location":"man3/OPENSSL_ia32cap/#synopsis","title":"SYNOPSIS","text":"<pre><code>unsigned long *OPENSSL_ia32cap_loc(void);\n#define OPENSSL_ia32cap ((OPENSSL_ia32cap_loc())[0])\n</code></pre>"},{"location":"man3/OPENSSL_ia32cap/#description","title":"DESCRIPTION","text":"<p>Value returned by OPENSSL_ia32cap_loc() is address of a variable containing IA-32 processor capabilities bit vector as it appears in EDX:ECX register pair after executing CPUID instruction with EAX=1 input value (see Intel Application Note #241618). Naturally it's meaningful on x86 and x86_64 platforms only. The variable is normally set up automatically upon toolkit initialization, but can be manipulated afterwards to modify crypto library behaviour. For the moment of this writing following bits are significant:</p> <ul> <li>bit #4 denoting presence of Time-Stamp Counter.</li> <li>bit #19 denoting availability of CLFLUSH instruction;</li> <li>bit #20, reserved by Intel, is used to choose among RC4 code paths;</li> <li>bit #23 denoting MMX support;</li> <li>bit #24, FXSR bit, denoting availability of XMM registers;</li> <li>bit #25 denoting SSE support;</li> <li>bit #26 denoting SSE2 support;</li> <li>bit #28 denoting Hyperthreading, which is used to distinguish cores with shared cache;</li> <li>bit #30, reserved by Intel, denotes specifically Intel CPUs;</li> <li>bit #33 denoting availability of PCLMULQDQ instruction;</li> <li>bit #41 denoting SSSE3, Supplemental SSE3, support;</li> <li>bit #43 denoting AMD XOP support (forced to zero on non-AMD CPUs);</li> <li>bit #57 denoting AES-NI instruction set extension;</li> <li>bit #59, OSXSAVE bit, denoting availability of YMM registers;</li> <li>bit #60 denoting AVX extension;</li> <li>bit #62 denoting availability of RDRAND instruction;</li> </ul> <p>For example, clearing bit #26 at run-time disables high-performance SSE2 code present in the crypto library, while clearing bit #24 disables SSE2 code operating on 128-bit XMM register bank. You might have to do the latter if target OpenSSL application is executed on SSE2 capable CPU, but under control of OS that does not enable XMM registers. Even though you can manipulate the value programmatically, you most likely will find it more appropriate to set up an environment variable with the same name prior starting target application, e.g. on Intel P4 processor 'env OPENSSL_ia32cap=0x16980010 apps/openssl', or better yet 'env OPENSSL_ia32cap=~0x1000000 apps/openssl' to achieve same effect without modifying the application source code. Alternatively you can reconfigure the toolkit with no-sse2 option and recompile.</p> <p>Less intuitive is clearing bit #28. The truth is that it's not copied from CPUID output verbatim, but is adjusted to reflect whether or not the data cache is actually shared between logical cores. This in turn affects the decision on whether or not expensive countermeasures against cache-timing attacks are applied, most notably in AES assembler module.</p> <p>The vector is further extended with EBX value returned by CPUID with EAX=7 and ECX=0 as input. Following bits are significant:</p> <ul> <li>bit #64+3 denoting availability of BMI1 instructions, e.g. ANDN;</li> <li>bit #64+5 denoting availability of AVX2 instructions;</li> <li>bit #64+8 denoting availability of BMI2 instructions, e.g. MUXL and RORX;</li> <li>bit #64+18 denoting availability of RDSEED instruction;</li> <li>bit #64+19 denoting availability of ADCX and ADOX instructions;</li> </ul>"},{"location":"man3/OPENSSL_instrument_bus/","title":"OPENSSL_instrument_bus","text":""},{"location":"man3/OPENSSL_instrument_bus/#name","title":"NAME","text":"<p>OPENSSL_instrument_bus, OPENSSL_instrument_bus2 - instrument references to memory bus</p>"},{"location":"man3/OPENSSL_instrument_bus/#synopsis","title":"SYNOPSIS","text":"<pre><code>#ifdef OPENSSL_CPUID_OBJ\nsize_t OPENSSL_instrument_bus (int *vector,size_t num);\nsize_t OPENSSL_instrument_bus2(int *vector,size_t num,size_t max);\n#endif\n</code></pre>"},{"location":"man3/OPENSSL_instrument_bus/#description","title":"DESCRIPTION","text":"<p>It was empirically found that timings of references to primary memory are subject to irregular, apparently non-deterministic variations. The subroutines in question instrument these references for purposes of gathering entropy for random number generator. In order to make it bus-bound a 'flush cache line' instruction is used between probes. In addition probes are added to vector elements in atomic or interlocked manner, which should contribute additional noise on multi-processor systems. This also means that vector[num] should be zeroed upon invocation (if you want to retrieve actual probe values).</p> <p>OPENSSL_instrument_bus performs num probes and records the number of oscillator cycles every probe took.</p> <p>OPENSSL_instrument_bus2 on the other hand accumulates consecutive probes with the same value, i.e. in a way it records duration of periods when probe values appeared deterministic. The subroutine performs at most max probes in attempt to fill the vector[num], with max value of 0 meaning \"as many as it takes.\"</p>"},{"location":"man3/OPENSSL_instrument_bus/#return-value","title":"RETURN VALUE","text":"<p>Return value of 0 indicates that CPU is not capable of performing the benchmark, either because oscillator counter or 'flush cache line' is not available on current platform. For reference, on x86 'flush cache line' was introduced with the SSE2 extensions.</p> <p>Otherwise number of recorded values is returned.</p>"},{"location":"man3/OPENSSL_load_builtin_modules/","title":"OPENSSL_load_builtin_modules","text":""},{"location":"man3/OPENSSL_load_builtin_modules/#name","title":"NAME","text":"<p>OPENSSL_load_builtin_modules, ASN1_add_oid_module, ENGINE_add_conf_module - add standard configuration modules</p>"},{"location":"man3/OPENSSL_load_builtin_modules/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/conf.h&gt;\n\nvoid OPENSSL_load_builtin_modules(void);\nvoid ASN1_add_oid_module(void);\nENGINE_add_conf_module();\n</code></pre>"},{"location":"man3/OPENSSL_load_builtin_modules/#description","title":"DESCRIPTION","text":"<p>The function OPENSSL_load_builtin_modules() adds all the standard OpenSSL configuration modules to the internal list. They can then be used by the OpenSSL configuration code.</p> <p>ASN1_add_oid_module() adds just the ASN1 OBJECT module.</p> <p>ENGINE_add_conf_module() adds just the ENGINE configuration module.</p>"},{"location":"man3/OPENSSL_load_builtin_modules/#notes","title":"NOTES","text":"<p>If the simple configuration function OPENSSL_config() is called then  OPENSSL_load_builtin_modules() is called automatically.</p> <p>Applications which use the configuration functions directly will need to call OPENSSL_load_builtin_modules() themselves before any other  configuration code.</p> <p>Applications should call OPENSSL_load_builtin_modules() to load all configuration modules instead of adding modules selectively: otherwise  functionality may be missing from the application if an when new modules are added.</p>"},{"location":"man3/OPENSSL_load_builtin_modules/#return-value","title":"RETURN VALUE","text":"<p>None of the functions return a value.</p>"},{"location":"man3/OPENSSL_load_builtin_modules/#see-also","title":"SEE ALSO","text":"<p>conf(3), OPENSSL_config(3)</p>"},{"location":"man3/OPENSSL_load_builtin_modules/#history","title":"HISTORY","text":"<p>These functions first appeared in OpenSSL 0.9.7.</p>"},{"location":"man3/OpenSSL_add_all_algorithms/","title":"OpenSSL_add_all_algorithms","text":""},{"location":"man3/OpenSSL_add_all_algorithms/#name","title":"NAME","text":"<p>OpenSSL_add_all_algorithms, OpenSSL_add_all_ciphers, OpenSSL_add_all_digests, EVP_cleanup - add algorithms to internal table</p>"},{"location":"man3/OpenSSL_add_all_algorithms/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nvoid OpenSSL_add_all_algorithms(void);\nvoid OpenSSL_add_all_ciphers(void);\nvoid OpenSSL_add_all_digests(void);\n\nvoid EVP_cleanup(void);\n</code></pre>"},{"location":"man3/OpenSSL_add_all_algorithms/#description","title":"DESCRIPTION","text":"<p>OpenSSL keeps an internal table of digest algorithms and ciphers. It uses this table to lookup ciphers via functions such as EVP_get_cipher_byname().</p> <p>OpenSSL_add_all_digests() adds all digest algorithms to the table.</p> <p>OpenSSL_add_all_algorithms() adds all algorithms to the table (digests and ciphers).</p> <p>OpenSSL_add_all_ciphers() adds all encryption algorithms to the table including password based encryption algorithms.</p> <p>EVP_cleanup() removes all ciphers and digests from the table.</p>"},{"location":"man3/OpenSSL_add_all_algorithms/#return-values","title":"RETURN VALUES","text":"<p>None of the functions return a value.</p>"},{"location":"man3/OpenSSL_add_all_algorithms/#notes","title":"NOTES","text":"<p>A typical application will call OpenSSL_add_all_algorithms() initially and EVP_cleanup() before exiting.</p> <p>An application does not need to add algorithms to use them explicitly, for example by EVP_sha1(). It just needs to add them if it (or any of the functions it calls) needs to lookup algorithms.</p> <p>The cipher and digest lookup functions are used in many parts of the library. If the table is not initialized several functions will misbehave and complain they cannot find algorithms. This includes the PEM, PKCS#12, SSL and S/MIME libraries. This is a common query in the OpenSSL mailing lists.</p> <p>Calling OpenSSL_add_all_algorithms() links in all algorithms: as a result a statically linked executable can be quite large. If this is important it is possible to just add the required ciphers and digests.</p>"},{"location":"man3/OpenSSL_add_all_algorithms/#bugs","title":"BUGS","text":"<p>Although the functions do not return error codes it is possible for them to fail. This will only happen as a result of a memory allocation failure so this is not too much of a problem in practice.</p>"},{"location":"man3/OpenSSL_add_all_algorithms/#see-also","title":"SEE ALSO","text":"<p>evp(3), EVP_DigestInit(3), EVP_EncryptInit(3)</p>"},{"location":"man3/PEM_write_bio_CMS_stream/","title":"PEM_write_bio_CMS_stream","text":""},{"location":"man3/PEM_write_bio_CMS_stream/#name","title":"NAME","text":"<pre><code>PEM_write_bio_CMS_stream - output CMS_ContentInfo structure in PEM format.\n</code></pre>"},{"location":"man3/PEM_write_bio_CMS_stream/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n#include &lt;openssl/pem.h&gt;\n\nint PEM_write_bio_CMS_stream(BIO *out, CMS_ContentInfo *cms, BIO *data, int flags);\n</code></pre>"},{"location":"man3/PEM_write_bio_CMS_stream/#description","title":"DESCRIPTION","text":"<p>PEM_write_bio_CMS_stream() outputs a CMS_ContentInfo structure in PEM format.</p> <p>It is otherwise identical to the function SMIME_write_CMS().</p>"},{"location":"man3/PEM_write_bio_CMS_stream/#notes","title":"NOTES","text":"<p>This function is effectively a version of the PEM_write_bio_CMS() supporting streaming.</p>"},{"location":"man3/PEM_write_bio_CMS_stream/#return-values","title":"RETURN VALUES","text":"<p>PEM_write_bio_CMS_stream() returns 1 for success or 0 for failure.</p>"},{"location":"man3/PEM_write_bio_CMS_stream/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_sign(3), CMS_verify(3), CMS_encrypt(3) CMS_decrypt(3), SMIME_write_CMS(3), i2d_CMS_bio_stream(3)</p>"},{"location":"man3/PEM_write_bio_CMS_stream/#history","title":"HISTORY","text":"<p>PEM_write_bio_CMS_stream() was added to OpenSSL 1.0.0</p>"},{"location":"man3/PEM_write_bio_PKCS7_stream/","title":"PEM_write_bio_PKCS7_stream","text":""},{"location":"man3/PEM_write_bio_PKCS7_stream/#name","title":"NAME","text":"<p>PEM_write_bio_PKCS7_stream - output PKCS7 structure in PEM format.</p>"},{"location":"man3/PEM_write_bio_PKCS7_stream/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/pkcs7.h&gt;\n#include &lt;openssl/pem.h&gt;\n\nint PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *data, int flags);\n</code></pre>"},{"location":"man3/PEM_write_bio_PKCS7_stream/#description","title":"DESCRIPTION","text":"<p>PEM_write_bio_PKCS7_stream() outputs a PKCS7 structure in PEM format.</p> <p>It is otherwise identical to the function SMIME_write_PKCS7().</p>"},{"location":"man3/PEM_write_bio_PKCS7_stream/#notes","title":"NOTES","text":"<p>This function is effectively a version of the PEM_write_bio_PKCS7() supporting streaming.</p>"},{"location":"man3/PEM_write_bio_PKCS7_stream/#return-values","title":"RETURN VALUES","text":"<p>PEM_write_bio_PKCS7_stream() returns 1 for success or 0 for failure.</p>"},{"location":"man3/PEM_write_bio_PKCS7_stream/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), PKCS7_sign(3), PKCS7_verify(3), PKCS7_encrypt(3) PKCS7_decrypt(3), SMIME_write_PKCS7(3), i2d_PKCS7_bio_stream(3)</p>"},{"location":"man3/PEM_write_bio_PKCS7_stream/#history","title":"HISTORY","text":"<p>PEM_write_bio_PKCS7_stream() was added to OpenSSL 1.0.0</p>"},{"location":"man3/PKCS12_create/","title":"PKCS12_create","text":""},{"location":"man3/PKCS12_create/#name","title":"NAME","text":"<p>PKCS12_create - create a PKCS#12 structure</p>"},{"location":"man3/PKCS12_create/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/pkcs12.h&gt;\n\nPKCS12 *PKCS12_create(char *pass, char *name, EVP_PKEY *pkey, X509 *cert, STACK_OF(X509) *ca,\n                               int nid_key, int nid_cert, int iter, int mac_iter, int keytype);\n</code></pre>"},{"location":"man3/PKCS12_create/#description","title":"DESCRIPTION","text":"<p>PKCS12_create() creates a PKCS#12 structure.</p> <p>pass is the passphrase to use. name is the friendlyName to use for the supplied certifictate and key. pkey is the private key to include in the structure and cert its corresponding certificates. ca, if not NULL is an optional set of certificates to also include in the structure.</p> <p>nid_key and nid_cert are the encryption algorithms that should be used for the key and certificate respectively. iter is the encryption algorithm iteration count to use and mac_iter is the MAC iteration count to use. keytype is the type of key.</p>"},{"location":"man3/PKCS12_create/#notes","title":"NOTES","text":"<p>The parameters nid_key, nid_cert, iter, mac_iter and keytype can all be set to zero and sensible defaults will be used.</p> <p>These defaults are: 40 bit RC2 encryption for certificates, triple DES encryption for private keys, a key iteration count of PKCS12_DEFAULT_ITER (currently 2048) and a MAC iteration count of 1.</p> <p>The default MAC iteration count is 1 in order to retain compatibility with old software which did not interpret MAC iteration counts. If such compatibility is not required then mac_iter should be set to PKCS12_DEFAULT_ITER.</p> <p>keytype adds a flag to the store private key. This is a non standard extension that is only currently interpreted by MSIE. If set to zero the flag is omitted, if set to KEY_SIG the key can be used for signing only, if set to KEY_EX it can be used for signing and encryption. This option was useful for old export grade software which could use signing only keys of arbitrary size but had restrictions on the permissible sizes of keys which could be used for encryption.</p>"},{"location":"man3/PKCS12_create/#new-functionality-in-openssl-098","title":"NEW FUNCTIONALITY IN OPENSSL 0.9.8","text":"<p>Some additional functionality was added to PKCS12_create() in OpenSSL 0.9.8. These extensions are detailed below.</p> <p>If a certificate contains an alias or keyid then this will be used for the corresponding friendlyName or localKeyID in the PKCS12 structure.</p> <p>Either pkey, cert or both can be NULL to indicate that no key or certficate is required. In previous versions both had to be present or a fatal error is returned.</p> <p>nid_key or nid_cert can be set to -1 indicating that no encryption should be used. </p> <p>mac_iter can be set to -1 and the MAC will then be omitted entirely.</p>"},{"location":"man3/PKCS12_create/#see-also","title":"SEE ALSO","text":"<p>d2i_PKCS12(3)</p>"},{"location":"man3/PKCS12_create/#history","title":"HISTORY","text":"<p>PKCS12_create was added in OpenSSL 0.9.3</p>"},{"location":"man3/PKCS12_parse/","title":"PKCS12_parse","text":""},{"location":"man3/PKCS12_parse/#name","title":"NAME","text":"<p>PKCS12_parse - parse a PKCS#12 structure</p>"},{"location":"man3/PKCS12_parse/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/pkcs12.h&gt;\n\nint PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert,\n                 STACK_OF(X509) **ca);\n</code></pre>"},{"location":"man3/PKCS12_parse/#description","title":"DESCRIPTION","text":"<p>PKCS12_parse() parses a PKCS12 structure.</p> <p>p12 is the PKCS12 structure to parse. pass is the passphrase to use. If successful the private key will be written to *pkey, the corresponding certificate to *cert and any additional certificates to *ca.</p>"},{"location":"man3/PKCS12_parse/#notes","title":"NOTES","text":"<p>The parameters pkey and cert cannot be NULL. ca can be &lt;NULL&gt; in which case additional certificates will be discarded. *ca can also be a valid STACK in which case additional certificates are appended to *ca. If *ca is NULL a new STACK will be allocated.</p> <p>The friendlyName and localKeyID attributes (if present) on each certificate will be stored in the alias and keyid attributes of the X509 structure.</p>"},{"location":"man3/PKCS12_parse/#return-values","title":"RETURN VALUES","text":"<p>PKCS12_parse() returns 1 for success and zero if an error occurred.</p> <p>The error can be obtained from ERR_get_error(3)</p>"},{"location":"man3/PKCS12_parse/#bugs","title":"BUGS","text":"<p>Only a single private key and corresponding certificate is returned by this function. More complex PKCS#12 files with multiple private keys will only return the first match.</p> <p>Only friendlyName and localKeyID attributes are currently stored in certificates. Other attributes are discarded.</p> <p>Attributes currently cannot be stored in the private key EVP_PKEY structure.</p>"},{"location":"man3/PKCS12_parse/#see-also","title":"SEE ALSO","text":"<p>d2i_PKCS12(3)</p>"},{"location":"man3/PKCS12_parse/#history","title":"HISTORY","text":"<p>PKCS12_parse was added in OpenSSL 0.9.3</p>"},{"location":"man3/PKCS7_decrypt/","title":"PKCS7_decrypt","text":""},{"location":"man3/PKCS7_decrypt/#name","title":"NAME","text":"<p>PKCS7_decrypt - decrypt content from a PKCS#7 envelopedData structure</p>"},{"location":"man3/PKCS7_decrypt/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/pkcs7.h&gt;\n\nint PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data, int flags);\n</code></pre>"},{"location":"man3/PKCS7_decrypt/#description","title":"DESCRIPTION","text":"<p>PKCS7_decrypt() extracts and decrypts the content from a PKCS#7 envelopedData structure. pkey is the private key of the recipient, cert is the recipients certificate, data is a BIO to write the content to and flags is an optional set of flags.</p>"},{"location":"man3/PKCS7_decrypt/#notes","title":"NOTES","text":"<p>OpenSSL_add_all_algorithms() (or equivalent) should be called before using this function or errors about unknown algorithms will occur.</p> <p>Although the recipients certificate is not needed to decrypt the data it is needed to locate the appropriate (of possible several) recipients in the PKCS#7 structure.</p> <p>The following flags can be passed in the flags parameter.</p> <p>If the PKCS7_TEXT flag is set MIME headers for type text/plain are deleted from the content. If the content is not of type text/plain then an error is returned.</p>"},{"location":"man3/PKCS7_decrypt/#return-values","title":"RETURN VALUES","text":"<p>PKCS7_decrypt() returns either 1 for success or 0 for failure. The error can be obtained from ERR_get_error(3)</p>"},{"location":"man3/PKCS7_decrypt/#bugs","title":"BUGS","text":"<p>PKCS7_decrypt() must be passed the correct recipient key and certificate. It would be better if it could look up the correct key and certificate from a database.</p> <p>The lack of single pass processing and need to hold all data in memory as mentioned in PKCS7_sign() also applies to PKCS7_verify().</p>"},{"location":"man3/PKCS7_decrypt/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), PKCS7_encrypt(3)</p>"},{"location":"man3/PKCS7_decrypt/#history","title":"HISTORY","text":"<p>PKCS7_decrypt() was added to OpenSSL 0.9.5</p>"},{"location":"man3/PKCS7_encrypt/","title":"PKCS7_encrypt","text":""},{"location":"man3/PKCS7_encrypt/#name","title":"NAME","text":"<p>PKCS7_encrypt - create a PKCS#7 envelopedData structure</p>"},{"location":"man3/PKCS7_encrypt/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/pkcs7.h&gt;\n\nPKCS7 *PKCS7_encrypt(STACK_OF(X509) *certs, BIO *in, const EVP_CIPHER *cipher, int flags);\n</code></pre>"},{"location":"man3/PKCS7_encrypt/#description","title":"DESCRIPTION","text":"<p>PKCS7_encrypt() creates and returns a PKCS#7 envelopedData structure. certs is a list of recipient certificates. in is the content to be encrypted. cipher is the symmetric cipher to use. flags is an optional set of flags.</p>"},{"location":"man3/PKCS7_encrypt/#notes","title":"NOTES","text":"<p>Only RSA keys are supported in PKCS#7 and envelopedData so the recipient certificates supplied to this function must all contain RSA public keys, though they do not have to be signed using the RSA algorithm.</p> <p>EVP_des_ede3_cbc() (triple DES) is the algorithm of choice for S/MIME use because most clients will support it.</p> <p>Some old \"export grade\" clients may only support weak encryption using 40 or 64 bit RC2. These can be used by passing EVP_rc2_40_cbc() and EVP_rc2_64_cbc() respectively.</p> <p>The algorithm passed in the cipher parameter must support ASN1 encoding of its parameters. </p> <p>Many browsers implement a \"sign and encrypt\" option which is simply an S/MIME envelopedData containing an S/MIME signed message. This can be readily produced by storing the S/MIME signed message in a memory BIO and passing it to PKCS7_encrypt().</p> <p>The following flags can be passed in the flags parameter.</p> <p>If the PKCS7_TEXT flag is set MIME headers for type text/plain are prepended to the data.</p> <p>Normally the supplied content is translated into MIME canonical format (as required by the S/MIME specifications) if PKCS7_BINARY is set no translation occurs. This option should be used if the supplied data is in binary format otherwise the translation will corrupt it. If PKCS7_BINARY is set then PKCS7_TEXT is ignored.</p> <p>If the PKCS7_STREAM flag is set a partial PKCS7 structure is output suitable for streaming I/O: no data is read from the BIO in.</p>"},{"location":"man3/PKCS7_encrypt/#notes_1","title":"NOTES","text":"<p>If the flag PKCS7_STREAM is set the returned PKCS7 structure is not complete and outputting its contents via a function that does not properly finalize the PKCS7 structure will give unpredictable  results.</p> <p>Several functions including SMIME_write_PKCS7(), i2d_PKCS7_bio_stream(), PEM_write_bio_PKCS7_stream() finalize the structure. Alternatively finalization can be performed by obtaining the streaming ASN1 BIO directly using BIO_new_PKCS7().</p>"},{"location":"man3/PKCS7_encrypt/#return-values","title":"RETURN VALUES","text":"<p>PKCS7_encrypt() returns either a PKCS7 structure or NULL if an error occurred. The error can be obtained from ERR_get_error(3).</p>"},{"location":"man3/PKCS7_encrypt/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), PKCS7_decrypt(3)</p>"},{"location":"man3/PKCS7_encrypt/#history","title":"HISTORY","text":"<p>PKCS7_decrypt() was added to OpenSSL 0.9.5 The PKCS7_STREAM flag was first supported in OpenSSL 1.0.0.</p>"},{"location":"man3/PKCS7_sign/","title":"PKCS7_sign","text":""},{"location":"man3/PKCS7_sign/#name","title":"NAME","text":"<p>PKCS7_sign - create a PKCS#7 signedData structure</p>"},{"location":"man3/PKCS7_sign/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/pkcs7.h&gt;\n\nPKCS7 *PKCS7_sign(X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs, BIO *data, int flags);\n</code></pre>"},{"location":"man3/PKCS7_sign/#description","title":"DESCRIPTION","text":"<p>PKCS7_sign() creates and returns a PKCS#7 signedData structure. signcert is the certificate to sign with, pkey is the corresponsding private key. certs is an optional additional set of certificates to include in the PKCS#7 structure (for example any intermediate CAs in the chain). </p> <p>The data to be signed is read from BIO data.</p> <p>flags is an optional set of flags.</p>"},{"location":"man3/PKCS7_sign/#notes","title":"NOTES","text":"<p>Any of the following flags (ored together) can be passed in the flags parameter.</p> <p>Many S/MIME clients expect the signed content to include valid MIME headers. If the PKCS7_TEXT flag is set MIME headers for type text/plain are prepended to the data.</p> <p>If PKCS7_NOCERTS is set the signer's certificate will not be included in the PKCS7 structure, the signer's certificate must still be supplied in the signcert parameter though. This can reduce the size of the signature if the signers certificate can be obtained by other means: for example a previously signed message.</p> <p>The data being signed is included in the PKCS7 structure, unless PKCS7_DETACHED is set in which case it is omitted. This is used for PKCS7 detached signatures which are used in S/MIME plaintext signed messages for example.</p> <p>Normally the supplied content is translated into MIME canonical format (as required by the S/MIME specifications) if PKCS7_BINARY is set no translation occurs. This option should be used if the supplied data is in binary format otherwise the translation will corrupt it.</p> <p>The signedData structure includes several PKCS#7 autenticatedAttributes including the signing time, the PKCS#7 content type and the supported list of ciphers in an SMIMECapabilities attribute. If PKCS7_NOATTR is set then no authenticatedAttributes will be used. If PKCS7_NOSMIMECAP is set then just the SMIMECapabilities are omitted.</p> <p>If present the SMIMECapabilities attribute indicates support for the following algorithms: triple DES, 128 bit RC2, 64 bit RC2, DES and 40 bit RC2. If any of these algorithms is disabled then it will not be included.</p> <p>If the flags PKCS7_STREAM is set then the returned PKCS7 structure is just initialized ready to perform the signing operation. The signing is however not performed and the data to be signed is not read from the data parameter. Signing is deferred until after the data has been written. In this way data can be signed in a single pass.</p> <p>If the PKCS7_PARTIAL flag is set a partial PKCS7 structure is output to which additional signers and capabilities can be added before finalization.</p>"},{"location":"man3/PKCS7_sign/#notes_1","title":"NOTES","text":"<p>If the flag PKCS7_STREAM is set the returned PKCS7 structure is not complete and outputting its contents via a function that does not properly finalize the PKCS7 structure will give unpredictable results.</p> <p>Several functions including SMIME_write_PKCS7(), i2d_PKCS7_bio_stream(), PEM_write_bio_PKCS7_stream() finalize the structure. Alternatively finalization can be performed by obtaining the streaming ASN1 BIO directly using BIO_new_PKCS7().</p> <p>If a signer is specified it will use the default digest for the signing algorithm. This is SHA1 for both RSA and DSA keys.</p> <p>In OpenSSL 1.0.0 the certs, signcert and pkey parameters can all be NULL if the PKCS7_PARTIAL flag is set. One or more signers can be added using the function PKCS7_sign_add_signer(). PKCS7_final() must also be called to finalize the structure if streaming is not enabled. Alternative signing digests can also be specified using this method.</p> <p>In OpenSSL 1.0.0 if signcert and pkey are NULL then a certificates only PKCS#7 structure is output.</p> <p>In versions of OpenSSL before 1.0.0 the signcert and pkey parameters must NOT be NULL.</p>"},{"location":"man3/PKCS7_sign/#bugs","title":"BUGS","text":"<p>Some advanced attributes such as counter signatures are not supported.</p>"},{"location":"man3/PKCS7_sign/#return-values","title":"RETURN VALUES","text":"<p>PKCS7_sign() returns either a valid PKCS7 structure or NULL if an error occurred.  The error can be obtained from ERR_get_error(3).</p>"},{"location":"man3/PKCS7_sign/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), PKCS7_verify(3)</p>"},{"location":"man3/PKCS7_sign/#history","title":"HISTORY","text":"<p>PKCS7_sign() was added to OpenSSL 0.9.5</p> <p>The PKCS7_PARTIAL flag was added in OpenSSL 1.0.0</p> <p>The PKCS7_STREAM flag was added in OpenSSL 1.0.0</p>"},{"location":"man3/PKCS7_sign_add_signer/","title":"PKCS7_sign_add_signer","text":""},{"location":"man3/PKCS7_sign_add_signer/#name","title":"NAME","text":"<p>PKCS7_sign_add_signer - add a signer PKCS7 signed data structure.</p>"},{"location":"man3/PKCS7_sign_add_signer/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/pkcs7.h&gt;\n\nPKCS7_SIGNER_INFO *PKCS7_sign_add_signer(PKCS7 *p7, X509 *signcert, EVP_PKEY *pkey, const EVP_MD *md, int flags);\n</code></pre>"},{"location":"man3/PKCS7_sign_add_signer/#description","title":"DESCRIPTION","text":"<p>PKCS7_sign_add_signer() adds a signer with certificate signcert and private key pkey using message digest md to a PKCS7 signed data structure p7.</p> <p>The PKCS7 structure should be obtained from an initial call to PKCS7_sign() with the flag PKCS7_PARTIAL set or in the case or re-signing a valid PKCS7 signed data structure.</p> <p>If the md parameter is NULL then the default digest for the public key algorithm will be used.</p> <p>Unless the PKCS7_REUSE_DIGEST flag is set the returned PKCS7 structure is not complete and must be finalized either by streaming (if applicable) or a call to PKCS7_final().</p>"},{"location":"man3/PKCS7_sign_add_signer/#notes","title":"NOTES","text":"<p>The main purpose of this function is to provide finer control over a PKCS#7 signed data structure where the simpler PKCS7_sign() function defaults are not appropriate. For example if multiple signers or non default digest algorithms are needed.</p> <p>Any of the following flags (ored together) can be passed in the flags parameter.</p> <p>If PKCS7_REUSE_DIGEST is set then an attempt is made to copy the content digest value from the PKCS7 struture: to add a signer to an existing structure. An error occurs if a matching digest value cannot be found to copy. The returned PKCS7 structure will be valid and finalized when this flag is set.</p> <p>If PKCS7_PARTIAL is set in addition to PKCS7_REUSE_DIGEST then the  PKCS7_SIGNER_INO structure will not be finalized so additional attributes can be added. In this case an explicit call to PKCS7_SIGNER_INFO_sign() is needed to finalize it.</p> <p>If PKCS7_NOCERTS is set the signer's certificate will not be included in the PKCS7 structure, the signer's certificate must still be supplied in the signcert parameter though. This can reduce the size of the signature if the signers certificate can be obtained by other means: for example a previously signed message.</p> <p>The signedData structure includes several PKCS#7 autenticatedAttributes including the signing time, the PKCS#7 content type and the supported list of ciphers in an SMIMECapabilities attribute. If PKCS7_NOATTR is set then no authenticatedAttributes will be used. If PKCS7_NOSMIMECAP is set then just the SMIMECapabilities are omitted.</p> <p>If present the SMIMECapabilities attribute indicates support for the following algorithms: triple DES, 128 bit RC2, 64 bit RC2, DES and 40 bit RC2. If any of these algorithms is disabled then it will not be included.</p> <p>PKCS7_sign_add_signers() returns an internal pointer to the PKCS7_SIGNER_INFO structure just added, this can be used to set additional attributes  before it is finalized.</p>"},{"location":"man3/PKCS7_sign_add_signer/#return-values","title":"RETURN VALUES","text":"<p>PKCS7_sign_add_signers() returns an internal pointer to the PKCS7_SIGNER_INFO structure just added or NULL if an error occurs.</p>"},{"location":"man3/PKCS7_sign_add_signer/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), PKCS7_sign(3), PKCS7_final(3),</p>"},{"location":"man3/PKCS7_sign_add_signer/#history","title":"HISTORY","text":"<p>PPKCS7_sign_add_signer() was added to OpenSSL 1.0.0</p>"},{"location":"man3/PKCS7_verify/","title":"PKCS7_verify","text":""},{"location":"man3/PKCS7_verify/#name","title":"NAME","text":"<p>PKCS7_verify, PKCS7_get0_signers - verify a PKCS#7 signedData structure</p>"},{"location":"man3/PKCS7_verify/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/pkcs7.h&gt;\n\nint PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store, BIO *indata, BIO *out, int flags);\n\nSTACK_OF(X509) *PKCS7_get0_signers(PKCS7 *p7, STACK_OF(X509) *certs, int flags);\n</code></pre>"},{"location":"man3/PKCS7_verify/#description","title":"DESCRIPTION","text":"<p>PKCS7_verify() verifies a PKCS#7 signedData structure. p7 is the PKCS7 structure to verify. certs is a set of certificates in which to search for the signer's certificate. store is a trusted certficate store (used for chain verification). indata is the signed data if the content is not present in p7 (that is it is detached). The content is written to out if it is not NULL.</p> <p>flags is an optional set of flags, which can be used to modify the verify operation.</p> <p>PKCS7_get0_signers() retrieves the signer's certificates from p7, it does not check their validity or whether any signatures are valid. The certs and flags parameters have the same meanings as in PKCS7_verify().</p>"},{"location":"man3/PKCS7_verify/#verify-process","title":"VERIFY PROCESS","text":"<p>Normally the verify process proceeds as follows.</p> <p>Initially some sanity checks are performed on p7. The type of p7 must be signedData. There must be at least one signature on the data and if the content is detached indata cannot be NULL.</p> <p>An attempt is made to locate all the signer's certificates, first looking in the certs parameter (if it is not NULL) and then looking in any certificates contained in the p7 structure itself. If any signer's certificates cannot be located the operation fails.</p> <p>Each signer's certificate is chain verified using the smimesign purpose and the supplied trusted certificate store. Any internal certificates in the message are used as untrusted CAs. If any chain verify fails an error code is returned.</p> <p>Finally the signed content is read (and written to out is it is not NULL) and the signature's checked.</p> <p>If all signature's verify correctly then the function is successful.</p> <p>Any of the following flags (ored together) can be passed in the flags parameter to change the default verify behaviour. Only the flag PKCS7_NOINTERN is meaningful to PKCS7_get0_signers().</p> <p>If PKCS7_NOINTERN is set the certificates in the message itself are not  searched when locating the signer's certificate. This means that all the signers certificates must be in the certs parameter.</p> <p>If the PKCS7_TEXT flag is set MIME headers for type text/plain are deleted from the content. If the content is not of type text/plain then an error is returned.</p> <p>If PKCS7_NOVERIFY is set the signer's certificates are not chain verified.</p> <p>If PKCS7_NOCHAIN is set then the certificates contained in the message are not used as untrusted CAs. This means that the whole verify chain (apart from the signer's certificate) must be contained in the trusted store.</p> <p>If PKCS7_NOSIGS is set then the signatures on the data are not checked.</p>"},{"location":"man3/PKCS7_verify/#notes","title":"NOTES","text":"<p>One application of PKCS7_NOINTERN is to only accept messages signed by a small number of certificates. The acceptable certificates would be passed in the certs parameter. In this case if the signer is not one of the certificates supplied in certs then the verify will fail because the signer cannot be found.</p> <p>Care should be taken when modifying the default verify behaviour, for example setting PKCS7_NOVERIFY|PKCS7_NOSIGS will totally disable all verification  and any signed message will be considered valid. This combination is however useful if one merely wishes to write the content to out and its validity is not considered important.</p> <p>Chain verification should arguably be performed  using the signing time rather than the current time. However since the signing time is supplied by the signer it cannot be trusted without additional evidence (such as a trusted timestamp).</p>"},{"location":"man3/PKCS7_verify/#return-values","title":"RETURN VALUES","text":"<p>PKCS7_verify() returns one for a successful verification and zero if an error occurs.</p> <p>PKCS7_get0_signers() returns all signers or NULL if an error occurred.</p> <p>The error can be obtained from ERR_get_error(3)</p>"},{"location":"man3/PKCS7_verify/#bugs","title":"BUGS","text":"<p>The trusted certificate store is not searched for the signers certificate, this is primarily due to the inadequacies of the current X509_STORE functionality.</p> <p>The lack of single pass processing and need to hold all data in memory as mentioned in PKCS7_sign() also applies to PKCS7_verify().</p>"},{"location":"man3/PKCS7_verify/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), PKCS7_sign(3)</p>"},{"location":"man3/PKCS7_verify/#history","title":"HISTORY","text":"<p>PKCS7_verify() was added to OpenSSL 0.9.5</p>"},{"location":"man3/RAND_add/","title":"RAND_add","text":""},{"location":"man3/RAND_add/#name","title":"NAME","text":"<p>RAND_add, RAND_seed, RAND_status, RAND_event, RAND_screen - add entropy to the PRNG</p>"},{"location":"man3/RAND_add/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rand.h&gt;\n\nvoid RAND_seed(const void *buf, int num);\n\nvoid RAND_add(const void *buf, int num, double entropy);\n\nint  RAND_status(void);\n\nint  RAND_event(UINT iMsg, WPARAM wParam, LPARAM lParam);\nvoid RAND_screen(void);\n</code></pre>"},{"location":"man3/RAND_add/#description","title":"DESCRIPTION","text":"<p>RAND_add() mixes the num bytes at buf into the PRNG state. Thus, if the data at buf are unpredictable to an adversary, this increases the uncertainty about the state and makes the PRNG output less predictable. Suitable input comes from user interaction (random key presses, mouse movements) and certain hardware events. The entropy argument is (the lower bound of) an estimate of how much randomness is contained in buf, measured in bytes. Details about sources of randomness and how to estimate their entropy can be found in the literature, e.g. RFC 1750.</p> <p>RAND_add() may be called with sensitive data such as user entered passwords. The seed values cannot be recovered from the PRNG output.</p> <p>OpenSSL makes sure that the PRNG state is unique for each thread. On systems that provide <code>/dev/urandom</code>, the randomness device is used to seed the PRNG transparently. However, on all other systems, the application is responsible for seeding the PRNG by calling RAND_add(), RAND_egd(3) or RAND_load_file(3).</p> <p>RAND_seed() is equivalent to RAND_add() when num == entropy.</p> <p>RAND_event() collects the entropy from Windows events such as mouse movements and other user interaction. It should be called with the iMsg, wParam and lParam arguments of all messages sent to the window procedure. It will estimate the entropy contained in the event message (if any), and add it to the PRNG. The program can then process the messages as usual.</p> <p>The RAND_screen() function is available for the convenience of Windows programmers. It adds the current contents of the screen to the PRNG. For applications that can catch Windows events, seeding the PRNG by calling RAND_event() is a significantly better source of randomness. It should be noted that both methods cannot be used on servers that run without user interaction.</p>"},{"location":"man3/RAND_add/#return-values","title":"RETURN VALUES","text":"<p>RAND_status() and RAND_event() return 1 if the PRNG has been seeded with enough data, 0 otherwise.</p> <p>The other functions do not return values.</p>"},{"location":"man3/RAND_add/#see-also","title":"SEE ALSO","text":"<p>rand(3), RAND_egd(3), RAND_load_file(3), RAND_cleanup(3)</p>"},{"location":"man3/RAND_add/#history","title":"HISTORY","text":"<p>RAND_seed() and RAND_screen() are available in all versions of SSLeay and OpenSSL. RAND_add() and RAND_status() have been added in OpenSSL 0.9.5, RAND_event() in OpenSSL 0.9.5a.</p>"},{"location":"man3/RAND_bytes/","title":"RAND_bytes","text":""},{"location":"man3/RAND_bytes/#name","title":"NAME","text":"<p>RAND_bytes, RAND_pseudo_bytes - generate random data</p>"},{"location":"man3/RAND_bytes/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rand.h&gt;\n\nint RAND_bytes(unsigned char *buf, int num);\n\nint RAND_pseudo_bytes(unsigned char *buf, int num);\n</code></pre>"},{"location":"man3/RAND_bytes/#description","title":"DESCRIPTION","text":"<p>RAND_bytes() puts num cryptographically strong pseudo-random bytes into buf. An error occurs if the PRNG has not been seeded with enough randomness to ensure an unpredictable byte sequence.</p> <p>RAND_pseudo_bytes() puts num pseudo-random bytes into buf. Pseudo-random byte sequences generated by RAND_pseudo_bytes() will be unique if they are of sufficient length, but are not necessarily unpredictable. They can be used for non-cryptographic purposes and for certain purposes in cryptographic protocols, but usually not for key generation etc.</p> <p>The contents of buf is mixed into the entropy pool before retrieving the new pseudo-random bytes unless disabled at compile time (see FAQ).</p>"},{"location":"man3/RAND_bytes/#return-values","title":"RETURN VALUES","text":"<p>RAND_bytes() returns 1 on success, 0 otherwise. The error code can be obtained by ERR_get_error(3). RAND_pseudo_bytes() returns 1 if the bytes generated are cryptographically strong, 0 otherwise. Both functions return -1 if they are not supported by the current RAND method.</p>"},{"location":"man3/RAND_bytes/#see-also","title":"SEE ALSO","text":"<p>rand(3), ERR_get_error(3), RAND_add(3)</p>"},{"location":"man3/RAND_bytes/#history","title":"HISTORY","text":"<p>RAND_bytes() is available in all versions of SSLeay and OpenSSL.  It has a return value since OpenSSL 0.9.5. RAND_pseudo_bytes() was added in OpenSSL 0.9.5.</p>"},{"location":"man3/RAND_cleanup/","title":"RAND_cleanup","text":""},{"location":"man3/RAND_cleanup/#name","title":"NAME","text":"<p>RAND_cleanup - erase the PRNG state</p>"},{"location":"man3/RAND_cleanup/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rand.h&gt;\n\nvoid RAND_cleanup(void);\n</code></pre>"},{"location":"man3/RAND_cleanup/#description","title":"DESCRIPTION","text":"<p>RAND_cleanup() erases the memory used by the PRNG.</p>"},{"location":"man3/RAND_cleanup/#return-value","title":"RETURN VALUE","text":"<p>RAND_cleanup() returns no value.</p>"},{"location":"man3/RAND_cleanup/#see-also","title":"SEE ALSO","text":"<p>rand(3)</p>"},{"location":"man3/RAND_cleanup/#history","title":"HISTORY","text":"<p>RAND_cleanup() is available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/RAND_egd/","title":"RAND_egd","text":""},{"location":"man3/RAND_egd/#name","title":"NAME","text":"<p>RAND_egd, RAND_egd_bytes, RAND_query_egd_bytes - query entropy gathering daemon</p>"},{"location":"man3/RAND_egd/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rand.h&gt;\n\nint RAND_egd(const char *path);\nint RAND_egd_bytes(const char *path, int bytes);\n\nint RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes);\n</code></pre>"},{"location":"man3/RAND_egd/#description","title":"DESCRIPTION","text":"<p>RAND_egd() queries the entropy gathering daemon EGD on socket path. It queries 255 bytes and uses RAND_add(3) to seed the OpenSSL built-in PRNG. RAND_egd(path) is a wrapper for RAND_egd_bytes(path, 255);</p> <p>RAND_egd_bytes() queries the entropy gathering daemon EGD on socket path. It queries bytes bytes and uses RAND_add(3) to seed the OpenSSL built-in PRNG. This function is more flexible than RAND_egd(). When only one secret key must be generated, it is not necessary to request the full amount 255 bytes from the EGD socket. This can be advantageous, since the amount of entropy that can be retrieved from EGD over time is limited.</p> <p>RAND_query_egd_bytes() performs the actual query of the EGD daemon on socket path. If buf is given, bytes bytes are queried and written into buf. If buf is NULL, bytes bytes are queried and used to seed the OpenSSL built-in PRNG using RAND_add(3).</p>"},{"location":"man3/RAND_egd/#notes","title":"NOTES","text":"<p>On systems without /dev/*random devices providing entropy from the kernel, the EGD entropy gathering daemon can be used to collect entropy. It provides a socket interface through which entropy can be gathered in chunks up to 255 bytes. Several chunks can be queried during one connection.</p> <p>EGD is available from http://www.lothar.com/tech/crypto/ (<code>perl Makefile.PL; make; make install</code> to install). It is run as egd path, where path is an absolute path designating a socket. When RAND_egd() is called with that path as an argument, it tries to read random bytes that EGD has collected. RAND_egd() retrieves entropy from the daemon using the daemon's \"non-blocking read\" command which shall be answered immediately by the daemon without waiting for additional entropy to be collected. The write and read socket operations in the communication are blocking.</p> <p>Alternatively, the EGD-interface compatible daemon PRNGD can be used. It is available from http://prngd.sourceforge.net/ . PRNGD does employ an internal PRNG itself and can therefore never run out of entropy.</p> <p>OpenSSL automatically queries EGD when entropy is requested via RAND_bytes() or the status is checked via RAND_status() for the first time, if the socket is located at /var/run/egd-pool, /dev/egd-pool or /etc/egd-pool.</p>"},{"location":"man3/RAND_egd/#return-value","title":"RETURN VALUE","text":"<p>RAND_egd() and RAND_egd_bytes() return the number of bytes read from the daemon on success, and -1 if the connection failed or the daemon did not return enough data to fully seed the PRNG.</p> <p>RAND_query_egd_bytes() returns the number of bytes read from the daemon on success, and -1 if the connection failed. The PRNG state is not considered.</p>"},{"location":"man3/RAND_egd/#see-also","title":"SEE ALSO","text":"<p>rand(3), RAND_add(3), RAND_cleanup(3)</p>"},{"location":"man3/RAND_egd/#history","title":"HISTORY","text":"<p>RAND_egd() is available since OpenSSL 0.9.5.</p> <p>RAND_egd_bytes() is available since OpenSSL 0.9.6.</p> <p>RAND_query_egd_bytes() is available since OpenSSL 0.9.7.</p> <p>The automatic query of /var/run/egd-pool et al was added in OpenSSL 0.9.7.</p>"},{"location":"man3/RAND_load_file/","title":"RAND_load_file","text":""},{"location":"man3/RAND_load_file/#name","title":"NAME","text":"<p>RAND_load_file, RAND_write_file, RAND_file_name - PRNG seed file</p>"},{"location":"man3/RAND_load_file/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rand.h&gt;\n\nconst char *RAND_file_name(char *buf, size_t num);\n\nint RAND_load_file(const char *filename, long max_bytes);\n\nint RAND_write_file(const char *filename);\n</code></pre>"},{"location":"man3/RAND_load_file/#description","title":"DESCRIPTION","text":"<p>RAND_file_name() generates a default path for the random seed file. buf points to a buffer of size num in which to store the filename. The seed file is $RANDFILE if that environment variable is set, $HOME/.rnd otherwise. If $HOME is not set either, or num is too small for the path name, an error occurs.</p> <p>RAND_load_file() reads a number of bytes from file filename and adds them to the PRNG. If max_bytes is non-negative, up to to max_bytes are read; starting with OpenSSL 0.9.5, if max_bytes is -1, the complete file is read.</p> <p>RAND_write_file() writes a number of random bytes (currently 1024) to file filename which can be used to initialize the PRNG by calling RAND_load_file() in a later session.</p>"},{"location":"man3/RAND_load_file/#return-values","title":"RETURN VALUES","text":"<p>RAND_load_file() returns the number of bytes read.</p> <p>RAND_write_file() returns the number of bytes written, and -1 if the bytes written were generated without appropriate seed.</p> <p>RAND_file_name() returns a pointer to buf on success, and NULL on error.</p>"},{"location":"man3/RAND_load_file/#see-also","title":"SEE ALSO","text":"<p>rand(3), RAND_add(3), RAND_cleanup(3)</p>"},{"location":"man3/RAND_load_file/#history","title":"HISTORY","text":"<p>RAND_load_file(), RAND_write_file() and RAND_file_name() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/RAND_set_rand_method/","title":"RAND_set_rand_method","text":""},{"location":"man3/RAND_set_rand_method/#name","title":"NAME","text":"<p>RAND_set_rand_method, RAND_get_rand_method, RAND_SSLeay - select RAND method</p>"},{"location":"man3/RAND_set_rand_method/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rand.h&gt;\n\nvoid RAND_set_rand_method(const RAND_METHOD *meth);\n\nconst RAND_METHOD *RAND_get_rand_method(void);\n\nRAND_METHOD *RAND_SSLeay(void);\n</code></pre>"},{"location":"man3/RAND_set_rand_method/#description","title":"DESCRIPTION","text":"<p>A RAND_METHOD specifies the functions that OpenSSL uses for random number generation. By modifying the method, alternative implementations such as hardware RNGs may be used. IMPORTANT: See the NOTES section for important information about how these RAND API functions are affected by the use of ENGINE API calls.</p> <p>Initially, the default RAND_METHOD is the OpenSSL internal implementation, as returned by RAND_SSLeay().</p> <p>RAND_set_default_method() makes meth the method for PRNG use. NB: This is true only whilst no ENGINE has been set as a default for RAND, so this function is no longer recommended.</p> <p>RAND_get_default_method() returns a pointer to the current RAND_METHOD. However, the meaningfulness of this result is dependent on whether the ENGINE API is being used, so this function is no longer recommended.</p>"},{"location":"man3/RAND_set_rand_method/#the-rand_method-structure","title":"THE RAND_METHOD STRUCTURE","text":"<pre><code>typedef struct rand_meth_st\n{\n       void (*seed)(const void *buf, int num);\n       int (*bytes)(unsigned char *buf, int num);\n       void (*cleanup)(void);\n       void (*add)(const void *buf, int num, int entropy);\n       int (*pseudorand)(unsigned char *buf, int num);\n       int (*status)(void);\n} RAND_METHOD;\n</code></pre> <p>The components point to the implementation of RAND_seed(), RAND_bytes(), RAND_cleanup(), RAND_add(), RAND_pseudo_rand() and RAND_status(). Each component may be NULL if the function is not implemented.</p>"},{"location":"man3/RAND_set_rand_method/#return-values","title":"RETURN VALUES","text":"<p>RAND_set_rand_method() returns no value. RAND_get_rand_method() and RAND_SSLeay() return pointers to the respective methods.</p>"},{"location":"man3/RAND_set_rand_method/#notes","title":"NOTES","text":"<p>As of version 0.9.7, RAND_METHOD implementations are grouped together with other algorithmic APIs (eg. RSA_METHOD, EVP_CIPHER, etc) in ENGINE modules. If a default ENGINE is specified for RAND functionality using an ENGINE API function, that will override any RAND defaults set using the RAND API (ie. RAND_set_rand_method()). For this reason, the ENGINE API is the recommended way to control default implementations for use in RAND and other cryptographic algorithms.</p>"},{"location":"man3/RAND_set_rand_method/#see-also","title":"SEE ALSO","text":"<p>rand(3), engine(3)</p>"},{"location":"man3/RAND_set_rand_method/#history","title":"HISTORY","text":"<p>RAND_set_rand_method(), RAND_get_rand_method() and RAND_SSLeay() are available in all versions of OpenSSL.</p> <p>In the engine version of version 0.9.6, RAND_set_rand_method() was altered to take an ENGINE pointer as its argument. As of version 0.9.7, that has been reverted as the ENGINE API transparently overrides RAND defaults if used, otherwise RAND API functions work as before. RAND_set_rand_engine() was also introduced in version 0.9.7.</p>"},{"location":"man3/RSA_blinding_on/","title":"RSA_blinding_on","text":""},{"location":"man3/RSA_blinding_on/#name","title":"NAME","text":"<p>RSA_blinding_on, RSA_blinding_off - protect the RSA operation from timing attacks</p>"},{"location":"man3/RSA_blinding_on/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nint RSA_blinding_on(RSA *rsa, BN_CTX *ctx);\n\nvoid RSA_blinding_off(RSA *rsa);\n</code></pre>"},{"location":"man3/RSA_blinding_on/#description","title":"DESCRIPTION","text":"<p>RSA is vulnerable to timing attacks. In a setup where attackers can measure the time of RSA decryption or signature operations, blinding must be used to protect the RSA operation from that attack.</p> <p>RSA_blinding_on() turns blinding on for key rsa and generates a random blinding factor. ctx is NULL or a pre-allocated and initialized BN_CTX. The random number generator must be seeded prior to calling RSA_blinding_on().</p> <p>RSA_blinding_off() turns blinding off and frees the memory used for the blinding factor.</p>"},{"location":"man3/RSA_blinding_on/#return-values","title":"RETURN VALUES","text":"<p>RSA_blinding_on() returns 1 on success, and 0 if an error occurred.</p> <p>RSA_blinding_off() returns no value.</p>"},{"location":"man3/RSA_blinding_on/#see-also","title":"SEE ALSO","text":"<p>rsa(3), rand(3)</p>"},{"location":"man3/RSA_blinding_on/#history","title":"HISTORY","text":"<p>RSA_blinding_on() and RSA_blinding_off() appeared in SSLeay 0.9.0.</p>"},{"location":"man3/RSA_check_key/","title":"RSA_check_key","text":""},{"location":"man3/RSA_check_key/#name","title":"NAME","text":"<p>RSA_check_key - validate private RSA keys</p>"},{"location":"man3/RSA_check_key/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nint RSA_check_key(RSA *rsa);\n</code></pre>"},{"location":"man3/RSA_check_key/#description","title":"DESCRIPTION","text":"<p>This function validates RSA keys. It checks that p and q are in fact prime, and that n = p*q.</p> <p>It also checks that d*e = 1 mod (p-1*q-1), and that dmp1, dmq1 and iqmp are set correctly or are NULL.</p> <p>As such, this function can not be used with any arbitrary RSA key object, even if it is otherwise fit for regular RSA operation. See NOTES for more information.</p>"},{"location":"man3/RSA_check_key/#return-value","title":"RETURN VALUE","text":"<p>RSA_check_key() returns 1 if rsa is a valid RSA key, and 0 otherwise. -1 is returned if an error occurs while checking the key.</p> <p>If the key is invalid or an error occurred, the reason code can be obtained using ERR_get_error(3).</p>"},{"location":"man3/RSA_check_key/#notes","title":"NOTES","text":"<p>This function does not work on RSA public keys that have only the modulus and public exponent elements populated. It performs integrity checks on all the RSA key material, so the RSA key structure must contain all the private key data too.</p> <p>Unlike most other RSA functions, this function does not work transparently with any underlying ENGINE implementation because it uses the key data in the RSA structure directly. An ENGINE implementation can override the way key data is stored and handled, and can even provide support for HSM keys - in which case the RSA structure may contain no key data at all! If the ENGINE in question is only being used for acceleration or analysis purposes, then in all likelihood the RSA key data is complete and untouched, but this can't be assumed in the general case.</p>"},{"location":"man3/RSA_check_key/#bugs","title":"BUGS","text":"<p>A method of verifying the RSA key using opaque RSA API functions might need to be considered. Right now RSA_check_key() simply uses the RSA structure elements directly, bypassing the RSA_METHOD table altogether (and completely violating encapsulation and object-orientation in the process). The best fix will probably be to introduce a \"check_key()\" handler to the RSA_METHOD function table so that alternative implementations can also provide their own verifiers.</p>"},{"location":"man3/RSA_check_key/#see-also","title":"SEE ALSO","text":"<p>rsa(3), ERR_get_error(3)</p>"},{"location":"man3/RSA_check_key/#history","title":"HISTORY","text":"<p>RSA_check_key() appeared in OpenSSL 0.9.4.</p>"},{"location":"man3/RSA_generate_key/","title":"RSA_generate_key","text":""},{"location":"man3/RSA_generate_key/#name","title":"NAME","text":"<p>RSA_generate_key_ex, RSA_generate_key - generate RSA key pair</p>"},{"location":"man3/RSA_generate_key/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nint RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);\n</code></pre> <p>Deprecated:</p> <pre><code>RSA *RSA_generate_key(int num, unsigned long e,\n   void (*callback)(int,int,void *), void *cb_arg);\n</code></pre>"},{"location":"man3/RSA_generate_key/#description","title":"DESCRIPTION","text":"<p>RSA_generate_key_ex() generates a key pair and stores it in the RSA structure provided in rsa. The pseudo-random number generator must be seeded prior to calling RSA_generate_key_ex().</p> <p>The modulus size will be of length bits, and the public exponent will be e. Key sizes with num &lt; 1024 should be considered insecure. The exponent is an odd number, typically 3, 17 or 65537.</p> <p>A callback function may be used to provide feedback about the progress of the key generation. If cb is not NULL, it will be called as follows using the BN_GENCB_call() function described on the BN_generate_prime(3) page.</p> <ul> <li>While a random prime number is generated, it is called as described in BN_generate_prime(3).</li> <li>When the n-th randomly generated prime is rejected as not suitable for the key, BN_GENCB_call(cb, 2, n) is called.</li> <li>When a random p has been found with p-1 relatively prime to e, it is called as BN_GENCB_call(cb, 3, 0).</li> </ul> <p>The process is then repeated for prime q with BN_GENCB_call(cb, 3, 1).</p> <p>RSA_generate_key is deprecated (new applications should use RSA_generate_key_ex instead). RSA_generate_key works in the same way as RSA_generate_key_ex except it uses \"old style\" call backs. See BN_generate_prime(3) for further details.</p>"},{"location":"man3/RSA_generate_key/#return-value","title":"RETURN VALUE","text":"<p>If key generation fails, RSA_generate_key() returns NULL.</p> <p>The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/RSA_generate_key/#bugs","title":"BUGS","text":"<p>BN_GENCB_call(cb, 2, x) is used with two different meanings.</p> <p>RSA_generate_key() goes into an infinite loop for illegal input values.</p>"},{"location":"man3/RSA_generate_key/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), rand(3), rsa(3), RSA_free(3), BN_generate_prime(3)</p>"},{"location":"man3/RSA_generate_key/#history","title":"HISTORY","text":"<p>The cb_arg argument was added in SSLeay 0.9.0.</p>"},{"location":"man3/RSA_get_ex_new_index/","title":"RSA_get_ex_new_index","text":""},{"location":"man3/RSA_get_ex_new_index/#name","title":"NAME","text":"<p>RSA_get_ex_new_index, RSA_set_ex_data, RSA_get_ex_data - add application specific data to RSA structures</p>"},{"location":"man3/RSA_get_ex_new_index/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nint RSA_get_ex_new_index(long argl, void *argp,\n               CRYPTO_EX_new *new_func,\n               CRYPTO_EX_dup *dup_func,\n               CRYPTO_EX_free *free_func);\n\nint RSA_set_ex_data(RSA *r, int idx, void *arg);\n\nvoid *RSA_get_ex_data(RSA *r, int idx);\n\ntypedef int CRYPTO_EX_new(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n                          int idx, long argl, void *argp);\ntypedef void CRYPTO_EX_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n                            int idx, long argl, void *argp);\ntypedef int CRYPTO_EX_dup(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d,\n                          int idx, long argl, void *argp);\n</code></pre>"},{"location":"man3/RSA_get_ex_new_index/#description","title":"DESCRIPTION","text":"<p>Several OpenSSL structures can have application specific data attached to them. This has several potential uses, it can be used to cache data associated with a structure (for example the hash of some part of the structure) or some additional data (for example a handle to the data in an external library).</p> <p>Since the application data can be anything at all it is passed and retrieved as a void * type.</p> <p>The RSA_get_ex_new_index() function is initially called to \"register\" some new application specific data. It takes three optional function pointers which are called when the parent structure (in this case an RSA structure) is initially created, when it is copied and when it is freed up. If any or all of these function pointer arguments are not used they should be set to NULL. The precise manner in which these function pointers are called is described in more detail below. RSA_get_ex_new_index() also takes additional long and pointer parameters which will be passed to the supplied functions but which otherwise have no special meaning. It returns an index which should be stored (typically in a static variable) and passed used in the idx parameter in the remaining functions. Each successful call to RSA_get_ex_new_index() will return an index greater than any previously returned, this is important because the optional functions are called in order of increasing index value.</p> <p>RSA_set_ex_data() is used to set application specific data, the data is supplied in the arg parameter and its precise meaning is up to the application.</p> <p>RSA_get_ex_data() is used to retrieve application specific data. The data is returned to the application, this will be the same value as supplied to a previous RSA_set_ex_data() call.</p> <p>new_func() is called when a structure is initially allocated (for example with RSA_new(). The parent structure members will not have any meaningful values at this point. This function will typically be used to allocate any application specific structure.</p> <p>free_func() is called when a structure is being freed up. The dynamic parent structure members should not be accessed because they will be freed up when this function is called.</p> <p>new_func() and free_func() take the same parameters. parent is a pointer to the parent RSA structure. ptr is a the application specific data (this wont be of much use in new_func(). ad is a pointer to the CRYPTO_EX_DATA structure from the parent RSA structure: the functions CRYPTO_get_ex_data() and CRYPTO_set_ex_data() can be called to manipulate it. The idx parameter is the index: this will be the same value returned by RSA_get_ex_new_index() when the functions were initially registered. Finally the argl and argp parameters are the values originally passed to the same corresponding parameters when RSA_get_ex_new_index() was called.</p> <p>dup_func() is called when a structure is being copied. Pointers to the destination and source CRYPTO_EX_DATA structures are passed in the to and from parameters respectively. The from_d parameter is passed a pointer to the source application data when the function is called, when the function returns the value is copied to the destination: the application can thus modify the data pointed to by from_d and have different values in the source and destination. The idx, argl and argp parameters are the same as those in new_func() and free_func().</p>"},{"location":"man3/RSA_get_ex_new_index/#return-values","title":"RETURN VALUES","text":"<p>RSA_get_ex_new_index() returns a new index or -1 on failure (note 0 is a valid index value).</p> <p>RSA_set_ex_data() returns 1 on success or 0 on failure.</p> <p>RSA_get_ex_data() returns the application data or 0 on failure. 0 may also be valid application data but currently it can only fail if given an invalid idx parameter.</p> <p>new_func() and dup_func() should return 0 for failure and 1 for success.</p> <p>On failure an error code can be obtained from ERR_get_error(3).</p>"},{"location":"man3/RSA_get_ex_new_index/#bugs","title":"BUGS","text":"<p>dup_func() is currently never called.</p> <p>The return value of new_func() is ignored.</p> <p>The new_func() function isn't very useful because no meaningful values are present in the parent RSA structure when it is called.</p>"},{"location":"man3/RSA_get_ex_new_index/#see-also","title":"SEE ALSO","text":"<p>rsa(3), CRYPTO_set_ex_data(3)</p>"},{"location":"man3/RSA_get_ex_new_index/#history","title":"HISTORY","text":"<p>RSA_get_ex_new_index(), RSA_set_ex_data() and RSA_get_ex_data() are available since SSLeay 0.9.0.</p>"},{"location":"man3/RSA_new/","title":"RSA_new","text":""},{"location":"man3/RSA_new/#name","title":"NAME","text":"<p>RSA_new, RSA_free - allocate and free RSA objects</p>"},{"location":"man3/RSA_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nRSA * RSA_new(void);\n\nvoid RSA_free(RSA *rsa);\n</code></pre>"},{"location":"man3/RSA_new/#description","title":"DESCRIPTION","text":"<p>RSA_new() allocates and initializes an RSA structure. It is equivalent to calling RSA_new_method(NULL).</p> <p>RSA_free() frees the RSA structure and its components. The key is erased before the memory is returned to the system.</p>"},{"location":"man3/RSA_new/#return-values","title":"RETURN VALUES","text":"<p>If the allocation fails, RSA_new() returns NULL and sets an error code that can be obtained by ERR_get_error(3). Otherwise it returns a pointer to the newly allocated structure.</p> <p>RSA_free() returns no value.</p>"},{"location":"man3/RSA_new/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), rsa(3), RSA_generate_key(3), RSA_new_method(3)</p>"},{"location":"man3/RSA_new/#history","title":"HISTORY","text":"<p>RSA_new() and RSA_free() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/RSA_padding_add_PKCS1_type_1/","title":"RSA_padding_add_PKCS1_type_1","text":""},{"location":"man3/RSA_padding_add_PKCS1_type_1/#name","title":"NAME","text":"<p>RSA_padding_add_PKCS1_type_1, RSA_padding_check_PKCS1_type_1, RSA_padding_add_PKCS1_type_2, RSA_padding_check_PKCS1_type_2, RSA_padding_add_PKCS1_OAEP, RSA_padding_check_PKCS1_OAEP, RSA_padding_add_SSLv23, RSA_padding_check_SSLv23, RSA_padding_add_none, RSA_padding_check_none - asymmetric encryption padding</p>"},{"location":"man3/RSA_padding_add_PKCS1_type_1/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nint RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,\n   unsigned char *f, int fl);\n\nint RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,\n   unsigned char *f, int fl, int rsa_len);\n\nint RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,\n   unsigned char *f, int fl);\n\nint RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,\n   unsigned char *f, int fl, int rsa_len);\n\nint RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,\n   unsigned char *f, int fl, unsigned char *p, int pl);\n\nint RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,\n   unsigned char *f, int fl, int rsa_len, unsigned char *p, int pl);\n\nint RSA_padding_add_SSLv23(unsigned char *to, int tlen,\n   unsigned char *f, int fl);\n\nint RSA_padding_check_SSLv23(unsigned char *to, int tlen,\n   unsigned char *f, int fl, int rsa_len);\n\nint RSA_padding_add_none(unsigned char *to, int tlen,\n   unsigned char *f, int fl);\n\nint RSA_padding_check_none(unsigned char *to, int tlen,\n   unsigned char *f, int fl, int rsa_len);\n</code></pre>"},{"location":"man3/RSA_padding_add_PKCS1_type_1/#description","title":"DESCRIPTION","text":"<p>The RSA_padding_xxx_xxx() functions are called from the RSA encrypt, decrypt, sign and verify functions. Normally they should not be called from application programs.</p> <p>However, they can also be called directly to implement padding for other asymmetric ciphers. RSA_padding_add_PKCS1_OAEP() and RSA_padding_check_PKCS1_OAEP() may be used in an application combined with RSA_NO_PADDING in order to implement OAEP with an encoding parameter.</p> <p>RSA_padding_add_xxx() encodes fl bytes from f so as to fit into tlen bytes and stores the result at to. An error occurs if fl does not meet the size requirements of the encoding method.</p> <p>The following encoding methods are implemented:</p> <ul> <li> <p>PKCS1_type_1</p> <p>PKCS #1 v2.0 EMSA-PKCS1-v1_5 (PKCS #1 v1.5 block type 1); used for signatures</p> </li> <li> <p>PKCS1_type_2</p> <p>PKCS #1 v2.0 EME-PKCS1-v1_5 (PKCS #1 v1.5 block type 2)</p> </li> <li> <p>PKCS1_OAEP</p> <p>PKCS #1 v2.0 EME-OAEP</p> </li> <li> <p>SSLv23</p> <p>PKCS #1 EME-PKCS1-v1_5 with SSL-specific modification</p> </li> <li> <p>none</p> <p>simply copy the data</p> </li> </ul> <p>The random number generator must be seeded prior to calling RSA_padding_add_xxx().</p> <p>RSA_padding_check_xxx() verifies that the fl bytes at f contain a valid encoding for a rsa_len byte RSA key in the respective encoding method and stores the recovered data of at most tlen bytes (for RSA_NO_PADDING: of size tlen) at to.</p> <p>For RSA_padding_xxx_OAEP(), p points to the encoding parameter of length pl. p may be NULL if pl is 0.</p>"},{"location":"man3/RSA_padding_add_PKCS1_type_1/#return-values","title":"RETURN VALUES","text":"<p>The RSA_padding_add_xxx() functions return 1 on success, 0 on error. The RSA_padding_check_xxx() functions return the length of the recovered data, -1 on error. Error codes can be obtained by calling ERR_get_error(3).</p>"},{"location":"man3/RSA_padding_add_PKCS1_type_1/#warning","title":"WARNING","text":"<p>The RSA_padding_check_PKCS1_type_2() padding check leaks timing information which can potentially be used to mount a Bleichenbacher padding oracle attack. This is an inherent weakness in the PKCS #1 v1.5 padding design. Prefer PKCS1_OAEP padding. Otherwise it can be recommended to pass zero-padded f, so that fl equals to rsa_len, and if fixed by protocol, tlen being set to the expected length. In such case leakage would be minimal, it would take attacker's ability to observe memory access pattern with byte granilarity as it occurs, post-factum timing analysis won't do.</p>"},{"location":"man3/RSA_padding_add_PKCS1_type_1/#see-also","title":"SEE ALSO","text":"<p>RSA_public_encrypt(3), RSA_private_decrypt(3), RSA_sign(3), RSA_verify(3)</p>"},{"location":"man3/RSA_padding_add_PKCS1_type_1/#history","title":"HISTORY","text":"<p>RSA_padding_add_PKCS1_type_1(), RSA_padding_check_PKCS1_type_1(), RSA_padding_add_PKCS1_type_2(), RSA_padding_check_PKCS1_type_2(), RSA_padding_add_SSLv23(), RSA_padding_check_SSLv23(), RSA_padding_add_none() and RSA_padding_check_none() appeared in SSLeay 0.9.0.</p> <p>RSA_padding_add_PKCS1_OAEP() and RSA_padding_check_PKCS1_OAEP() were added in OpenSSL 0.9.2b.</p>"},{"location":"man3/RSA_print/","title":"RSA_print","text":""},{"location":"man3/RSA_print/#name","title":"NAME","text":"<p>RSA_print, RSA_print_fp, DSAparams_print, DSAparams_print_fp, DSA_print, DSA_print_fp, DHparams_print, DHparams_print_fp - print cryptographic parameters</p>"},{"location":"man3/RSA_print/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nint RSA_print(BIO *bp, RSA *x, int offset);\nint RSA_print_fp(FILE *fp, RSA *x, int offset);\n\n#include &lt;openssl/dsa.h&gt;\n\nint DSAparams_print(BIO *bp, DSA *x);\nint DSAparams_print_fp(FILE *fp, DSA *x);\nint DSA_print(BIO *bp, DSA *x, int offset);\nint DSA_print_fp(FILE *fp, DSA *x, int offset);\n\n#include &lt;openssl/dh.h&gt;\n\nint DHparams_print(BIO *bp, DH *x);\nint DHparams_print_fp(FILE *fp, DH *x);\n</code></pre>"},{"location":"man3/RSA_print/#description","title":"DESCRIPTION","text":"<p>A human-readable hexadecimal output of the components of the RSA key, DSA parameters or key or DH parameters is printed to bp or fp.</p> <p>The output lines are indented by offset spaces.</p>"},{"location":"man3/RSA_print/#return-values","title":"RETURN VALUES","text":"<p>These functions return 1 on success, 0 on error.</p>"},{"location":"man3/RSA_print/#see-also","title":"SEE ALSO","text":"<p>dh(3), dsa(3), rsa(3), BN_bn2bin(3)</p>"},{"location":"man3/RSA_print/#history","title":"HISTORY","text":"<p>RSA_print(), RSA_print_fp(), DSA_print(), DSA_print_fp(), DH_print(), DH_print_fp() are available in all versions of SSLeay and OpenSSL. DSAparams_print() and DSAparams_print_fp() were added in SSLeay 0.8.</p>"},{"location":"man3/RSA_private_encrypt/","title":"RSA_private_encrypt","text":""},{"location":"man3/RSA_private_encrypt/#name","title":"NAME","text":"<p>RSA_private_encrypt, RSA_public_decrypt - low level signature operations</p>"},{"location":"man3/RSA_private_encrypt/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nint RSA_private_encrypt(int flen, const unsigned char *from,\n   unsigned char *to, RSA *rsa, int padding);\n\nint RSA_public_decrypt(int flen, const unsigned char *from,\n   unsigned char *to, RSA *rsa, int padding);\n</code></pre>"},{"location":"man3/RSA_private_encrypt/#description","title":"DESCRIPTION","text":"<p>These functions handle RSA signatures at a low level.</p> <p>RSA_private_encrypt() signs the flen bytes at from (usually a message digest with an algorithm identifier) using the private key rsa and stores the signature in to. to must point to RSA_size(rsa) bytes of memory.</p> <p>padding denotes one of the following modes:</p> <ul> <li> <p>RSA_PKCS1_PADDING</p> <p>PKCS #1 v1.5 padding. This function does not handle the algorithmIdentifier specified in PKCS #1. When generating or verifying PKCS #1 signatures, RSA_sign(3) and RSA_verify(3) should be used.</p> </li> <li> <p>RSA_NO_PADDING</p> <p>Raw RSA signature. This mode should only be used to implement cryptographically sound padding modes in the application code. Signing user data directly with RSA is insecure.</p> </li> </ul> <p>RSA_public_decrypt() recovers the message digest from the flen bytes long signature at from using the signer's public key rsa. to must point to a memory section large enough to hold the message digest (which is smaller than RSA_size(rsa) - 11). padding is the padding mode that was used to sign the data.</p>"},{"location":"man3/RSA_private_encrypt/#return-values","title":"RETURN VALUES","text":"<p>RSA_private_encrypt() returns the size of the signature (i.e., RSA_size(rsa)). RSA_public_decrypt() returns the size of the recovered message digest.</p> <p>On error, -1 is returned; the error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/RSA_private_encrypt/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), rsa(3), RSA_sign(3), RSA_verify(3)</p>"},{"location":"man3/RSA_private_encrypt/#history","title":"HISTORY","text":"<p>The padding argument was added in SSLeay 0.8. RSA_NO_PADDING is available since SSLeay 0.9.0.</p>"},{"location":"man3/RSA_public_encrypt/","title":"RSA_public_encrypt","text":""},{"location":"man3/RSA_public_encrypt/#name","title":"NAME","text":"<p>RSA_public_encrypt, RSA_private_decrypt - RSA public key cryptography</p>"},{"location":"man3/RSA_public_encrypt/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nint RSA_public_encrypt(int flen, const unsigned char *from,\n   unsigned char *to, RSA *rsa, int padding);\n\nint RSA_private_decrypt(int flen, const unsigned char *from,\n    unsigned char *to, RSA *rsa, int padding);\n</code></pre>"},{"location":"man3/RSA_public_encrypt/#description","title":"DESCRIPTION","text":"<p>RSA_public_encrypt() encrypts the flen bytes at from (usually a session key) using the public key rsa and stores the ciphertext in to. to must point to RSA_size(rsa) bytes of memory.</p> <p>padding denotes one of the following modes:</p> <ul> <li> <p>RSA_PKCS1_PADDING</p> <p>PKCS #1 v1.5 padding. This currently is the most widely used mode.</p> </li> <li> <p>RSA_PKCS1_OAEP_PADDING</p> <p>EME-OAEP as defined in PKCS #1 v2.0 with SHA-1, MGF1 and an empty encoding parameter. This mode is recommended for all new applications.</p> </li> <li> <p>RSA_SSLV23_PADDING</p> <p>PKCS #1 v1.5 padding with an SSL-specific modification that denotes that the server is SSL3 capable.</p> </li> <li> <p>RSA_NO_PADDING</p> <p>Raw RSA encryption. This mode should only be used to implement cryptographically sound padding modes in the application code. Encrypting user data directly with RSA is insecure.</p> </li> </ul> <p>flen must be less than RSA_size(rsa) - 11 for the PKCS #1 v1.5 based padding modes, less than RSA_size(rsa) - 41 for RSA_PKCS1_OAEP_PADDING and exactly RSA_size(rsa) for RSA_NO_PADDING. The random number generator must be seeded prior to calling RSA_public_encrypt().</p> <p>RSA_private_decrypt() decrypts the flen bytes at from using the private key rsa and stores the plaintext in to. to must point to a memory section large enough to hold the decrypted data (which is smaller than RSA_size(rsa)). padding is the padding mode that was used to encrypt the data.</p>"},{"location":"man3/RSA_public_encrypt/#return-values","title":"RETURN VALUES","text":"<p>RSA_public_encrypt() returns the size of the encrypted data (i.e., RSA_size(rsa)). RSA_private_decrypt() returns the size of the recovered plaintext.</p> <p>On error, -1 is returned; the error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/RSA_public_encrypt/#warning","title":"WARNING","text":"<p>Decryption failures in the RSA_PKCS1_PADDING mode leak information which can potentially be used to mount a Bleichenbacher padding oracle attack. This is an inherent weakness in the PKCS #1 v1.5 padding design. Prefer RSA_PKCS1_OAEP_PADDING.</p>"},{"location":"man3/RSA_public_encrypt/#conforming-to","title":"CONFORMING TO","text":"<p>SSL, PKCS #1 v2.0</p>"},{"location":"man3/RSA_public_encrypt/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), rand(3), rsa(3), RSA_size(3)</p>"},{"location":"man3/RSA_public_encrypt/#history","title":"HISTORY","text":"<p>The padding argument was added in SSLeay 0.8. RSA_NO_PADDING is available since SSLeay 0.9.0, OAEP was added in OpenSSL 0.9.2b.</p>"},{"location":"man3/RSA_set_method/","title":"RSA_set_method","text":""},{"location":"man3/RSA_set_method/#name","title":"NAME","text":"<p>RSA_set_default_method, RSA_get_default_method, RSA_set_method, RSA_get_method, RSA_PKCS1_SSLeay, RSA_null_method, RSA_flags, RSA_new_method - select RSA method</p>"},{"location":"man3/RSA_set_method/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nvoid RSA_set_default_method(const RSA_METHOD *meth);\n\nRSA_METHOD *RSA_get_default_method(void);\n\nint RSA_set_method(RSA *rsa, const RSA_METHOD *meth);\n\nRSA_METHOD *RSA_get_method(const RSA *rsa);\n\nRSA_METHOD *RSA_PKCS1_SSLeay(void);\n\nRSA_METHOD *RSA_null_method(void);\n\nint RSA_flags(const RSA *rsa);\n\nRSA *RSA_new_method(RSA_METHOD *method);\n</code></pre>"},{"location":"man3/RSA_set_method/#description","title":"DESCRIPTION","text":"<p>An RSA_METHOD specifies the functions that OpenSSL uses for RSA operations. By modifying the method, alternative implementations such as hardware accelerators may be used. IMPORTANT: See the NOTES section for important information about how these RSA API functions are affected by the use of ENGINE API calls.</p> <p>Initially, the default RSA_METHOD is the OpenSSL internal implementation, as returned by RSA_PKCS1_SSLeay().</p> <p>RSA_set_default_method() makes meth the default method for all RSA structures created later. NB: This is true only whilst no ENGINE has been set as a default for RSA, so this function is no longer recommended.</p> <p>RSA_get_default_method() returns a pointer to the current default RSA_METHOD. However, the meaningfulness of this result is dependent on whether the ENGINE API is being used, so this function is no longer  recommended.</p> <p>RSA_set_method() selects meth to perform all operations using the key rsa. This will replace the RSA_METHOD used by the RSA key and if the previous method was supplied by an ENGINE, the handle to that ENGINE will be released during the change. It is possible to have RSA keys that only work with certain RSA_METHOD implementations (eg. from an ENGINE module that supports embedded hardware-protected keys), and in such cases attempting to change the RSA_METHOD for the key can have unexpected results.</p> <p>RSA_get_method() returns a pointer to the RSA_METHOD being used by rsa. This method may or may not be supplied by an ENGINE implementation, but if it is, the return value can only be guaranteed to be valid as long as the RSA key itself is valid and does not have its implementation changed by RSA_set_method().</p> <p>RSA_flags() returns the flags that are set for rsa's current RSA_METHOD. See the BUGS section.</p> <p>RSA_new_method() allocates and initializes an RSA structure so that engine will be used for the RSA operations. If engine is NULL, the default ENGINE for RSA operations is used, and if no default ENGINE is set, the RSA_METHOD controlled by RSA_set_default_method() is used.</p> <p>RSA_flags() returns the flags that are set for rsa's current method.</p> <p>RSA_new_method() allocates and initializes an RSA structure so that method will be used for the RSA operations. If method is NULL, the default method is used.</p>"},{"location":"man3/RSA_set_method/#the-rsa_method-structure","title":"THE RSA_METHOD STRUCTURE","text":"<pre><code>typedef struct rsa_meth_st\n{\n    /* name of the implementation */\n       const char *name;\n\n    /* encrypt */\n       int (*rsa_pub_enc)(int flen, unsigned char *from,\n         unsigned char *to, RSA *rsa, int padding);\n\n    /* verify arbitrary data */\n       int (*rsa_pub_dec)(int flen, unsigned char *from,\n         unsigned char *to, RSA *rsa, int padding);\n\n    /* sign arbitrary data */\n       int (*rsa_priv_enc)(int flen, unsigned char *from,\n         unsigned char *to, RSA *rsa, int padding);\n\n    /* decrypt */\n       int (*rsa_priv_dec)(int flen, unsigned char *from,\n         unsigned char *to, RSA *rsa, int padding);\n\n    /* compute r0 = r0 ^ I mod rsa-&gt;n (May be NULL for some\n                                       implementations) */\n       int (*rsa_mod_exp)(BIGNUM *r0, BIGNUM *I, RSA *rsa);\n\n    /* compute r = a ^ p mod m (May be NULL for some implementations) */\n       int (*bn_mod_exp)(BIGNUM *r, BIGNUM *a, const BIGNUM *p,\n         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);\n\n    /* called at RSA_new */\n       int (*init)(RSA *rsa);\n\n    /* called at RSA_free */\n       int (*finish)(RSA *rsa);\n\n    /* RSA_FLAG_EXT_PKEY        - rsa_mod_exp is called for private key\n     *                            operations, even if p,q,dmp1,dmq1,iqmp\n     *                            are NULL\n     * RSA_FLAG_SIGN_VER        - enable rsa_sign and rsa_verify\n     * RSA_METHOD_FLAG_NO_CHECK - don't check pub/private match\n     */\n       int flags;\n\n       char *app_data; /* ?? */\n\n    /* sign. For backward compatibility, this is used only\n     * if (flags &amp; RSA_FLAG_SIGN_VER)\n     */\n       int (*rsa_sign)(int type,\n               const unsigned char *m, unsigned int m_length,\n               unsigned char *sigret, unsigned int *siglen, const RSA *rsa);\n    /* verify. For backward compatibility, this is used only\n     * if (flags &amp; RSA_FLAG_SIGN_VER)\n     */\n       int (*rsa_verify)(int dtype,\n               const unsigned char *m, unsigned int m_length,\n               const unsigned char *sigbuf, unsigned int siglen,\n                                                               const RSA *rsa);\n    /* keygen. If NULL builtin RSA key generation will be used */\n       int (*rsa_keygen)(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);\n\n} RSA_METHOD;\n</code></pre>"},{"location":"man3/RSA_set_method/#return-values","title":"RETURN VALUES","text":"<p>RSA_PKCS1_SSLeay(), RSA_PKCS1_null_method(), RSA_get_default_method() and RSA_get_method() return pointers to the respective RSA_METHODs.</p> <p>RSA_set_default_method() returns no value.</p> <p>RSA_set_method() returns a pointer to the old RSA_METHOD implementation that was replaced. However, this return value should probably be ignored because if it was supplied by an ENGINE, the pointer could be invalidated at any time if the ENGINE is unloaded (in fact it could be unloaded as a result of the RSA_set_method() function releasing its handle to the ENGINE). For this reason, the return type may be replaced with a void declaration in a future release.</p> <p>RSA_new_method() returns NULL and sets an error code that can be obtained by ERR_get_error(3) if the allocation fails. Otherwise it returns a pointer to the newly allocated structure.</p>"},{"location":"man3/RSA_set_method/#notes","title":"NOTES","text":"<p>As of version 0.9.7, RSA_METHOD implementations are grouped together with other algorithmic APIs (eg. DSA_METHOD, EVP_CIPHER, etc) into ENGINE modules. If a default ENGINE is specified for RSA functionality using an ENGINE API function, that will override any RSA defaults set using the RSA API (ie.  RSA_set_default_method()). For this reason, the ENGINE API is the recommended way to control default implementations for use in RSA and other cryptographic algorithms.</p>"},{"location":"man3/RSA_set_method/#bugs","title":"BUGS","text":"<p>The behaviour of RSA_flags() is a mis-feature that is left as-is for now to avoid creating compatibility problems. RSA functionality, such as the encryption functions, are controlled by the flags value in the RSA key itself, not by the flags value in the RSA_METHOD attached to the RSA key (which is what this function returns). If the flags element of an RSA key is changed, the changes will be honoured by RSA functionality but will not be reflected in the return value of the RSA_flags() function - in effect RSA_flags() behaves more like an RSA_default_flags() function (which does not currently exist).</p>"},{"location":"man3/RSA_set_method/#see-also","title":"SEE ALSO","text":"<p>rsa(3), RSA_new(3)</p>"},{"location":"man3/RSA_set_method/#history","title":"HISTORY","text":"<p>RSA_new_method() and RSA_set_default_method() appeared in SSLeay 0.8. RSA_get_default_method(), RSA_set_method() and RSA_get_method() as well as the rsa_sign and rsa_verify components of RSA_METHOD were added in OpenSSL 0.9.4.</p> <p>RSA_set_default_openssl_method() and RSA_get_default_openssl_method() replaced RSA_set_default_method() and RSA_get_default_method() respectively, and RSA_set_method() and RSA_new_method() were altered to use ENGINEs rather than RSA_METHODs during development of the engine version of OpenSSL 0.9.6. For 0.9.7, the handling of defaults in the ENGINE API was restructured so that this change was reversed, and behaviour of the other functions resembled more closely the previous behaviour. The behaviour of defaults in the ENGINE API now transparently overrides the behaviour of defaults in the RSA API without requiring changing these function prototypes.</p>"},{"location":"man3/RSA_sign/","title":"RSA_sign","text":""},{"location":"man3/RSA_sign/#name","title":"NAME","text":"<p>RSA_sign, RSA_verify - RSA signatures</p>"},{"location":"man3/RSA_sign/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nint RSA_sign(int type, const unsigned char *m, unsigned int m_len,\n   unsigned char *sigret, unsigned int *siglen, RSA *rsa);\n\nint RSA_verify(int type, const unsigned char *m, unsigned int m_len,\n   unsigned char *sigbuf, unsigned int siglen, RSA *rsa);\n</code></pre>"},{"location":"man3/RSA_sign/#description","title":"DESCRIPTION","text":"<p>RSA_sign() signs the message digest m of size m_len using the private key rsa as specified in PKCS #1 v2.0. It stores the signature in sigret and the signature size in siglen. sigret must point to RSA_size(rsa) bytes of memory. Note that PKCS #1 adds meta-data, placing limits on the size of the key that can be used. See RSA_private_encrypt(3) for lower-level operations.</p> <p>type denotes the message digest algorithm that was used to generate m. It usually is one of NID_sha1, NID_ripemd160 and NID_md5; see objects(3) for details. If type is NID_md5_sha1, an SSL signature (MD5 and SHA1 message digests with PKCS #1 padding and no algorithm identifier) is created.</p> <p>RSA_verify() verifies that the signature sigbuf of size siglen matches a given message digest m of size m_len. type denotes the message digest algorithm that was used to generate the signature. rsa is the signer's public key.</p>"},{"location":"man3/RSA_sign/#return-values","title":"RETURN VALUES","text":"<p>RSA_sign() returns 1 on success, 0 otherwise.  RSA_verify() returns 1 on successful verification, 0 otherwise.</p> <p>The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/RSA_sign/#bugs","title":"BUGS","text":"<p>Certain signatures with an improper algorithm identifier are accepted for compatibility with SSLeay 0.4.5 :-)</p>"},{"location":"man3/RSA_sign/#conforming-to","title":"CONFORMING TO","text":"<p>SSL, PKCS #1 v2.0</p>"},{"location":"man3/RSA_sign/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), objects(3), rsa(3), RSA_private_encrypt(3), RSA_public_decrypt(3) </p>"},{"location":"man3/RSA_sign/#history","title":"HISTORY","text":"<p>RSA_sign() and RSA_verify() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/RSA_sign_ASN1_OCTET_STRING/","title":"RSA_sign_ASN1_OCTET_STRING","text":""},{"location":"man3/RSA_sign_ASN1_OCTET_STRING/#name","title":"NAME","text":"<p>RSA_sign_ASN1_OCTET_STRING, RSA_verify_ASN1_OCTET_STRING - RSA signatures</p>"},{"location":"man3/RSA_sign_ASN1_OCTET_STRING/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nint RSA_sign_ASN1_OCTET_STRING(int dummy, unsigned char *m,\n   unsigned int m_len, unsigned char *sigret, unsigned int *siglen,\n   RSA *rsa);\n\nint RSA_verify_ASN1_OCTET_STRING(int dummy, unsigned char *m,\n   unsigned int m_len, unsigned char *sigbuf, unsigned int siglen,\n   RSA *rsa);\n</code></pre>"},{"location":"man3/RSA_sign_ASN1_OCTET_STRING/#description","title":"DESCRIPTION","text":"<p>RSA_sign_ASN1_OCTET_STRING() signs the octet string m of size m_len using the private key rsa represented in DER using PKCS #1 padding. It stores the signature in sigret and the signature size in siglen. sigret must point to RSA_size(rsa) bytes of memory.</p> <p>dummy is ignored.</p> <p>The random number generator must be seeded prior to calling RSA_sign_ASN1_OCTET_STRING().</p> <p>RSA_verify_ASN1_OCTET_STRING() verifies that the signature sigbuf of size siglen is the DER representation of a given octet string m of size m_len. dummy is ignored. rsa is the signer's public key.</p>"},{"location":"man3/RSA_sign_ASN1_OCTET_STRING/#return-values","title":"RETURN VALUES","text":"<p>RSA_sign_ASN1_OCTET_STRING() returns 1 on success, 0 otherwise. RSA_verify_ASN1_OCTET_STRING() returns 1 on successful verification, 0 otherwise.</p> <p>The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/RSA_sign_ASN1_OCTET_STRING/#bugs","title":"BUGS","text":"<p>These functions serve no recognizable purpose.</p>"},{"location":"man3/RSA_sign_ASN1_OCTET_STRING/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), objects(3), rand(3), rsa(3), RSA_sign(3), RSA_verify(3)</p>"},{"location":"man3/RSA_sign_ASN1_OCTET_STRING/#history","title":"HISTORY","text":"<p>RSA_sign_ASN1_OCTET_STRING() and RSA_verify_ASN1_OCTET_STRING() were added in SSLeay 0.8.</p>"},{"location":"man3/RSA_size/","title":"RSA_size","text":""},{"location":"man3/RSA_size/#name","title":"NAME","text":"<p>RSA_size - get RSA modulus size</p>"},{"location":"man3/RSA_size/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n\nint RSA_size(const RSA *rsa);\n</code></pre>"},{"location":"man3/RSA_size/#description","title":"DESCRIPTION","text":"<p>This function returns the RSA modulus size in bytes. It can be used to determine how much memory must be allocated for an RSA encrypted value.</p> <p>rsa-&gt;n must not be NULL.</p>"},{"location":"man3/RSA_size/#return-value","title":"RETURN VALUE","text":"<p>The size in bytes.</p>"},{"location":"man3/RSA_size/#see-also","title":"SEE ALSO","text":"<p>rsa(3)</p>"},{"location":"man3/RSA_size/#history","title":"HISTORY","text":"<p>RSA_size() is available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/SMIME_read_CMS/","title":"SMIME_read_CMS","text":""},{"location":"man3/SMIME_read_CMS/#name","title":"NAME","text":"<pre><code>SMIME_read_CMS - parse S/MIME message.\n</code></pre>"},{"location":"man3/SMIME_read_CMS/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nCMS_ContentInfo *SMIME_read_CMS(BIO *in, BIO **bcont);\n</code></pre>"},{"location":"man3/SMIME_read_CMS/#description","title":"DESCRIPTION","text":"<p>SMIME_read_CMS() parses a message in S/MIME format.</p> <p>in is a BIO to read the message from.</p> <p>If cleartext signing is used then the content is saved in a memory bio which is written to *bcont, otherwise *bcont is set to NULL.</p> <p>The parsed CMS_ContentInfo structure is returned or NULL if an error occurred.</p>"},{"location":"man3/SMIME_read_CMS/#notes","title":"NOTES","text":"<p>If *bcont is not NULL then the message is clear text signed. *bcont can then be passed to CMS_verify() with the CMS_DETACHED flag set.</p> <p>Otherwise the type of the returned structure can be determined using CMS_get0_type().</p> <p>To support future functionality if bcont is not NULL *bcont should be initialized to NULL. For example:</p> <pre><code>BIO *cont = NULL;\nCMS_ContentInfo *cms;\n\ncms = SMIME_read_CMS(in, &amp;cont);\n</code></pre>"},{"location":"man3/SMIME_read_CMS/#bugs","title":"BUGS","text":"<p>The MIME parser used by SMIME_read_CMS() is somewhat primitive.  While it will handle most S/MIME messages more complex compound formats may not work.</p> <p>The parser assumes that the CMS_ContentInfo structure is always base64 encoded and will not handle the case where it is in binary format or uses quoted printable format.</p> <p>The use of a memory BIO to hold the signed content limits the size of message which can be processed due to memory restraints: a streaming single pass option should be available.</p>"},{"location":"man3/SMIME_read_CMS/#return-values","title":"RETURN VALUES","text":"<p>SMIME_read_CMS() returns a valid CMS_ContentInfo structure or NULL if an error occurred. The error can be obtained from ERR_get_error(3).</p>"},{"location":"man3/SMIME_read_CMS/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_type(3) SMIME_read_CMS(3), CMS_sign(3), CMS_verify(3), CMS_encrypt(3) CMS_decrypt(3)</p>"},{"location":"man3/SMIME_read_CMS/#history","title":"HISTORY","text":"<p>SMIME_read_CMS() was added to OpenSSL 0.9.8</p>"},{"location":"man3/SMIME_read_PKCS7/","title":"SMIME_read_PKCS7","text":""},{"location":"man3/SMIME_read_PKCS7/#name","title":"NAME","text":"<p>SMIME_read_PKCS7 - parse S/MIME message.</p>"},{"location":"man3/SMIME_read_PKCS7/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/pkcs7.h&gt;\n\nPKCS7 *SMIME_read_PKCS7(BIO *in, BIO **bcont);\n</code></pre>"},{"location":"man3/SMIME_read_PKCS7/#description","title":"DESCRIPTION","text":"<p>SMIME_read_PKCS7() parses a message in S/MIME format.</p> <p>in is a BIO to read the message from.</p> <p>If cleartext signing is used then the content is saved in a memory bio which is written to *bcont, otherwise *bcont is set to NULL.</p> <p>The parsed PKCS#7 structure is returned or NULL if an error occurred.</p>"},{"location":"man3/SMIME_read_PKCS7/#notes","title":"NOTES","text":"<p>If *bcont is not NULL then the message is clear text signed. *bcont can then be passed to PKCS7_verify() with the PKCS7_DETACHED flag set.</p> <p>Otherwise the type of the returned structure can be determined using PKCS7_type().</p> <p>To support future functionality if bcont is not NULL *bcont should be initialized to NULL. For example:</p> <pre><code>BIO *cont = NULL;\nPKCS7 *p7;\n\np7 = SMIME_read_PKCS7(in, &amp;cont);\n</code></pre>"},{"location":"man3/SMIME_read_PKCS7/#bugs","title":"BUGS","text":"<p>The MIME parser used by SMIME_read_PKCS7() is somewhat primitive. While it will handle most S/MIME messages more complex compound formats may not work.</p> <p>The parser assumes that the PKCS7 structure is always base64 encoded and will not handle the case where it is in binary format or uses quoted printable format.</p> <p>The use of a memory BIO to hold the signed content limits the size of message which can be processed due to memory restraints: a streaming single pass option should be available.</p>"},{"location":"man3/SMIME_read_PKCS7/#return-values","title":"RETURN VALUES","text":"<p>SMIME_read_PKCS7() returns a valid PKCS7 structure or NULL if an error occurred. The error can be obtained from ERR_get_error(3).</p>"},{"location":"man3/SMIME_read_PKCS7/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), PKCS7_type(3) SMIME_read_PKCS7(3), PKCS7_sign(3), PKCS7_verify(3), PKCS7_encrypt(3) PKCS7_decrypt(3)</p>"},{"location":"man3/SMIME_read_PKCS7/#history","title":"HISTORY","text":"<p>SMIME_read_PKCS7() was added to OpenSSL 0.9.5</p>"},{"location":"man3/SMIME_write_CMS/","title":"SMIME_write_CMS","text":""},{"location":"man3/SMIME_write_CMS/#name","title":"NAME","text":"<pre><code>SMIME_write_CMS - convert CMS structure to S/MIME format.\n</code></pre>"},{"location":"man3/SMIME_write_CMS/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nint SMIME_write_CMS(BIO *out, CMS_ContentInfo *cms, BIO *data, int flags);\n</code></pre>"},{"location":"man3/SMIME_write_CMS/#description","title":"DESCRIPTION","text":"<p>SMIME_write_CMS() adds the appropriate MIME headers to a CMS structure to produce an S/MIME message.</p> <p>out is the BIO to write the data to. cms is the appropriate CMS_ContentInfo structure. If streaming is enabled then the content must be supplied in the data argument. flags is an optional set of flags.</p>"},{"location":"man3/SMIME_write_CMS/#notes","title":"NOTES","text":"<p>The following flags can be passed in the flags parameter.</p> <p>If CMS_DETACHED is set then cleartext signing will be used, this option only makes sense for SignedData where CMS_DETACHED is also set when CMS_sign() is called.</p> <p>If the CMS_TEXT flag is set MIME headers for type text/plain are added to the content, this only makes sense if CMS_DETACHED is also set.</p> <p>If the CMS_STREAM flag is set streaming is performed. This flag should only be set if CMS_STREAM was also set in the previous call to a CMS_ContentInfo creation function.</p> <p>If cleartext signing is being used and CMS_STREAM not set then the data must be read twice: once to compute the signature in CMS_sign() and once to output the S/MIME message.</p> <p>If streaming is performed the content is output in BER format using indefinite length constructed encoding except in the case of signed data with detached content where the content is absent and DER format is used.</p>"},{"location":"man3/SMIME_write_CMS/#bugs","title":"BUGS","text":"<p>SMIME_write_CMS() always base64 encodes CMS structures, there should be an option to disable this.</p>"},{"location":"man3/SMIME_write_CMS/#return-values","title":"RETURN VALUES","text":"<p>SMIME_write_CMS() returns 1 for success or 0 for failure.</p>"},{"location":"man3/SMIME_write_CMS/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_sign(3), CMS_verify(3), CMS_encrypt(3) CMS_decrypt(3)</p>"},{"location":"man3/SMIME_write_CMS/#history","title":"HISTORY","text":"<p>SMIME_write_CMS() was added to OpenSSL 0.9.8</p>"},{"location":"man3/SMIME_write_PKCS7/","title":"SMIME_write_PKCS7","text":""},{"location":"man3/SMIME_write_PKCS7/#name","title":"NAME","text":"<p>SMIME_write_PKCS7 - convert PKCS#7 structure to S/MIME format.</p>"},{"location":"man3/SMIME_write_PKCS7/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/pkcs7.h&gt;\n\nint SMIME_write_PKCS7(BIO *out, PKCS7 *p7, BIO *data, int flags);\n</code></pre>"},{"location":"man3/SMIME_write_PKCS7/#description","title":"DESCRIPTION","text":"<p>SMIME_write_PKCS7() adds the appropriate MIME headers to a PKCS#7 structure to produce an S/MIME message.</p> <p>out is the BIO to write the data to. p7 is the appropriate PKCS7 structure. If streaming is enabled then the content must be supplied in the data argument. flags is an optional set of flags.</p>"},{"location":"man3/SMIME_write_PKCS7/#notes","title":"NOTES","text":"<p>The following flags can be passed in the flags parameter.</p> <p>If PKCS7_DETACHED is set then cleartext signing will be used, this option only makes sense for signedData where PKCS7_DETACHED is also set when PKCS7_sign() is also called.</p> <p>If the PKCS7_TEXT flag is set MIME headers for type text/plain are added to the content, this only makes sense if PKCS7_DETACHED is also set.</p> <p>If the PKCS7_STREAM flag is set streaming is performed. This flag should only be set if PKCS7_STREAM was also set in the previous call to PKCS7_sign() or PKCS7_encrypt().</p> <p>If cleartext signing is being used and PKCS7_STREAM not set then the data must be read twice: once to compute the signature in PKCS7_sign() and once to output the S/MIME message.</p> <p>If streaming is performed the content is output in BER format using indefinite length constructuted encoding except in the case of signed data with detached content where the content is absent and DER format is used.</p>"},{"location":"man3/SMIME_write_PKCS7/#bugs","title":"BUGS","text":"<p>SMIME_write_PKCS7() always base64 encodes PKCS#7 structures, there should be an option to disable this.</p>"},{"location":"man3/SMIME_write_PKCS7/#return-values","title":"RETURN VALUES","text":"<p>SMIME_write_PKCS7() returns 1 for success or 0 for failure.</p>"},{"location":"man3/SMIME_write_PKCS7/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), PKCS7_sign(3), PKCS7_verify(3), PKCS7_encrypt(3) PKCS7_decrypt(3)</p>"},{"location":"man3/SMIME_write_PKCS7/#history","title":"HISTORY","text":"<p>SMIME_write_PKCS7() was added to OpenSSL 0.9.5</p>"},{"location":"man3/SSL_CIPHER_get_name/","title":"SSL_CIPHER_get_name","text":""},{"location":"man3/SSL_CIPHER_get_name/#name","title":"NAME","text":"<p>SSL_CIPHER_get_name, SSL_CIPHER_get_bits, SSL_CIPHER_get_version, SSL_CIPHER_description - get SSL_CIPHER properties</p>"},{"location":"man3/SSL_CIPHER_get_name/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nconst char *SSL_CIPHER_get_name(const SSL_CIPHER *cipher);\nint SSL_CIPHER_get_bits(const SSL_CIPHER *cipher, int *alg_bits);\nchar *SSL_CIPHER_get_version(const SSL_CIPHER *cipher);\nchar *SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf, int size);\n</code></pre>"},{"location":"man3/SSL_CIPHER_get_name/#description","title":"DESCRIPTION","text":"<p>SSL_CIPHER_get_name() returns a pointer to the name of cipher. If the argument is the NULL pointer, a pointer to the constant value \"NONE\" is returned.</p> <p>SSL_CIPHER_get_bits() returns the number of secret bits used for cipher. If alg_bits is not NULL, it contains the number of bits processed by the chosen algorithm. If cipher is NULL, 0 is returned.</p> <p>SSL_CIPHER_get_version() returns string which indicates the SSL/TLS protocol version that first defined the cipher. This is currently SSLv2 or TLSv1/SSLv3. In some cases it should possibly return \"TLSv1.2\" but does not; use SSL_CIPHER_description() instead. If cipher is NULL, \"(NONE)\" is returned.</p> <p>SSL_CIPHER_description() returns a textual description of the cipher used into the buffer buf of length len provided. len must be at least 128 bytes, otherwise a pointer to the string \"Buffer too small\" is returned. If buf is NULL, a buffer of 128 bytes is allocated using OPENSSL_malloc(). If the allocation fails, a pointer to the string \"OPENSSL_malloc Error\" is returned.</p>"},{"location":"man3/SSL_CIPHER_get_name/#notes","title":"NOTES","text":"<p>The number of bits processed can be different from the secret bits. An export cipher like e.g. EXP-RC4-MD5 has only 40 secret bits. The algorithm does use the full 128 bits (which would be returned for alg_bits), of which however 88bits are fixed. The search space is hence only 40 bits.</p> <p>The string returned by SSL_CIPHER_description() in case of success consists of cleartext information separated by one or more blanks in the following sequence:</p> <ul> <li> <p>&lt;ciphername&gt;</p> <p>Textual representation of the cipher name.</p> </li> <li> <p>&lt;protocol version&gt;</p> <p>Protocol version: SSLv2, SSLv3, TLSv1.2. The TLSv1.0 ciphers are flagged with SSLv3. No new ciphers were added by TLSv1.1.</p> </li> <li> <p>Kx=&lt;key exchange&gt;</p> <p>Key exchange method: RSA (for export ciphers as RSA(512) or RSA(1024)), DH (for export ciphers as DH(512) or DH(1024)), DH/RSA, DH/DSS, Fortezza.</p> </li> <li> <p>Au=&lt;authentication&gt;</p> <p>Authentication method: RSA, DSS, DH, None. None is the representation of anonymous ciphers.</p> </li> <li> <p>Enc=&lt;symmetric encryption method&gt;</p> <p>Encryption method with number of secret bits: DES(40), DES(56), 3DES(168), RC4(40), RC4(56), RC4(64), RC4(128), RC2(40), RC2(56), RC2(128), IDEA(128), Fortezza, None.</p> </li> <li> <p>Mac=&lt;message authentication code&gt;</p> <p>Message digest: MD5, SHA1.</p> </li> <li> <p>&lt;export flag&gt;</p> <p>If the cipher is flagged exportable with respect to old US crypto regulations, the word \"export\" is printed.</p> </li> </ul>"},{"location":"man3/SSL_CIPHER_get_name/#examples","title":"EXAMPLES","text":"<p>Some examples for the output of SSL_CIPHER_description():</p> <pre><code>EDH-RSA-DES-CBC3-SHA    SSLv3 Kx=DH       Au=RSA  Enc=3DES(168) Mac=SHA1\nEDH-DSS-DES-CBC3-SHA    SSLv3 Kx=DH       Au=DSS  Enc=3DES(168) Mac=SHA1\nRC4-MD5                 SSLv3 Kx=RSA      Au=RSA  Enc=RC4(128)  Mac=MD5\nEXP-RC4-MD5             SSLv3 Kx=RSA(512) Au=RSA  Enc=RC4(40)   Mac=MD5  export\n</code></pre> <p>A comp[lete list can be retrieved by invoking the following command:</p> <pre><code>openssl ciphers -v ALL\n</code></pre>"},{"location":"man3/SSL_CIPHER_get_name/#bugs","title":"BUGS","text":"<p>If SSL_CIPHER_description() is called with cipher being NULL, the library crashes.</p> <p>If SSL_CIPHER_description() cannot handle a built-in cipher, the according description of the cipher property is unknown. This case should not occur.</p> <p>The standard terminology for ephemeral Diffie-Hellman schemes is DHE (finite field) or ECDHE (elliptic curve).  This version of OpenSSL idiosyncratically reports these schemes as EDH and EECDH, even though it also accepts the standard terminology.</p> <p>It is recommended to use the standard terminology (DHE and ECDHE) during configuration (e.g. via SSL_CTX_set_cipher_list) for clarity of configuration.  OpenSSL versions after 1.0.2 will report the standard terms via SSL_CIPHER_get_name and SSL_CIPHER_description.</p>"},{"location":"man3/SSL_CIPHER_get_name/#return-values","title":"RETURN VALUES","text":"<p>See DESCRIPTION</p>"},{"location":"man3/SSL_CIPHER_get_name/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_get_current_cipher(3), SSL_get_ciphers(3), ciphers(1), SSL_CTX_set_cipher_list(3)</p>"},{"location":"man3/SSL_COMP_add_compression_method/","title":"SSL_COMP_add_compression_method","text":""},{"location":"man3/SSL_COMP_add_compression_method/#name","title":"NAME","text":"<p>SSL_COMP_add_compression_method, SSL_COMP_free_compression_methods - handle SSL/TLS integrated compression methods</p>"},{"location":"man3/SSL_COMP_add_compression_method/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_COMP_add_compression_method(int id, COMP_METHOD *cm);\n\n+void SSL_COMP_free_compression_methods(void);\n</code></pre>"},{"location":"man3/SSL_COMP_add_compression_method/#description","title":"DESCRIPTION","text":"<p>SSL_COMP_add_compression_method() adds the compression method cm with the identifier id to the list of available compression methods. This list is globally maintained for all SSL operations within this application. It cannot be set for specific SSL_CTX or SSL objects.</p> <p>SSL_COMP_free_compression_methods() frees the internal table of compression methods that were built internally, and possibly augmented by adding SSL_COMP_add_compression_method().</p>"},{"location":"man3/SSL_COMP_add_compression_method/#notes","title":"NOTES","text":"<p>The TLS standard (or SSLv3) allows the integration of compression methods into the communication. The TLS RFC does however not specify compression methods or their corresponding identifiers, so there is currently no compatible way to integrate compression with unknown peers. It is therefore currently not recommended to integrate compression into applications. Applications for non-public use may agree on certain compression methods. Using different compression methods with the same identifier will lead to connection failure.</p> <p>An OpenSSL client speaking a protocol that allows compression (SSLv3, TLSv1) will unconditionally send the list of all compression methods enabled with SSL_COMP_add_compression_method() to the server during the handshake. Unlike the mechanisms to set a cipher list, there is no method available to restrict the list of compression method on a per connection basis.</p> <p>An OpenSSL server will match the identifiers listed by a client against its own compression methods and will unconditionally activate compression when a matching identifier is found. There is no way to restrict the list of compression methods supported on a per connection basis.</p> <p>If enabled during compilation, the OpenSSL library will have the COMP_zlib() compression method available.</p>"},{"location":"man3/SSL_COMP_add_compression_method/#warnings","title":"WARNINGS","text":"<p>Once the identities of the compression methods for the TLS protocol have been standardized, the compression API will most likely be changed. Using it in the current state is not recommended.</p>"},{"location":"man3/SSL_COMP_add_compression_method/#return-values","title":"RETURN VALUES","text":"<p>SSL_COMP_add_compression_method() may return the following values:</p> <ul> <li> <p>0</p> <p>The operation succeeded.</p> </li> <li> <p>1</p> <p>The operation failed. Check the error queue to find out the reason.</p> </li> </ul>"},{"location":"man3/SSL_COMP_add_compression_method/#see-also","title":"SEE ALSO","text":"<p>ssl(3)</p>"},{"location":"man3/SSL_CONF_CTX_new/","title":"SSL_CONF_CTX_new","text":""},{"location":"man3/SSL_CONF_CTX_new/#name","title":"NAME","text":"<p>SSL_CONF_CTX_new, SSL_CONF_CTX_free - SSL configuration allocation functions</p>"},{"location":"man3/SSL_CONF_CTX_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nSSL_CONF_CTX *SSL_CONF_CTX_new(void);\nvoid SSL_CONF_CTX_free(SSL_CONF_CTX *cctx);\n</code></pre>"},{"location":"man3/SSL_CONF_CTX_new/#description","title":"DESCRIPTION","text":"<p>The function SSL_CONF_CTX_new() allocates and initialises an SSL_CONF_CTX structure for use with the SSL_CONF functions.</p> <p>The function SSL_CONF_CTX_free() frees up the context cctx.</p>"},{"location":"man3/SSL_CONF_CTX_new/#return-values","title":"RETURN VALUES","text":"<p>SSL_CONF_CTX_new() returns either the newly allocated SSL_CONF_CTX structure or NULL if an error occurs.</p> <p>SSL_CONF_CTX_free() does not return a value.</p>"},{"location":"man3/SSL_CONF_CTX_new/#see-also","title":"SEE ALSO","text":"<p>SSL_CONF_CTX_set_flags(3), SSL_CONF_CTX_set_ssl_ctx(3), SSL_CONF_CTX_set1_prefix(3), SSL_CONF_cmd(3), SSL_CONF_cmd_argv(3)</p>"},{"location":"man3/SSL_CONF_CTX_new/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.2</p>"},{"location":"man3/SSL_CONF_CTX_set1_prefix/","title":"SSL_CONF_CTX_set1_prefix","text":""},{"location":"man3/SSL_CONF_CTX_set1_prefix/#name","title":"NAME","text":"<p>SSL_CONF_CTX_set1_prefix - Set configuration context command prefix</p>"},{"location":"man3/SSL_CONF_CTX_set1_prefix/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nunsigned int SSL_CONF_CTX_set1_prefix(SSL_CONF_CTX *cctx, const char *prefix);\n</code></pre>"},{"location":"man3/SSL_CONF_CTX_set1_prefix/#description","title":"DESCRIPTION","text":"<p>The function SSL_CONF_CTX_set1_prefix() sets the command prefix of cctx to prefix. If prefix is NULL it is restored to the default value.</p>"},{"location":"man3/SSL_CONF_CTX_set1_prefix/#notes","title":"NOTES","text":"<p>Command prefixes alter the commands recognised by subsequent SSL_CTX_cmd() calls. For example for files, if the prefix \"SSL\" is set then command names such as \"SSLProtocol\", \"SSLOptions\" etc. are recognised instead of \"Protocol\" and \"Options\". Similarly for command lines if the prefix is \"--ssl-\" then  \"--ssl-no_tls1_2\" is recognised instead of \"-no_tls1_2\".</p> <p>If the SSL_CONF_FLAG_CMDLINE flag is set then prefix checks are case sensitive and \"-\" is the default. In the unlikely even an application explicitly wants to set no prefix it must be explicitly set to \"\".</p> <p>If the SSL_CONF_FLAG_FILE flag is set then prefix checks are case insensitive and no prefix is the default.</p>"},{"location":"man3/SSL_CONF_CTX_set1_prefix/#return-values","title":"RETURN VALUES","text":"<p>SSL_CONF_CTX_set1_prefix() returns 1 for success and 0 for failure.</p>"},{"location":"man3/SSL_CONF_CTX_set1_prefix/#see-also","title":"SEE ALSO","text":"<p>SSL_CONF_CTX_new(3), SSL_CONF_CTX_set_flags(3), SSL_CONF_CTX_set_ssl_ctx(3), SSL_CONF_cmd(3), SSL_CONF_cmd_argv(3)</p>"},{"location":"man3/SSL_CONF_CTX_set1_prefix/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.2</p>"},{"location":"man3/SSL_CONF_CTX_set_flags/","title":"SSL_CONF_CTX_set_flags","text":""},{"location":"man3/SSL_CONF_CTX_set_flags/#name","title":"NAME","text":"<p>SSL_CONF_CTX_set_flags, SSL_CONF_CTX_clear_flags - Set of clear SSL configuration context flags</p>"},{"location":"man3/SSL_CONF_CTX_set_flags/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nunsigned int SSL_CONF_CTX_set_flags(SSL_CONF_CTX *cctx, unsigned int flags);\nunsigned int SSL_CONF_CTX_clear_flags(SSL_CONF_CTX *cctx, unsigned int flags);\n</code></pre>"},{"location":"man3/SSL_CONF_CTX_set_flags/#description","title":"DESCRIPTION","text":"<p>The function SSL_CONF_CTX_set_flags() sets flags in the context cctx.</p> <p>The function SSL_CONF_CTX_clear_flags() clears flags in the context cctx.</p>"},{"location":"man3/SSL_CONF_CTX_set_flags/#notes","title":"NOTES","text":"<p>The flags set affect how subsequent calls to SSL_CONF_cmd() or SSL_CONF_argv() behave.</p> <p>Currently the following flags values are recognised:</p> <ul> <li> <p>SSL_CONF_FLAG_CMDLINE, SSL_CONF_FLAG_FILE</p> <p>recognise options intended for command line or configuration file use. At least one of these flags must be set.</p> </li> <li> <p>SSL_CONF_FLAG_CLIENT, SSL_CONF_FLAG_SERVER</p> <p>recognise options intended for use in SSL/TLS clients or servers. One or both of these flags must be set.</p> </li> <li> <p>SSL_CONF_FLAG_CERTIFICATE</p> <p>recognise certificate and private key options.</p> </li> <li> <p>SSL_CONF_FLAG_SHOW_ERRORS</p> <p>indicate errors relating to unrecognised options or missing arguments in the error queue. If this option isn't set such errors are only reflected in the return values of SSL_CONF_set_cmd() or SSL_CONF_set_argv()</p> </li> </ul>"},{"location":"man3/SSL_CONF_CTX_set_flags/#return-values","title":"RETURN VALUES","text":"<p>SSL_CONF_CTX_set_flags() and SSL_CONF_CTX_clear_flags() returns the new flags value after setting or clearing flags.</p>"},{"location":"man3/SSL_CONF_CTX_set_flags/#see-also","title":"SEE ALSO","text":"<p>SSL_CONF_CTX_new(3), SSL_CONF_CTX_set_ssl_ctx(3), SSL_CONF_CTX_set1_prefix(3), SSL_CONF_cmd(3), SSL_CONF_cmd_argv(3)</p>"},{"location":"man3/SSL_CONF_CTX_set_flags/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.2</p>"},{"location":"man3/SSL_CONF_CTX_set_ssl_ctx/","title":"SSL_CONF_CTX_set_ssl_ctx","text":""},{"location":"man3/SSL_CONF_CTX_set_ssl_ctx/#name","title":"NAME","text":"<p>SSL_CONF_CTX_set_ssl_ctx, SSL_CONF_CTX_set_ssl - set context to configure</p>"},{"location":"man3/SSL_CONF_CTX_set_ssl_ctx/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CONF_CTX_set_ssl_ctx(SSL_CONF_CTX *cctx, SSL_CTX *ctx);\nvoid SSL_CONF_CTX_set_ssl(SSL_CONF_CTX *cctx, SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_CONF_CTX_set_ssl_ctx/#description","title":"DESCRIPTION","text":"<p>SSL_CONF_CTX_set_ssl_ctx() sets the context associated with cctx to the SSL_CTX structure ctx. Any previous SSL or SSL_CTX associated with cctx is cleared. Subsequent calls to SSL_CONF_cmd() will be sent to ctx.</p> <p>SSL_CONF_CTX_set_ssl() sets the context associated with cctx to the SSL structure ssl. Any previous SSL or SSL_CTX associated with cctx is cleared. Subsequent calls to SSL_CONF_cmd() will be sent to ssl.</p>"},{"location":"man3/SSL_CONF_CTX_set_ssl_ctx/#notes","title":"NOTES","text":"<p>The context need not be set or it can be set to NULL in which case only syntax checking of commands is performed, where possible.</p>"},{"location":"man3/SSL_CONF_CTX_set_ssl_ctx/#return-values","title":"RETURN VALUES","text":"<p>SSL_CONF_CTX_set_ssl_ctx() and SSL_CTX_set_ssl() do not return a value.</p>"},{"location":"man3/SSL_CONF_CTX_set_ssl_ctx/#see-also","title":"SEE ALSO","text":"<p>SSL_CONF_CTX_new(3), SSL_CONF_CTX_set_flags(3), SSL_CONF_CTX_set1_prefix(3), SSL_CONF_cmd(3), SSL_CONF_cmd_argv(3)</p>"},{"location":"man3/SSL_CONF_CTX_set_ssl_ctx/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.2</p>"},{"location":"man3/SSL_CONF_cmd/","title":"SSL_CONF_cmd","text":""},{"location":"man3/SSL_CONF_cmd/#name","title":"NAME","text":"<p>SSL_CONF_cmd - send configuration command</p>"},{"location":"man3/SSL_CONF_cmd/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CONF_cmd(SSL_CONF_CTX *cctx, const char *cmd, const char *value);\nint SSL_CONF_cmd_value_type(SSL_CONF_CTX *cctx, const char *cmd);\nint SSL_CONF_finish(SSL_CONF_CTX *cctx);\n</code></pre>"},{"location":"man3/SSL_CONF_cmd/#description","title":"DESCRIPTION","text":"<p>The function SSL_CONF_cmd() performs configuration operation cmd with optional parameter value on ctx. Its purpose is to simplify application configuration of SSL_CTX or SSL structures by providing a common framework for command line options or configuration files.</p> <p>SSL_CONF_cmd_value_type() returns the type of value that cmd refers to.</p> <p>The function SSL_CONF_finish() must be called after all configuration operations have been completed. It is used to finalise any operations or to process defaults.</p>"},{"location":"man3/SSL_CONF_cmd/#supported-command-line-commands","title":"SUPPORTED COMMAND LINE COMMANDS","text":"<p>Currently supported cmd names for command lines (i.e. when the flag SSL_CONF_CMDLINE is set) are listed below. Note: all cmd names are case sensitive. Unless otherwise stated commands can be used by both clients and servers and the value parameter is not used. The default prefix for command line commands is - and that is reflected below.</p> <ul> <li> <p>-sigalgs</p> <p>This sets the supported signature algorithms for TLS v1.2. For clients this value is used directly for the supported signature algorithms extension. For servers it is used to determine which signature algorithms to support.</p> <p>The value argument should be a colon separated list of signature algorithms in order of decreasing preference of the form algorithm+hash. algorithm is one of RSA, DSA or ECDSA and hash is a supported algorithm OID short name such as SHA1, SHA224, SHA256, SHA384 of SHA512. Note: algorithm and hash names are case sensitive.</p> <p>If this option is not set then all signature algorithms supported by the OpenSSL library are permissible.</p> </li> <li> <p>-client_sigalgs</p> <p>This sets the supported signature algorithms associated with client authentication for TLS v1.2. For servers the value is used in the supported signature algorithms field of a certificate request. For clients it is used to determine which signature algorithm to with the client certificate. If a server does not request a certificate this option has no effect.</p> <p>The syntax of value is identical to -sigalgs. If not set then the value set for -sigalgs will be used instead.</p> </li> <li> <p>-curves</p> <p>This sets the supported elliptic curves. For clients the curves are sent using the supported curves extension. For servers it is used to determine which curve to use. This setting affects curves used for both signatures and key exchange, if applicable.</p> <p>The value argument is a colon separated list of curves. The curve can be either the NIST name (e.g. P-256) or an OpenSSL OID name (e.g prime256v1). Curve names are case sensitive.</p> </li> <li> <p>-named_curve</p> <p>This sets the temporary curve used for ephemeral ECDH modes. Only used by servers</p> <p>The value argument is a curve name or the special value auto which picks an appropriate curve based on client and server preferences. The curve can be either the NIST name (e.g. P-256) or an OpenSSL OID name (e.g prime256v1). Curve names are case sensitive.</p> </li> <li> <p>-cipher</p> <p>Sets the cipher suite list to value. Note: syntax checking of value is currently not performed unless a SSL or SSL_CTX structure is associated with cctx.</p> </li> <li> <p>-cert</p> <p>Attempts to use the file value as the certificate for the appropriate context. It currently uses SSL_CTX_use_certificate_chain_file() if an SSL_CTX structure is set or SSL_use_certificate_file() with filetype PEM if an SSL structure is set. This option is only supported if certificate operations are permitted.</p> </li> <li> <p>-key</p> <p>Attempts to use the file value as the private key for the appropriate context. This option is only supported if certificate operations are permitted. Note: if no -key option is set then a private key is not loaded: it does not currently use the -cert file.</p> </li> <li> <p>-dhparam</p> <p>Attempts to use the file value as the set of temporary DH parameters for the appropriate context. This option is only supported if certificate operations are permitted.</p> </li> <li> <p>-no_ssl2, -no_ssl3, -no_tls1, -no_tls1_1, -no_tls1_2</p> <p>Disables protocol support for SSLv2, SSLv3, TLSv1.0, TLSv1.1 or TLSv1.2 by setting the corresponding options SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1 and SSL_OP_NO_TLSv1_2 respectively.</p> </li> <li> <p>-bugs</p> <p>Various bug workarounds are set, same as setting SSL_OP_ALL.</p> </li> <li> <p>-no_comp</p> <p>Disables support for SSL/TLS compression, same as setting SSL_OP_NO_COMPRESS.</p> </li> <li> <p>-no_ticket</p> <p>Disables support for session tickets, same as setting SSL_OP_NO_TICKET.</p> </li> <li> <p>-serverpref</p> <p>Use server and not client preference order when determining which cipher suite, signature algorithm or elliptic curve to use for an incoming connection. Equivalent to SSL_OP_CIPHER_SERVER_PREFERENCE. Only used by servers.</p> </li> <li> <p>-no_resumption_on_reneg</p> <p>set SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION flag. Only used by servers.</p> </li> <li> <p>-legacyrenegotiation</p> <p>permits the use of unsafe legacy renegotiation. Equivalent to setting SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION.</p> </li> <li> <p>-legacy_server_connect, -no_legacy_server_connect</p> <p>permits or prohibits the use of unsafe legacy renegotiation for OpenSSL clients only. Equivalent to setting or clearing SSL_OP_LEGACY_SERVER_CONNECT. Set by default.</p> </li> <li> <p>-strict</p> <p>enables strict mode protocol handling. Equivalent to setting SSL_CERT_FLAG_TLS_STRICT.</p> </li> <li> <p>-debug_broken_protocol</p> <p>disables various checks and permits several kinds of broken protocol behaviour for testing purposes: it should NEVER be used in anything other than a test environment. Only supported if OpenSSL is configured with -DOPENSSL_SSL_DEBUG_BROKEN_PROTOCOL.</p> </li> </ul>"},{"location":"man3/SSL_CONF_cmd/#supported-configuration-file-commands","title":"SUPPORTED CONFIGURATION FILE COMMANDS","text":"<p>Currently supported cmd names for configuration files (i.e. when the flag SSL_CONF_FLAG_FILE is set) are listed below. All configuration file cmd names and are case insensitive so signaturealgorithms is recognised as well as SignatureAlgorithms. Unless otherwise stated the value names are also case insensitive.</p> <p>Note: the command prefix (if set) alters the recognised cmd values.</p> <ul> <li> <p>CipherString</p> <p>Sets the cipher suite list to value. Note: syntax checking of value is currently not performed unless an SSL or SSL_CTX structure is associated with cctx.</p> </li> <li> <p>Certificate</p> <p>Attempts to use the file value as the certificate for the appropriate context. It currently uses SSL_CTX_use_certificate_chain_file() if an SSL_CTX structure is set or SSL_use_certificate_file() with filetype PEM if an SSL structure is set. This option is only supported if certificate operations are permitted.</p> </li> <li> <p>PrivateKey</p> <p>Attempts to use the file value as the private key for the appropriate context. This option is only supported if certificate operations are permitted. Note: if no -key option is set then a private key is not loaded: it does not currently use the Certificate file.</p> </li> <li> <p>ServerInfoFile</p> <p>Attempts to use the file value in the \"serverinfo\" extension using the function SSL_CTX_use_serverinfo_file.</p> </li> <li> <p>DHParameters</p> <p>Attempts to use the file value as the set of temporary DH parameters for the appropriate context. This option is only supported if certificate operations are permitted.</p> </li> <li> <p>SignatureAlgorithms</p> <p>This sets the supported signature algorithms for TLS v1.2. For clients this value is used directly for the supported signature algorithms extension. For servers it is used to determine which signature algorithms to support.</p> <p>The value argument should be a colon separated list of signature algorithms in order of decreasing preference of the form algorithm+hash. algorithm is one of RSA, DSA or ECDSA and hash is a supported algorithm OID short name such as SHA1, SHA224, SHA256, SHA384 of SHA512. Note: algorithm and hash names are case sensitive.</p> <p>If this option is not set then all signature algorithms supported by the OpenSSL library are permissible.</p> </li> <li> <p>ClientSignatureAlgorithms</p> <p>This sets the supported signature algorithms associated with client authentication for TLS v1.2. For servers the value is used in the supported signature algorithms field of a certificate request. For clients it is used to determine which signature algorithm to with the client certificate.</p> <p>The syntax of value is identical to SignatureAlgorithms. If not set then the value set for SignatureAlgorithms will be used instead.</p> </li> <li> <p>Curves</p> <p>This sets the supported elliptic curves. For clients the curves are sent using the supported curves extension. For servers it is used to determine which curve to use. This setting affects curves used for both signatures and key exchange, if applicable.</p> <p>The value argument is a colon separated list of curves. The curve can be either the NIST name (e.g. P-256) or an OpenSSL OID name (e.g prime256v1). Curve names are case sensitive.</p> </li> <li> <p>ECDHParameters</p> <p>This sets the temporary curve used for ephemeral ECDH modes. Only used by servers</p> <p>The value argument is a curve name or the special value Automatic which picks an appropriate curve based on client and server preferences. The curve can be either the NIST name (e.g. P-256) or an OpenSSL OID name (e.g prime256v1). Curve names are case sensitive.</p> </li> <li> <p>Protocol</p> <p>The supported versions of the SSL or TLS protocol.</p> <p>The value argument is a comma separated list of supported protocols to enable or disable. If an protocol is preceded by - that version is disabled. Currently supported protocol values are SSLv2, SSLv3, TLSv1, TLSv1.1 and TLSv1.2. All protocol versions other than SSLv2 are enabled by default. To avoid inadvertent enabling of SSLv2, when SSLv2 is disabled, it is not possible to enable it via the Protocol command.</p> </li> <li> <p>Options</p> <p>The value argument is a comma separated list of various flags to set. If a flag string is preceded - it is disabled. See the SSL_CTX_set_options function for more details of individual options.</p> <p>Each option is listed below. Where an operation is enabled by default the -flag syntax is needed to disable it.</p> <p>SessionTicket: session ticket support, enabled by default. Inverse of SSL_OP_NO_TICKET: that is -SessionTicket is the same as setting SSL_OP_NO_TICKET.</p> <p>Compression: SSL/TLS compression support, enabled by default. Inverse of SSL_OP_NO_COMPRESSION.</p> <p>EmptyFragments: use empty fragments as a countermeasure against a SSL 3.0/TLS 1.0 protocol vulnerability affecting CBC ciphers. It is set by default. Inverse of SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS.</p> <p>Bugs: enable various bug workarounds. Same as SSL_OP_ALL.</p> <p>DHSingle: enable single use DH keys, set by default. Inverse of SSL_OP_DH_SINGLE. Only used by servers.</p> <p>ECDHSingle enable single use ECDH keys, set by default. Inverse of SSL_OP_ECDH_SINGLE. Only used by servers.</p> <p>ServerPreference use server and not client preference order when determining which cipher suite, signature algorithm or elliptic curve to use for an incoming connection.  Equivalent to SSL_OP_CIPHER_SERVER_PREFERENCE. Only used by servers.</p> <p>NoResumptionOnRenegotiation set SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION flag. Only used by servers.</p> <p>UnsafeLegacyRenegotiation permits the use of unsafe legacy renegotiation. Equivalent to SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION.</p> <p>UnsafeLegacyServerConnect permits the use of unsafe legacy renegotiation for OpenSSL clients only. Equivalent to SSL_OP_LEGACY_SERVER_CONNECT. Set by default.</p> </li> </ul>"},{"location":"man3/SSL_CONF_cmd/#supported-command-types","title":"SUPPORTED COMMAND TYPES","text":"<p>The function SSL_CONF_cmd_value_type() currently returns one of the following types:</p> <ul> <li> <p>SSL_CONF_TYPE_UNKNOWN</p> <p>The cmd string is unrecognised, this return value can be use to flag syntax errors.</p> </li> <li> <p>SSL_CONF_TYPE_STRING</p> <p>The value is a string without any specific structure.</p> </li> <li> <p>SSL_CONF_TYPE_FILE</p> <p>The value is a file name.</p> </li> <li> <p>SSL_CONF_TYPE_DIR</p> <p>The value is a directory name.</p> </li> </ul>"},{"location":"man3/SSL_CONF_cmd/#notes","title":"NOTES","text":"<p>The order of operations is significant. This can be used to set either defaults or values which cannot be overridden. For example if an application calls:</p> <pre><code>SSL_CONF_cmd(ctx, \"Protocol\", \"-SSLv3\");\nSSL_CONF_cmd(ctx, userparam, uservalue);\n</code></pre> <p>it will disable SSLv3 support by default but the user can override it. If however the call sequence is:</p> <pre><code>SSL_CONF_cmd(ctx, userparam, uservalue);\nSSL_CONF_cmd(ctx, \"Protocol\", \"-SSLv3\");\n</code></pre> <p>then SSLv3 is always disabled and attempt to override this by the user are ignored.</p> <p>By checking the return code of SSL_CTX_cmd() it is possible to query if a given cmd is recognised, this is useful is SSL_CTX_cmd() values are mixed with additional application specific operations.</p> <p>For example an application might call SSL_CTX_cmd() and if it returns -2 (unrecognised command) continue with processing of application specific commands.</p> <p>Applications can also use SSL_CTX_cmd() to process command lines though the utility function SSL_CTX_cmd_argv() is normally used instead. One way to do this is to set the prefix to an appropriate value using SSL_CONF_CTX_set1_prefix(), pass the current argument to cmd and the following argument to value (which may be NULL).</p> <p>In this case if the return value is positive then it is used to skip that number of arguments as they have been processed by SSL_CTX_cmd(). If -2 is returned then cmd is not recognised and application specific arguments can be checked instead. If -3 is returned a required argument is missing and an error is indicated. If 0 is returned some other error occurred and this can be reported back to the user.</p> <p>The function SSL_CONF_cmd_value_type() can be used by applications to check for the existence of a command or to perform additional syntax checking or translation of the command value. For example if the return value is SSL_CONF_TYPE_FILE an application could translate a relative pathname to an absolute pathname.</p>"},{"location":"man3/SSL_CONF_cmd/#examples","title":"EXAMPLES","text":"<p>Set supported signature algorithms:</p> <pre><code>SSL_CONF_cmd(ctx, \"SignatureAlgorithms\", \"ECDSA+SHA256:RSA+SHA256:DSA+SHA256\");\n</code></pre> <p>Enable all protocols except SSLv3 and SSLv2:</p> <pre><code>SSL_CONF_cmd(ctx, \"Protocol\", \"ALL,-SSLv3,-SSLv2\");\n</code></pre> <p>Only enable TLSv1.2:</p> <pre><code>SSL_CONF_cmd(ctx, \"Protocol\", \"-ALL,TLSv1.2\");\n</code></pre> <p>Disable TLS session tickets:</p> <pre><code>SSL_CONF_cmd(ctx, \"Options\", \"-SessionTicket\");\n</code></pre> <p>Set supported curves to P-256, P-384:</p> <pre><code>SSL_CONF_cmd(ctx, \"Curves\", \"P-256:P-384\");\n</code></pre> <p>Set automatic support for any elliptic curve for key exchange:</p> <pre><code>SSL_CONF_cmd(ctx, \"ECDHParameters\", \"Automatic\");\n</code></pre>"},{"location":"man3/SSL_CONF_cmd/#return-values","title":"RETURN VALUES","text":"<p>SSL_CONF_cmd() returns 1 if the value of cmd is recognised and value is NOT used and 2 if both cmd and value are used. In other words it returns the number of arguments processed. This is useful when processing command lines.</p> <p>A return value of -2 means cmd is not recognised.</p> <p>A return value of -3 means cmd is recognised and the command requires a value but value is NULL.</p> <p>A return code of 0 indicates that both cmd and value are valid but an error occurred attempting to perform the operation: for example due to an error in the syntax of value in this case the error queue may provide additional information.</p> <p>SSL_CONF_finish() returns 1 for success and 0 for failure.</p>"},{"location":"man3/SSL_CONF_cmd/#see-also","title":"SEE ALSO","text":"<p>SSL_CONF_CTX_new(3), SSL_CONF_CTX_set_flags(3), SSL_CONF_CTX_set1_prefix(3), SSL_CONF_CTX_set_ssl_ctx(3), SSL_CONF_cmd_argv(3)</p>"},{"location":"man3/SSL_CONF_cmd/#history","title":"HISTORY","text":"<p>SSL_CONF_cmd() was first added to OpenSSL 1.0.2</p>"},{"location":"man3/SSL_CONF_cmd_argv/","title":"SSL_CONF_cmd_argv","text":""},{"location":"man3/SSL_CONF_cmd_argv/#name","title":"NAME","text":"<p>SSL_CONF_cmd_argv - SSL configuration command line processing.</p>"},{"location":"man3/SSL_CONF_cmd_argv/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CONF_cmd_argv(SSL_CONF_CTX *cctx, int *pargc, char ***pargv);\n</code></pre>"},{"location":"man3/SSL_CONF_cmd_argv/#description","title":"DESCRIPTION","text":"<p>The function SSL_CONF_cmd_argv() processes at most two command line arguments from pargv and pargc. The values of pargv and pargc are updated to reflect the number of command options processed. The pargc argument can be set to NULL is it is not used.</p>"},{"location":"man3/SSL_CONF_cmd_argv/#return-values","title":"RETURN VALUES","text":"<p>SSL_CONF_cmd_argv() returns the number of command arguments processed: 0, 1, 2 or a negative error code.</p> <p>If -2 is returned then an argument for a command is missing.</p> <p>If -1 is returned the command is recognised but couldn't be processed due to an error: for example a syntax error in the argument.</p>"},{"location":"man3/SSL_CONF_cmd_argv/#see-also","title":"SEE ALSO","text":"<p>SSL_CONF_CTX_new(3), SSL_CONF_CTX_set_flags(3), SSL_CONF_CTX_set1_prefix(3), SSL_CONF_CTX_set_ssl_ctx(3), SSL_CONF_cmd(3)</p>"},{"location":"man3/SSL_CONF_cmd_argv/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.2</p>"},{"location":"man3/SSL_CTX_add1_chain_cert/","title":"SSL_CTX_add1_chain_cert","text":""},{"location":"man3/SSL_CTX_add1_chain_cert/#name","title":"NAME","text":"<p>SSL_CTX_set0_chain, SSL_CTX_set1_chain, SSL_CTX_add0_chain_cert, SSL_CTX_add1_chain_cert, SSL_CTX_get0_chain_certs, SSL_CTX_clear_chain_certs, SSL_set0_chain, SSL_set1_chain, SSL_add0_chain_cert, SSL_add1_chain_cert, SSL_get0_chain_certs, SSL_clear_chain_certs, SSL_CTX_build_cert_chain, SSL_build_cert_chain, SSL_CTX_select_current_cert, SSL_select_current_cert, SSL_CTX_set_current_cert, SSL_set_current_cert - extra chain certificate processing</p>"},{"location":"man3/SSL_CTX_add1_chain_cert/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_set0_chain(SSL_CTX *ctx, STACK_OF(X509) *sk);\nint SSL_CTX_set1_chain(SSL_CTX *ctx, STACK_OF(X509) *sk);\nint SSL_CTX_add0_chain_cert(SSL_CTX *ctx, X509 *x509);\nint SSL_CTX_add1_chain_cert(SSL_CTX *ctx, X509 *x509);\nint SSL_CTX_get0_chain_certs(SSL_CTX *ctx, STACK_OF(X509) **sk);\nint SSL_CTX_clear_chain_certs(SSL_CTX *ctx);\n\nint SSL_set0_chain(SSL *ssl, STACK_OF(X509) *sk);\nint SSL_set1_chain(SSL *ssl, STACK_OF(X509) *sk);\nint SSL_add0_chain_cert(SSL *ssl, X509 *x509);\nint SSL_add1_chain_cert(SSL *ssl, X509 *x509);\nint SSL_get0_chain_certs(SSL *ssl, STACK_OF(X509) **sk);\nint SSL_clear_chain_certs(SSL *ssl);\n\nint SSL_CTX_build_cert_chain(SSL_CTX *ctx, flags);\nint SSL_build_cert_chain(SSL *ssl, flags);\n\nint SSL_CTX_select_current_cert(SSL_CTX *ctx, X509 *x509);\nint SSL_select_current_cert(SSL *ssl, X509 *x509);\nint SSL_CTX_set_current_cert(SSL_CTX *ctx, long op);\nint SSL_set_current_cert(SSL *ssl, long op);\n</code></pre>"},{"location":"man3/SSL_CTX_add1_chain_cert/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set0_chain() and SSL_CTX_set1_chain() set the certificate chain associated with the current certificate of ctx to sk.</p> <p>SSL_CTX_add0_chain_cert() and SSL_CTX_add1_chain_cert() append the single certificate x509 to the chain associated with the current certificate of ctx.</p> <p>SSL_CTX_get0_chain_certs() retrieves the chain associated with the current certificate of ctx.</p> <p>SSL_CTX_clear_chain_certs() clears any existing chain associated with the current certificate of ctx.  (This is implemented by calling SSL_CTX_set0_chain() with sk set to NULL).</p> <p>SSL_CTX_build_cert_chain() builds the certificate chain for ctx normally this uses the chain store or the verify store if the chain store is not set. If the function is successful the built chain will replace any existing chain. The flags parameter can be set to SSL_BUILD_CHAIN_FLAG_UNTRUSTED to use existing chain certificates as untrusted CAs, SSL_BUILD_CHAIN_FLAG_NO_ROOT to omit the root CA from the built chain, SSL_BUILD_CHAIN_FLAG_CHECK to use all existing chain certificates only to build the chain (effectively sanity checking and rearranging them if necessary), the flag SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR ignores any errors during verification: if flag SSL_BUILD_CHAIN_FLAG_CLEAR_ERROR is also set verification errors are cleared from the error queue.</p> <p>Each of these functions operates on the current end entity (i.e. server or client) certificate. This is the last certificate loaded or selected on the corresponding ctx structure.</p> <p>SSL_CTX_select_current_cert() selects x509 as the current end entity certificate, but only if x509 has already been loaded into ctx using a function such as SSL_CTX_use_certificate().</p> <p>SSL_set0_chain(), SSL_set1_chain(), SSL_add0_chain_cert(), SSL_add1_chain_cert(), SSL_get0_chain_certs(), SSL_clear_chain_certs(), SSL_build_cert_chain(), SSL_select_current_cert() and SSL_set_current_cert() are similar except they apply to SSL structure ssl.</p> <p>SSL_CTX_set_current_cert() changes the current certificate to a value based on the op argument. Currently op can be SSL_CERT_SET_FIRST to use the first valid certificate or SSL_CERT_SET_NEXT to set the next valid certificate after the current certificate. These two operations can be used to iterate over all certificates in an SSL_CTX structure.</p> <p>SSL_set_current_cert() also supports the option SSL_CERT_SET_SERVER. If ssl is a server and has sent a certificate to a connected client this option sets that certificate to the current certificate and returns 1. If the negotiated ciphersuite is anonymous (and thus no certificate will be sent) 2 is returned and the current certificate is unchanged. If ssl is not a server or a certificate has not been sent 0 is returned and the current certificate is unchanged.</p> <p>All these functions are implemented as macros. Those containing a 1 increment the reference count of the supplied certificate or chain so it must be freed at some point after the operation. Those containing a 0 do not increment reference counts and the supplied certificate or chain MUST NOT be freed after the operation.</p>"},{"location":"man3/SSL_CTX_add1_chain_cert/#notes","title":"NOTES","text":"<p>The chains associate with an SSL_CTX structure are copied to any SSL structures when SSL_new() is called. SSL structures will not be affected by any chains subsequently changed in the parent SSL_CTX.</p> <p>One chain can be set for each key type supported by a server. So, for example, an RSA and a DSA certificate can (and often will) have different chains.</p> <p>The functions SSL_CTX_build_cert_chain() and SSL_build_cert_chain() can be used to check application configuration and to ensure any necessary subordinate CAs are sent in the correct order. Misconfigured applications sending incorrect certificate chains often cause problems with peers.</p> <p>For example an application can add any set of certificates using SSL_CTX_use_certificate_chain_file() then call SSL_CTX_build_cert_chain() with the option SSL_BUILD_CHAIN_FLAG_CHECK to check and reorder them.</p> <p>Applications can issue non fatal warnings when checking chains by setting the flag SSL_BUILD_CHAIN_FLAG_IGNORE_ERRORS and checking the return value.</p> <p>Calling SSL_CTX_build_cert_chain() or SSL_build_cert_chain() is more efficient than the automatic chain building as it is only performed once. Automatic chain building is performed on each new session.</p> <p>If any certificates are added using these functions no certificates added using SSL_CTX_add_extra_chain_cert() will be used.</p>"},{"location":"man3/SSL_CTX_add1_chain_cert/#return-values","title":"RETURN VALUES","text":"<p>SSL_set_current_cert() with SSL_CERT_SET_SERVER return 1 for success, 2 if no server certificate is used because the ciphersuites is anonymous and 0 for failure.</p> <p>SSL_CTX_build_cert_chain() and SSL_build_cert_chain() return 1 for success and 0 for failure. If the flag SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR and a verification error occurs then 2 is returned.</p> <p>All other functions return 1 for success and 0 for failure.</p>"},{"location":"man3/SSL_CTX_add1_chain_cert/#see-also","title":"SEE ALSO","text":"<p>SSL_CTX_add_extra_chain_cert(3)</p>"},{"location":"man3/SSL_CTX_add1_chain_cert/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.2.</p>"},{"location":"man3/SSL_CTX_add_extra_chain_cert/","title":"SSL_CTX_add_extra_chain_cert","text":""},{"location":"man3/SSL_CTX_add_extra_chain_cert/#name","title":"NAME","text":"<p>SSL_CTX_add_extra_chain_cert, SSL_CTX_clear_extra_chain_certs - add or clear extra chain certificates</p>"},{"location":"man3/SSL_CTX_add_extra_chain_cert/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_CTX_add_extra_chain_cert(SSL_CTX *ctx, X509 *x509);\nlong SSL_CTX_clear_extra_chain_certs(SSL_CTX *ctx);\n</code></pre>"},{"location":"man3/SSL_CTX_add_extra_chain_cert/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_add_extra_chain_cert() adds the certificate x509 to the extra chain certificates associated with ctx. Several certificates can be added one after another.</p> <p>SSL_CTX_clear_extra_chain_certs() clears all extra chain certificates associated with ctx.</p> <p>These functions are implemented as macros.</p>"},{"location":"man3/SSL_CTX_add_extra_chain_cert/#notes","title":"NOTES","text":"<p>When sending a certificate chain, extra chain certificates are sent in order following the end entity certificate.</p> <p>If no chain is specified, the library will try to complete the chain from the available CA certificates in the trusted CA storage, see SSL_CTX_load_verify_locations(3).</p> <p>The x509 certificate provided to SSL_CTX_add_extra_chain_cert() will be freed by the library when the SSL_CTX is destroyed. An application should not free the x509 object.</p>"},{"location":"man3/SSL_CTX_add_extra_chain_cert/#restrictions","title":"RESTRICTIONS","text":"<p>Only one set of extra chain certificates can be specified per SSL_CTX structure. Different chains for different certificates (for example if both RSA and DSA certificates are specified by the same server) or different SSL structures with the same parent SSL_CTX cannot be specified using this function. For more flexibility functions such as SSL_add1_chain_cert() should be used instead.</p>"},{"location":"man3/SSL_CTX_add_extra_chain_cert/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_add_extra_chain_cert() and SSL_CTX_clear_extra_chain_certs() return 1 on success and 0 for failure. Check out the error stack to find out the reason for failure.</p>"},{"location":"man3/SSL_CTX_add_extra_chain_cert/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_use_certificate(3), SSL_CTX_set_client_cert_cb(3), SSL_CTX_load_verify_locations(3) SSL_CTX_set0_chain(3) SSL_CTX_set1_chain(3) SSL_CTX_add0_chain_cert(3) SSL_CTX_add1_chain_cert(3) SSL_set0_chain(3) SSL_set1_chain(3) SSL_add0_chain_cert(3) SSL_add1_chain_cert(3) SSL_CTX_build_cert_chain(3) SSL_build_cert_chain(3)</p>"},{"location":"man3/SSL_CTX_add_session/","title":"SSL_CTX_add_session","text":""},{"location":"man3/SSL_CTX_add_session/#name","title":"NAME","text":"<p>SSL_CTX_add_session, SSL_add_session, SSL_CTX_remove_session, SSL_remove_session - manipulate session cache</p>"},{"location":"man3/SSL_CTX_add_session/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *c);\nint SSL_add_session(SSL_CTX *ctx, SSL_SESSION *c);\n\nint SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *c);\nint SSL_remove_session(SSL_CTX *ctx, SSL_SESSION *c);\n</code></pre>"},{"location":"man3/SSL_CTX_add_session/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_add_session() adds the session c to the context ctx. The reference count for session c is incremented by 1. If a session with the same session id already exists, the old session is removed by calling SSL_SESSION_free(3).</p> <p>SSL_CTX_remove_session() removes the session c from the context ctx. SSL_SESSION_free(3) is called once for c.</p> <p>SSL_add_session() and SSL_remove_session() are synonyms for their SSL_CTX_*() counterparts.</p>"},{"location":"man3/SSL_CTX_add_session/#notes","title":"NOTES","text":"<p>When adding a new session to the internal session cache, it is examined whether a session with the same session id already exists. In this case it is assumed that both sessions are identical. If the same session is stored in a different SSL_SESSION object, The old session is removed and replaced by the new session. If the session is actually identical (the SSL_SESSION object is identical), SSL_CTX_add_session() is a no-op, and the return value is 0.</p> <p>If a server SSL_CTX is configured with the SSL_SESS_CACHE_NO_INTERNAL_STORE flag then the internal cache will not be populated automatically by new sessions negotiated by the SSL/TLS implementation, even though the internal cache will be searched automatically for session-resume requests (the latter can be suppressed by SSL_SESS_CACHE_NO_INTERNAL_LOOKUP). So the application can use SSL_CTX_add_session() directly to have full control over the sessions that can be resumed if desired.</p>"},{"location":"man3/SSL_CTX_add_session/#return-values","title":"RETURN VALUES","text":"<p>The following values are returned by all functions:</p> <ul> <li> <p>0</p> <pre><code>The operation failed. In case of the add operation, it was tried to add\nthe same (identical) session twice. In case of the remove operation, the\nsession was not found in the cache.\n</code></pre> </li> <li> <p>1</p> <pre><code>The operation succeeded.\n</code></pre> </li> </ul>"},{"location":"man3/SSL_CTX_add_session/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_session_cache_mode(3), SSL_SESSION_free(3)</p>"},{"location":"man3/SSL_CTX_ctrl/","title":"SSL_CTX_ctrl","text":""},{"location":"man3/SSL_CTX_ctrl/#name","title":"NAME","text":"<p>SSL_CTX_ctrl, SSL_CTX_callback_ctrl, SSL_ctrl, SSL_callback_ctrl - internal handling functions for SSL_CTX and SSL objects</p>"},{"location":"man3/SSL_CTX_ctrl/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg);\nlong SSL_CTX_callback_ctrl(SSL_CTX *, int cmd, void (*fp)());\n\nlong SSL_ctrl(SSL *ssl, int cmd, long larg, void *parg);\nlong SSL_callback_ctrl(SSL *, int cmd, void (*fp)());\n</code></pre>"},{"location":"man3/SSL_CTX_ctrl/#description","title":"DESCRIPTION","text":"<p>The SSL_*_ctrl() family of functions is used to manipulate settings of the SSL_CTX and SSL objects. Depending on the command cmd the arguments larg, parg, or fp are evaluated. These functions should never be called directly. All functionalities needed are made available via other functions or macros.</p>"},{"location":"man3/SSL_CTX_ctrl/#return-values","title":"RETURN VALUES","text":"<p>The return values of the SSL*_ctrl() functions depend on the command supplied via the cmd parameter.</p>"},{"location":"man3/SSL_CTX_ctrl/#see-also","title":"SEE ALSO","text":"<p>ssl(3)</p>"},{"location":"man3/SSL_CTX_flush_sessions/","title":"SSL_CTX_flush_sessions","text":""},{"location":"man3/SSL_CTX_flush_sessions/#name","title":"NAME","text":"<p>SSL_CTX_flush_sessions, SSL_flush_sessions - remove expired sessions</p>"},{"location":"man3/SSL_CTX_flush_sessions/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_flush_sessions(SSL_CTX *ctx, long tm);\nvoid SSL_flush_sessions(SSL_CTX *ctx, long tm);\n</code></pre>"},{"location":"man3/SSL_CTX_flush_sessions/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_flush_sessions() causes a run through the session cache of ctx to remove sessions expired at time tm.</p> <p>SSL_flush_sessions() is a synonym for SSL_CTX_flush_sessions().</p>"},{"location":"man3/SSL_CTX_flush_sessions/#notes","title":"NOTES","text":"<p>If enabled, the internal session cache will collect all sessions established up to the specified maximum number (see SSL_CTX_sess_set_cache_size()). As sessions will not be reused ones they are expired, they should be removed from the cache to save resources. This can either be done  automatically whenever 255 new sessions were established (see SSL_CTX_set_session_cache_mode(3)) or manually by calling SSL_CTX_flush_sessions(). </p> <p>The parameter tm specifies the time which should be used for the expiration test, in most cases the actual time given by time(0) will be used.</p> <p>SSL_CTX_flush_sessions() will only check sessions stored in the internal cache. When a session is found and removed, the remove_session_cb is however called to synchronize with the external cache (see SSL_CTX_sess_set_get_cb(3)).</p>"},{"location":"man3/SSL_CTX_flush_sessions/#return-values","title":"RETURN VALUES","text":""},{"location":"man3/SSL_CTX_flush_sessions/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_session_cache_mode(3), SSL_CTX_set_timeout(3), SSL_CTX_sess_set_get_cb(3)</p>"},{"location":"man3/SSL_CTX_free/","title":"SSL_CTX_free","text":""},{"location":"man3/SSL_CTX_free/#name","title":"NAME","text":"<p>SSL_CTX_free - free an allocated SSL_CTX object</p>"},{"location":"man3/SSL_CTX_free/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_free(SSL_CTX *ctx);\n</code></pre>"},{"location":"man3/SSL_CTX_free/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_free() decrements the reference count of ctx, and removes the SSL_CTX object pointed to by ctx and frees up the allocated memory if the the reference count has reached 0.</p> <p>It also calls the free()ing procedures for indirectly affected items, if applicable: the session cache, the list of ciphers, the list of Client CAs, the certificates and keys.</p>"},{"location":"man3/SSL_CTX_free/#warnings","title":"WARNINGS","text":"<p>If a session-remove callback is set (SSL_CTX_sess_set_remove_cb()), this callback will be called for each session being freed from ctx's session cache. This implies, that all corresponding sessions from an external session cache are removed as well. If this is not desired, the user should explicitly unset the callback by calling SSL_CTX_sess_set_remove_cb(ctx, NULL) prior to calling SSL_CTX_free().</p>"},{"location":"man3/SSL_CTX_free/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_free() does not provide diagnostic information.</p>"},{"location":"man3/SSL_CTX_free/#see-also","title":"SEE ALSO","text":"<p>SSL_CTX_new(3), ssl(3), SSL_CTX_sess_set_get_cb(3)</p>"},{"location":"man3/SSL_CTX_get0_param/","title":"SSL_CTX_get0_param","text":""},{"location":"man3/SSL_CTX_get0_param/#name","title":"NAME","text":"<p>SSL_CTX_get0_param, SSL_get0_param, SSL_CTX_set1_param, SSL_set1_param - get and set verification parameters</p>"},{"location":"man3/SSL_CTX_get0_param/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nX509_VERIFY_PARAM *SSL_CTX_get0_param(SSL_CTX *ctx)\nX509_VERIFY_PARAM *SSL_get0_param(SSL *ssl)\nint SSL_CTX_set1_param(SSL_CTX *ctx, X509_VERIFY_PARAM *vpm)\nint SSL_set1_param(SSL *ssl, X509_VERIFY_PARAM *vpm)\n</code></pre>"},{"location":"man3/SSL_CTX_get0_param/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_get0_param() and SSL_get0_param() retrieve an internal pointer to the verification parameters for ctx or ssl respectively. The returned pointer must not be freed by the calling application.</p> <p>SSL_CTX_set1_param() and SSL_set1_param() set the verification parameters to vpm for ctx or ssl.</p>"},{"location":"man3/SSL_CTX_get0_param/#notes","title":"NOTES","text":"<p>Typically parameters are retrieved from an SSL_CTX or SSL structure using SSL_CTX_get0_param() or SSL_get0_param() and an application modifies them to suit its needs: for example to add a hostname check.</p>"},{"location":"man3/SSL_CTX_get0_param/#example","title":"EXAMPLE","text":"<p>Check hostname matches \"www.foo.com\" in peer certificate:</p> <pre><code>X509_VERIFY_PARAM *vpm = SSL_get0_param(ssl);\nX509_VERIFY_PARAM_set1_host(vpm, \"www.foo.com\", 0);\n</code></pre>"},{"location":"man3/SSL_CTX_get0_param/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_get0_param() and SSL_get0_param() return a pointer to an X509_VERIFY_PARAM structure.</p> <p>SSL_CTX_set1_param() and SSL_set1_param() return 1 for success and 0 for failure.</p>"},{"location":"man3/SSL_CTX_get0_param/#see-also","title":"SEE ALSO","text":"<p>X509_VERIFY_PARAM_set_flags(3)</p>"},{"location":"man3/SSL_CTX_get0_param/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.2.</p>"},{"location":"man3/SSL_CTX_get_ex_new_index/","title":"SSL_CTX_get_ex_new_index","text":""},{"location":"man3/SSL_CTX_get_ex_new_index/#name","title":"NAME","text":"<p>SSL_CTX_get_ex_new_index, SSL_CTX_set_ex_data, SSL_CTX_get_ex_data - internal application specific data functions</p>"},{"location":"man3/SSL_CTX_get_ex_new_index/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_get_ex_new_index(long argl, void *argp,\n               CRYPTO_EX_new *new_func,\n               CRYPTO_EX_dup *dup_func,\n               CRYPTO_EX_free *free_func);\n\nint SSL_CTX_set_ex_data(SSL_CTX *ctx, int idx, void *arg);\n\nvoid *SSL_CTX_get_ex_data(const SSL_CTX *ctx, int idx);\n\ntypedef int new_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n               int idx, long argl, void *argp);\ntypedef void free_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n               int idx, long argl, void *argp);\ntypedef int dup_func(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d,\n               int idx, long argl, void *argp);\n</code></pre>"},{"location":"man3/SSL_CTX_get_ex_new_index/#description","title":"DESCRIPTION","text":"<p>Several OpenSSL structures can have application specific data attached to them. These functions are used internally by OpenSSL to manipulate application specific data attached to a specific structure.</p> <p>SSL_CTX_get_ex_new_index() is used to register a new index for application specific data.</p> <p>SSL_CTX_set_ex_data() is used to store application data at arg for idx into the ctx object.</p> <p>SSL_CTX_get_ex_data() is used to retrieve the information for idx from ctx.</p> <p>A detailed description for the *_get_ex_new_index() functionality can be found in RSA_get_ex_new_index(3). The *_get_ex_data() and *_set_ex_data() functionality is described in CRYPTO_set_ex_data(3).</p>"},{"location":"man3/SSL_CTX_get_ex_new_index/#see-also","title":"SEE ALSO","text":"<p>ssl(3), RSA_get_ex_new_index(3), CRYPTO_set_ex_data(3)</p>"},{"location":"man3/SSL_CTX_get_verify_mode/","title":"SSL_CTX_get_verify_mode","text":""},{"location":"man3/SSL_CTX_get_verify_mode/#name","title":"NAME","text":"<p>SSL_CTX_get_verify_mode, SSL_get_verify_mode, SSL_CTX_get_verify_depth, SSL_get_verify_depth, SSL_get_verify_callback, SSL_CTX_get_verify_callback - get currently set verification parameters</p>"},{"location":"man3/SSL_CTX_get_verify_mode/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_get_verify_mode(const SSL_CTX *ctx);\nint SSL_get_verify_mode(const SSL *ssl);\nint SSL_CTX_get_verify_depth(const SSL_CTX *ctx);\nint SSL_get_verify_depth(const SSL *ssl);\nint (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int, X509_STORE_CTX *);\nint (*SSL_get_verify_callback(const SSL *ssl))(int, X509_STORE_CTX *);\n</code></pre>"},{"location":"man3/SSL_CTX_get_verify_mode/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_get_verify_mode() returns the verification mode currently set in ctx.</p> <p>SSL_get_verify_mode() returns the verification mode currently set in ssl.</p> <p>SSL_CTX_get_verify_depth() returns the verification depth limit currently set in ctx. If no limit has been explicitly set, -1 is returned and the default value will be used.</p> <p>SSL_get_verify_depth() returns the verification depth limit currently set in ssl. If no limit has been explicitly set, -1 is returned and the default value will be used.</p> <p>SSL_CTX_get_verify_callback() returns a function pointer to the verification callback currently set in ctx. If no callback was explicitly set, the NULL pointer is returned and the default callback will be used.</p> <p>SSL_get_verify_callback() returns a function pointer to the verification callback currently set in ssl. If no callback was explicitly set, the NULL pointer is returned and the default callback will be used.</p>"},{"location":"man3/SSL_CTX_get_verify_mode/#return-values","title":"RETURN VALUES","text":"<p>See DESCRIPTION</p>"},{"location":"man3/SSL_CTX_get_verify_mode/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_verify(3)</p>"},{"location":"man3/SSL_CTX_load_verify_locations/","title":"SSL_CTX_load_verify_locations","text":""},{"location":"man3/SSL_CTX_load_verify_locations/#name","title":"NAME","text":"<p>SSL_CTX_load_verify_locations - set default locations for trusted CA certificates</p>"},{"location":"man3/SSL_CTX_load_verify_locations/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,\n                                  const char *CApath);\n</code></pre>"},{"location":"man3/SSL_CTX_load_verify_locations/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_load_verify_locations() specifies the locations for ctx, at which CA certificates for verification purposes are located. The certificates available via CAfile and CApath are trusted.</p>"},{"location":"man3/SSL_CTX_load_verify_locations/#notes","title":"NOTES","text":"<p>If CAfile is not NULL, it points to a file of CA certificates in PEM format. The file can contain several CA certificates identified by</p> <pre><code>-----BEGIN CERTIFICATE-----\n... (CA certificate in base64 encoding) ...\n-----END CERTIFICATE-----\n</code></pre> <p>sequences. Before, between, and after the certificates text is allowed which can be used e.g. for descriptions of the certificates.</p> <p>The CAfile is processed on execution of the SSL_CTX_load_verify_locations() function.</p> <p>If CApath is not NULL, it points to a directory containing CA certificates in PEM format. The files each contain one CA certificate. The files are looked up by the CA subject name hash value, which must hence be available. If more than one CA certificate with the same name hash value exist, the extension must be different (e.g. 9d66eef0.0, 9d66eef0.1 etc). The search is performed in the ordering of the extension number, regardless of other properties of the certificates. Use the c_rehash utility to create the necessary links.</p> <p>The certificates in CApath are only looked up when required, e.g. when building the certificate chain or when actually performing the verification of a peer certificate.</p> <p>When looking up CA certificates, the OpenSSL library will first search the certificates in CAfile, then those in CApath. Certificate matching is done based on the subject name, the key identifier (if present), and the serial number as taken from the certificate to be verified. If these data do not match, the next certificate will be tried. If a first certificate matching the parameters is found, the verification process will be performed; no other certificates for the same parameters will be searched in case of failure.</p> <p>In server mode, when requesting a client certificate, the server must send the list of CAs of which it will accept client certificates. This list is not influenced by the contents of CAfile or CApath and must explicitly be set using the SSL_CTX_set_client_CA_list(3) family of functions.</p> <p>When building its own certificate chain, an OpenSSL client/server will try to fill in missing certificates from CAfile/CApath, if the certificate chain was not explicitly specified (see SSL_CTX_add_extra_chain_cert(3), SSL_CTX_use_certificate(3).</p>"},{"location":"man3/SSL_CTX_load_verify_locations/#warnings","title":"WARNINGS","text":"<p>If several CA certificates matching the name, key identifier, and serial number condition are available, only the first one will be examined. This may lead to unexpected results if the same CA certificate is available with different expiration dates. If a \"certificate expired\" verification error occurs, no other certificate will be searched. Make sure to not have expired certificates mixed with valid ones.</p>"},{"location":"man3/SSL_CTX_load_verify_locations/#examples","title":"EXAMPLES","text":"<p>Generate a CA certificate file with descriptive text from the CA certificates ca1.pem ca2.pem ca3.pem:</p> <pre><code>#!/bin/sh\nrm CAfile.pem\nfor i in ca1.pem ca2.pem ca3.pem ; do\n  openssl x509 -in $i -text &gt;&gt; CAfile.pem\ndone\n</code></pre> <p>Prepare the directory /some/where/certs containing several CA certificates for use as CApath:</p> <pre><code>cd /some/where/certs\nc_rehash .\n</code></pre>"},{"location":"man3/SSL_CTX_load_verify_locations/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>0</p> <p>The operation failed because CAfile and CApath are NULL or the processing at one of the locations specified failed. Check the error stack to find out the reason.</p> </li> <li> <p>1</p> <p>The operation succeeded.</p> </li> </ul>"},{"location":"man3/SSL_CTX_load_verify_locations/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_client_CA_list(3), SSL_get_client_CA_list(3), SSL_CTX_use_certificate(3), SSL_CTX_add_extra_chain_cert(3), SSL_CTX_set_cert_store(3)</p>"},{"location":"man3/SSL_CTX_new/","title":"SSL_CTX_new","text":""},{"location":"man3/SSL_CTX_new/#name","title":"NAME","text":"<p>SSL_CTX_new, SSLv23_method, SSLv23_server_method, SSLv23_client_method, TLSv1_2_method, TLSv1_2_server_method, TLSv1_2_client_method, TLSv1_1_method, TLSv1_1_server_method, TLSv1_1_client_method, TLSv1_method, TLSv1_server_method, TLSv1_client_method, SSLv3_method, SSLv3_server_method, SSLv3_client_method, SSLv2_method, SSLv2_server_method, SSLv2_client_method, DTLS_method, DTLS_server_method, DTLS_client_method, DTLSv1_2_method, DTLSv1_2_server_method, DTLSv1_2_client_method, DTLSv1_method, DTLSv1_server_method, DTLSv1_client_method - create a new SSL_CTX object as framework for TLS/SSL enabled functions</p>"},{"location":"man3/SSL_CTX_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nSSL_CTX *SSL_CTX_new(const SSL_METHOD *method);\nconst SSL_METHOD *SSLv23_method(void);\nconst SSL_METHOD *SSLv23_server_method(void);\nconst SSL_METHOD *SSLv23_client_method(void);\nconst SSL_METHOD *TLSv1_2_method(void);\nconst SSL_METHOD *TLSv1_2_server_method(void);\nconst SSL_METHOD *TLSv1_2_client_method(void);\nconst SSL_METHOD *TLSv1_1_method(void);\nconst SSL_METHOD *TLSv1_1_server_method(void);\nconst SSL_METHOD *TLSv1_1_client_method(void);\nconst SSL_METHOD *TLSv1_method(void);\nconst SSL_METHOD *TLSv1_server_method(void);\nconst SSL_METHOD *TLSv1_client_method(void);\n#ifndef OPENSSL_NO_SSL3_METHOD\nconst SSL_METHOD *SSLv3_method(void);\nconst SSL_METHOD *SSLv3_server_method(void);\nconst SSL_METHOD *SSLv3_client_method(void);\n#endif\n#ifndef OPENSSL_NO_SSL2\nconst SSL_METHOD *SSLv2_method(void);\nconst SSL_METHOD *SSLv2_server_method(void);\nconst SSL_METHOD *SSLv2_client_method(void);\n#endif\n\nconst SSL_METHOD *DTLS_method(void);\nconst SSL_METHOD *DTLS_server_method(void);\nconst SSL_METHOD *DTLS_client_method(void);\nconst SSL_METHOD *DTLSv1_2_method(void);\nconst SSL_METHOD *DTLSv1_2_server_method(void);\nconst SSL_METHOD *DTLSv1_2_client_method(void);\nconst SSL_METHOD *DTLSv1_method(void);\nconst SSL_METHOD *DTLSv1_server_method(void);\nconst SSL_METHOD *DTLSv1_client_method(void);\n</code></pre>"},{"location":"man3/SSL_CTX_new/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_new() creates a new SSL_CTX object as framework to establish TLS/SSL enabled connections.</p>"},{"location":"man3/SSL_CTX_new/#notes","title":"NOTES","text":"<p>The SSL_CTX object uses method as connection method. The methods exist in a generic type (for client and server use), a server only type, and a client only type. method can be of the following types:</p> <ul> <li> <p>SSLv23_method(), SSLv23_server_method(), SSLv23_client_method()</p> <p>These are the general-purpose version-flexible SSL/TLS methods. The actual protocol version used will be negotiated to the highest version mutually supported by the client and the server. The supported protocols are SSLv2, SSLv3, TLSv1, TLSv1.1 and TLSv1.2. Most applications should use these method, and avoid the version specific methods described below.</p> <p>The list of protocols available can be further limited using the SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1 and SSL_OP_NO_TLSv1_2 options of the SSL_CTX_set_options(3) or SSL_set_options(3) functions. Clients should avoid creating \"holes\" in the set of protocols they support, when disabling a protocol, make sure that you also disable either all previous or all subsequent protocol versions. In clients, when a protocol version is disabled without disabling all previous protocol versions, the effect is to also disable all subsequent protocol versions.</p> <p>The SSLv2 and SSLv3 protocols are deprecated and should generally not be used. Applications should typically use SSL_CTX_set_options(3) in combination with the SSL_OP_NO_SSLv3 flag to disable negotiation of SSLv3 via the above version-flexible SSL/TLS methods. The SSL_OP_NO_SSLv2 option is set by default, and would need to be cleared via SSL_CTX_clear_options(3) in order to enable negotiation of SSLv2.</p> </li> <li> <p>TLSv1_2_method(), TLSv1_2_server_method(), TLSv1_2_client_method()</p> <p>A TLS/SSL connection established with these methods will only understand the TLSv1.2 protocol.  A client will send out TLSv1.2 client hello messages and will also indicate that it only understand TLSv1.2.  A server will only understand TLSv1.2 client hello messages.</p> </li> <li> <p>TLSv1_1_method(), TLSv1_1_server_method(), TLSv1_1_client_method()</p> <p>A TLS/SSL connection established with these methods will only understand the TLSv1.1 protocol.  A client will send out TLSv1.1 client hello messages and will also indicate that it only understand TLSv1.1.  A server will only understand TLSv1.1 client hello messages.</p> </li> <li> <p>TLSv1_method(), TLSv1_server_method(), TLSv1_client_method()</p> <p>A TLS/SSL connection established with these methods will only understand the TLSv1 protocol.  A client will send out TLSv1 client hello messages and will indicate that it only understands TLSv1.  A server will only understand TLSv1 client hello messages.</p> </li> <li> <p>SSLv3_method(), SSLv3_server_method(), SSLv3_client_method()</p> <p>A TLS/SSL connection established with these methods will only understand the SSLv3 protocol.  A client will send out SSLv3 client hello messages and will indicate that it only understands SSLv3.  A server will only understand SSLv3 client hello messages.  The SSLv3 protocol is deprecated and should not be used.</p> </li> <li> <p>SSLv2_method(), SSLv2_server_method(), SSLv2_client_method()</p> <p>A TLS/SSL connection established with these methods will only understand the SSLv2 protocol.  A client will send out SSLv2 client hello messages and will also indicate that it only understand SSLv2.  A server will only understand SSLv2 client hello messages.  The SSLv2 protocol offers little to no security and should not be used. As of OpenSSL 1.0.2g, EXPORT ciphers and 56-bit DES are no longer available with SSLv2.</p> </li> <li> <p>DTLS_method(), DTLS_server_method(), DTLS_client_method()</p> <p>These are the version-flexible DTLS methods.</p> </li> <li> <p>DTLSv1_2_method(), DTLSv1_2_server_method(), DTLSv1_2_client_method()</p> <p>These are the version-specific methods for DTLSv1.2.</p> </li> <li> <p>DTLSv1_method(), DTLSv1_server_method(), DTLSv1_client_method()</p> <p>These are the version-specific methods for DTLSv1.</p> </li> </ul> <p>SSL_CTX_new() initializes the list of ciphers, the session cache setting, the callbacks, the keys and certificates and the options to its default values.</p>"},{"location":"man3/SSL_CTX_new/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>NULL</p> <p>The creation of a new SSL_CTX object failed. Check the error stack to find out the reason.</p> </li> <li> <p>Pointer to an SSL_CTX object</p> <p>The return value points to an allocated SSL_CTX object.</p> </li> </ul>"},{"location":"man3/SSL_CTX_new/#see-also","title":"SEE ALSO","text":"<p>SSL_CTX_set_options(3), SSL_CTX_clear_options(3), SSL_set_options(3), SSL_CTX_free(3), SSL_accept(3), ssl(3),  SSL_set_connect_state(3)</p>"},{"location":"man3/SSL_CTX_sess_number/","title":"SSL_CTX_sess_number","text":""},{"location":"man3/SSL_CTX_sess_number/#name","title":"NAME","text":"<p>SSL_CTX_sess_number, SSL_CTX_sess_connect, SSL_CTX_sess_connect_good, SSL_CTX_sess_connect_renegotiate, SSL_CTX_sess_accept, SSL_CTX_sess_accept_good, SSL_CTX_sess_accept_renegotiate, SSL_CTX_sess_hits, SSL_CTX_sess_cb_hits, SSL_CTX_sess_misses, SSL_CTX_sess_timeouts, SSL_CTX_sess_cache_full - obtain session cache statistics</p>"},{"location":"man3/SSL_CTX_sess_number/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_CTX_sess_number(SSL_CTX *ctx);\nlong SSL_CTX_sess_connect(SSL_CTX *ctx);\nlong SSL_CTX_sess_connect_good(SSL_CTX *ctx);\nlong SSL_CTX_sess_connect_renegotiate(SSL_CTX *ctx);\nlong SSL_CTX_sess_accept(SSL_CTX *ctx);\nlong SSL_CTX_sess_accept_good(SSL_CTX *ctx);\nlong SSL_CTX_sess_accept_renegotiate(SSL_CTX *ctx);\nlong SSL_CTX_sess_hits(SSL_CTX *ctx);\nlong SSL_CTX_sess_cb_hits(SSL_CTX *ctx);\nlong SSL_CTX_sess_misses(SSL_CTX *ctx);\nlong SSL_CTX_sess_timeouts(SSL_CTX *ctx);\nlong SSL_CTX_sess_cache_full(SSL_CTX *ctx);\n</code></pre>"},{"location":"man3/SSL_CTX_sess_number/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_sess_number() returns the current number of sessions in the internal session cache.</p> <p>SSL_CTX_sess_connect() returns the number of started SSL/TLS handshakes in client mode.</p> <p>SSL_CTX_sess_connect_good() returns the number of successfully established SSL/TLS sessions in client mode.</p> <p>SSL_CTX_sess_connect_renegotiate() returns the number of start renegotiations in client mode.</p> <p>SSL_CTX_sess_accept() returns the number of started SSL/TLS handshakes in server mode.</p> <p>SSL_CTX_sess_accept_good() returns the number of successfully established SSL/TLS sessions in server mode.</p> <p>SSL_CTX_sess_accept_renegotiate() returns the number of start renegotiations in server mode.</p> <p>SSL_CTX_sess_hits() returns the number of successfully reused sessions. In client mode a session set with SSL_set_session(3) successfully reused is counted as a hit. In server mode a session successfully retrieved from internal or external cache is counted as a hit.</p> <p>SSL_CTX_sess_cb_hits() returns the number of successfully retrieved sessions from the external session cache in server mode.</p> <p>SSL_CTX_sess_misses() returns the number of sessions proposed by clients that were not found in the internal session cache in server mode.</p> <p>SSL_CTX_sess_timeouts() returns the number of sessions proposed by clients and either found in the internal or external session cache in server mode,  but that were invalid due to timeout. These sessions are not included in the SSL_CTX_sess_hits() count.</p> <p>SSL_CTX_sess_cache_full() returns the number of sessions that were removed because the maximum session cache size was exceeded.</p>"},{"location":"man3/SSL_CTX_sess_number/#return-values","title":"RETURN VALUES","text":"<p>The functions return the values indicated in the DESCRIPTION section.</p>"},{"location":"man3/SSL_CTX_sess_number/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_set_session(3), SSL_CTX_set_session_cache_mode(3) SSL_CTX_sess_set_cache_size(3)</p>"},{"location":"man3/SSL_CTX_sess_set_cache_size/","title":"SSL_CTX_sess_set_cache_size","text":""},{"location":"man3/SSL_CTX_sess_set_cache_size/#name","title":"NAME","text":"<p>SSL_CTX_sess_set_cache_size, SSL_CTX_sess_get_cache_size - manipulate session cache size</p>"},{"location":"man3/SSL_CTX_sess_set_cache_size/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_CTX_sess_set_cache_size(SSL_CTX *ctx, long t);\nlong SSL_CTX_sess_get_cache_size(SSL_CTX *ctx);\n</code></pre>"},{"location":"man3/SSL_CTX_sess_set_cache_size/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_sess_set_cache_size() sets the size of the internal session cache of context ctx to t. This value is a hint and not an absolute; see the notes below.</p> <p>SSL_CTX_sess_get_cache_size() returns the currently valid session cache size.</p>"},{"location":"man3/SSL_CTX_sess_set_cache_size/#notes","title":"NOTES","text":"<p>The internal session cache size is SSL_SESSION_CACHE_MAX_SIZE_DEFAULT, currently 1024*20, so that up to 20000 sessions can be held. This size can be modified using the SSL_CTX_sess_set_cache_size() call. A special case is the size 0, which is used for unlimited size.</p> <p>If adding the session makes the cache exceed its size, then unused sessions are dropped from the end of the cache. Cache space may also be reclaimed by calling SSL_CTX_flush_sessions(3) to remove expired sessions.</p> <p>If the size of the session cache is reduced and more sessions are already in the session cache, old session will be removed at the next time a session shall be added. This removal is not synchronized with the expiration of sessions.</p>"},{"location":"man3/SSL_CTX_sess_set_cache_size/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_sess_set_cache_size() returns the previously valid size.</p> <p>SSL_CTX_sess_get_cache_size() returns the currently valid size.</p>"},{"location":"man3/SSL_CTX_sess_set_cache_size/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_session_cache_mode(3), SSL_CTX_sess_number(3), SSL_CTX_flush_sessions(3)</p>"},{"location":"man3/SSL_CTX_sess_set_get_cb/","title":"SSL_CTX_sess_set_get_cb","text":""},{"location":"man3/SSL_CTX_sess_set_get_cb/#name","title":"NAME","text":"<p>SSL_CTX_sess_set_new_cb, SSL_CTX_sess_set_remove_cb, SSL_CTX_sess_set_get_cb, SSL_CTX_sess_get_new_cb, SSL_CTX_sess_get_remove_cb, SSL_CTX_sess_get_get_cb - provide callback functions for server side external session caching</p>"},{"location":"man3/SSL_CTX_sess_set_get_cb/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,\n                             int (*new_session_cb)(SSL *, SSL_SESSION *));\nvoid SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx,\n          void (*remove_session_cb)(SSL_CTX *ctx, SSL_SESSION *));\nvoid SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,\n          SSL_SESSION (*get_session_cb)(SSL *, unsigned char *, int, int *));\n\nint (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx))(struct ssl_st *ssl, SSL_SESSION *sess);\nvoid (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(struct ssl_ctx_st *ctx, SSL_SESSION *sess);\nSSL_SESSION *(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(struct ssl_st *ssl, unsigned char *data, int len, int *copy);\n\nint (*new_session_cb)(struct ssl_st *ssl, SSL_SESSION *sess);\nvoid (*remove_session_cb)(struct ssl_ctx_st *ctx, SSL_SESSION *sess);\nSSL_SESSION *(*get_session_cb)(struct ssl_st *ssl, unsigned char *data,\n              int len, int *copy);\n</code></pre>"},{"location":"man3/SSL_CTX_sess_set_get_cb/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_sess_set_new_cb() sets the callback function, which is automatically called whenever a new session was negotiated.</p> <p>SSL_CTX_sess_set_remove_cb() sets the callback function, which is automatically called whenever a session is removed by the SSL engine, because it is considered faulty or the session has become obsolete because of exceeding the timeout value.</p> <p>SSL_CTX_sess_set_get_cb() sets the callback function which is called, whenever a SSL/TLS client proposed to resume a session but the session could not be found in the internal session cache (see SSL_CTX_set_session_cache_mode(3)). (SSL/TLS server only.)</p> <p>SSL_CTX_sess_get_new_cb(), SSL_CTX_sess_get_remove_cb(), and SSL_CTX_sess_get_get_cb() allow to retrieve the function pointers of the provided callback functions. If a callback function has not been set, the NULL pointer is returned.</p>"},{"location":"man3/SSL_CTX_sess_set_get_cb/#notes","title":"NOTES","text":"<p>In order to allow external session caching, synchronization with the internal session cache is realized via callback functions. Inside these callback functions, session can be saved to disk or put into a database using the d2i_SSL_SESSION(3) interface.</p> <p>The new_session_cb() is called, whenever a new session has been negotiated and session caching is enabled (see SSL_CTX_set_session_cache_mode(3)). The new_session_cb() is passed the ssl connection and the ssl session sess. If the callback returns 0, the session will be immediately removed again.</p> <p>The remove_session_cb() is called, whenever the SSL engine removes a session from the internal cache. This happens when the session is removed because it is expired or when a connection was not shutdown cleanly. It also happens for all sessions in the internal session cache when SSL_CTX_free(3) is called. The remove_session_cb() is passed the ctx and the ssl session sess. It does not provide any feedback.</p> <p>The get_session_cb() is only called on SSL/TLS servers with the session id proposed by the client. The get_session_cb() is always called, also when session caching was disabled. The get_session_cb() is passed the ssl connection, the session id of length length at the memory location data. With the parameter copy the callback can require the SSL engine to increment the reference count of the SSL_SESSION object, Normally the reference count is not incremented and therefore the session must not be explicitly freed with SSL_SESSION_free(3).</p>"},{"location":"man3/SSL_CTX_sess_set_get_cb/#see-also","title":"SEE ALSO","text":"<p>ssl(3), d2i_SSL_SESSION(3), SSL_CTX_set_session_cache_mode(3), SSL_CTX_flush_sessions(3), SSL_SESSION_free(3), SSL_CTX_free(3)</p>"},{"location":"man3/SSL_CTX_sessions/","title":"SSL_CTX_sessions","text":""},{"location":"man3/SSL_CTX_sessions/#name","title":"NAME","text":"<p>SSL_CTX_sessions - access internal session cache</p>"},{"location":"man3/SSL_CTX_sessions/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nstruct lhash_st *SSL_CTX_sessions(SSL_CTX *ctx);\n</code></pre>"},{"location":"man3/SSL_CTX_sessions/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_sessions() returns a pointer to the lhash databases containing the internal session cache for ctx.</p>"},{"location":"man3/SSL_CTX_sessions/#notes","title":"NOTES","text":"<p>The sessions in the internal session cache are kept in an lhash(3) type database. It is possible to directly access this database e.g. for searching. In parallel, the sessions form a linked list which is maintained separately from the lhash(3) operations, so that the database must not be modified directly but by using the SSL_CTX_add_session(3) family of functions.</p>"},{"location":"man3/SSL_CTX_sessions/#see-also","title":"SEE ALSO","text":"<p>ssl(3), lhash(3), SSL_CTX_add_session(3), SSL_CTX_set_session_cache_mode(3)</p>"},{"location":"man3/SSL_CTX_set1_curves/","title":"SSL_CTX_set1_curves","text":""},{"location":"man3/SSL_CTX_set1_curves/#name","title":"NAME","text":"<p>SSL_CTX_set1_curves, SSL_CTX_set1_curves_list, SSL_set1_curves, SSL_set1_curves_list, SSL_get1_curves, SSL_get_shared_curve, SSL_CTX_set_ecdh_auto, SSL_set_ecdh_auto - EC supported curve functions</p>"},{"location":"man3/SSL_CTX_set1_curves/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_set1_curves(SSL_CTX *ctx, int *clist, int clistlen);\nint SSL_CTX_set1_curves_list(SSL_CTX *ctx, char *list);\n\nint SSL_set1_curves(SSL *ssl, int *clist, int clistlen);\nint SSL_set1_curves_list(SSL *ssl, char *list);\n\nint SSL_get1_curves(SSL *ssl, int *curves);\nint SSL_get_shared_curve(SSL *s, int n);\n\nint SSL_CTX_set_ecdh_auto(SSL_CTX *ctx, int onoff);\nint SSL_set_ecdh_auto(SSL *s, int onoff);\n</code></pre>"},{"location":"man3/SSL_CTX_set1_curves/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set1_curves() sets the supported curves for ctx to clistlen curves in the array clist. The array consist of all NIDs of curves in preference order. For a TLS client the curves are used directly in the supported curves extension. For a TLS server the curves are used to  determine the set of shared curves.</p> <p>SSL_CTX_set1_curves_list() sets the supported curves for ctx to string list. The string is a colon separated list of curve NIDs or names, for example \"P-521:P-384:P-256\".</p> <p>SSL_set1_curves() and SSL_set1_curves_list() are similar except they set supported curves for the SSL structure ssl.</p> <p>SSL_get1_curves() returns the set of supported curves sent by a client in the supported curves extension. It returns the total number of  supported curves. The curves parameter can be NULL to simply return the number of curves for memory allocation purposes. The curves array is in the form of a set of curve NIDs in preference order. It can return zero if the client did not send a supported curves extension.</p> <p>SSL_get_shared_curve() returns shared curve n for a server-side SSL ssl. If n is -1 then the total number of shared curves is returned, which may be zero. Other than for diagnostic purposes, most applications will only be interested in the first shared curve so n is normally set to zero. If the value n is out of range, NID_undef is returned.</p> <p>SSL_CTX_set_ecdh_auto() and SSL_set_ecdh_auto() set automatic curve selection for server ctx or ssl to onoff. If onoff is 1 then  the highest preference curve is automatically used for ECDH temporary keys used during key exchange.</p> <p>All these functions are implemented as macros.</p>"},{"location":"man3/SSL_CTX_set1_curves/#notes","title":"NOTES","text":"<p>If an application wishes to make use of several of these functions for configuration purposes either on a command line or in a file it should consider using the SSL_CONF interface instead of manually parsing options.</p> <p>The functions SSL_CTX_set_ecdh_auto() and SSL_set_ecdh_auto() can be used to make a server always choose the most appropriate curve for a client. If set it will override any temporary ECDH parameters set by a server. Previous versions of OpenSSL could effectively only use a single ECDH curve set using a function such as SSL_CTX_set_ecdh_tmp(). Newer applications should just call:</p> <pre><code>SSL_CTX_set_ecdh_auto(ctx, 1);\n</code></pre> <p>and they will automatically support ECDH using the most appropriate shared curve.</p>"},{"location":"man3/SSL_CTX_set1_curves/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set1_curves(), SSL_CTX_set1_curves_list(), SSL_set1_curves(), SSL_set1_curves_list(), SSL_CTX_set_ecdh_auto() and SSL_set_ecdh_auto() return 1 for success and 0 for failure.</p> <p>SSL_get1_curves() returns the number of curves, which may be zero.</p> <p>SSL_get_shared_curve() returns the NID of shared curve n or NID_undef if there is no shared curve n; or the total number of shared curves if n is -1.</p> <p>When called on a client ssl, SSL_get_shared_curve() has no meaning and returns -1.</p>"},{"location":"man3/SSL_CTX_set1_curves/#see-also","title":"SEE ALSO","text":"<p>SSL_CTX_add_extra_chain_cert(3)</p>"},{"location":"man3/SSL_CTX_set1_curves/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.2.</p>"},{"location":"man3/SSL_CTX_set1_verify_cert_store/","title":"SSL_CTX_set1_verify_cert_store","text":""},{"location":"man3/SSL_CTX_set1_verify_cert_store/#name","title":"NAME","text":"<p>SSL_CTX_set0_verify_cert_store, SSL_CTX_set1_verify_cert_store, SSL_CTX_set0_chain_cert_store, SSL_CTX_set1_chain_cert_store, SSL_set0_verify_cert_store, SSL_set1_verify_cert_store, SSL_set0_chain_cert_store, SSL_set1_chain_cert_store - set certificate verification or chain store</p>"},{"location":"man3/SSL_CTX_set1_verify_cert_store/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_set0_verify_cert_store(SSL_CTX *ctx, X509_STORE *st);\nint SSL_CTX_set1_verify_cert_store(SSL_CTX *ctx, X509_STORE *st);\nint SSL_CTX_set0_chain_cert_store(SSL_CTX *ctx, X509_STORE *st);\nint SSL_CTX_set1_chain_cert_store(SSL_CTX *ctx, X509_STORE *st);\n\nint SSL_set0_verify_cert_store(SSL *ctx, X509_STORE *st);\nint SSL_set1_verify_cert_store(SSL *ctx, X509_STORE *st);\nint SSL_set0_chain_cert_store(SSL *ctx, X509_STORE *st);\nint SSL_set1_chain_cert_store(SSL *ctx, X509_STORE *st);\n</code></pre>"},{"location":"man3/SSL_CTX_set1_verify_cert_store/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set0_verify_cert_store() and SSL_CTX_set1_verify_cert_store() set the certificate store used for certificate verification to st.</p> <p>SSL_CTX_set0_chain_cert_store() and SSL_CTX_set1_chain_cert_store() set the certificate store used for certificate chain building to st.</p> <p>SSL_set0_verify_cert_store(), SSL_set1_verify_cert_store(), SSL_set0_chain_cert_store() and SSL_set1_chain_cert_store() are similar except they apply to SSL structure ssl.</p> <p>All these functions are implemented as macros. Those containing a 1 increment the reference count of the supplied store so it must be freed at some point after the operation. Those containing a 0 do not increment reference counts and the supplied store MUST NOT be freed after the operation.</p>"},{"location":"man3/SSL_CTX_set1_verify_cert_store/#notes","title":"NOTES","text":"<p>The stores pointers associated with an SSL_CTX structure are copied to any SSL structures when SSL_new() is called. As a result SSL structures will not be affected if the parent SSL_CTX store pointer is set to a new value.</p> <p>The verification store is used to verify the certificate chain sent by the peer: that is an SSL/TLS client will use the verification store to verify the server's certificate chain and a SSL/TLS server will use it to verify any client certificate chain.</p> <p>The chain store is used to build the certificate chain.</p> <p>If the mode SSL_MODE_NO_AUTO_CHAIN is set or a certificate chain is configured already (for example using the functions such as  SSL_CTX_add1_chain_cert(3) or SSL_CTX_add_extra_chain_cert(3)) then automatic chain building is disabled.</p> <p>If the mode SSL_MODE_NO_AUTO_CHAIN is set then automatic chain building is disabled.</p> <p>If the chain or the verification store is not set then the store associated with the parent SSL_CTX is used instead to retain compatibility with previous versions of OpenSSL.</p>"},{"location":"man3/SSL_CTX_set1_verify_cert_store/#return-values","title":"RETURN VALUES","text":"<p>All these functions return 1 for success and 0 for failure.</p>"},{"location":"man3/SSL_CTX_set1_verify_cert_store/#see-also","title":"SEE ALSO","text":"<p>SSL_CTX_add_extra_chain_cert(3) SSL_CTX_set0_chain(3) SSL_CTX_set1_chain(3) SSL_CTX_add0_chain_cert(3) SSL_CTX_add1_chain_cert(3) SSL_set0_chain(3) SSL_set1_chain(3) SSL_add0_chain_cert(3) SSL_add1_chain_cert(3) SSL_CTX_build_cert_chain(3) SSL_build_cert_chain(3)</p>"},{"location":"man3/SSL_CTX_set1_verify_cert_store/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 1.0.2.</p>"},{"location":"man3/SSL_CTX_set_alpn_select_cb/","title":"SSL_CTX_set_alpn_select_cb","text":""},{"location":"man3/SSL_CTX_set_alpn_select_cb/#name","title":"NAME","text":"<p>SSL_CTX_set_alpn_protos, SSL_set_alpn_protos, SSL_CTX_set_alpn_select_cb, SSL_select_next_proto, SSL_get0_alpn_selected - handle application layer protocol negotiation (ALPN)</p>"},{"location":"man3/SSL_CTX_set_alpn_select_cb/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_set_alpn_protos(SSL_CTX *ctx, const unsigned char *protos,\n                            unsigned protos_len);\nint SSL_set_alpn_protos(SSL *ssl, const unsigned char *protos,\n                        unsigned protos_len);\nvoid SSL_CTX_set_alpn_select_cb(SSL_CTX *ctx,\n                                int (*cb) (SSL *ssl,\n                                           const unsigned char **out,\n                                           unsigned char *outlen,\n                                           const unsigned char *in,\n                                           unsigned int inlen,\n                                           void *arg), void *arg);\nint SSL_select_next_proto(unsigned char **out, unsigned char *outlen,\n                          const unsigned char *server,\n                          unsigned int server_len,\n                          const unsigned char *client,\n                          unsigned int client_len)\nvoid SSL_get0_alpn_selected(const SSL *ssl, const unsigned char **data,\n                            unsigned int *len);\n</code></pre>"},{"location":"man3/SSL_CTX_set_alpn_select_cb/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_alpn_protos() and SSL_set_alpn_protos() are used by the client to set the list of protocols available to be negotiated. The protos must be in protocol-list format, described below. The length of protos is specified in protos_len.</p> <p>SSL_CTX_set_alpn_select_cb() sets the application callback cb used by a server to select which protocol to use for the incoming connection. When cb is NULL, ALPN is not used. The arg value is a pointer which is passed to the application callback.</p> <p>cb is the application defined callback. The in, inlen parameters are a vector in protocol-list format. The value of the out, outlen vector should be set to the value of a single protocol selected from the in, inlen vector. The arg parameter is the pointer set via SSL_CTX_set_alpn_select_cb().</p> <p>SSL_select_next_proto() is a helper function used to select protocols. It implements the standard protocol selection. It is expected that this function is called from the application callback cb. The protocol data in server, server_len and client, client_len must be in the protocol-list format described below. The first item in the server, server_len list that matches an item in the client, client_len list is selected, and returned in out, outlen. The out value will point into either server or client, so it should be copied immediately. If no match is found, the first item in client, client_len is returned in out, outlen. This function can also be used in the NPN callback.</p> <p>SSL_get0_alpn_selected() returns a pointer to the selected protocol in data with length len. It is not NUL-terminated. data is set to NULL and len is set to 0 if no protocol has been selected. data must not be freed.</p>"},{"location":"man3/SSL_CTX_set_alpn_select_cb/#notes","title":"NOTES","text":"<p>The protocol-lists must be in wire-format, which is defined as a vector of non-empty, 8-bit length-prefixed, byte strings. The length-prefix byte is not included in the length. Each string is limited to 255 bytes. A byte-string length of 0 is invalid. A truncated byte-string is invalid. The length of the vector is not in the vector itself, but in a separate variable.</p> <p>Example:</p> <pre><code>unsigned char vector[] = {\n    6, 's', 'p', 'd', 'y', '/', '1',\n    8, 'h', 't', 't', 'p', '/', '1', '.', '1'\n};\nunsigned int length = sizeof(vector);\n</code></pre> <p>The ALPN callback is executed after the servername callback; as that servername callback may update the SSL_CTX, and subsequently, the ALPN callback.</p> <p>If there is no ALPN proposed in the ClientHello, the ALPN callback is not invoked.</p>"},{"location":"man3/SSL_CTX_set_alpn_select_cb/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_alpn_protos() and SSL_set_alpn_protos() return 0 on success, and non-0 on failure. WARNING: these functions reverse the return value convention.</p> <p>SSL_select_next_proto() returns one of the following:</p> <ul> <li> <p>OPENSSL_NPN_NEGOTIATED</p> <p>A match was found and is returned in out, outlen.</p> </li> <li> <p>OPENSSL_NPN_NO_OVERLAP</p> <p>No match was found. The first item in client, client_len is returned in out, outlen.</p> </li> </ul> <p>The ALPN select callback cb, must return one of the following:</p> <ul> <li> <p>SSL_TLSEXT_ERR_OK</p> <p>ALPN protocol selected.</p> </li> <li> <p>SSL_TLSEXT_ERR_NOACK</p> <p>ALPN protocol not selected.</p> </li> </ul>"},{"location":"man3/SSL_CTX_set_alpn_select_cb/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_tlsext_servername_callback(3), SSL_CTX_set_tlsext_servername_arg(3)</p>"},{"location":"man3/SSL_CTX_set_cert_cb/","title":"SSL_CTX_set_cert_cb","text":""},{"location":"man3/SSL_CTX_set_cert_cb/#name","title":"NAME","text":"<p>SSL_CTX_set_cert_cb, SSL_set_cert_cb - handle certificate callback function</p>"},{"location":"man3/SSL_CTX_set_cert_cb/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_cert_cb(SSL_CTX *c, int (*cert_cb)(SSL *ssl, void *arg), void *arg);\nvoid SSL_set_cert_cb(SSL *s, int (*cert_cb)(SSL *ssl, void *arg), void *arg);\n\nint (*cert_cb)(SSL *ssl, void *arg);\n</code></pre>"},{"location":"man3/SSL_CTX_set_cert_cb/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_cert_cb() and SSL_set_cert_cb() sets the cert_cb() callback, arg value is pointer which is passed to the application callback.</p> <p>When cert_cb() is NULL, no callback function is used.</p> <p>cert_cb() is the application defined callback. It is called before a certificate will be used by a client or server. The callback can then inspect the passed ssl structure and set or clear any appropriate certificates. If the callback is successful it MUST return 1 even if no certificates have been set. A zero is returned on error which will abort the handshake with a fatal internal error alert. A negative return value will suspend the handshake and the handshake function will return immediately. SSL_get_error(3) will return SSL_ERROR_WANT_X509_LOOKUP to indicate, that the handshake was suspended. The next call to the handshake function will again lead to the call of cert_cb(). It is the job of the cert_cb() to store information about the state of the last call, if required to continue.</p>"},{"location":"man3/SSL_CTX_set_cert_cb/#notes","title":"NOTES","text":"<p>An application will typically call SSL_use_certificate() and SSL_use_PrivateKey() to set the end entity certificate and private key. It can add intermediate and optionally the root CA certificates using SSL_add1_chain_cert().</p> <p>It might also call SSL_certs_clear() to delete any certificates associated with the SSL object.</p> <p>The certificate callback functionality supercedes the (largely broken) functionality provided by the old client certificate callback interface. It is always called even is a certificate is already set so the callback can modify or delete the existing certificate.</p> <p>A more advanced callback might examine the handshake parameters and set whatever chain is appropriate. For example a legacy client supporting only TLS v1.0 might receive a certificate chain signed using SHA1 whereas a TLS v1.2 client which advertises support for SHA256 could receive a chain using SHA256.</p> <p>Normal server sanity checks are performed on any certificates set by the callback. So if an EC chain is set for a curve the client does not support it will not be used.</p>"},{"location":"man3/SSL_CTX_set_cert_cb/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_use_certificate(3), SSL_add1_chain_cert(3), SSL_get_client_CA_list(3), SSL_clear(3), SSL_free(3)</p>"},{"location":"man3/SSL_CTX_set_cert_store/","title":"SSL_CTX_set_cert_store","text":""},{"location":"man3/SSL_CTX_set_cert_store/#name","title":"NAME","text":"<p>SSL_CTX_set_cert_store, SSL_CTX_get_cert_store - manipulate X509 certificate verification storage</p>"},{"location":"man3/SSL_CTX_set_cert_store/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_cert_store(SSL_CTX *ctx, X509_STORE *store);\nX509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *ctx);\n</code></pre>"},{"location":"man3/SSL_CTX_set_cert_store/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_cert_store() sets/replaces the certificate verification storage of ctx to/with store. If another X509_STORE object is currently set in ctx, it will be X509_STORE_free()ed.</p> <p>SSL_CTX_get_cert_store() returns a pointer to the current certificate verification storage.</p>"},{"location":"man3/SSL_CTX_set_cert_store/#notes","title":"NOTES","text":"<p>In order to verify the certificates presented by the peer, trusted CA certificates must be accessed. These CA certificates are made available via lookup methods, handled inside the X509_STORE. From the X509_STORE the X509_STORE_CTX used when verifying certificates is created.</p> <p>Typically the trusted certificate store is handled indirectly via using SSL_CTX_load_verify_locations(3). Using the SSL_CTX_set_cert_store() and SSL_CTX_get_cert_store() functions it is possible to manipulate the X509_STORE object beyond the SSL_CTX_load_verify_locations(3) call.</p> <p>Currently no detailed documentation on how to use the X509_STORE object is available. Not all members of the X509_STORE are used when the verification takes place. So will e.g. the verify_callback() be overridden with the verify_callback() set via the SSL_CTX_set_verify(3) family of functions. This document must therefore be updated when documentation about the X509_STORE object and its handling becomes available.</p>"},{"location":"man3/SSL_CTX_set_cert_store/#restrictions","title":"RESTRICTIONS","text":"<p>The X509_STORE structure used by an SSL_CTX is used for verifying peer certificates and building certificate chains, it is also shared by every child SSL structure. Applications wanting finer control can use  functions such as SSL_CTX_set1_verify_cert_store() instead.</p>"},{"location":"man3/SSL_CTX_set_cert_store/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_cert_store() does not return diagnostic output.</p> <p>SSL_CTX_get_cert_store() returns the current setting.</p>"},{"location":"man3/SSL_CTX_set_cert_store/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_load_verify_locations(3), SSL_CTX_set_verify(3)</p>"},{"location":"man3/SSL_CTX_set_cert_verify_callback/","title":"SSL_CTX_set_cert_verify_callback","text":""},{"location":"man3/SSL_CTX_set_cert_verify_callback/#name","title":"NAME","text":"<p>SSL_CTX_set_cert_verify_callback - set peer certificate verification procedure</p>"},{"location":"man3/SSL_CTX_set_cert_verify_callback/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*callback)(X509_STORE_CTX *,void *), void *arg);\n</code></pre>"},{"location":"man3/SSL_CTX_set_cert_verify_callback/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_cert_verify_callback() sets the verification callback function for ctx. SSL objects that are created from ctx inherit the setting valid at the time when SSL_new(3) is called.</p>"},{"location":"man3/SSL_CTX_set_cert_verify_callback/#notes","title":"NOTES","text":"<p>Whenever a certificate is verified during a SSL/TLS handshake, a verification function is called. If the application does not explicitly specify a verification callback function, the built-in verification function is used. If a verification callback callback is specified via SSL_CTX_set_cert_verify_callback(), the supplied callback function is called instead. By setting callback to NULL, the default behaviour is restored.</p> <p>When the verification must be performed, callback will be called with the arguments callback(X509_STORE_CTX *x509_store_ctx, void *arg). The  argument arg is specified by the application when setting callback.</p> <p>callback should return 1 to indicate verification success and 0 to indicate verification failure. If SSL_VERIFY_PEER is set and callback returns 0, the handshake will fail. As the verification procedure may allow to continue the connection in case of failure (by always returning 1) the verification result must be set in any case using the error member of x509_store_ctx so that the calling application will be informed about the detailed result of the verification procedure! </p> <p>Within x509_store_ctx, callback has access to the verify_callback function set using SSL_CTX_set_verify(3).</p>"},{"location":"man3/SSL_CTX_set_cert_verify_callback/#warnings","title":"WARNINGS","text":"<p>Do not mix the verification callback described in this function with the verify_callback function called during the verification process. The latter is set using the SSL_CTX_set_verify(3) family of functions.</p> <p>Providing a complete verification procedure including certificate purpose settings etc is a complex task. The built-in procedure is quite powerful and in most cases it should be sufficient to modify its behaviour using the verify_callback function.</p>"},{"location":"man3/SSL_CTX_set_cert_verify_callback/#bugs","title":"BUGS","text":""},{"location":"man3/SSL_CTX_set_cert_verify_callback/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_cert_verify_callback() does not provide diagnostic information.</p>"},{"location":"man3/SSL_CTX_set_cert_verify_callback/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_verify(3), SSL_get_verify_result(3), SSL_CTX_load_verify_locations(3)</p>"},{"location":"man3/SSL_CTX_set_cert_verify_callback/#history","title":"HISTORY","text":"<p>Previous to OpenSSL 0.9.7, the arg argument to SSL_CTX_set_cert_verify_callback was ignored, and callback was called simply as  int (*callback)(X509_STORE_CTX *) To compile software written for previous versions of OpenSSL, a dummy argument will have to be added to callback.</p>"},{"location":"man3/SSL_CTX_set_cipher_list/","title":"SSL_CTX_set_cipher_list","text":""},{"location":"man3/SSL_CTX_set_cipher_list/#name","title":"NAME","text":"<p>SSL_CTX_set_cipher_list, SSL_set_cipher_list - choose list of available SSL_CIPHERs</p>"},{"location":"man3/SSL_CTX_set_cipher_list/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str);\nint SSL_set_cipher_list(SSL *ssl, const char *str);\n</code></pre>"},{"location":"man3/SSL_CTX_set_cipher_list/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_cipher_list() sets the list of available ciphers for ctx using the control string str. The format of the string is described in ciphers(1). The list of ciphers is inherited by all ssl objects created from ctx.</p> <p>SSL_set_cipher_list() sets the list of ciphers only for ssl.</p>"},{"location":"man3/SSL_CTX_set_cipher_list/#notes","title":"NOTES","text":"<p>The control string str should be universally usable and not depend on details of the library configuration (ciphers compiled in). Thus no syntax checking takes place. Items that are not recognized, because the corresponding ciphers are not compiled in or because they are mistyped, are simply ignored. Failure is only flagged if no ciphers could be collected at all.</p> <p>It should be noted, that inclusion of a cipher to be used into the list is a necessary condition. On the client side, the inclusion into the list is also sufficient. On the server side, additional restrictions apply. All ciphers have additional requirements. ADH ciphers don't need a certificate, but DH-parameters must have been set. All other ciphers need a corresponding certificate and key.</p> <p>A RSA cipher can only be chosen, when a RSA certificate is available. RSA export ciphers with a keylength of 512 bits for the RSA key require a temporary 512 bit RSA key, as typically the supplied key has a length of 1024 bit (see SSL_CTX_set_tmp_rsa_callback(3)). RSA ciphers using DHE need a certificate and key and additional DH-parameters (see SSL_CTX_set_tmp_dh_callback(3)).</p> <p>A DSA cipher can only be chosen, when a DSA certificate is available. DSA ciphers always use DH key exchange and therefore need DH-parameters (see SSL_CTX_set_tmp_dh_callback(3)).</p> <p>When these conditions are not met for any cipher in the list (e.g. a client only supports export RSA ciphers with a asymmetric key length of 512 bits and the server is not configured to use temporary RSA keys), the \"no shared cipher\" (SSL_R_NO_SHARED_CIPHER) error is generated and the handshake will fail.</p> <p>If the cipher list does not contain any SSLv2 cipher suites (this is the default) then SSLv2 is effectively disabled and neither clients nor servers will attempt to use SSLv2.</p>"},{"location":"man3/SSL_CTX_set_cipher_list/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_cipher_list() and SSL_set_cipher_list() return 1 if any cipher could be selected and 0 on complete failure.</p>"},{"location":"man3/SSL_CTX_set_cipher_list/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_get_ciphers(3), SSL_CTX_use_certificate(3), SSL_CTX_set_tmp_rsa_callback(3), SSL_CTX_set_tmp_dh_callback(3), ciphers(1)</p>"},{"location":"man3/SSL_CTX_set_client_CA_list/","title":"SSL_CTX_set_client_CA_list","text":""},{"location":"man3/SSL_CTX_set_client_CA_list/#name","title":"NAME","text":"<p>SSL_CTX_set_client_CA_list, SSL_set_client_CA_list, SSL_CTX_add_client_CA, SSL_add_client_CA - set list of CAs sent to the client when requesting a client certificate</p>"},{"location":"man3/SSL_CTX_set_client_CA_list/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_client_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *list);\nvoid SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *list);\nint SSL_CTX_add_client_CA(SSL_CTX *ctx, X509 *cacert);\nint SSL_add_client_CA(SSL *ssl, X509 *cacert);\n</code></pre>"},{"location":"man3/SSL_CTX_set_client_CA_list/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_client_CA_list() sets the list of CAs sent to the client when requesting a client certificate for ctx.</p> <p>SSL_set_client_CA_list() sets the list of CAs sent to the client when requesting a client certificate for the chosen ssl, overriding the setting valid for ssl's SSL_CTX object.</p> <p>SSL_CTX_add_client_CA() adds the CA name extracted from cacert to the list of CAs sent to the client when requesting a client certificate for ctx.</p> <p>SSL_add_client_CA() adds the CA name extracted from cacert to the list of CAs sent to the client when requesting a client certificate for the chosen ssl, overriding the setting valid for ssl's SSL_CTX object.</p>"},{"location":"man3/SSL_CTX_set_client_CA_list/#notes","title":"NOTES","text":"<p>When a TLS/SSL server requests a client certificate (see SSL_CTX_set_verify(3)), it sends a list of CAs, for which it will accept certificates, to the client.</p> <p>This list must explicitly be set using SSL_CTX_set_client_CA_list() for ctx and SSL_set_client_CA_list() for the specific ssl. The list specified overrides the previous setting. The CAs listed do not become trusted (list only contains the names, not the complete certificates); use SSL_CTX_load_verify_locations(3)  to additionally load them for verification.</p> <p>If the list of acceptable CAs is compiled in a file, the SSL_load_client_CA_file(3) function can be used to help importing the necessary data.</p> <p>SSL_CTX_add_client_CA() and SSL_add_client_CA() can be used to add additional items the list of client CAs. If no list was specified before using SSL_CTX_set_client_CA_list() or SSL_set_client_CA_list(), a new client CA list for ctx or ssl (as appropriate) is opened.</p> <p>These functions are only useful for TLS/SSL servers.</p>"},{"location":"man3/SSL_CTX_set_client_CA_list/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_client_CA_list() and SSL_set_client_CA_list() do not return diagnostic information.</p> <p>SSL_CTX_add_client_CA() and SSL_add_client_CA() have the following return values:</p> <ul> <li> <p>0</p> <p>A failure while manipulating the STACK_OF(X509_NAME) object occurred or the X509_NAME could not be extracted from cacert. Check the error stack to find out the reason.</p> </li> <li> <p>1</p> <p>The operation succeeded.</p> </li> </ul>"},{"location":"man3/SSL_CTX_set_client_CA_list/#examples","title":"EXAMPLES","text":"<p>Scan all certificates in CAfile and list them as acceptable CAs:</p> <pre><code>SSL_CTX_set_client_CA_list(ctx,SSL_load_client_CA_file(CAfile));\n</code></pre>"},{"location":"man3/SSL_CTX_set_client_CA_list/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_get_client_CA_list(3), SSL_load_client_CA_file(3), SSL_CTX_load_verify_locations(3)</p>"},{"location":"man3/SSL_CTX_set_client_cert_cb/","title":"SSL_CTX_set_client_cert_cb","text":""},{"location":"man3/SSL_CTX_set_client_cert_cb/#name","title":"NAME","text":"<p>SSL_CTX_set_client_cert_cb, SSL_CTX_get_client_cert_cb - handle client certificate callback function</p>"},{"location":"man3/SSL_CTX_set_client_cert_cb/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_client_cert_cb(SSL_CTX *ctx, int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey));\nint (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))(SSL *ssl, X509 **x509, EVP_PKEY **pkey);\nint (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey);\n</code></pre>"},{"location":"man3/SSL_CTX_set_client_cert_cb/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_client_cert_cb() sets the client_cert_cb() callback, that is called when a client certificate is requested by a server and no certificate was yet set for the SSL object.</p> <p>When client_cert_cb() is NULL, no callback function is used.</p> <p>SSL_CTX_get_client_cert_cb() returns a pointer to the currently set callback function.</p> <p>client_cert_cb() is the application defined callback. If it wants to set a certificate, a certificate/private key combination must be set using the x509 and pkey arguments and \"1\" must be returned. The certificate will be installed into ssl, see the NOTES and BUGS sections. If no certificate should be set, \"0\" has to be returned and no certificate will be sent. A negative return value will suspend the handshake and the handshake function will return immediately. SSL_get_error(3) will return SSL_ERROR_WANT_X509_LOOKUP to indicate, that the handshake was suspended. The next call to the handshake function will again lead to the call of client_cert_cb(). It is the job of the client_cert_cb() to store information about the state of the last call, if required to continue.</p>"},{"location":"man3/SSL_CTX_set_client_cert_cb/#notes","title":"NOTES","text":"<p>During a handshake (or renegotiation) a server may request a certificate from the client. A client certificate must only be sent, when the server did send the request.</p> <p>When a certificate was set using the SSL_CTX_use_certificate(3) family of functions, it will be sent to the server. The TLS standard requires that only a certificate is sent, if it matches the list of acceptable CAs sent by the server. This constraint is violated by the default behavior of the OpenSSL library. Using the callback function it is possible to implement a proper selection routine or to allow a user interaction to choose the certificate to be sent.</p> <p>If a callback function is defined and no certificate was yet defined for the SSL object, the callback function will be called. If the callback function returns a certificate, the OpenSSL library will try to load the private key and certificate data into the SSL object using the SSL_use_certificate() and SSL_use_private_key() functions. Thus it will permanently install the certificate and key for this SSL object. It will not be reset by calling SSL_clear(3). If the callback returns no certificate, the OpenSSL library will not send a certificate.</p>"},{"location":"man3/SSL_CTX_set_client_cert_cb/#bugs","title":"BUGS","text":"<p>The client_cert_cb() cannot return a complete certificate chain, it can only return one client certificate. If the chain only has a length of 2, the root CA certificate may be omitted according to the TLS standard and thus a standard conforming answer can be sent to the server. For a longer chain, the client must send the complete chain (with the option to leave out the root CA certificate). This can only be accomplished by either adding the intermediate CA certificates into the trusted certificate store for the SSL_CTX object (resulting in having to add CA certificates that otherwise maybe would not be trusted), or by adding the chain certificates using the SSL_CTX_add_extra_chain_cert(3) function, which is only available for the SSL_CTX object as a whole and that therefore probably can only apply for one client certificate, making the concept of the callback function (to allow the choice from several certificates) questionable.</p> <p>Once the SSL object has been used in conjunction with the callback function, the certificate will be set for the SSL object and will not be cleared even when SSL_clear(3) is being called. It is therefore mandatory to destroy the SSL object using SSL_free(3) and create a new one to return to the previous state.</p>"},{"location":"man3/SSL_CTX_set_client_cert_cb/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_use_certificate(3), SSL_CTX_add_extra_chain_cert(3), SSL_get_client_CA_list(3), SSL_clear(3), SSL_free(3)</p>"},{"location":"man3/SSL_CTX_set_custom_cli_ext/","title":"SSL_CTX_set_custom_cli_ext","text":""},{"location":"man3/SSL_CTX_set_custom_cli_ext/#name","title":"NAME","text":"<p>SSL_CTX_add_client_custom_ext, SSL_CTX_add_server_custom_ext - custom TLS extension handling</p>"},{"location":"man3/SSL_CTX_set_custom_cli_ext/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_add_client_custom_ext(SSL_CTX *ctx, unsigned int ext_type,\n                                  custom_ext_add_cb add_cb,\n                                  custom_ext_free_cb free_cb, void *add_arg,\n                                  custom_ext_parse_cb parse_cb,\n                                  void *parse_arg);\n\nint SSL_CTX_add_server_custom_ext(SSL_CTX *ctx, unsigned int ext_type,\n                                  custom_ext_add_cb add_cb,\n                                  custom_ext_free_cb free_cb, void *add_arg,\n                                  custom_ext_parse_cb parse_cb,\n                                  void *parse_arg);\n\nint SSL_extension_supported(unsigned int ext_type);\n\ntypedef int (*custom_ext_add_cb)(SSL *s, unsigned int ext_type,\n                                 const unsigned char **out,\n                                 size_t *outlen, int *al,\n                                 void *add_arg);\n\ntypedef void (*custom_ext_free_cb)(SSL *s, unsigned int ext_type,\n                                   const unsigned char *out,\n                                   void *add_arg);\n\ntypedef int (*custom_ext_parse_cb)(SSL *s, unsigned int ext_type,\n                                   const unsigned char *in,\n                                   size_t inlen, int *al,\n                                   void *parse_arg);\n</code></pre>"},{"location":"man3/SSL_CTX_set_custom_cli_ext/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_add_client_custom_ext() adds a custom extension for a TLS client  with extension type ext_type and callbacks add_cb, free_cb and parse_cb.</p> <p>SSL_CTX_add_server_custom_ext() adds a custom extension for a TLS server  with extension type ext_type and callbacks add_cb, free_cb and parse_cb.</p> <p>In both cases the extension type must not be handled by OpenSSL internally or an error occurs.</p> <p>SSL_extension_supported() returns 1 if the extension ext_type is handled internally by OpenSSL and 0 otherwise.</p>"},{"location":"man3/SSL_CTX_set_custom_cli_ext/#extension-callbacks","title":"EXTENSION CALLBACKS","text":"<p>The callback add_cb is called to send custom extension data to be  included in ClientHello for TLS clients or ServerHello for servers. The ext_type parameter is set to the extension type which will be added and add_arg to the value set when the extension handler was added.</p> <p>If the application wishes to include the extension ext_type it should set *out to the extension data, set *outlen to the length of the extension data and return 1.</p> <p>If the add_cb does not wish to include the extension it must return 0.</p> <p>If add_cb returns -1 a fatal handshake error occurs using the TLS alert value specified in *al.</p> <p>For clients (but not servers) if add_cb is set to NULL a zero length extension is added for ext_type.</p> <p>For clients every registered add_cb is always called to see if the application wishes to add an extension to ClientHello.</p> <p>For servers every registered add_cb is called once if and only if the corresponding extension was received in ClientHello to see if the application wishes to add the extension to ServerHello. That is, if no corresponding extension was received in ClientHello then add_cb will not be called.</p> <p>If an extension is added (that is add_cb returns 1) free_cb is called (if it is set) with the value of out set by the add callback. It can be used to free up any dynamic extension data set by add_cb. Since out is constant (to permit use of constant data in add_cb) applications may need to cast away const to free the data.</p> <p>The callback parse_cb receives data for TLS extensions. For TLS clients the extension data will come from ServerHello and for TLS servers it will come from ClientHello.</p> <p>The extension data consists of inlen bytes in the buffer in for the extension extension_type.</p> <p>If the parse_cb considers the extension data acceptable it must return 1. If it returns 0 or a negative value a fatal handshake error occurs using the TLS alert value specified in *al.</p> <p>The buffer in is a temporary internal buffer which will not be valid after the callback returns.</p>"},{"location":"man3/SSL_CTX_set_custom_cli_ext/#notes","title":"NOTES","text":"<p>The add_arg and parse_arg parameters can be set to arbitrary values which will be passed to the corresponding callbacks. They can, for example, be used to store the extension data received in a convenient structure or pass the extension data to be added or freed when adding extensions.</p> <p>The ext_type parameter corresponds to the extension_type field of RFC5246 et al. It is not a NID.</p> <p>If the same custom extension type is received multiple times a fatal decode_error alert is sent and the handshake aborts. If a custom extension is received in ServerHello which was not sent in ClientHello a fatal unsupported_extension alert is sent and the handshake is aborted. The ServerHello add_cb callback is only called if the corresponding extension was received in ClientHello. This is compliant with the TLS specifications. This behaviour ensures that each callback is called at most once and that an application can never send unsolicited extensions.</p>"},{"location":"man3/SSL_CTX_set_custom_cli_ext/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_add_client_custom_ext() and SSL_CTX_add_server_custom_ext() return 1 for success and 0 for failure. A failure can occur if an attempt is made to add the same ext_type more than once, if an attempt is made to use an extension type handled internally by OpenSSL or if an internal error occurs (for example a memory allocation failure).</p> <p>SSL_extension_supported() returns 1 if the extension ext_type is handled internally by OpenSSL and 0 otherwise.</p>"},{"location":"man3/SSL_CTX_set_default_passwd_cb/","title":"SSL_CTX_set_default_passwd_cb","text":""},{"location":"man3/SSL_CTX_set_default_passwd_cb/#name","title":"NAME","text":"<p>SSL_CTX_set_default_passwd_cb, SSL_CTX_set_default_passwd_cb_userdata - set passwd callback for encrypted PEM file handling</p>"},{"location":"man3/SSL_CTX_set_default_passwd_cb/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb);\nvoid SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx, void *u);\n\nint pem_passwd_cb(char *buf, int size, int rwflag, void *userdata);\n</code></pre>"},{"location":"man3/SSL_CTX_set_default_passwd_cb/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_default_passwd_cb() sets the default password callback called when loading/storing a PEM certificate with encryption.</p> <p>SSL_CTX_set_default_passwd_cb_userdata() sets a pointer to userdata which will be provided to the password callback on invocation.</p> <p>The pem_passwd_cb(), which must be provided by the application, hands back the password to be used during decryption. On invocation a pointer to userdata is provided. The pem_passwd_cb must write the password into the provided buffer buf which is of size size. The actual length of the password must be returned to the calling function. rwflag indicates whether the callback is used for reading/decryption (rwflag=0) or writing/encryption (rwflag=1).</p>"},{"location":"man3/SSL_CTX_set_default_passwd_cb/#notes","title":"NOTES","text":"<p>When loading or storing private keys, a password might be supplied to protect the private key. The way this password can be supplied may depend on the application. If only one private key is handled, it can be practical to have pem_passwd_cb() handle the password dialog interactively. If several keys have to be handled, it can be practical to ask for the password once, then keep it in memory and use it several times. In the last case, the password could be stored into the userdata storage and the pem_passwd_cb() only returns the password already stored.</p> <p>When asking for the password interactively, pem_passwd_cb() can use rwflag to check, whether an item shall be encrypted (rwflag=1). In this case the password dialog may ask for the same password twice for comparison in order to catch typos, that would make decryption impossible.</p> <p>Other items in PEM formatting (certificates) can also be encrypted, it is however not usual, as certificate information is considered public.</p>"},{"location":"man3/SSL_CTX_set_default_passwd_cb/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_default_passwd_cb() and SSL_CTX_set_default_passwd_cb_userdata() do not provide diagnostic information.</p>"},{"location":"man3/SSL_CTX_set_default_passwd_cb/#examples","title":"EXAMPLES","text":"<p>The following example returns the password provided as userdata to the calling function. The password is considered to be a '\\0' terminated string. If the password does not fit into the buffer, the password is truncated.</p> <pre><code>int pem_passwd_cb(char *buf, int size, int rwflag, void *password)\n{\n strncpy(buf, (char *)(password), size);\n buf[size - 1] = '\\0';\n return(strlen(buf));\n}\n</code></pre>"},{"location":"man3/SSL_CTX_set_default_passwd_cb/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_use_certificate(3)</p>"},{"location":"man3/SSL_CTX_set_generate_session_id/","title":"SSL_CTX_set_generate_session_id","text":""},{"location":"man3/SSL_CTX_set_generate_session_id/#name","title":"NAME","text":"<p>SSL_CTX_set_generate_session_id, SSL_set_generate_session_id, SSL_has_matching_session_id - manipulate generation of SSL session IDs (server only)</p>"},{"location":"man3/SSL_CTX_set_generate_session_id/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\ntypedef int (*GEN_SESSION_CB)(const SSL *ssl, unsigned char *id,\n                              unsigned int *id_len);\n\nint SSL_CTX_set_generate_session_id(SSL_CTX *ctx, GEN_SESSION_CB cb);\nint SSL_set_generate_session_id(SSL *ssl, GEN_SESSION_CB, cb);\nint SSL_has_matching_session_id(const SSL *ssl, const unsigned char *id,\n                                unsigned int id_len);\n</code></pre>"},{"location":"man3/SSL_CTX_set_generate_session_id/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_generate_session_id() sets the callback function for generating new session ids for SSL/TLS sessions for ctx to be cb.</p> <p>SSL_set_generate_session_id() sets the callback function for generating new session ids for SSL/TLS sessions for ssl to be cb.</p> <p>SSL_has_matching_session_id() checks, whether a session with id id (of length id_len) is already contained in the internal session cache of the parent context of ssl.</p>"},{"location":"man3/SSL_CTX_set_generate_session_id/#notes","title":"NOTES","text":"<p>When a new session is established between client and server, the server generates a session id. The session id is an arbitrary sequence of bytes. The length of the session id is 16 bytes for SSLv2 sessions and between 1 and 32 bytes for SSLv3/TLSv1. The session id is not security critical but must be unique for the server. Additionally, the session id is transmitted in the clear when reusing the session so it must not contain sensitive information.</p> <p>Without a callback being set, an OpenSSL server will generate a unique session id from pseudo random numbers of the maximum possible length. Using the callback function, the session id can be changed to contain additional information like e.g. a host id in order to improve load balancing or external caching techniques.</p> <p>The callback function receives a pointer to the memory location to put id into and a pointer to the maximum allowed length id_len. The buffer at location id is only guaranteed to have the size id_len. The callback is only allowed to generate a shorter id and reduce id_len; the callback must never increase id_len or write to the location id exceeding the given limit.</p> <p>If a SSLv2 session id is generated and id_len is reduced, it will be restored after the callback has finished and the session id will be padded with 0x00. It is not recommended to change the id_len for SSLv2 sessions. The callback can use the SSL_get_version(3) function to check, whether the session is of type SSLv2.</p> <p>The location id is filled with 0x00 before the callback is called, so the callback may only fill part of the possible length and leave id_len untouched while maintaining reproducibility.</p> <p>Since the sessions must be distinguished, session ids must be unique. Without the callback a random number is used, so that the probability of generating the same session id is extremely small (2^128 possible ids for an SSLv2 session, 2^256 for SSLv3/TLSv1). In order to assure the uniqueness of the generated session id, the callback must call SSL_has_matching_session_id() and generate another id if a conflict occurs. If an id conflict is not resolved, the handshake will fail. If the application codes e.g. a unique host id, a unique process number, and a unique sequence number into the session id, uniqueness could easily be achieved without randomness added (it should however be taken care that no confidential information is leaked this way). If the application can not guarantee uniqueness, it is recommended to use the maximum id_len and fill in the bytes not used to code special information with random data to avoid collisions.</p> <p>SSL_has_matching_session_id() will only query the internal session cache, not the external one. Since the session id is generated before the handshake is completed, it is not immediately added to the cache. If another thread is using the same internal session cache, a race condition can occur in that another thread generates the same session id. Collisions can also occur when using an external session cache, since the external cache is not tested with SSL_has_matching_session_id() and the same race condition applies.</p> <p>When calling SSL_has_matching_session_id() for an SSLv2 session with reduced id_len, the match operation will be performed using the fixed length required and with a 0x00 padded id.</p> <p>The callback must return 0 if it cannot generate a session id for whatever reason and return 1 on success.</p>"},{"location":"man3/SSL_CTX_set_generate_session_id/#examples","title":"EXAMPLES","text":"<p>The callback function listed will generate a session id with the server id given, and will fill the rest with pseudo random bytes:</p> <pre><code>const char session_id_prefix = \"www-18\";\n\n#define MAX_SESSION_ID_ATTEMPTS 10\nstatic int generate_session_id(const SSL *ssl, unsigned char *id,\n                             unsigned int *id_len)\n     {\n     unsigned int count = 0;\n     const char *version;\n\n     version = SSL_get_version(ssl);\n     if (!strcmp(version, \"SSLv2\"))\n         /* we must not change id_len */;\n\n     do      {\n             RAND_pseudo_bytes(id, *id_len);\n             /* Prefix the session_id with the required prefix. NB: If our\n              * prefix is too long, clip it - but there will be worse effects\n              * anyway, eg. the server could only possibly create 1 session\n              * ID (ie. the prefix!) so all future session negotiations will\n              * fail due to conflicts. */\n             memcpy(id, session_id_prefix,\n                     (strlen(session_id_prefix) &lt; *id_len) ?\n                     strlen(session_id_prefix) : *id_len);\n             }\n     while(SSL_has_matching_session_id(ssl, id, *id_len) &amp;&amp;\n             (++count &lt; MAX_SESSION_ID_ATTEMPTS));\n     if(count &gt;= MAX_SESSION_ID_ATTEMPTS)\n             return 0;\n     return 1;\n     }\n</code></pre>"},{"location":"man3/SSL_CTX_set_generate_session_id/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_generate_session_id() and SSL_set_generate_session_id() always return 1.</p> <p>SSL_has_matching_session_id() returns 1 if another session with the same id is already in the cache.</p>"},{"location":"man3/SSL_CTX_set_generate_session_id/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_get_version(3)</p>"},{"location":"man3/SSL_CTX_set_generate_session_id/#history","title":"HISTORY","text":"<p>SSL_CTX_set_generate_session_id(), SSL_set_generate_session_id() and SSL_has_matching_session_id() have been introduced in OpenSSL 0.9.7.</p>"},{"location":"man3/SSL_CTX_set_info_callback/","title":"SSL_CTX_set_info_callback","text":""},{"location":"man3/SSL_CTX_set_info_callback/#name","title":"NAME","text":"<p>SSL_CTX_set_info_callback, SSL_CTX_get_info_callback, SSL_set_info_callback, SSL_get_info_callback - handle information callback for SSL connections</p>"},{"location":"man3/SSL_CTX_set_info_callback/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_info_callback(SSL_CTX *ctx, void (*callback)());\nvoid (*SSL_CTX_get_info_callback(const SSL_CTX *ctx))();\n\nvoid SSL_set_info_callback(SSL *ssl, void (*callback)());\nvoid (*SSL_get_info_callback(const SSL *ssl))();\n</code></pre>"},{"location":"man3/SSL_CTX_set_info_callback/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_info_callback() sets the callback function, that can be used to obtain state information for SSL objects created from ctx during connection setup and use. The setting for ctx is overridden from the setting for a specific SSL object, if specified. When callback is NULL, not callback function is used.</p> <p>SSL_set_info_callback() sets the callback function, that can be used to obtain state information for ssl during connection setup and use. When callback is NULL, the callback setting currently valid for ctx is used.</p> <p>SSL_CTX_get_info_callback() returns a pointer to the currently set information callback function for ctx.</p> <p>SSL_get_info_callback() returns a pointer to the currently set information callback function for ssl.</p>"},{"location":"man3/SSL_CTX_set_info_callback/#notes","title":"NOTES","text":"<p>When setting up a connection and during use, it is possible to obtain state information from the SSL/TLS engine. When set, an information callback function is called whenever the state changes, an alert appears, or an error occurs.</p> <p>The callback function is called as callback(SSL *ssl, int where, int ret). The where argument specifies information about where (in which context) the callback function was called. If ret is 0, an error condition occurred. If an alert is handled, SSL_CB_ALERT is set and ret specifies the alert information.</p> <p>where is a bitmask made up of the following bits:</p> <ul> <li> <p>SSL_CB_LOOP</p> <p>Callback has been called to indicate state change inside a loop.</p> </li> <li> <p>SSL_CB_EXIT</p> <p>Callback has been called to indicate error exit of a handshake function. (May be soft error with retry option for non-blocking setups.)</p> </li> <li> <p>SSL_CB_READ</p> <p>Callback has been called during read operation.</p> </li> <li> <p>SSL_CB_WRITE</p> <p>Callback has been called during write operation.</p> </li> <li> <p>SSL_CB_ALERT</p> <p>Callback has been called due to an alert being sent or received.</p> </li> <li> <p>SSL_CB_READ_ALERT               (SSL_CB_ALERT|SSL_CB_READ)</p> </li> <li>SSL_CB_WRITE_ALERT              (SSL_CB_ALERT|SSL_CB_WRITE)</li> <li>SSL_CB_ACCEPT_LOOP              (SSL_ST_ACCEPT|SSL_CB_LOOP)</li> <li>SSL_CB_ACCEPT_EXIT              (SSL_ST_ACCEPT|SSL_CB_EXIT)</li> <li>SSL_CB_CONNECT_LOOP             (SSL_ST_CONNECT|SSL_CB_LOOP)</li> <li>SSL_CB_CONNECT_EXIT             (SSL_ST_CONNECT|SSL_CB_EXIT)</li> <li> <p>SSL_CB_HANDSHAKE_START</p> <p>Callback has been called because a new handshake is started.</p> </li> <li> <p>SSL_CB_HANDSHAKE_DONE           0x20</p> <p>Callback has been called because a handshake is finished.</p> </li> </ul> <p>The current state information can be obtained using the SSL_state_string(3) family of functions.</p> <p>The ret information can be evaluated using the SSL_alert_type_string(3) family of functions.</p>"},{"location":"man3/SSL_CTX_set_info_callback/#return-values","title":"RETURN VALUES","text":"<p>SSL_set_info_callback() does not provide diagnostic information.</p> <p>SSL_get_info_callback() returns the current setting.</p>"},{"location":"man3/SSL_CTX_set_info_callback/#examples","title":"EXAMPLES","text":"<p>The following example callback function prints state strings, information about alerts being handled and error messages to the bio_err BIO.</p> <pre><code>void apps_ssl_info_callback(SSL *s, int where, int ret)\n       {\n       const char *str;\n       int w;\n\n       w=where&amp; ~SSL_ST_MASK;\n\n       if (w &amp; SSL_ST_CONNECT) str=\"SSL_connect\";\n       else if (w &amp; SSL_ST_ACCEPT) str=\"SSL_accept\";\n       else str=\"undefined\";\n\n       if (where &amp; SSL_CB_LOOP)\n               {\n               BIO_printf(bio_err,\"%s:%s\\n\",str,SSL_state_string_long(s));\n               }\n       else if (where &amp; SSL_CB_ALERT)\n               {\n               str=(where &amp; SSL_CB_READ)?\"read\":\"write\";\n               BIO_printf(bio_err,\"SSL3 alert %s:%s:%s\\n\",\n                       str,\n                       SSL_alert_type_string_long(ret),\n                       SSL_alert_desc_string_long(ret));\n               }\n       else if (where &amp; SSL_CB_EXIT)\n               {\n               if (ret == 0)\n                       BIO_printf(bio_err,\"%s:failed in %s\\n\",\n                               str,SSL_state_string_long(s));\n               else if (ret &lt; 0)\n                       {\n                       BIO_printf(bio_err,\"%s:error in %s\\n\",\n                               str,SSL_state_string_long(s));\n                       }\n               }\n       }\n</code></pre>"},{"location":"man3/SSL_CTX_set_info_callback/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_state_string(3), SSL_alert_type_string(3)</p>"},{"location":"man3/SSL_CTX_set_max_cert_list/","title":"SSL_CTX_set_max_cert_list","text":""},{"location":"man3/SSL_CTX_set_max_cert_list/#name","title":"NAME","text":"<p>SSL_CTX_set_max_cert_list, SSL_CTX_get_max_cert_list, SSL_set_max_cert_list, SSL_get_max_cert_list, - manipulate allowed for the peer's certificate chain</p>"},{"location":"man3/SSL_CTX_set_max_cert_list/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_CTX_set_max_cert_list(SSL_CTX *ctx, long size);\nlong SSL_CTX_get_max_cert_list(SSL_CTX *ctx);\n\nlong SSL_set_max_cert_list(SSL *ssl, long size);\nlong SSL_get_max_cert_list(SSL *ctx);\n</code></pre>"},{"location":"man3/SSL_CTX_set_max_cert_list/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_max_cert_list() sets the maximum size allowed for the peer's certificate chain for all SSL objects created from ctx to be &lt;size&gt; bytes. The SSL objects inherit the setting valid for ctx at the time SSL_new(3) is being called.</p> <p>SSL_CTX_get_max_cert_list() returns the currently set maximum size for ctx.</p> <p>SSL_set_max_cert_list() sets the maximum size allowed for the peer's certificate chain for ssl to be &lt;size&gt; bytes. This setting stays valid until a new value is set.</p> <p>SSL_get_max_cert_list() returns the currently set maximum size for ssl.</p>"},{"location":"man3/SSL_CTX_set_max_cert_list/#notes","title":"NOTES","text":"<p>During the handshake process, the peer may send a certificate chain. The TLS/SSL standard does not give any maximum size of the certificate chain. The OpenSSL library handles incoming data by a dynamically allocated buffer. In order to prevent this buffer from growing without bounds due to data received from a faulty or malicious peer, a maximum size for the certificate chain is set.</p> <p>The default value for the maximum certificate chain size is 100kB (30kB on the 16bit DOS platform). This should be sufficient for usual certificate chains (OpenSSL's default maximum chain length is 10, see SSL_CTX_set_verify(3), and certificates without special extensions have a typical size of 1-2kB).</p> <p>For special applications it can be necessary to extend the maximum certificate chain size allowed to be sent by the peer, see e.g. the work on \"Internet X.509 Public Key Infrastructure Proxy Certificate Profile\" and \"TLS Delegation Protocol\" at http://www.ietf.org/ and http://www.globus.org/ .</p> <p>Under normal conditions it should never be necessary to set a value smaller than the default, as the buffer is handled dynamically and only uses the memory actually required by the data sent by the peer.</p> <p>If the maximum certificate chain size allowed is exceeded, the handshake will fail with a SSL_R_EXCESSIVE_MESSAGE_SIZE error.</p>"},{"location":"man3/SSL_CTX_set_max_cert_list/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_max_cert_list() and SSL_set_max_cert_list() return the previously set value.</p> <p>SSL_CTX_get_max_cert_list() and SSL_get_max_cert_list() return the currently set value.</p>"},{"location":"man3/SSL_CTX_set_max_cert_list/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_new(3), SSL_CTX_set_verify(3)</p>"},{"location":"man3/SSL_CTX_set_max_cert_list/#history","title":"HISTORY","text":"<p>SSL*_set/get_max_cert_list() have been introduced in OpenSSL 0.9.7.</p>"},{"location":"man3/SSL_CTX_set_mode/","title":"SSL_CTX_set_mode","text":""},{"location":"man3/SSL_CTX_set_mode/#name","title":"NAME","text":"<p>SSL_CTX_set_mode, SSL_set_mode, SSL_CTX_get_mode, SSL_get_mode - manipulate SSL engine mode</p>"},{"location":"man3/SSL_CTX_set_mode/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_CTX_set_mode(SSL_CTX *ctx, long mode);\nlong SSL_set_mode(SSL *ssl, long mode);\n\nlong SSL_CTX_get_mode(SSL_CTX *ctx);\nlong SSL_get_mode(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_CTX_set_mode/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_mode() adds the mode set via bitmask in mode to ctx. Options already set before are not cleared.</p> <p>SSL_set_mode() adds the mode set via bitmask in mode to ssl. Options already set before are not cleared.</p> <p>SSL_CTX_get_mode() returns the mode set for ctx.</p> <p>SSL_get_mode() returns the mode set for ssl.</p>"},{"location":"man3/SSL_CTX_set_mode/#notes","title":"NOTES","text":"<p>The following mode changes are available:</p> <ul> <li> <p>SSL_MODE_ENABLE_PARTIAL_WRITE</p> <p>Allow SSL_write(..., n) to return r with 0 &lt; r &lt; n (i.e. report success when just a single record has been written). When not set (the default), SSL_write() will only report success once the complete chunk was written. Once SSL_write() returns with r, r bytes have been successfully written and the next call to SSL_write() must only send the n-r bytes left, imitating the behaviour of write().</p> </li> <li> <p>SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER</p> <p>Make it possible to retry SSL_write() with changed buffer location (the buffer contents must stay the same). This is not the default to avoid the misconception that non-blocking SSL_write() behaves like non-blocking write().</p> </li> <li> <p>SSL_MODE_AUTO_RETRY</p> <p>Never bother the application with retries if the transport is blocking. If a renegotiation take place during normal operation, a SSL_read(3) or SSL_write(3) would return with -1 and indicate the need to retry with SSL_ERROR_WANT_READ. In a non-blocking environment applications must be prepared to handle incomplete read/write operations. In a blocking environment, applications are not always prepared to deal with read/write operations returning without success report. The flag SSL_MODE_AUTO_RETRY will cause read/write operations to only return after the handshake and successful completion.</p> </li> <li> <p>SSL_MODE_RELEASE_BUFFERS</p> <p>When we no longer need a read buffer or a write buffer for a given SSL, then release the memory we were using to hold it.  Released memory is either appended to a list of unused RAM chunks on the SSL_CTX, or simply freed if the list of unused chunks would become longer than  SSL_CTX-&gt;freelist_max_len, which defaults to 32.  Using this flag can save around 34k per idle SSL connection. This flag has no effect on SSL v2 connections, or on DTLS connections.</p> </li> <li> <p>SSL_MODE_SEND_FALLBACK_SCSV</p> <p>Send TLS_FALLBACK_SCSV in the ClientHello. To be set only by applications that reconnect with a downgraded protocol version; see draft-ietf-tls-downgrade-scsv-00 for details.</p> <p>DO NOT ENABLE THIS if your application attempts a normal handshake. Only use this in explicit fallback retries, following the guidance in draft-ietf-tls-downgrade-scsv-00.</p> </li> </ul>"},{"location":"man3/SSL_CTX_set_mode/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_mode() and SSL_set_mode() return the new mode bitmask after adding mode.</p> <p>SSL_CTX_get_mode() and SSL_get_mode() return the current bitmask.</p>"},{"location":"man3/SSL_CTX_set_mode/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_read(3), SSL_write(3)</p>"},{"location":"man3/SSL_CTX_set_mode/#history","title":"HISTORY","text":"<p>SSL_MODE_AUTO_RETRY as been added in OpenSSL 0.9.6.</p>"},{"location":"man3/SSL_CTX_set_msg_callback/","title":"SSL_CTX_set_msg_callback","text":""},{"location":"man3/SSL_CTX_set_msg_callback/#name","title":"NAME","text":"<p>SSL_CTX_set_msg_callback, SSL_CTX_set_msg_callback_arg, SSL_set_msg_callback, SSL_get_msg_callback_arg - install callback for observing protocol messages</p>"},{"location":"man3/SSL_CTX_set_msg_callback/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_msg_callback(SSL_CTX *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg));\nvoid SSL_CTX_set_msg_callback_arg(SSL_CTX *ctx, void *arg);\n\nvoid SSL_set_msg_callback(SSL *ssl, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg));\nvoid SSL_set_msg_callback_arg(SSL *ssl, void *arg);\n</code></pre>"},{"location":"man3/SSL_CTX_set_msg_callback/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_msg_callback() or SSL_set_msg_callback() can be used to define a message callback function cb for observing all SSL/TLS protocol messages (such as handshake messages) that are received or sent.  SSL_CTX_set_msg_callback_arg() and SSL_set_msg_callback_arg() can be used to set argument arg to the callback function, which is available for arbitrary application use.</p> <p>SSL_CTX_set_msg_callback() and SSL_CTX_set_msg_callback_arg() specify default settings that will be copied to new SSL objects by SSL_new(3). SSL_set_msg_callback() and SSL_set_msg_callback_arg() modify the actual settings of an SSL object. Using a 0 pointer for cb disables the message callback.</p> <p>When cb is called by the SSL/TLS library for a protocol message, the function arguments have the following meaning:</p> <ul> <li> <p>write_p</p> <p>This flag is 0 when a protocol message has been received and 1 when a protocol message has been sent.</p> </li> <li> <p>version</p> <p>The protocol version according to which the protocol message is interpreted by the library. Currently, this is one of SSL2_VERSION, SSL3_VERSION and TLS1_VERSION (for SSL 2.0, SSL 3.0 and TLS 1.0, respectively).</p> </li> <li> <p>content_type</p> <p>In the case of SSL 2.0, this is always 0.  In the case of SSL 3.0 or TLS 1.0, this is one of the ContentType values defined in the protocol specification (change_cipher_spec(20), alert(21), handshake(22); but never application_data(23) because the callback will only be called for protocol messages).</p> </li> <li> <p>buf, len</p> <p>buf points to a buffer containing the protocol message, which consists of len bytes. The buffer is no longer valid after the callback function has returned.</p> </li> <li> <p>ssl</p> <p>The SSL object that received or sent the message.</p> </li> <li> <p>arg</p> <p>The user-defined argument optionally defined by SSL_CTX_set_msg_callback_arg() or SSL_set_msg_callback_arg().</p> </li> </ul>"},{"location":"man3/SSL_CTX_set_msg_callback/#notes","title":"NOTES","text":"<p>Protocol messages are passed to the callback function after decryption and fragment collection where applicable. (Thus record boundaries are not visible.)</p> <p>If processing a received protocol message results in an error, the callback function may not be called.  For example, the callback function will never see messages that are considered too large to be processed.</p> <p>Due to automatic protocol version negotiation, version is not necessarily the protocol version used by the sender of the message: If a TLS 1.0 ClientHello message is received by an SSL 3.0-only server, version will be SSL3_VERSION.</p>"},{"location":"man3/SSL_CTX_set_msg_callback/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_new(3)</p>"},{"location":"man3/SSL_CTX_set_msg_callback/#history","title":"HISTORY","text":"<p>SSL_CTX_set_msg_callback(), SSL_CTX_set_msg_callback_arg(), SSL_set_msg_callback() and SSL_get_msg_callback_arg() were added in OpenSSL 0.9.7.</p>"},{"location":"man3/SSL_CTX_set_options/","title":"SSL_CTX_set_options","text":""},{"location":"man3/SSL_CTX_set_options/#name","title":"NAME","text":"<p>SSL_CTX_set_options, SSL_set_options, SSL_CTX_clear_options, SSL_clear_options, SSL_CTX_get_options, SSL_get_options, SSL_get_secure_renegotiation_support - manipulate SSL options</p>"},{"location":"man3/SSL_CTX_set_options/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_CTX_set_options(SSL_CTX *ctx, long options);\nlong SSL_set_options(SSL *ssl, long options);\n\nlong SSL_CTX_clear_options(SSL_CTX *ctx, long options);\nlong SSL_clear_options(SSL *ssl, long options);\n\nlong SSL_CTX_get_options(SSL_CTX *ctx);\nlong SSL_get_options(SSL *ssl);\n\nlong SSL_get_secure_renegotiation_support(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_CTX_set_options/#description","title":"DESCRIPTION","text":"<p>Note: all these functions are implemented using macros.</p> <p>SSL_CTX_set_options() adds the options set via bitmask in options to ctx. Options already set before are not cleared!</p> <p>SSL_set_options() adds the options set via bitmask in options to ssl. Options already set before are not cleared!</p> <p>SSL_CTX_clear_options() clears the options set via bitmask in options to ctx.</p> <p>SSL_clear_options() clears the options set via bitmask in options to ssl.</p> <p>SSL_CTX_get_options() returns the options set for ctx.</p> <p>SSL_get_options() returns the options set for ssl.</p> <p>SSL_get_secure_renegotiation_support() indicates whether the peer supports secure renegotiation.</p>"},{"location":"man3/SSL_CTX_set_options/#notes","title":"NOTES","text":"<p>The behaviour of the SSL library can be changed by setting several options. The options are coded as bitmasks and can be combined by a logical or operation (|).</p> <p>SSL_CTX_set_options() and SSL_set_options() affect the (external) protocol behaviour of the SSL library. The (internal) behaviour of the API can be changed by using the similar SSL_CTX_set_mode(3) and SSL_set_mode() functions.</p> <p>During a handshake, the option settings of the SSL object are used. When a new SSL object is created from a context using SSL_new(), the current option setting is copied. Changes to ctx do not affect already created SSL objects. SSL_clear() does not affect the settings.</p> <p>The following bug workaround options are available:</p> <ul> <li> <p>SSL_OP_MICROSOFT_SESS_ID_BUG</p> <p>www.microsoft.com - when talking SSLv2, if session-id reuse is performed, the session-id passed back in the server-finished message is different from the one decided upon.</p> </li> <li> <p>SSL_OP_NETSCAPE_CHALLENGE_BUG</p> <p>Netscape-Commerce/1.12, when talking SSLv2, accepts a 32 byte challenge but then appears to only use 16 bytes when generating the encryption keys.  Using 16 bytes is ok but it should be ok to use 32. According to the SSLv3 spec, one should use 32 bytes for the challenge when operating in SSLv2/v3 compatibility mode, but as mentioned above, this breaks this server so 16 bytes is the way to go.</p> </li> <li> <p>SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG</p> <p>As of OpenSSL 0.9.8q and 1.0.0c, this option has no effect.</p> </li> <li> <p>SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG</p> <p>...</p> </li> <li> <p>SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER</p> <p>...</p> </li> <li> <p>SSL_OP_SAFARI_ECDHE_ECDSA_BUG</p> <p>Don't prefer ECDHE-ECDSA ciphers when the client appears to be Safari on OS X. OS X 10.8..10.8.3 has broken support for ECDHE-ECDSA ciphers.</p> </li> <li> <p>SSL_OP_SSLEAY_080_CLIENT_DH_BUG</p> <p>...</p> </li> <li> <p>SSL_OP_TLS_D5_BUG</p> <p>...</p> </li> <li> <p>SSL_OP_TLS_BLOCK_PADDING_BUG</p> <p>...</p> </li> <li> <p>SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS</p> <p>Disables a countermeasure against a SSL 3.0/TLS 1.0 protocol vulnerability affecting CBC ciphers, which cannot be handled by some broken SSL implementations.  This option has no effect for connections using other ciphers.</p> </li> <li> <p>SSL_OP_TLSEXT_PADDING</p> <p>Adds a padding extension to ensure the ClientHello size is never between 256 and 511 bytes in length. This is needed as a workaround for some implementations.</p> </li> <li> <p>SSL_OP_ALL</p> <p>All of the above bug workarounds.</p> </li> </ul> <p>It is usually safe to use SSL_OP_ALL to enable the bug workaround options if compatibility with somewhat broken implementations is desired.</p> <p>The following modifying options are available:</p> <ul> <li> <p>SSL_OP_TLS_ROLLBACK_BUG</p> <p>Disable version rollback attack detection.</p> <p>During the client key exchange, the client must send the same information about acceptable SSL/TLS protocol levels as during the first hello. Some clients violate this rule by adapting to the server's answer. (Example: the client sends a SSLv2 hello and accepts up to SSLv3.1=TLSv1, the server only understands up to SSLv3. In this case the client must still use the same SSLv3.1=TLSv1 announcement. Some clients step down to SSLv3 with respect to the server's answer and violate the version rollback protection.)</p> </li> <li> <p>SSL_OP_SINGLE_DH_USE</p> <p>Always create a new key when using temporary/ephemeral DH parameters (see SSL_CTX_set_tmp_dh_callback(3)). This option must be used to prevent small subgroup attacks, when the DH parameters were not generated using \"strong\" primes (e.g. when using DSA-parameters, see dhparam(1)). If \"strong\" primes were used, it is not strictly necessary to generate a new DH key during each handshake but it is also recommended. SSL_OP_SINGLE_DH_USE should therefore be enabled whenever temporary/ephemeral DH parameters are used.</p> </li> <li> <p>SSL_OP_EPHEMERAL_RSA</p> <p>This option is no longer implemented and is treated as no op.</p> </li> <li> <p>SSL_OP_CIPHER_SERVER_PREFERENCE</p> <p>When choosing a cipher, use the server's preferences instead of the client preferences. When not set, the SSL server will always follow the clients preferences. When set, the SSLv3/TLSv1 server will choose following its own preferences. Because of the different protocol, for SSLv2 the server will send its list of preferences to the client and the client chooses.</p> </li> <li> <p>SSL_OP_PKCS1_CHECK_1</p> <p>...</p> </li> <li> <p>SSL_OP_PKCS1_CHECK_2</p> <p>...</p> </li> <li> <p>SSL_OP_NETSCAPE_CA_DN_BUG</p> <p>If we accept a netscape connection, demand a client cert, have a non-self-signed CA which does not have its CA in netscape, and the browser has a cert, it will crash/hang.  Works for 3.x and 4.xbeta </p> </li> <li> <p>SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG</p> <p>...</p> </li> <li> <p>SSL_OP_NO_SSLv2</p> <p>Do not use the SSLv2 protocol. As of OpenSSL 1.0.2g the SSL_OP_NO_SSLv2 option is set by default.</p> </li> <li> <p>SSL_OP_NO_SSLv3</p> <p>Do not use the SSLv3 protocol. It is recommended that applications should set this option.</p> </li> <li> <p>SSL_OP_NO_TLSv1</p> <p>Do not use the TLSv1 protocol.</p> </li> <li> <p>SSL_OP_NO_TLSv1_1</p> <p>Do not use the TLSv1.1 protocol.</p> </li> <li> <p>SSL_OP_NO_TLSv1_2</p> <p>Do not use the TLSv1.2 protocol.</p> </li> <li> <p>SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION</p> <p>When performing renegotiation as a server, always start a new session (i.e., session resumption requests are only accepted in the initial handshake). This option is not needed for clients.</p> </li> <li> <p>SSL_OP_NO_TICKET</p> <p>Normally clients and servers will, where possible, transparently make use of RFC4507bis tickets for stateless session resumption.</p> <p>If this option is set this functionality is disabled and tickets will not be used by clients or servers.</p> </li> <li> <p>SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION</p> <p>Allow legacy insecure renegotiation between OpenSSL and unpatched clients or servers. See the SECURE RENEGOTIATION section for more details.</p> </li> <li> <p>SSL_OP_LEGACY_SERVER_CONNECT</p> <p>Allow legacy insecure renegotiation between OpenSSL and unpatched servers only: this option is currently set by default. See the SECURE RENEGOTIATION section for more details.</p> </li> </ul>"},{"location":"man3/SSL_CTX_set_options/#secure-renegotiation","title":"SECURE RENEGOTIATION","text":"<p>OpenSSL 0.9.8m and later always attempts to use secure renegotiation as described in RFC5746. This counters the prefix attack described in CVE-2009-3555 and elsewhere.</p> <p>The deprecated and highly broken SSLv2 protocol does not support renegotiation at all: its use is strongly discouraged.</p> <p>This attack has far reaching consequences which application writers should be aware of. In the description below an implementation supporting secure renegotiation is referred to as patched. A server not supporting secure renegotiation is referred to as unpatched.</p> <p>The following sections describe the operations permitted by OpenSSL's secure renegotiation implementation.</p>"},{"location":"man3/SSL_CTX_set_options/#patched-client-and-server","title":"Patched client and server","text":"<p>Connections and renegotiation are always permitted by OpenSSL implementations.</p>"},{"location":"man3/SSL_CTX_set_options/#unpatched-client-and-patched-openssl-server","title":"Unpatched client and patched OpenSSL server","text":"<p>The initial connection succeeds but client renegotiation is denied by the server with a no_renegotiation warning alert if TLS v1.0 is used or a fatal handshake_failure alert in SSL v3.0.</p> <p>If the patched OpenSSL server attempts to renegotiate a fatal handshake_failure alert is sent. This is because the server code may be unaware of the unpatched nature of the client.</p> <p>If the option SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION is set then renegotiation always succeeds.</p> <p>NB: a bug in OpenSSL clients earlier than 0.9.8m (all of which are unpatched) will result in the connection hanging if it receives a no_renegotiation alert. OpenSSL versions 0.9.8m and later will regard a no_renegotiation alert as fatal and respond with a fatal handshake_failure alert. This is because the OpenSSL API currently has no provision to indicate to an application that a renegotiation attempt was refused.</p>"},{"location":"man3/SSL_CTX_set_options/#patched-openssl-client-and-unpatched-server","title":"Patched OpenSSL client and unpatched server.","text":"<p>If the option SSL_OP_LEGACY_SERVER_CONNECT or SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION is set then initial connections and renegotiation between patched OpenSSL clients and unpatched servers succeeds. If neither option is set then initial connections to unpatched servers will fail.</p> <p>The option SSL_OP_LEGACY_SERVER_CONNECT is currently set by default even though it has security implications: otherwise it would be impossible to connect to unpatched servers (i.e. all of them initially) and this is clearly not acceptable. Renegotiation is permitted because this does not add any additional security issues: during an attack clients do not see any renegotiations anyway.</p> <p>As more servers become patched the option SSL_OP_LEGACY_SERVER_CONNECT will not be set by default in a future version of OpenSSL.</p> <p>OpenSSL client applications wishing to ensure they can connect to unpatched servers should always set SSL_OP_LEGACY_SERVER_CONNECT</p> <p>OpenSSL client applications that want to ensure they can not connect to unpatched servers (and thus avoid any security issues) should always clear SSL_OP_LEGACY_SERVER_CONNECT using SSL_CTX_clear_options() or SSL_clear_options().</p> <p>The difference between the SSL_OP_LEGACY_SERVER_CONNECT and SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION options is that SSL_OP_LEGACY_SERVER_CONNECT enables initial connections and secure renegotiation between OpenSSL clients and unpatched servers only, while SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION allows initial connections and renegotiation between OpenSSL and unpatched clients or servers.</p>"},{"location":"man3/SSL_CTX_set_options/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_options() and SSL_set_options() return the new options bitmask after adding options.</p> <p>SSL_CTX_clear_options() and SSL_clear_options() return the new options bitmask after clearing options.</p> <p>SSL_CTX_get_options() and SSL_get_options() return the current bitmask.</p> <p>SSL_get_secure_renegotiation_support() returns 1 is the peer supports secure renegotiation and 0 if it does not.</p>"},{"location":"man3/SSL_CTX_set_options/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_new(3), SSL_clear(3), SSL_CTX_set_tmp_dh_callback(3), SSL_CTX_set_tmp_rsa_callback(3), dhparam(1)</p>"},{"location":"man3/SSL_CTX_set_options/#history","title":"HISTORY","text":"<p>SSL_OP_CIPHER_SERVER_PREFERENCE and SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION have been added in OpenSSL 0.9.7.</p> <p>SSL_OP_TLS_ROLLBACK_BUG has been added in OpenSSL 0.9.6 and was automatically enabled with SSL_OP_ALL. As of 0.9.7, it is no longer included in SSL_OP_ALL and must be explicitly set.</p> <p>SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS has been added in OpenSSL 0.9.6e. Versions up to OpenSSL 0.9.6c do not include the countermeasure that can be disabled with this option (in OpenSSL 0.9.6d, it was always enabled).</p> <p>SSL_CTX_clear_options() and SSL_clear_options() were first added in OpenSSL 0.9.8m.</p> <p>SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION, SSL_OP_LEGACY_SERVER_CONNECT and the function SSL_get_secure_renegotiation_support() were first added in OpenSSL 0.9.8m.</p>"},{"location":"man3/SSL_CTX_set_psk_client_callback/","title":"SSL_CTX_set_psk_client_callback","text":""},{"location":"man3/SSL_CTX_set_psk_client_callback/#name","title":"NAME","text":"<p>SSL_CTX_set_psk_client_callback, SSL_set_psk_client_callback - set PSK client callback</p>"},{"location":"man3/SSL_CTX_set_psk_client_callback/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_psk_client_callback(SSL_CTX *ctx,\n       unsigned int (*callback)(SSL *ssl, const char *hint,\n       char *identity, unsigned int max_identity_len,\n       unsigned char *psk, unsigned int max_psk_len));\nvoid SSL_set_psk_client_callback(SSL *ssl,\n       unsigned int (*callback)(SSL *ssl, const char *hint,\n       char *identity, unsigned int max_identity_len,\n       unsigned char *psk, unsigned int max_psk_len));\n</code></pre>"},{"location":"man3/SSL_CTX_set_psk_client_callback/#description","title":"DESCRIPTION","text":"<p>A client application must provide a callback function which is called when the client is sending the ClientKeyExchange message to the server.</p> <p>The purpose of the callback function is to select the PSK identity and the pre-shared key to use during the connection setup phase.</p> <p>The callback is set using functions SSL_CTX_set_psk_client_callback() or SSL_set_psk_client_callback(). The callback function is given the connection in parameter ssl, a NULL-terminated PSK identity hint sent by the server in parameter hint, a buffer identity of length max_identity_len bytes where the the resulting NULL-terminated identity is to be stored, and a buffer psk of length max_psk_len bytes where the resulting pre-shared key is to be stored.</p>"},{"location":"man3/SSL_CTX_set_psk_client_callback/#notes","title":"NOTES","text":"<p>Note that parameter hint given to the callback may be NULL.</p>"},{"location":"man3/SSL_CTX_set_psk_client_callback/#return-values","title":"RETURN VALUES","text":"<p>Return values from the client callback are interpreted as follows:</p> <p>On success (callback found a PSK identity and a pre-shared key to use) the length (&gt; 0) of psk in bytes is returned.</p> <p>Otherwise or on errors callback should return 0. In this case the connection setup fails.</p>"},{"location":"man3/SSL_CTX_set_quiet_shutdown/","title":"SSL_CTX_set_quiet_shutdown","text":""},{"location":"man3/SSL_CTX_set_quiet_shutdown/#name","title":"NAME","text":"<p>SSL_CTX_set_quiet_shutdown, SSL_CTX_get_quiet_shutdown, SSL_set_quiet_shutdown, SSL_get_quiet_shutdown - manipulate shutdown behaviour</p>"},{"location":"man3/SSL_CTX_set_quiet_shutdown/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx, int mode);\nint SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx);\n\nvoid SSL_set_quiet_shutdown(SSL *ssl, int mode);\nint SSL_get_quiet_shutdown(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_CTX_set_quiet_shutdown/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_quiet_shutdown() sets the \"quiet shutdown\" flag for ctx to be mode. SSL objects created from ctx inherit the mode valid at the time SSL_new(3) is called. mode may be 0 or 1.</p> <p>SSL_CTX_get_quiet_shutdown() returns the \"quiet shutdown\" setting of ctx.</p> <p>SSL_set_quiet_shutdown() sets the \"quiet shutdown\" flag for ssl to be mode. The setting stays valid until ssl is removed with SSL_free(3) or SSL_set_quiet_shutdown() is called again. It is not changed when SSL_clear(3) is called. mode may be 0 or 1.</p> <p>SSL_get_quiet_shutdown() returns the \"quiet shutdown\" setting of ssl.</p>"},{"location":"man3/SSL_CTX_set_quiet_shutdown/#notes","title":"NOTES","text":"<p>Normally when a SSL connection is finished, the parties must send out \"close notify\" alert messages using SSL_shutdown(3) for a clean shutdown.</p> <p>When setting the \"quiet shutdown\" flag to 1, SSL_shutdown(3) will set the internal flags to SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN. (SSL_shutdown(3) then behaves like SSL_set_shutdown(3) called with SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN.) The session is thus considered to be shutdown, but no \"close notify\" alert is sent to the peer. This behaviour violates the TLS standard.</p> <p>The default is normal shutdown behaviour as described by the TLS standard.</p>"},{"location":"man3/SSL_CTX_set_quiet_shutdown/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_quiet_shutdown() and SSL_set_quiet_shutdown() do not return diagnostic information.</p> <p>SSL_CTX_get_quiet_shutdown() and SSL_get_quiet_shutdown return the current setting.</p>"},{"location":"man3/SSL_CTX_set_quiet_shutdown/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_shutdown(3), SSL_set_shutdown(3), SSL_new(3), SSL_clear(3), SSL_free(3)</p>"},{"location":"man3/SSL_CTX_set_read_ahead/","title":"SSL_CTX_set_read_ahead","text":""},{"location":"man3/SSL_CTX_set_read_ahead/#name","title":"NAME","text":"<p>SSL_CTX_set_read_ahead, SSL_CTX_set_default_read_ahead, SSL_CTX_get_read_ahead, SSL_CTX_get_default_read_ahead, SSL_set_read_ahead, SSL_get_read_ahead - manage whether to read as many input bytes as possible</p>"},{"location":"man3/SSL_CTX_set_read_ahead/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_get_read_ahead(const SSL *s);\nvoid SSL_set_read_ahead(SSL *s, int yes);\n\n#define SSL_CTX_get_default_read_ahead(ctx)\n#define SSL_CTX_set_default_read_ahead(ctx,m)\n#define SSL_CTX_get_read_ahead(ctx)\n#define SSL_CTX_set_read_ahead(ctx,m)\n</code></pre>"},{"location":"man3/SSL_CTX_set_read_ahead/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_read_ahead() and SSL_set_read_ahead() set whether we should read as many input bytes as possible (for non-blocking reads) or not. For example if x bytes are currently required by OpenSSL, but y bytes are available from the underlying BIO (where y &gt; x), then OpenSSL will read all y bytes into its buffer (providing that the buffer is large enough) if reading ahead is on, or x bytes otherwise. The parameter yes or m should be 0 to ensure reading ahead is off, or non zero otherwise.</p> <p>SSL_CTX_set_default_read_ahead is a synonym for SSL_CTX_set_read_ahead, and SSL_CTX_get_default_read_ahead is a synonym for SSL_CTX_get_read_ahead.</p> <p>SSL_CTX_get_read_ahead() and SSL_get_read_ahead() indicate whether reading ahead has been set or not.</p>"},{"location":"man3/SSL_CTX_set_read_ahead/#notes","title":"NOTES","text":"<p>These functions have no impact when used with DTLS. The return values for SSL_CTX_get_read_head() and SSL_get_read_ahead() are undefined for DTLS.</p>"},{"location":"man3/SSL_CTX_set_read_ahead/#return-values","title":"RETURN VALUES","text":"<p>SSL_get_read_ahead and SSL_CTX_get_read_ahead return 0 if reading ahead is off, and non zero otherwise.</p>"},{"location":"man3/SSL_CTX_set_read_ahead/#see-also","title":"SEE ALSO","text":"<p>ssl(3)</p>"},{"location":"man3/SSL_CTX_set_session_cache_mode/","title":"SSL_CTX_set_session_cache_mode","text":""},{"location":"man3/SSL_CTX_set_session_cache_mode/#name","title":"NAME","text":"<p>SSL_CTX_set_session_cache_mode, SSL_CTX_get_session_cache_mode - enable/disable session caching</p>"},{"location":"man3/SSL_CTX_set_session_cache_mode/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_CTX_set_session_cache_mode(SSL_CTX ctx, long mode);\nlong SSL_CTX_get_session_cache_mode(SSL_CTX ctx);\n</code></pre>"},{"location":"man3/SSL_CTX_set_session_cache_mode/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_session_cache_mode() enables/disables session caching by setting the operational mode for ctx to &lt;mode&gt;.</p> <p>SSL_CTX_get_session_cache_mode() returns the currently used cache mode.</p>"},{"location":"man3/SSL_CTX_set_session_cache_mode/#notes","title":"NOTES","text":"<p>The OpenSSL library can store/retrieve SSL/TLS sessions for later reuse. The sessions can be held in memory for each ctx, if more than one SSL_CTX object is being maintained, the sessions are unique for each SSL_CTX object.</p> <p>In order to reuse a session, a client must send the session's id to the server. It can only send exactly one id.  The server then either  agrees to reuse the session or it starts a full handshake (to create a new session).</p> <p>A server will look up the session in its internal session storage. If the session is not found in internal storage or lookups for the internal storage have been deactivated (SSL_SESS_CACHE_NO_INTERNAL_LOOKUP), the server will try the external storage if available.</p> <p>Since a client may try to reuse a session intended for use in a different context, the session id context must be set by the server (see SSL_CTX_set_session_id_context(3)).</p> <p>The following session cache modes and modifiers are available:</p> <ul> <li> <p>SSL_SESS_CACHE_OFF</p> <p>No session caching for client or server takes place.</p> </li> <li> <p>SSL_SESS_CACHE_CLIENT</p> <p>Client sessions are added to the session cache. As there is no reliable way for the OpenSSL library to know whether a session should be reused or which session to choose (due to the abstract BIO layer the SSL engine does not have details about the connection), the application must select the session to be reused by using the SSL_set_session(3) function. This option is not activated by default.</p> </li> <li> <p>SSL_SESS_CACHE_SERVER</p> <p>Server sessions are added to the session cache. When a client proposes a session to be reused, the server looks for the corresponding session in (first) the internal session cache (unless SSL_SESS_CACHE_NO_INTERNAL_LOOKUP is set), then (second) in the external cache if available. If the session is found, the server will try to reuse the session.  This is the default.</p> </li> <li> <p>SSL_SESS_CACHE_BOTH</p> <p>Enable both SSL_SESS_CACHE_CLIENT and SSL_SESS_CACHE_SERVER at the same time.</p> </li> <li> <p>SSL_SESS_CACHE_NO_AUTO_CLEAR</p> <p>Normally the session cache is checked for expired sessions every 255 connections using the SSL_CTX_flush_sessions(3) function. Since this may lead to a delay which cannot be controlled, the automatic flushing may be disabled and SSL_CTX_flush_sessions(3) can be called explicitly by the application.</p> </li> <li> <p>SSL_SESS_CACHE_NO_INTERNAL_LOOKUP</p> <p>By setting this flag, session-resume operations in an SSL/TLS server will not automatically look up sessions in the internal cache, even if sessions are automatically stored there. If external session caching callbacks are in use, this flag guarantees that all lookups are directed to the external cache. As automatic lookup only applies for SSL/TLS servers, the flag has no effect on clients.</p> </li> <li> <p>SSL_SESS_CACHE_NO_INTERNAL_STORE</p> <p>Depending on the presence of SSL_SESS_CACHE_CLIENT and/or SSL_SESS_CACHE_SERVER, sessions negotiated in an SSL/TLS handshake may be cached for possible reuse. Normally a new session is added to the internal cache as well as any external session caching (callback) that is configured for the SSL_CTX. This flag will prevent sessions being stored in the internal cache (though the application can add them manually using SSL_CTX_add_session(3)). Note: in any SSL/TLS servers where external caching is configured, any successful session lookups in the external cache (ie. for session-resume requests) would normally be copied into the local cache before processing continues - this flag prevents these additions to the internal cache as well.</p> </li> <li> <p>SSL_SESS_CACHE_NO_INTERNAL</p> <p>Enable both SSL_SESS_CACHE_NO_INTERNAL_LOOKUP and SSL_SESS_CACHE_NO_INTERNAL_STORE at the same time.</p> </li> </ul> <p>The default mode is SSL_SESS_CACHE_SERVER.</p>"},{"location":"man3/SSL_CTX_set_session_cache_mode/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_session_cache_mode() returns the previously set cache mode.</p> <p>SSL_CTX_get_session_cache_mode() returns the currently set cache mode.</p>"},{"location":"man3/SSL_CTX_set_session_cache_mode/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_set_session(3), SSL_session_reused(3), SSL_CTX_add_session(3), SSL_CTX_sess_number(3), SSL_CTX_sess_set_cache_size(3), SSL_CTX_sess_set_get_cb(3), SSL_CTX_set_session_id_context(3), SSL_CTX_set_timeout(3), SSL_CTX_flush_sessions(3)</p>"},{"location":"man3/SSL_CTX_set_session_cache_mode/#history","title":"HISTORY","text":"<p>SSL_SESS_CACHE_NO_INTERNAL_STORE and SSL_SESS_CACHE_NO_INTERNAL were introduced in OpenSSL 0.9.6h.</p>"},{"location":"man3/SSL_CTX_set_session_id_context/","title":"SSL_CTX_set_session_id_context","text":""},{"location":"man3/SSL_CTX_set_session_id_context/#name","title":"NAME","text":"<p>SSL_CTX_set_session_id_context, SSL_set_session_id_context - set context within which session can be reused (server side only)</p>"},{"location":"man3/SSL_CTX_set_session_id_context/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_set_session_id_context(SSL_CTX *ctx, const unsigned char *sid_ctx,\n                                   unsigned int sid_ctx_len);\nint SSL_set_session_id_context(SSL *ssl, const unsigned char *sid_ctx,\n                               unsigned int sid_ctx_len);\n</code></pre>"},{"location":"man3/SSL_CTX_set_session_id_context/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_session_id_context() sets the context sid_ctx of length sid_ctx_len within which a session can be reused for the ctx object.</p> <p>SSL_set_session_id_context() sets the context sid_ctx of length sid_ctx_len within which a session can be reused for the ssl object.</p>"},{"location":"man3/SSL_CTX_set_session_id_context/#notes","title":"NOTES","text":"<p>Sessions are generated within a certain context. When exporting/importing sessions with i2d_SSL_SESSION/d2i_SSL_SESSION it would be possible, to re-import a session generated from another context (e.g. another application), which might lead to malfunctions. Therefore each application must set its own session id context sid_ctx which is used to distinguish the contexts and is stored in exported sessions. The sid_ctx can be any kind of binary data with a given length, it is therefore possible to use e.g. the name of the application and/or the hostname and/or service name ...</p> <p>The session id context becomes part of the session. The session id context is set by the SSL/TLS server. The SSL_CTX_set_session_id_context() and SSL_set_session_id_context() functions are therefore only useful on the server side.</p> <p>OpenSSL clients will check the session id context returned by the server when reusing a session.</p> <p>The maximum length of the sid_ctx is limited to SSL_MAX_SSL_SESSION_ID_LENGTH.</p>"},{"location":"man3/SSL_CTX_set_session_id_context/#warnings","title":"WARNINGS","text":"<p>If the session id context is not set on an SSL/TLS server and client certificates are used, stored sessions will not be reused but a fatal error will be flagged and the handshake will fail.</p> <p>If a server returns a different session id context to an OpenSSL client when reusing a session, an error will be flagged and the handshake will fail. OpenSSL servers will always return the correct session id context, as an OpenSSL server checks the session id context itself before reusing a session as described above.</p>"},{"location":"man3/SSL_CTX_set_session_id_context/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_session_id_context() and SSL_set_session_id_context() return the following values:</p> <ul> <li> <p>0</p> <p>The length sid_ctx_len of the session id context sid_ctx exceeded the maximum allowed length of SSL_MAX_SSL_SESSION_ID_LENGTH. The error is logged to the error stack.</p> </li> <li> <p>1</p> <p>The operation succeeded.</p> </li> </ul>"},{"location":"man3/SSL_CTX_set_session_id_context/#see-also","title":"SEE ALSO","text":"<p>ssl(3)</p>"},{"location":"man3/SSL_CTX_set_ssl_version/","title":"SSL_CTX_set_ssl_version","text":""},{"location":"man3/SSL_CTX_set_ssl_version/#name","title":"NAME","text":"<p>SSL_CTX_set_ssl_version, SSL_set_ssl_method, SSL_get_ssl_method - choose a new TLS/SSL method</p>"},{"location":"man3/SSL_CTX_set_ssl_version/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_set_ssl_version(SSL_CTX *ctx, const SSL_METHOD *method);\nint SSL_set_ssl_method(SSL *s, const SSL_METHOD *method);\nconst SSL_METHOD *SSL_get_ssl_method(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_CTX_set_ssl_version/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_ssl_version() sets a new default TLS/SSL method for SSL objects newly created from this ctx. SSL objects already created with SSL_new(3) are not affected, except when SSL_clear(3) is being called.</p> <p>SSL_set_ssl_method() sets a new TLS/SSL method for a particular ssl object. It may be reset, when SSL_clear() is called.</p> <p>SSL_get_ssl_method() returns a function pointer to the TLS/SSL method set in ssl.</p>"},{"location":"man3/SSL_CTX_set_ssl_version/#notes","title":"NOTES","text":"<p>The available method choices are described in SSL_CTX_new(3).</p> <p>When SSL_clear(3) is called and no session is connected to an SSL object, the method of the SSL object is reset to the method currently set in the corresponding SSL_CTX object.</p>"},{"location":"man3/SSL_CTX_set_ssl_version/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur for SSL_CTX_set_ssl_version() and SSL_set_ssl_method():</p> <ul> <li> <p>0</p> <p>The new choice failed, check the error stack to find out the reason.</p> </li> <li> <p>1</p> <p>The operation succeeded.</p> </li> </ul>"},{"location":"man3/SSL_CTX_set_ssl_version/#see-also","title":"SEE ALSO","text":"<p>SSL_CTX_new(3), SSL_new(3), SSL_clear(3), ssl(3), SSL_set_connect_state(3)</p>"},{"location":"man3/SSL_CTX_set_timeout/","title":"SSL_CTX_set_timeout","text":""},{"location":"man3/SSL_CTX_set_timeout/#name","title":"NAME","text":"<p>SSL_CTX_set_timeout, SSL_CTX_get_timeout - manipulate timeout values for session caching</p>"},{"location":"man3/SSL_CTX_set_timeout/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_CTX_set_timeout(SSL_CTX *ctx, long t);\nlong SSL_CTX_get_timeout(SSL_CTX *ctx);\n</code></pre>"},{"location":"man3/SSL_CTX_set_timeout/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_timeout() sets the timeout for newly created sessions for ctx to t. The timeout value t must be given in seconds.</p> <p>SSL_CTX_get_timeout() returns the currently set timeout value for ctx.</p>"},{"location":"man3/SSL_CTX_set_timeout/#notes","title":"NOTES","text":"<p>Whenever a new session is created, it is assigned a maximum lifetime. This lifetime is specified by storing the creation time of the session and the timeout value valid at this time. If the actual time is later than creation time plus timeout, the session is not reused.</p> <p>Due to this realization, all sessions behave according to the timeout value valid at the time of the session negotiation. Changes of the timeout value do not affect already established sessions.</p> <p>The expiration time of a single session can be modified using the SSL_SESSION_get_time(3) family of functions.</p> <p>Expired sessions are removed from the internal session cache, whenever SSL_CTX_flush_sessions(3) is called, either directly by the application or automatically (see SSL_CTX_set_session_cache_mode(3))</p> <p>The default value for session timeout is decided on a per protocol basis, see SSL_get_default_timeout(3). All currently supported protocols have the same default timeout value of 300 seconds.</p>"},{"location":"man3/SSL_CTX_set_timeout/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_timeout() returns the previously set timeout value.</p> <p>SSL_CTX_get_timeout() returns the currently set timeout value.</p>"},{"location":"man3/SSL_CTX_set_timeout/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_session_cache_mode(3), SSL_SESSION_get_time(3), SSL_CTX_flush_sessions(3), SSL_get_default_timeout(3)</p>"},{"location":"man3/SSL_CTX_set_tlsext_servername_callback/","title":"SSL_CTX_set_tlsext_servername_callback","text":""},{"location":"man3/SSL_CTX_set_tlsext_servername_callback/#name","title":"NAME","text":"<p>SSL_CTX_set_tlsext_servername_callback, SSL_CTX_set_tlsext_servername_arg, SSL_get_servername_type, SSL_get_servername - handle server name indication (SNI)</p>"},{"location":"man3/SSL_CTX_set_tlsext_servername_callback/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_CTX_set_tlsext_servername_callback(SSL_CTX *ctx,\n                                  int (*cb)(SSL *, int *, void *));\nlong SSL_CTX_set_tlsext_servername_arg(SSL_CTX *ctx, void *arg);\n\nconst char *SSL_get_servername(const SSL *s, const int type);\nint SSL_get_servername_type(const SSL *s);\n</code></pre>"},{"location":"man3/SSL_CTX_set_tlsext_servername_callback/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_tlsext_servername_callback() sets the application callback cb used by a server to perform any actions or configuration required based on the servername extension received in the incoming connection. When cb is NULL, SNI is not used. The arg value is a pointer which is passed to the application callback.</p> <p>SSL_CTX_set_tlsext_servername_arg() sets a context-specific argument to be passed into the callback for this SSL_CTX.</p> <p>SSL_get_servername() returns a servername extension value of the specified type if provided in the Client Hello or NULL.</p> <p>SSL_get_servername_type() returns the servername type or -1 if no servername is present. Currently the only supported type (defined in RFC3546) is TLSEXT_NAMETYPE_host_name.</p>"},{"location":"man3/SSL_CTX_set_tlsext_servername_callback/#notes","title":"NOTES","text":"<p>The ALPN and SNI callbacks are both executed during Client Hello processing. The servername callback is executed first, followed by the ALPN callback.</p>"},{"location":"man3/SSL_CTX_set_tlsext_servername_callback/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_tlsext_servername_callback() and SSL_CTX_set_tlsext_servername_arg() both always return 1 indicating success.</p>"},{"location":"man3/SSL_CTX_set_tlsext_servername_callback/#see-also","title":"SEE ALSO","text":"<p>ssl(7), SSL_CTX_set_alpn_select_cb(3), SSL_get0_alpn_selected(3)</p>"},{"location":"man3/SSL_CTX_set_tlsext_servername_callback/#copyright","title":"COPYRIGHT","text":"<p>Copyright 2017 The OpenSSL Project Authors. All Rights Reserved.</p> <p>Licensed under the OpenSSL license (the \"License\").  You may not use this file except in compliance with the License.  You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html.</p>"},{"location":"man3/SSL_CTX_set_tlsext_status_cb/","title":"SSL_CTX_set_tlsext_status_cb","text":""},{"location":"man3/SSL_CTX_set_tlsext_status_cb/#name","title":"NAME","text":"<p>SSL_CTX_set_tlsext_status_cb, SSL_CTX_set_tlsext_status_arg, SSL_set_tlsext_status_type, SSL_get_tlsext_status_ocsp_resp, SSL_set_tlsext_status_ocsp_resp - OCSP Certificate Status Request functions</p>"},{"location":"man3/SSL_CTX_set_tlsext_status_cb/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/tls1.h&gt;\n\nlong SSL_CTX_set_tlsext_status_cb(SSL_CTX *ctx,\n                                  int (*callback)(SSL *, void *));\nlong SSL_CTX_set_tlsext_status_arg(SSL_CTX *ctx, void *arg);\n\nlong SSL_set_tlsext_status_type(SSL *s, int type);\n\nlong SSL_get_tlsext_status_ocsp_resp(ssl, unsigned char **resp);\nlong SSL_set_tlsext_status_ocsp_resp(ssl, unsigned char *resp, int len);\n</code></pre>"},{"location":"man3/SSL_CTX_set_tlsext_status_cb/#description","title":"DESCRIPTION","text":"<p>A client application may request that a server send back an OCSP status response (also known as OCSP stapling). To do so the client should call the SSL_set_tlsext_status_type() function prior to the start of the handshake. Currently the only supported type is TLSEXT_STATUSTYPE_ocsp. This value should be passed in the type argument. The client should additionally provide a callback function to decide what to do with the returned OCSP response by calling SSL_CTX_set_tlsext_status_cb(). The callback function should determine whether the returned OCSP response is acceptable or not. The callback will be passed as an argument the value previously set via a call to SSL_CTX_set_tlsext_status_arg(). Note that the callback will not be called in the event of a handshake where session resumption occurs (because there are no Certificates exchanged in such a handshake).</p> <p>The response returned by the server can be obtained via a call to SSL_get_tlsext_status_ocsp_resp(). The value *resp will be updated to point to the OCSP response data and the return value will be the length of that data. Typically a callback would obtain an OCSP_RESPONSE object from this data via a call to the d2i_OCSP_RESPONSE() function. If the server has not provided any response data then *resp will be NULL and the return value from SSL_get_tlsext_status_ocsp_resp() will be -1.</p> <p>A server application must also call the SSL_CTX_set_tlsext_status_cb() function if it wants to be able to provide clients with OCSP Certificate Status responses. Typically the server callback would obtain the server certificate that is being sent back to the client via a call to SSL_get_certificate(); obtain the OCSP response to be sent back; and then set that response data by calling SSL_set_tlsext_status_ocsp_resp(). A pointer to the response data should be provided in the resp argument, and the length of that data should be in the len argument.</p>"},{"location":"man3/SSL_CTX_set_tlsext_status_cb/#return-values","title":"RETURN VALUES","text":"<p>The callback when used on the client side should return a negative value on error; 0 if the response is not acceptable (in which case the handshake will fail) or a positive value if it is acceptable.</p> <p>The callback when used on the server side should return with either SSL_TLSEXT_ERR_OK (meaning that the OCSP response that has been set should be returned), SSL_TLSEXT_ERR_NOACK (meaning that an OCSP response should not be returned) or SSL_TLSEXT_ERR_ALERT_FATAL (meaning that a fatal error has occurred).</p> <p>SSL_CTX_set_tlsext_status_cb(), SSL_CTX_set_tlsext_status_arg(), SSL_set_tlsext_status_type() and SSL_set_tlsext_status_ocsp_resp() return 0 on error or 1 on success.</p> <p>SSL_get_tlsext_status_ocsp_resp() returns the length of the OCSP response data or -1 if there is no OCSP response data.</p>"},{"location":"man3/SSL_CTX_set_tlsext_ticket_key_cb/","title":"SSL_CTX_set_tlsext_ticket_key_cb","text":""},{"location":"man3/SSL_CTX_set_tlsext_ticket_key_cb/#name","title":"NAME","text":"<p>SSL_CTX_set_tlsext_ticket_key_cb - set a callback for session ticket processing</p>"},{"location":"man3/SSL_CTX_set_tlsext_ticket_key_cb/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/tls1.h&gt;\n\nlong SSL_CTX_set_tlsext_ticket_key_cb(SSL_CTX sslctx,\n       int (*cb)(SSL *s, unsigned char key_name[16],\n                 unsigned char iv[EVP_MAX_IV_LENGTH],\n                 EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int enc));\n</code></pre>"},{"location":"man3/SSL_CTX_set_tlsext_ticket_key_cb/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_tlsext_ticket_key_cb() sets a callback fuction cb for handling  session tickets for the ssl context sslctx. Session tickets, defined in  RFC5077 provide an enhanced session resumption capability where the server implementation is not required to maintain per session state. It only applies to TLS and there is no SSLv3 implementation.</p> <p>The callback is available when the OpenSSL library was built without  OPENSSL_NO_TLSEXT being defined.</p> <p>The callback function cb will be called for every client instigated TLS session when session ticket extension is presented in the TLS hello message. It is the responsibility of this function to create or retrieve the cryptographic parameters and to maintain their state.</p> <p>The OpenSSL library uses your callback function to help implement a common TLS  ticket construction state according to RFC5077 Section 4 such that per session state is unnecessary and a small set of cryptographic variables needs to be  maintained by the callback function implementation.</p> <p>In order to reuse a session, a TLS client must send the a session ticket extension to the server. The client can only send exactly one session ticket. The server, through the callback function, either agrees to reuse the session ticket information or it starts a full TLS handshake to create a new session ticket.</p> <p>Before the callback function is started ctx and hctx have been  initialised with EVP_CIPHER_CTX_init and HMAC_CTX_init respectively.</p> <p>For new sessions tickets, when the client doesn't present a session ticket, or an attempted retreival of the ticket failed, or a renew option was indicated, the callback function will be called with enc equal to 1. The OpenSSL library expects that the function will set an arbitary name, initialize iv, and set the cipher context ctx and the hash context hctx.</p> <p>The name is 16 characters long and is used as a key identifier.</p> <p>The iv length is the length of the IV of the corresponding cipher. The maximum IV length is EVP_MAX_IV_LENGTH bytes defined in evp.h.</p> <p>The initialization vector iv should be a random value. The cipher context  ctx should use the initialisation vector iv. The cipher context can be  set using EVP_EncryptInit_ex. The hmac context can be set using HMAC_Init_ex.</p> <p>When the client presents a session ticket, the callback function with be called  with enc set to 0 indicating that the cb function should retreive a set of parameters. In this case name and iv have already been parsed out of the session ticket. The OpenSSL library expects that the name will be used to retrieve a cryptographic parameters and that the cryptographic context ctx will be set with the retreived parameters and the initialization vector iv. using a function like EVP_DecryptInit_ex. The hctx needs to be set using HMAC_Init_ex.</p> <p>If the name is still valid but a renewal of the ticket is required the callback function should return 2. The library will call the callback again with an arguement of enc equal to 1 to set the new ticket.</p> <p>The return value of the cb function is used by OpenSSL to determine what further processing will occur. The following return values have meaning:</p> <ul> <li> <p>2</p> <p>This indicates that the ctx and hctx have been set and the session can  continue on those parameters. Additionally it indicates that the session ticket is in a renewal period and should be replaced. The OpenSSL library will call cb again with an enc argument of 1 to set the new ticket (see RFC5077 3.3 paragraph 2).</p> </li> <li> <p>1</p> <p>This indicates that the ctx and hctx have been set and the session can  continue on those parameters.</p> </li> <li> <p>0</p> <p>This indicates that it was not possible to set/retrieve a session ticket and  the SSL/TLS session will continue by by negiotationing a set of cryptographic parameters or using the alternate SSL/TLS resumption mechanism, session ids.</p> <p>If called with enc equal to 0 the library will call the cb again to get a new set of parameters.</p> </li> <li> <p>less than 0</p> <p>This indicates an error.</p> </li> </ul>"},{"location":"man3/SSL_CTX_set_tlsext_ticket_key_cb/#notes","title":"NOTES","text":"<p>Session resumption shortcuts the TLS so that the client certificate negiotation don't occur. It makes up for this by storing client certificate an all other negotiated state information encrypted within the ticket. In a resumed session the applications will have all this state information available exactly as if a full negiotation had occured.</p> <p>If an attacker can obtain the key used to encrypt a session ticket, they can obtain the master secret for any ticket using that key and decrypt any traffic using that session: even if the ciphersuite supports forward secrecy. As a result applications may wish to use multiple keys and avoid using long term keys stored in files.</p> <p>Applications can use longer keys to maintain a consistent level of security. For example if a ciphersuite uses 256 bit ciphers but only a 128 bit ticket key the overall security is only 128 bits because breaking the ticket key will enable an attacker to obtain the session keys.</p>"},{"location":"man3/SSL_CTX_set_tlsext_ticket_key_cb/#examples","title":"EXAMPLES","text":"<p>Reference Implemention:   SSL_CTX_set_tlsext_ticket_key_cb(SSL,ssl_tlsext_ticket_key_cb);   ....</p> <pre><code>static int ssl_tlsext_ticket_key_cb(SSL *s, unsigned char key_name[16], unsigned char *iv, EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int enc)\n{\n    if (enc) { /* create new session */\n        if (RAND_bytes(iv, EVP_MAX_IV_LENGTH) ) {\n            return -1; /* insufficient random */\n        }\n\n        key = currentkey(); /* something that you need to implement */\n        if ( !key ) {\n            /* current key doesn't exist or isn't valid */\n            key = createkey(); /* something that you need to implement.\n                                 * createkey needs to initialise, a name,\n                                 * an aes_key, a hmac_key and optionally\n                                 * an expire time. */\n            if ( !key ) { /* key couldn't be created */\n                return 0;\n            }\n        }\n        memcpy(key_name, key-&gt;name, 16);\n\n        EVP_EncryptInit_ex(&amp;ctx, EVP_aes_128_cbc(), NULL, key-&gt;aes_key, iv);\n        HMAC_Init_ex(&amp;hctx, key-&gt;hmac_key, 16, EVP_sha256(), NULL);\n\n        return 1;\n\n    } else { /* retrieve session */\n        key = findkey(name);\n\n        if  (!key || key-&gt;expire &lt; now() ) {\n            return 0;\n        }\n\n        HMAC_Init_ex(&amp;hctx, key-&gt;hmac_key, 16, EVP_sha256(), NULL);\n        EVP_DecryptInit_ex(&amp;ctx, EVP_aes_128_cbc(), NULL, key-&gt;aes_key, iv );\n\n        if (key-&gt;expire &lt; ( now() - RENEW_TIME ) ) {\n            /* return 2 - this session will get a new ticket even though the current is still valid */\n            return 2;\n        }\n        return 1;\n\n    }\n}\n</code></pre>"},{"location":"man3/SSL_CTX_set_tlsext_ticket_key_cb/#return-values","title":"RETURN VALUES","text":"<p>returns 0 to indicate the callback function was set.</p>"},{"location":"man3/SSL_CTX_set_tlsext_ticket_key_cb/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_set_session(3), SSL_session_reused(3), SSL_CTX_add_session(3), SSL_CTX_sess_number(3), SSL_CTX_sess_set_get_cb(3), SSL_CTX_set_session_id_context(3),</p>"},{"location":"man3/SSL_CTX_set_tlsext_ticket_key_cb/#history","title":"HISTORY","text":"<p>This function was introduced in OpenSSL 0.9.8h</p>"},{"location":"man3/SSL_CTX_set_tmp_dh_callback/","title":"SSL_CTX_set_tmp_dh_callback","text":""},{"location":"man3/SSL_CTX_set_tmp_dh_callback/#name","title":"NAME","text":"<p>SSL_CTX_set_tmp_dh_callback, SSL_CTX_set_tmp_dh, SSL_set_tmp_dh_callback, SSL_set_tmp_dh - handle DH keys for ephemeral key exchange</p>"},{"location":"man3/SSL_CTX_set_tmp_dh_callback/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx,\n           DH *(*tmp_dh_callback)(SSL *ssl, int is_export, int keylength));\nlong SSL_CTX_set_tmp_dh(SSL_CTX *ctx, DH *dh);\n\nvoid SSL_set_tmp_dh_callback(SSL *ctx,\n           DH *(*tmp_dh_callback)(SSL *ssl, int is_export, int keylength));\nlong SSL_set_tmp_dh(SSL *ssl, DH *dh)\n</code></pre>"},{"location":"man3/SSL_CTX_set_tmp_dh_callback/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_tmp_dh_callback() sets the callback function for ctx to be used when a DH parameters are required to tmp_dh_callback. The callback is inherited by all ssl objects created from ctx.</p> <p>SSL_CTX_set_tmp_dh() sets DH parameters to be used to be dh. The key is inherited by all ssl objects created from ctx.</p> <p>SSL_set_tmp_dh_callback() sets the callback only for ssl.</p> <p>SSL_set_tmp_dh() sets the parameters only for ssl.</p> <p>These functions apply to SSL/TLS servers only.</p>"},{"location":"man3/SSL_CTX_set_tmp_dh_callback/#notes","title":"NOTES","text":"<p>When using a cipher with RSA authentication, an ephemeral DH key exchange can take place. Ciphers with DSA keys always use ephemeral DH keys as well. In these cases, the session data are negotiated using the ephemeral/temporary DH key and the key supplied and certified by the certificate chain is only used for signing. Anonymous ciphers (without a permanent server key) also use ephemeral DH keys.</p> <p>Using ephemeral DH key exchange yields forward secrecy, as the connection can only be decrypted, when the DH key is known. By generating a temporary DH key inside the server application that is lost when the application is left, it becomes impossible for an attacker to decrypt past sessions, even if he gets hold of the normal (certified) key, as this key was only used for signing.</p> <p>In order to perform a DH key exchange the server must use a DH group (DH parameters) and generate a DH key. The server will always generate a new DH key during the negotiation.</p> <p>As generating DH parameters is extremely time consuming, an application should not generate the parameters on the fly but supply the parameters. DH parameters can be reused, as the actual key is newly generated during the negotiation. The risk in reusing DH parameters is that an attacker may specialize on a very often used DH group. Applications should therefore generate their own DH parameters during the installation process using the openssl dhparam(1) application. This application guarantees that \"strong\" primes are used.</p> <p>Files dh2048.pem, and dh4096.pem in the 'apps' directory of the current version of the OpenSSL distribution contain the 'SKIP' DH parameters, which use safe primes and were generated verifiably pseudo-randomly. These files can be converted into C code using the -C option of the dhparam(1) application. Generation of custom DH parameters during installation should still be preferred to stop an attacker from specializing on a commonly used group. Files dh1024.pem and dh512.pem contain old parameters that must not be used by applications.</p> <p>An application may either directly specify the DH parameters or can supply the DH parameters via a callback function.</p> <p>Previous versions of the callback used is_export and keylength parameters to control parameter generation for export and non-export cipher suites. Modern servers that do not support export ciphersuites are advised to either use SSL_CTX_set_tmp_dh() or alternatively, use the callback but ignore keylength and is_export and simply supply at least 2048-bit parameters in the callback.</p>"},{"location":"man3/SSL_CTX_set_tmp_dh_callback/#examples","title":"EXAMPLES","text":"<p>Setup DH parameters with a key length of 2048 bits. (Error handling partly left out.)</p> <pre><code>Command-line parameter generation:\n$ openssl dhparam -out dh_param_2048.pem 2048\n\nCode for setting up parameters during server initialization:\n\n...\nSSL_CTX ctx = SSL_CTX_new();\n...\n\n/* Set up ephemeral DH parameters. */\nDH *dh_2048 = NULL;\nFILE *paramfile;\nparamfile = fopen(\"dh_param_2048.pem\", \"r\");\nif (paramfile) {\n  dh_2048 = PEM_read_DHparams(paramfile, NULL, NULL, NULL);\n  fclose(paramfile);\n} else {\n  /* Error. */\n}\nif (dh_2048 == NULL) {\n /* Error. */\n}\nif (SSL_CTX_set_tmp_dh(ctx, dh_2048) != 1) {\n  /* Error. */\n}\n...\n</code></pre>"},{"location":"man3/SSL_CTX_set_tmp_dh_callback/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_tmp_dh_callback() and SSL_set_tmp_dh_callback() do not return diagnostic output.</p> <p>SSL_CTX_set_tmp_dh() and SSL_set_tmp_dh() do return 1 on success and 0 on failure. Check the error queue to find out the reason of failure.</p>"},{"location":"man3/SSL_CTX_set_tmp_dh_callback/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_cipher_list(3), SSL_CTX_set_tmp_rsa_callback(3), SSL_CTX_set_options(3), ciphers(1), dhparam(1)</p>"},{"location":"man3/SSL_CTX_set_tmp_rsa_callback/","title":"SSL_CTX_set_tmp_rsa_callback","text":""},{"location":"man3/SSL_CTX_set_tmp_rsa_callback/#name","title":"NAME","text":"<p>SSL_CTX_set_tmp_rsa_callback, SSL_CTX_set_tmp_rsa, SSL_CTX_need_tmp_rsa, SSL_set_tmp_rsa_callback, SSL_set_tmp_rsa, SSL_need_tmp_rsa - handle RSA keys for ephemeral key exchange</p>"},{"location":"man3/SSL_CTX_set_tmp_rsa_callback/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx,\n           RSA *(*tmp_rsa_callback)(SSL *ssl, int is_export, int keylength));\nlong SSL_CTX_set_tmp_rsa(SSL_CTX *ctx, RSA *rsa);\nlong SSL_CTX_need_tmp_rsa(SSL_CTX *ctx);\n\nvoid SSL_set_tmp_rsa_callback(SSL_CTX *ctx,\n           RSA *(*tmp_rsa_callback)(SSL *ssl, int is_export, int keylength));\nlong SSL_set_tmp_rsa(SSL *ssl, RSA *rsa)\nlong SSL_need_tmp_rsa(SSL *ssl)\n\nRSA *(*tmp_rsa_callback)(SSL *ssl, int is_export, int keylength);\n</code></pre>"},{"location":"man3/SSL_CTX_set_tmp_rsa_callback/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_tmp_rsa_callback() sets the callback function for ctx to be used when a temporary/ephemeral RSA key is required to tmp_rsa_callback. The callback is inherited by all SSL objects newly created from ctx with &lt;SSL_new(3)|SSL_new(3)&gt;. Already created SSL objects are not affected.</p> <p>SSL_CTX_set_tmp_rsa() sets the temporary/ephemeral RSA key to be used to be rsa. The key is inherited by all SSL objects newly created from ctx with &lt;SSL_new(3)|SSL_new(3)&gt;. Already created SSL objects are not affected.</p> <p>SSL_CTX_need_tmp_rsa() returns 1, if a temporary/ephemeral RSA key is needed for RSA-based strength-limited 'exportable' ciphersuites because a RSA key with a keysize larger than 512 bits is installed.</p> <p>SSL_set_tmp_rsa_callback() sets the callback only for ssl.</p> <p>SSL_set_tmp_rsa() sets the key only for ssl.</p> <p>SSL_need_tmp_rsa() returns 1, if a temporary/ephemeral RSA key is needed, for RSA-based strength-limited 'exportable' ciphersuites because a RSA key with a keysize larger than 512 bits is installed.</p> <p>These functions apply to SSL/TLS servers only.</p>"},{"location":"man3/SSL_CTX_set_tmp_rsa_callback/#notes","title":"NOTES","text":"<p>When using a cipher with RSA authentication, an ephemeral RSA key exchange can take place. In this case the session data are negotiated using the ephemeral/temporary RSA key and the RSA key supplied and certified by the certificate chain is only used for signing.</p> <p>Under previous export restrictions, ciphers with RSA keys shorter (512 bits) than the usual key length of 1024 bits were created. To use these ciphers with RSA keys of usual length, an ephemeral key exchange must be performed, as the normal (certified) key cannot be directly used.</p> <p>Using ephemeral RSA key exchange yields forward secrecy, as the connection can only be decrypted, when the RSA key is known. By generating a temporary RSA key inside the server application that is lost when the application is left, it becomes impossible for an attacker to decrypt past sessions, even if he gets hold of the normal (certified) RSA key, as this key was used for signing only. The downside is that creating a RSA key is computationally expensive.</p> <p>Additionally, the use of ephemeral RSA key exchange is only allowed in the TLS standard, when the RSA key can be used for signing only, that is for export ciphers. Using ephemeral RSA key exchange for other purposes violates the standard and can break interoperability with clients. It is therefore strongly recommended to not use ephemeral RSA key exchange and use DHE (Ephemeral Diffie-Hellman) key exchange instead in order to achieve forward secrecy (see SSL_CTX_set_tmp_dh_callback(3)).</p> <p>An application may either directly specify the key or can supply the key via a callback function. The callback approach has the advantage, that the callback may generate the key only in case it is actually needed. As the generation of a RSA key is however costly, it will lead to a significant delay in the handshake procedure.  Another advantage of the callback function is that it can supply keys of different size while the explicit setting of the key is only useful for key size of 512 bits to satisfy the export restricted ciphers and does give away key length if a longer key would be allowed.</p> <p>The tmp_rsa_callback is called with the keylength needed and the is_export information. The is_export flag is set, when the ephemeral RSA key exchange is performed with an export cipher.</p>"},{"location":"man3/SSL_CTX_set_tmp_rsa_callback/#examples","title":"EXAMPLES","text":"<p>Generate temporary RSA keys to prepare ephemeral RSA key exchange. As the generation of a RSA key costs a lot of computer time, they saved for later reuse. For demonstration purposes, two keys for 512 bits and 1024 bits respectively are generated.</p> <pre><code>...\n/* Set up ephemeral RSA stuff */\nRSA *rsa_512 = NULL;\nRSA *rsa_1024 = NULL;\n\nrsa_512 = RSA_generate_key(512,RSA_F4,NULL,NULL);\nif (rsa_512 == NULL)\n    evaluate_error_queue();\n\nrsa_1024 = RSA_generate_key(1024,RSA_F4,NULL,NULL);\nif (rsa_1024 == NULL)\n  evaluate_error_queue();\n\n...\n\nRSA *tmp_rsa_callback(SSL *s, int is_export, int keylength)\n{\n   RSA *rsa_tmp=NULL;\n\n   switch (keylength) {\n   case 512:\n     if (rsa_512)\n       rsa_tmp = rsa_512;\n     else { /* generate on the fly, should not happen in this example */\n       rsa_tmp = RSA_generate_key(keylength,RSA_F4,NULL,NULL);\n       rsa_512 = rsa_tmp; /* Remember for later reuse */\n     }\n     break;\n   case 1024:\n     if (rsa_1024)\n       rsa_tmp=rsa_1024;\n     else\n       should_not_happen_in_this_example();\n     break;\n   default:\n     /* Generating a key on the fly is very costly, so use what is there */\n     if (rsa_1024)\n       rsa_tmp=rsa_1024;\n     else\n       rsa_tmp=rsa_512; /* Use at least a shorter key */\n   }\n   return(rsa_tmp);\n}\n</code></pre>"},{"location":"man3/SSL_CTX_set_tmp_rsa_callback/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_tmp_rsa_callback() and SSL_set_tmp_rsa_callback() do not return diagnostic output.</p> <p>SSL_CTX_set_tmp_rsa() and SSL_set_tmp_rsa() do return 1 on success and 0 on failure. Check the error queue to find out the reason of failure.</p> <p>SSL_CTX_need_tmp_rsa() and SSL_need_tmp_rsa() return 1 if a temporary RSA key is needed and 0 otherwise.</p>"},{"location":"man3/SSL_CTX_set_tmp_rsa_callback/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_cipher_list(3), SSL_CTX_set_options(3), SSL_CTX_set_tmp_dh_callback(3), SSL_new(3), ciphers(1)</p>"},{"location":"man3/SSL_CTX_set_verify/","title":"SSL_CTX_set_verify","text":""},{"location":"man3/SSL_CTX_set_verify/#name","title":"NAME","text":"<p>SSL_CTX_set_verify, SSL_set_verify, SSL_CTX_set_verify_depth, SSL_set_verify_depth - set peer certificate verification parameters</p>"},{"location":"man3/SSL_CTX_set_verify/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_CTX_set_verify(SSL_CTX *ctx, int mode,\n                        int (*verify_callback)(int, X509_STORE_CTX *));\nvoid SSL_set_verify(SSL *s, int mode,\n                    int (*verify_callback)(int, X509_STORE_CTX *));\nvoid SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth);\nvoid SSL_set_verify_depth(SSL *s, int depth);\n\nint verify_callback(int preverify_ok, X509_STORE_CTX *x509_ctx);\n</code></pre>"},{"location":"man3/SSL_CTX_set_verify/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_set_verify() sets the verification flags for ctx to be mode and specifies the verify_callback function to be used. If no callback function shall be specified, the NULL pointer can be used for verify_callback.</p> <p>SSL_set_verify() sets the verification flags for ssl to be mode and specifies the verify_callback function to be used. If no callback function shall be specified, the NULL pointer can be used for verify_callback. In this case last verify_callback set specifically for this ssl remains. If no special callback was set before, the default callback for the underlying ctx is used, that was valid at the time ssl was created with SSL_new(3).</p> <p>SSL_CTX_set_verify_depth() sets the maximum depth for the certificate chain verification that shall be allowed for ctx. (See the BUGS section.)</p> <p>SSL_set_verify_depth() sets the maximum depth for the certificate chain verification that shall be allowed for ssl. (See the BUGS section.)</p>"},{"location":"man3/SSL_CTX_set_verify/#notes","title":"NOTES","text":"<p>The verification of certificates can be controlled by a set of logically or'ed mode flags:</p> <ul> <li> <p>SSL_VERIFY_NONE</p> <p>Server mode: the server will not send a client certificate request to the client, so the client will not send a certificate.</p> <p>Client mode: if not using an anonymous cipher (by default disabled), the server will send a certificate which will be checked. The result of the certificate verification process can be checked after the TLS/SSL handshake using the SSL_get_verify_result(3) function. The handshake will be continued regardless of the verification result.</p> </li> <li> <p>SSL_VERIFY_PEER</p> <p>Server mode: the server sends a client certificate request to the client. The certificate returned (if any) is checked. If the verification process fails, the TLS/SSL handshake is immediately terminated with an alert message containing the reason for the verification failure. The behaviour can be controlled by the additional SSL_VERIFY_FAIL_IF_NO_PEER_CERT and SSL_VERIFY_CLIENT_ONCE flags.</p> <p>Client mode: the server certificate is verified. If the verification process fails, the TLS/SSL handshake is immediately terminated with an alert message containing the reason for the verification failure. If no server certificate is sent, because an anonymous cipher is used, SSL_VERIFY_PEER is ignored.</p> </li> <li> <p>SSL_VERIFY_FAIL_IF_NO_PEER_CERT</p> <p>Server mode: if the client did not return a certificate, the TLS/SSL handshake is immediately terminated with a \"handshake failure\" alert. This flag must be used together with SSL_VERIFY_PEER.</p> <p>Client mode: ignored</p> </li> <li> <p>SSL_VERIFY_CLIENT_ONCE</p> <p>Server mode: only request a client certificate on the initial TLS/SSL handshake. Do not ask for a client certificate again in case of a renegotiation. This flag must be used together with SSL_VERIFY_PEER.</p> <p>Client mode: ignored</p> </li> </ul> <p>Exactly one of the mode flags SSL_VERIFY_NONE and SSL_VERIFY_PEER must be set at any time.</p> <p>The actual verification procedure is performed either using the built-in verification procedure or using another application provided verification function set with SSL_CTX_set_cert_verify_callback(3). The following descriptions apply in the case of the built-in procedure. An application provided procedure also has access to the verify depth information and the verify_callback() function, but the way this information is used may be different.</p> <p>SSL_CTX_set_verify_depth() and SSL_set_verify_depth() set the limit up to which depth certificates in a chain are used during the verification procedure. If the certificate chain is longer than allowed, the certificates above the limit are ignored. Error messages are generated as if these certificates would not be present, most likely a X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY will be issued. The depth count is \"level 0:peer certificate\", \"level 1: CA certificate\", \"level 2: higher level CA certificate\", and so on. Setting the maximum depth to 2 allows the levels 0, 1, and 2. The default depth limit is 100, allowing for the peer certificate and additional 100 CA certificates.</p> <p>The verify_callback function is used to control the behaviour when the SSL_VERIFY_PEER flag is set. It must be supplied by the application and receives two arguments: preverify_ok indicates, whether the verification of the certificate in question was passed (preverify_ok=1) or not (preverify_ok=0). x509_ctx is a pointer to the complete context used for the certificate chain verification.</p> <p>The certificate chain is checked starting with the deepest nesting level (the root CA certificate) and worked upward to the peer's certificate. At each level signatures and issuer attributes are checked. Whenever a verification error is found, the error number is stored in x509_ctx and verify_callback is called with preverify_ok=0. By applying X509_CTX_store_* functions verify_callback can locate the certificate in question and perform additional steps (see EXAMPLES). If no error is found for a certificate, verify_callback is called with preverify_ok=1 before advancing to the next level.</p> <p>The return value of verify_callback controls the strategy of the further verification process. If verify_callback returns 0, the verification process is immediately stopped with \"verification failed\" state. If SSL_VERIFY_PEER is set, a verification failure alert is sent to the peer and the TLS/SSL handshake is terminated. If verify_callback returns 1, the verification process is continued. If verify_callback always returns 1, the TLS/SSL handshake will not be terminated with respect to verification failures and the connection will be established. The calling process can however retrieve the error code of the last verification error using SSL_get_verify_result(3) or by maintaining its own error storage managed by verify_callback.</p> <p>If no verify_callback is specified, the default callback will be used. Its return value is identical to preverify_ok, so that any verification failure will lead to a termination of the TLS/SSL handshake with an alert message, if SSL_VERIFY_PEER is set.</p>"},{"location":"man3/SSL_CTX_set_verify/#bugs","title":"BUGS","text":"<p>In client mode, it is not checked whether the SSL_VERIFY_PEER flag is set, but whether SSL_VERIFY_NONE is not set. This can lead to unexpected behaviour, if the SSL_VERIFY_PEER and SSL_VERIFY_NONE are not used as required (exactly one must be set at any time).</p> <p>The certificate verification depth set with SSL[_CTX]_verify_depth() stops the verification at a certain depth. The error message produced will be that of an incomplete certificate chain and not X509_V_ERR_CERT_CHAIN_TOO_LONG as may be expected.</p>"},{"location":"man3/SSL_CTX_set_verify/#return-values","title":"RETURN VALUES","text":"<p>The SSL*_set_verify*() functions do not provide diagnostic information.</p>"},{"location":"man3/SSL_CTX_set_verify/#examples","title":"EXAMPLES","text":"<p>The following code sequence realizes an example verify_callback function that will always continue the TLS/SSL handshake regardless of verification failure, if wished. The callback realizes a verification depth limit with more informational output.</p> <p>All verification errors are printed; information about the certificate chain is printed on request. The example is realized for a server that does allow but not require client certificates.</p> <p>The example makes use of the ex_data technique to store application data into/retrieve application data from the SSL structure (see SSL_get_ex_new_index(3), SSL_get_ex_data_X509_STORE_CTX_idx(3)).</p> <pre><code>...\ntypedef struct {\n  int verbose_mode;\n  int verify_depth;\n  int always_continue;\n} mydata_t;\nint mydata_index;\n...\nstatic int verify_callback(int preverify_ok, X509_STORE_CTX *ctx)\n{\n   char    buf[256];\n   X509   *err_cert;\n   int     err, depth;\n   SSL    *ssl;\n   mydata_t *mydata;\n\n   err_cert = X509_STORE_CTX_get_current_cert(ctx);\n   err = X509_STORE_CTX_get_error(ctx);\n   depth = X509_STORE_CTX_get_error_depth(ctx);\n\n   /*\n    * Retrieve the pointer to the SSL of the connection currently treated\n    * and the application specific data stored into the SSL object.\n    */\n   ssl = X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx());\n   mydata = SSL_get_ex_data(ssl, mydata_index);\n\n   X509_NAME_oneline(X509_get_subject_name(err_cert), buf, 256);\n\n   /*\n    * Catch a too long certificate chain. The depth limit set using\n    * SSL_CTX_set_verify_depth() is by purpose set to \"limit+1\" so\n    * that whenever the \"depth&gt;verify_depth\" condition is met, we\n    * have violated the limit and want to log this error condition.\n    * We must do it here, because the CHAIN_TOO_LONG error would not\n    * be found explicitly; only errors introduced by cutting off the\n    * additional certificates would be logged.\n    */\n   if (depth &gt; mydata-&gt;verify_depth) {\n       preverify_ok = 0;\n       err = X509_V_ERR_CERT_CHAIN_TOO_LONG;\n       X509_STORE_CTX_set_error(ctx, err);\n   } \n   if (!preverify_ok) {\n       printf(\"verify error:num=%d:%s:depth=%d:%s\\n\", err,\n                X509_verify_cert_error_string(err), depth, buf);\n   }\n   else if (mydata-&gt;verbose_mode)\n   {\n       printf(\"depth=%d:%s\\n\", depth, buf);\n   }\n\n   /*\n    * At this point, err contains the last verification error. We can use\n    * it for something special\n    */\n   if (!preverify_ok &amp;&amp; (err == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT))\n   {\n     X509_NAME_oneline(X509_get_issuer_name(ctx-&gt;current_cert), buf, 256);\n     printf(\"issuer= %s\\n\", buf);\n   }\n\n   if (mydata-&gt;always_continue)\n     return 1;\n   else\n     return preverify_ok;\n}\n...\n\nmydata_t mydata;\n\n...\nmydata_index = SSL_get_ex_new_index(0, \"mydata index\", NULL, NULL, NULL);\n\n...\nSSL_CTX_set_verify(ctx, SSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE,\n                   verify_callback);\n\n/*\n * Let the verify_callback catch the verify_depth error so that we get\n * an appropriate error in the logfile.\n */\nSSL_CTX_set_verify_depth(verify_depth + 1);\n\n/*\n * Set up the SSL specific data into \"mydata\" and store it into th SSL\n * structure.\n */\nmydata.verify_depth = verify_depth; ...\nSSL_set_ex_data(ssl, mydata_index, &amp;mydata);\n\n...\nSSL_accept(ssl);       /* check of success left out for clarity */\nif (peer = SSL_get_peer_certificate(ssl))\n{\n  if (SSL_get_verify_result(ssl) == X509_V_OK)\n  {\n    /* The client sent a certificate which verified OK */\n  }\n}\n</code></pre>"},{"location":"man3/SSL_CTX_set_verify/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_new(3), SSL_CTX_get_verify_mode(3), SSL_get_verify_result(3), SSL_CTX_load_verify_locations(3), SSL_get_peer_certificate(3), SSL_CTX_set_cert_verify_callback(3), SSL_get_ex_data_X509_STORE_CTX_idx(3), SSL_get_ex_new_index(3)</p>"},{"location":"man3/SSL_CTX_use_certificate/","title":"SSL_CTX_use_certificate","text":""},{"location":"man3/SSL_CTX_use_certificate/#name","title":"NAME","text":"<p>SSL_CTX_use_certificate, SSL_CTX_use_certificate_ASN1, SSL_CTX_use_certificate_file, SSL_use_certificate, SSL_use_certificate_ASN1, SSL_use_certificate_file, SSL_CTX_use_certificate_chain_file, SSL_CTX_use_PrivateKey, SSL_CTX_use_PrivateKey_ASN1, SSL_CTX_use_PrivateKey_file, SSL_CTX_use_RSAPrivateKey, SSL_CTX_use_RSAPrivateKey_ASN1, SSL_CTX_use_RSAPrivateKey_file, SSL_use_PrivateKey_file, SSL_use_PrivateKey_ASN1, SSL_use_PrivateKey, SSL_use_RSAPrivateKey, SSL_use_RSAPrivateKey_ASN1, SSL_use_RSAPrivateKey_file, SSL_CTX_check_private_key, SSL_check_private_key - load certificate and key data</p>"},{"location":"man3/SSL_CTX_use_certificate/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);\nint SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, unsigned char *d);\nint SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type);\nint SSL_use_certificate(SSL *ssl, X509 *x);\nint SSL_use_certificate_ASN1(SSL *ssl, unsigned char *d, int len);\nint SSL_use_certificate_file(SSL *ssl, const char *file, int type);\n\nint SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file);\n\nint SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);\nint SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx, unsigned char *d,\n                                long len);\nint SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);\nint SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);\nint SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long len);\nint SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type);\nint SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey);\nint SSL_use_PrivateKey_ASN1(int pk,SSL *ssl, unsigned char *d, long len);\nint SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type);\nint SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa);\nint SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len);\nint SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type);\n\nint SSL_CTX_check_private_key(const SSL_CTX *ctx);\nint SSL_check_private_key(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_CTX_use_certificate/#description","title":"DESCRIPTION","text":"<p>These functions load the certificates and private keys into the SSL_CTX or SSL object, respectively.</p> <p>The SSL_CTX_* class of functions loads the certificates and keys into the SSL_CTX object ctx. The information is passed to SSL objects ssl created from ctx with SSL_new(3) by copying, so that changes applied to ctx do not propagate to already existing SSL objects.</p> <p>The SSL_* class of functions only loads certificates and keys into a specific SSL object. The specific information is kept, when SSL_clear(3) is called for this SSL object.</p> <p>SSL_CTX_use_certificate() loads the certificate x into ctx, SSL_use_certificate() loads x into ssl. The rest of the certificates needed to form the complete certificate chain can be specified using the SSL_CTX_add_extra_chain_cert(3) function.</p> <p>SSL_CTX_use_certificate_ASN1() loads the ASN1 encoded certificate from the memory location d (with length len) into ctx, SSL_use_certificate_ASN1() loads the ASN1 encoded certificate into ssl.</p> <p>SSL_CTX_use_certificate_file() loads the first certificate stored in file into ctx. The formatting type of the certificate must be specified from the known types SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1. SSL_use_certificate_file() loads the certificate from file into ssl. See the NOTES section on why SSL_CTX_use_certificate_chain_file() should be preferred.</p> <p>SSL_CTX_use_certificate_chain_file() loads a certificate chain from  file into ctx. The certificates must be in PEM format and must be sorted starting with the subject's certificate (actual client or server certificate), followed by intermediate CA certificates if applicable, and ending at the highest level (root) CA. There is no corresponding function working on a single SSL object.</p> <p>SSL_CTX_use_PrivateKey() adds pkey as private key to ctx. SSL_CTX_use_RSAPrivateKey() adds the private key rsa of type RSA to ctx. SSL_use_PrivateKey() adds pkey as private key to ssl; SSL_use_RSAPrivateKey() adds rsa as private key of type RSA to ssl. If a certificate has already been set and the private does not belong to the certificate an error is returned. To change a certificate, private key pair the new certificate needs to be set with SSL_use_certificate() or SSL_CTX_use_certificate() before setting the private key with SSL_CTX_use_PrivateKey() or SSL_use_PrivateKey(). </p> <p>SSL_CTX_use_PrivateKey_ASN1() adds the private key of type pk stored at memory location d (length len) to ctx. SSL_CTX_use_RSAPrivateKey_ASN1() adds the private key of type RSA stored at memory location d (length len) to ctx. SSL_use_PrivateKey_ASN1() and SSL_use_RSAPrivateKey_ASN1() add the private key to ssl.</p> <p>SSL_CTX_use_PrivateKey_file() adds the first private key found in file to ctx. The formatting type of the certificate must be specified from the known types SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1. SSL_CTX_use_RSAPrivateKey_file() adds the first private RSA key found in file to ctx. SSL_use_PrivateKey_file() adds the first private key found in file to ssl; SSL_use_RSAPrivateKey_file() adds the first private RSA key found to ssl.</p> <p>SSL_CTX_check_private_key() checks the consistency of a private key with the corresponding certificate loaded into ctx. If more than one key/certificate pair (RSA/DSA) is installed, the last item installed will be checked. If e.g. the last item was a RSA certificate or key, the RSA key/certificate pair will be checked. SSL_check_private_key() performs the same check for ssl. If no key/certificate was explicitly added for this ssl, the last item added into ctx will be checked.</p>"},{"location":"man3/SSL_CTX_use_certificate/#notes","title":"NOTES","text":"<p>The internal certificate store of OpenSSL can hold several private key/certificate pairs at a time. The certificate used depends on the cipher selected, see also SSL_CTX_set_cipher_list(3).</p> <p>When reading certificates and private keys from file, files of type SSL_FILETYPE_ASN1 (also known as DER, binary encoding) can only contain one certificate or private key, consequently  SSL_CTX_use_certificate_chain_file() is only applicable to PEM formatting. Files of type SSL_FILETYPE_PEM can contain more than one item.</p> <p>SSL_CTX_use_certificate_chain_file() adds the first certificate found in the file to the certificate store. The other certificates are added to the store of chain certificates using SSL_CTX_add1_chain_cert(3). Note: versions of OpenSSL before 1.0.2 only had a single certificate chain store for all certificate types, OpenSSL 1.0.2 and later have a separate chain store for each type. SSL_CTX_use_certificate_chain_file()  should be used instead of the SSL_CTX_use_certificate_file() function in order to allow the use of complete certificate chains even when no trusted CA storage is used or when the CA issuing the certificate shall not be added to the trusted CA storage.</p> <p>If additional certificates are needed to complete the chain during the TLS negotiation, CA certificates are additionally looked up in the locations of trusted CA certificates, see SSL_CTX_load_verify_locations(3).</p> <p>The private keys loaded from file can be encrypted. In order to successfully load encrypted keys, a function returning the passphrase must have been supplied, see SSL_CTX_set_default_passwd_cb(3). (Certificate files might be encrypted as well from the technical point of view, it however does not make sense as the data in the certificate is considered public anyway.)</p> <p>All of the functions to set a new certificate will replace any existing certificate of the same type that has already been set. Similarly all of the functions to set a new private key will replace any private key that has already been set. Applications should call SSL_CTX_check_private_key(3) or SSL_check_private_key(3) as appropriate after loading a new certificate and private key to confirm that the certificate and key match.</p>"},{"location":"man3/SSL_CTX_use_certificate/#return-values","title":"RETURN VALUES","text":"<p>On success, the functions return 1. Otherwise check out the error stack to find out the reason.</p>"},{"location":"man3/SSL_CTX_use_certificate/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_new(3), SSL_clear(3), SSL_CTX_load_verify_locations(3), SSL_CTX_set_default_passwd_cb(3), SSL_CTX_set_cipher_list(3), SSL_CTX_set_client_cert_cb(3), SSL_CTX_add_extra_chain_cert(3)</p>"},{"location":"man3/SSL_CTX_use_certificate/#history","title":"HISTORY","text":"<p>Support for DER encoded private keys (SSL_FILETYPE_ASN1) in SSL_CTX_use_PrivateKey_file() and SSL_use_PrivateKey_file() was added in 0.9.8 .</p>"},{"location":"man3/SSL_CTX_use_psk_identity_hint/","title":"SSL_CTX_use_psk_identity_hint","text":""},{"location":"man3/SSL_CTX_use_psk_identity_hint/#name","title":"NAME","text":"<p>SSL_CTX_use_psk_identity_hint, SSL_use_psk_identity_hint, SSL_CTX_set_psk_server_callback, SSL_set_psk_server_callback - set PSK identity hint to use</p>"},{"location":"man3/SSL_CTX_use_psk_identity_hint/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *hint);\nint SSL_use_psk_identity_hint(SSL *ssl, const char *hint);\n\nvoid SSL_CTX_set_psk_server_callback(SSL_CTX *ctx,\n       unsigned int (*callback)(SSL *ssl, const char *identity,\n       unsigned char *psk, int max_psk_len));\nvoid SSL_set_psk_server_callback(SSL *ssl,\n       unsigned int (*callback)(SSL *ssl, const char *identity,\n       unsigned char *psk, int max_psk_len));\n</code></pre>"},{"location":"man3/SSL_CTX_use_psk_identity_hint/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_use_psk_identity_hint() sets the given NULL-terminated PSK identity hint hint to SSL context object ctx. SSL_use_psk_identity_hint() sets the given NULL-terminated PSK identity hint hint to SSL connection object ssl. If hint is NULL the current hint from ctx or ssl is deleted.</p> <p>In the case where PSK identity hint is NULL, the server does not send the ServerKeyExchange message to the client.</p> <p>A server application must provide a callback function which is called when the server receives the ClientKeyExchange message from the client. The purpose of the callback function is to validate the received PSK identity and to fetch the pre-shared key used during the connection setup phase. The callback is set using functions SSL_CTX_set_psk_server_callback() or SSL_set_psk_server_callback(). The callback function is given the connection in parameter ssl, NULL-terminated PSK identity sent by the client in parameter identity, and a buffer psk of length max_psk_len bytes where the pre-shared key is to be stored.</p>"},{"location":"man3/SSL_CTX_use_psk_identity_hint/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_use_psk_identity_hint() and SSL_use_psk_identity_hint() return 1 on success, 0 otherwise.</p> <p>Return values from the server callback are interpreted as follows:</p> <ul> <li> <p>0</p> <p>PSK identity was not found. An \"unknown_psk_identity\" alert message will be sent and the connection setup fails.</p> </li> <li> <p>&gt;0</p> <p>PSK identity was found and the server callback has provided the PSK successfully in parameter psk. Return value is the length of psk in bytes. It is an error to return a value greater than max_psk_len.</p> <p>If the PSK identity was not found but the callback instructs the protocol to continue anyway, the callback must provide some random data to psk and return the length of the random data, so the connection will fail with decryption_error before it will be finished completely.</p> </li> </ul>"},{"location":"man3/SSL_CTX_use_serverinfo/","title":"SSL_CTX_use_serverinfo","text":""},{"location":"man3/SSL_CTX_use_serverinfo/#name","title":"NAME","text":"<p>SSL_CTX_use_serverinfo, SSL_CTX_use_serverinfo_file - use serverinfo extension</p>"},{"location":"man3/SSL_CTX_use_serverinfo/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_CTX_use_serverinfo(SSL_CTX *ctx, const unsigned char *serverinfo,\n                           size_t serverinfo_length);\n\nint SSL_CTX_use_serverinfo_file(SSL_CTX *ctx, const char *file);\n</code></pre>"},{"location":"man3/SSL_CTX_use_serverinfo/#description","title":"DESCRIPTION","text":"<p>These functions load \"serverinfo\" TLS ServerHello Extensions into the SSL_CTX. A \"serverinfo\" extension is returned in response to an empty ClientHello Extension.</p> <p>SSL_CTX_use_serverinfo() loads one or more serverinfo extensions from a byte array into ctx.  The extensions must be concatenated into a  sequence of bytes.  Each extension must consist of a 2-byte Extension Type,  a 2-byte length, and then length bytes of extension_data.</p> <p>SSL_CTX_use_serverinfo_file() loads one or more serverinfo extensions from file into ctx.  The extensions must be in PEM format.  Each extension must consist of a 2-byte Extension Type, a 2-byte length, and then length bytes of extension_data.  Each PEM extension name must begin with the phrase \"BEGIN SERVERINFO FOR \".</p> <p>If more than one certificate (RSA/DSA) is installed using SSL_CTX_use_certificate(), the serverinfo extension will be loaded into the last certificate installed.  If e.g. the last item was a RSA certificate, the loaded serverinfo extension data will be loaded for that certificate.  To use the serverinfo extension for multiple certificates, SSL_CTX_use_serverinfo() needs to be called multiple times, once after each time a certificate is loaded.</p>"},{"location":"man3/SSL_CTX_use_serverinfo/#notes","title":"NOTES","text":""},{"location":"man3/SSL_CTX_use_serverinfo/#return-values","title":"RETURN VALUES","text":"<p>On success, the functions return 1. On failure, the functions return 0.  Check out the error stack to find out the reason.</p>"},{"location":"man3/SSL_CTX_use_serverinfo/#see-also","title":"SEE ALSO","text":""},{"location":"man3/SSL_CTX_use_serverinfo/#history","title":"HISTORY","text":""},{"location":"man3/SSL_SESSION_free/","title":"SSL_SESSION_free","text":""},{"location":"man3/SSL_SESSION_free/#name","title":"NAME","text":"<p>SSL_SESSION_free - free an allocated SSL_SESSION structure</p>"},{"location":"man3/SSL_SESSION_free/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_SESSION_free(SSL_SESSION *session);\n</code></pre>"},{"location":"man3/SSL_SESSION_free/#description","title":"DESCRIPTION","text":"<p>SSL_SESSION_free() decrements the reference count of session and removes the SSL_SESSION structure pointed to by session and frees up the allocated memory, if the reference count has reached 0.</p>"},{"location":"man3/SSL_SESSION_free/#notes","title":"NOTES","text":"<p>SSL_SESSION objects are allocated, when a TLS/SSL handshake operation is successfully completed. Depending on the settings, see SSL_CTX_set_session_cache_mode(3), the SSL_SESSION objects are internally referenced by the SSL_CTX and linked into its session cache. SSL objects may be using the SSL_SESSION object; as a session may be reused, several SSL objects may be using one SSL_SESSION object at the same time. It is therefore crucial to keep the reference count (usage information) correct and not delete a SSL_SESSION object that is still used, as this may lead to program failures due to dangling pointers. These failures may also appear delayed, e.g. when an SSL_SESSION object was completely freed as the reference count incorrectly became 0, but it is still referenced in the internal session cache and the cache list is processed during a SSL_CTX_flush_sessions(3) operation.</p> <p>SSL_SESSION_free() must only be called for SSL_SESSION objects, for which the reference count was explicitly incremented (e.g. by calling SSL_get1_session(), see SSL_get_session(3)) or when the SSL_SESSION object was generated outside a TLS handshake operation, e.g. by using d2i_SSL_SESSION(3). It must not be called on other SSL_SESSION objects, as this would cause incorrect reference counts and therefore program failures.</p>"},{"location":"man3/SSL_SESSION_free/#return-values","title":"RETURN VALUES","text":"<p>SSL_SESSION_free() does not provide diagnostic information.</p>"},{"location":"man3/SSL_SESSION_free/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_get_session(3), SSL_CTX_set_session_cache_mode(3), SSL_CTX_flush_sessions(3),  d2i_SSL_SESSION(3)</p>"},{"location":"man3/SSL_SESSION_get_ex_new_index/","title":"SSL_SESSION_get_ex_new_index","text":""},{"location":"man3/SSL_SESSION_get_ex_new_index/#name","title":"NAME","text":"<p>SSL_SESSION_get_ex_new_index, SSL_SESSION_set_ex_data, SSL_SESSION_get_ex_data - internal application specific data functions</p>"},{"location":"man3/SSL_SESSION_get_ex_new_index/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_SESSION_get_ex_new_index(long argl, void *argp,\n               CRYPTO_EX_new *new_func,\n               CRYPTO_EX_dup *dup_func,\n               CRYPTO_EX_free *free_func);\n\nint SSL_SESSION_set_ex_data(SSL_SESSION *session, int idx, void *arg);\n\nvoid *SSL_SESSION_get_ex_data(const SSL_SESSION *session, int idx);\n\ntypedef int new_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n               int idx, long argl, void *argp);\ntypedef void free_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n               int idx, long argl, void *argp);\ntypedef int dup_func(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d,\n               int idx, long argl, void *argp);\n</code></pre>"},{"location":"man3/SSL_SESSION_get_ex_new_index/#description","title":"DESCRIPTION","text":"<p>Several OpenSSL structures can have application specific data attached to them. These functions are used internally by OpenSSL to manipulate application specific data attached to a specific structure.</p> <p>SSL_SESSION_get_ex_new_index() is used to register a new index for application specific data.</p> <p>SSL_SESSION_set_ex_data() is used to store application data at arg for idx into the session object.</p> <p>SSL_SESSION_get_ex_data() is used to retrieve the information for idx from session.</p> <p>A detailed description for the *_get_ex_new_index() functionality can be found in RSA_get_ex_new_index(3). The *_get_ex_data() and *_set_ex_data() functionality is described in CRYPTO_set_ex_data(3).</p>"},{"location":"man3/SSL_SESSION_get_ex_new_index/#warnings","title":"WARNINGS","text":"<p>The application data is only maintained for sessions held in memory. The application data is not included when dumping the session with i2d_SSL_SESSION() (and all functions indirectly calling the dump functions like PEM_write_SSL_SESSION() and PEM_write_bio_SSL_SESSION()) and can therefore not be restored.</p>"},{"location":"man3/SSL_SESSION_get_ex_new_index/#see-also","title":"SEE ALSO","text":"<p>ssl(3), RSA_get_ex_new_index(3), CRYPTO_set_ex_data(3)</p>"},{"location":"man3/SSL_SESSION_get_time/","title":"SSL_SESSION_get_time","text":""},{"location":"man3/SSL_SESSION_get_time/#name","title":"NAME","text":"<p>SSL_SESSION_get_time, SSL_SESSION_set_time, SSL_SESSION_get_timeout, SSL_SESSION_set_timeout - retrieve and manipulate session time and timeout settings</p>"},{"location":"man3/SSL_SESSION_get_time/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_SESSION_get_time(const SSL_SESSION *s);\nlong SSL_SESSION_set_time(SSL_SESSION *s, long tm);\nlong SSL_SESSION_get_timeout(const SSL_SESSION *s);\nlong SSL_SESSION_set_timeout(SSL_SESSION *s, long tm);\n\nlong SSL_get_time(const SSL_SESSION *s);\nlong SSL_set_time(SSL_SESSION *s, long tm);\nlong SSL_get_timeout(const SSL_SESSION *s);\nlong SSL_set_timeout(SSL_SESSION *s, long tm);\n</code></pre>"},{"location":"man3/SSL_SESSION_get_time/#description","title":"DESCRIPTION","text":"<p>SSL_SESSION_get_time() returns the time at which the session s was established. The time is given in seconds since the Epoch and therefore compatible to the time delivered by the time() call.</p> <p>SSL_SESSION_set_time() replaces the creation time of the session s with the chosen value tm.</p> <p>SSL_SESSION_get_timeout() returns the timeout value set for session s in seconds.</p> <p>SSL_SESSION_set_timeout() sets the timeout value for session s in seconds to tm.</p> <p>The SSL_get_time(), SSL_set_time(), SSL_get_timeout(), and SSL_set_timeout() functions are synonyms for the SSL_SESSION_*() counterparts.</p>"},{"location":"man3/SSL_SESSION_get_time/#notes","title":"NOTES","text":"<p>Sessions are expired by examining the creation time and the timeout value. Both are set at creation time of the session to the actual time and the default timeout value at creation, respectively, as set by SSL_CTX_set_timeout(3). Using these functions it is possible to extend or shorten the lifetime of the session.</p>"},{"location":"man3/SSL_SESSION_get_time/#return-values","title":"RETURN VALUES","text":"<p>SSL_SESSION_get_time() and SSL_SESSION_get_timeout() return the currently valid values.</p> <p>SSL_SESSION_set_time() and SSL_SESSION_set_timeout() return 1 on success.</p> <p>If any of the function is passed the NULL pointer for the session s,  0 is returned.</p>"},{"location":"man3/SSL_SESSION_get_time/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_timeout(3), SSL_get_default_timeout(3)</p>"},{"location":"man3/SSL_accept/","title":"SSL_accept","text":""},{"location":"man3/SSL_accept/#name","title":"NAME","text":"<p>SSL_accept - wait for a TLS/SSL client to initiate a TLS/SSL handshake</p>"},{"location":"man3/SSL_accept/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_accept(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_accept/#description","title":"DESCRIPTION","text":"<p>SSL_accept() waits for a TLS/SSL client to initiate the TLS/SSL handshake. The communication channel must already have been set and assigned to the ssl by setting an underlying BIO.</p>"},{"location":"man3/SSL_accept/#notes","title":"NOTES","text":"<p>The behaviour of SSL_accept() depends on the underlying BIO. </p> <p>If the underlying BIO is blocking, SSL_accept() will only return once the handshake has been finished or an error occurred.</p> <p>If the underlying BIO is non-blocking, SSL_accept() will also return when the underlying BIO could not satisfy the needs of SSL_accept() to continue the handshake, indicating the problem by the return value -1. In this case a call to SSL_get_error() with the return value of SSL_accept() will yield SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process then must repeat the call after taking appropriate action to satisfy the needs of SSL_accept(). The action depends on the underlying BIO. When using a non-blocking socket, nothing is to be done, but select() can be used to check for the required condition. When using a buffering BIO, like a BIO pair, data must be written into or retrieved out of the BIO before being able to continue.</p>"},{"location":"man3/SSL_accept/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>0</p> <p>The TLS/SSL handshake was not successful but was shut down controlled and by the specifications of the TLS/SSL protocol. Call SSL_get_error() with the return value ret to find out the reason.</p> </li> <li> <p>1</p> <p>The TLS/SSL handshake was successfully completed, a TLS/SSL connection has been established.</p> </li> <li> <p>&lt;0</p> <p>The TLS/SSL handshake was not successful because a fatal error occurred either at the protocol level or a connection failure occurred. The shutdown was not clean. It can also occur of action is need to continue the operation for non-blocking BIOs. Call SSL_get_error() with the return value ret to find out the reason.</p> </li> </ul>"},{"location":"man3/SSL_accept/#see-also","title":"SEE ALSO","text":"<p>SSL_get_error(3), SSL_connect(3), SSL_shutdown(3), ssl(3), bio(3), SSL_set_connect_state(3), SSL_do_handshake(3), SSL_CTX_new(3)</p>"},{"location":"man3/SSL_alert_type_string/","title":"SSL_alert_type_string","text":""},{"location":"man3/SSL_alert_type_string/#name","title":"NAME","text":"<p>SSL_alert_type_string, SSL_alert_type_string_long, SSL_alert_desc_string, SSL_alert_desc_string_long - get textual description of alert information</p>"},{"location":"man3/SSL_alert_type_string/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nconst char *SSL_alert_type_string(int value);\nconst char *SSL_alert_type_string_long(int value);\n\nconst char *SSL_alert_desc_string(int value);\nconst char *SSL_alert_desc_string_long(int value);\n</code></pre>"},{"location":"man3/SSL_alert_type_string/#description","title":"DESCRIPTION","text":"<p>SSL_alert_type_string() returns a one letter string indicating the type of the alert specified by value.</p> <p>SSL_alert_type_string_long() returns a string indicating the type of the alert specified by value.</p> <p>SSL_alert_desc_string() returns a two letter string as a short form describing the reason of the alert specified by value.</p> <p>SSL_alert_desc_string_long() returns a string describing the reason of the alert specified by value.</p>"},{"location":"man3/SSL_alert_type_string/#notes","title":"NOTES","text":"<p>When one side of an SSL/TLS communication wants to inform the peer about a special situation, it sends an alert. The alert is sent as a special message and does not influence the normal data stream (unless its contents results in the communication being canceled).</p> <p>A warning alert is sent, when a non-fatal error condition occurs. The \"close notify\" alert is sent as a warning alert. Other examples for non-fatal errors are certificate errors (\"certificate expired\", \"unsupported certificate\"), for which a warning alert may be sent. (The sending party may however decide to send a fatal error.) The receiving side may cancel the connection on reception of a warning alert on it discretion.</p> <p>Several alert messages must be sent as fatal alert messages as specified by the TLS RFC. A fatal alert always leads to a connection abort.</p>"},{"location":"man3/SSL_alert_type_string/#return-values","title":"RETURN VALUES","text":"<p>The following strings can occur for SSL_alert_type_string() or SSL_alert_type_string_long():</p> <ul> <li>\"W\"/\"warning\"</li> <li>\"F\"/\"fatal\"</li> <li> <p>\"U\"/\"unknown\"</p> <p>This indicates that no support is available for this alert type. Probably value does not contain a correct alert message.</p> </li> </ul> <p>The following strings can occur for SSL_alert_desc_string() or SSL_alert_desc_string_long():</p> <ul> <li> <p>\"CN\"/\"close notify\"</p> <p>The connection shall be closed. This is a warning alert.</p> </li> <li> <p>\"UM\"/\"unexpected message\"</p> <p>An inappropriate message was received. This alert is always fatal and should never be observed in communication between proper implementations.</p> </li> <li> <p>\"BM\"/\"bad record mac\"</p> <p>This alert is returned if a record is received with an incorrect MAC. This message is always fatal.</p> </li> <li> <p>\"DF\"/\"decompression failure\"</p> <p>The decompression function received improper input (e.g. data that would expand to excessive length). This message is always fatal.</p> </li> <li> <p>\"HF\"/\"handshake failure\"</p> <p>Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available. This is a fatal error.</p> </li> <li> <p>\"NC\"/\"no certificate\"</p> <p>A client, that was asked to send a certificate, does not send a certificate (SSLv3 only).</p> </li> <li> <p>\"BC\"/\"bad certificate\"</p> <p>A certificate was corrupt, contained signatures that did not verify correctly, etc</p> </li> <li> <p>\"UC\"/\"unsupported certificate\"</p> <p>A certificate was of an unsupported type.</p> </li> <li> <p>\"CR\"/\"certificate revoked\"</p> <p>A certificate was revoked by its signer.</p> </li> <li> <p>\"CE\"/\"certificate expired\"</p> <p>A certificate has expired or is not currently valid.</p> </li> <li> <p>\"CU\"/\"certificate unknown\"</p> <p>Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.</p> </li> <li> <p>\"IP\"/\"illegal parameter\"</p> <p>A field in the handshake was out of range or inconsistent with other fields. This is always fatal.</p> </li> <li> <p>\"DC\"/\"decryption failed\"</p> <p>A TLSCiphertext decrypted in an invalid way: either it wasn't an even multiple of the block length or its padding values, when checked, weren't correct. This message is always fatal.</p> </li> <li> <p>\"RO\"/\"record overflow\"</p> <p>A TLSCiphertext record was received which had a length more than 2^14+2048 bytes, or a record decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always fatal.</p> </li> <li> <p>\"CA\"/\"unknown CA\"</p> <p>A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn't be matched with a known, trusted CA.  This message is always fatal.</p> </li> <li> <p>\"AD\"/\"access denied\"</p> <p>A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation. This message is always fatal.</p> </li> <li> <p>\"DE\"/\"decode error\"</p> <p>A message could not be decoded because some field was out of the specified range or the length of the message was incorrect. This message is always fatal.</p> </li> <li> <p>\"CY\"/\"decrypt error\"</p> <p>A handshake cryptographic operation failed, including being unable to correctly verify a signature, decrypt a key exchange, or validate a finished message.</p> </li> <li> <p>\"ER\"/\"export restriction\"</p> <p>A negotiation not in compliance with export restrictions was detected; for example, attempting to transfer a 1024 bit ephemeral RSA key for the RSA_EXPORT handshake method. This message is always fatal.</p> </li> <li> <p>\"PV\"/\"protocol version\"</p> <p>The protocol version the client has attempted to negotiate is recognized, but not supported. (For example, old protocol versions might be avoided for security reasons). This message is always fatal.</p> </li> <li> <p>\"IS\"/\"insufficient security\"</p> <p>Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client. This message is always fatal.</p> </li> <li> <p>\"IE\"/\"internal error\"</p> <p>An internal error unrelated to the peer or the correctness of the protocol makes it impossible to continue (such as a memory allocation failure). This message is always fatal.</p> </li> <li> <p>\"US\"/\"user canceled\"</p> <p>This handshake is being canceled for some reason unrelated to a protocol failure. If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate. This alert should be followed by a close_notify. This message is generally a warning.</p> </li> <li> <p>\"NR\"/\"no renegotiation\"</p> <p>Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking. Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should respond with this alert; at that point, the original requester can decide whether to proceed with the connection. One case where this would be appropriate would be where a server has spawned a process to satisfy a request; the process might receive security parameters (key length, authentication, etc.) at startup and it might be difficult to communicate changes to these parameters after that point. This message is always a warning.</p> </li> <li> <p>\"UP\"/\"unknown PSK identity\"</p> <p>Sent by the server to indicate that it does not recognize a PSK identity or an SRP identity. </p> </li> <li> <p>\"UK\"/\"unknown\"</p> <p>This indicates that no description is available for this alert type. Probably value does not contain a correct alert message.</p> </li> </ul>"},{"location":"man3/SSL_alert_type_string/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_info_callback(3)</p>"},{"location":"man3/SSL_check_chain/","title":"SSL_check_chain","text":""},{"location":"man3/SSL_check_chain/#name","title":"NAME","text":"<p>SSL_check_chain - check certificate chain suitability</p>"},{"location":"man3/SSL_check_chain/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_check_chain(SSL *s, X509 *x, EVP_PKEY *pk, STACK_OF(X509) *chain);\n</code></pre>"},{"location":"man3/SSL_check_chain/#description","title":"DESCRIPTION","text":"<p>SSL_check_chain() checks whether certificate x, private key pk and certificate chain chain is suitable for use with the current session s.</p>"},{"location":"man3/SSL_check_chain/#return-values","title":"RETURN VALUES","text":"<p>SSL_check_chain() returns a bitmap of flags indicating the validity of the chain.</p> <p>CERT_PKEY_VALID: the chain can be used with the current session. If this flag is not set then the certificate will never be used even if the application tries to set it because it is inconsistent with the peer preferences.</p> <p>CERT_PKEY_SIGN: the EE key can be used for signing.</p> <p>CERT_PKEY_EE_SIGNATURE: the signature algorithm of the EE certificate is acceptable.</p> <p>CERT_PKEY_CA_SIGNATURE: the signature algorithms of all CA certificates are acceptable.</p> <p>CERT_PKEY_EE_PARAM: the parameters of the end entity certificate are acceptable (e.g. it is a supported curve).</p> <p>CERT_PKEY_CA_PARAM: the parameters of all CA certificates are acceptable.</p> <p>CERT_PKEY_EXPLICIT_SIGN: the end entity certificate algorithm can be used explicitly for signing (i.e. it is mentioned in the signature algorithms extension).</p> <p>CERT_PKEY_ISSUER_NAME: the issuer name is acceptable. This is only meaningful for client authentication.</p> <p>CERT_PKEY_CERT_TYPE: the certificate type is acceptable. Only meaningful for client authentication.</p> <p>CERT_PKEY_SUITEB: chain is suitable for Suite B use.</p>"},{"location":"man3/SSL_check_chain/#notes","title":"NOTES","text":"<p>SSL_check_chain() must be called in servers after a client hello message or in clients after a certificate request message. It will typically be called in the certificate callback.</p> <p>An application wishing to support multiple certificate chains may call this function on each chain in turn: starting with the one it considers the most secure. It could then use the chain of the first set which returns suitable flags.</p> <p>As a minimum the flag CERT_PKEY_VALID must be set for a chain to be usable. An application supporting multiple chains with different CA signature algorithms may also wish to check CERT_PKEY_CA_SIGNATURE too. If no chain is suitable a server should fall back to the most secure chain which sets CERT_PKEY_VALID.</p> <p>The validity of a chain is determined by checking if it matches a supported signature algorithm, supported curves and in the case of client authentication certificate types and issuer names.</p> <p>Since the supported signature algorithms extension is only used in TLS 1.2 and DTLS 1.2 the results for earlier versions of TLS and DTLS may not be very useful. Applications may wish to specify a different \"legacy\" chain for earlier versions of TLS or DTLS.</p>"},{"location":"man3/SSL_check_chain/#see-also","title":"SEE ALSO","text":"<p>SSL_CTX_set_cert_cb(3), ssl(3)</p>"},{"location":"man3/SSL_clear/","title":"SSL_clear","text":""},{"location":"man3/SSL_clear/#name","title":"NAME","text":"<p>SSL_clear - reset SSL object to allow another connection</p>"},{"location":"man3/SSL_clear/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_clear(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_clear/#description","title":"DESCRIPTION","text":"<p>Reset ssl to allow another connection. All settings (method, ciphers, BIOs) are kept.</p>"},{"location":"man3/SSL_clear/#notes","title":"NOTES","text":"<p>SSL_clear is used to prepare an SSL object for a new connection. While all settings are kept, a side effect is the handling of the current SSL session. If a session is still open, it is considered bad and will be removed from the session cache, as required by RFC2246. A session is considered open, if SSL_shutdown(3) was not called for the connection or at least SSL_set_shutdown(3) was used to set the SSL_SENT_SHUTDOWN state.</p> <p>If a session was closed cleanly, the session object will be kept and all settings corresponding. This explicitly means, that e.g. the special method used during the session will be kept for the next handshake. So if the session was a TLSv1 session, a SSL client object will use a TLSv1 client method for the next handshake and a SSL server object will use a TLSv1 server method, even if SSLv23_*_methods were chosen on startup. This will might lead to connection failures (see SSL_new(3)) for a description of the method's properties.</p>"},{"location":"man3/SSL_clear/#warnings","title":"WARNINGS","text":"<p>SSL_clear() resets the SSL object to allow for another connection. The reset operation however keeps several settings of the last sessions (some of these settings were made automatically during the last handshake). It only makes sense for a new connection with the exact same peer that shares these settings, and may fail if that peer changes its settings between connections. Use the sequence SSL_get_session(3); SSL_new(3); SSL_set_session(3); SSL_free(3) instead to avoid such failures (or simply SSL_free(3); SSL_new(3) if session reuse is not desired).</p>"},{"location":"man3/SSL_clear/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>0</p> <p>The SSL_clear() operation could not be performed. Check the error stack to find out the reason.</p> </li> <li> <p>1</p> <p>The SSL_clear() operation was successful.</p> </li> </ul> <p>SSL_new(3), SSL_free(3), SSL_shutdown(3), SSL_set_shutdown(3), SSL_CTX_set_options(3), ssl(3), SSL_CTX_set_client_cert_cb(3)</p>"},{"location":"man3/SSL_connect/","title":"SSL_connect","text":""},{"location":"man3/SSL_connect/#name","title":"NAME","text":"<p>SSL_connect - initiate the TLS/SSL handshake with an TLS/SSL server</p>"},{"location":"man3/SSL_connect/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_connect(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_connect/#description","title":"DESCRIPTION","text":"<p>SSL_connect() initiates the TLS/SSL handshake with a server. The communication channel must already have been set and assigned to the ssl by setting an underlying BIO.</p>"},{"location":"man3/SSL_connect/#notes","title":"NOTES","text":"<p>The behaviour of SSL_connect() depends on the underlying BIO. </p> <p>If the underlying BIO is blocking, SSL_connect() will only return once the handshake has been finished or an error occurred.</p> <p>If the underlying BIO is non-blocking, SSL_connect() will also return when the underlying BIO could not satisfy the needs of SSL_connect() to continue the handshake, indicating the problem by the return value -1. In this case a call to SSL_get_error() with the return value of SSL_connect() will yield SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process then must repeat the call after taking appropriate action to satisfy the needs of SSL_connect(). The action depends on the underlying BIO. When using a non-blocking socket, nothing is to be done, but select() can be used to check for the required condition. When using a buffering BIO, like a BIO pair, data must be written into or retrieved out of the BIO before being able to continue.</p>"},{"location":"man3/SSL_connect/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>0</p> <p>The TLS/SSL handshake was not successful but was shut down controlled and by the specifications of the TLS/SSL protocol. Call SSL_get_error() with the return value ret to find out the reason.</p> </li> <li> <p>1</p> <p>The TLS/SSL handshake was successfully completed, a TLS/SSL connection has been established.</p> </li> <li> <p>&lt;0</p> <p>The TLS/SSL handshake was not successful, because a fatal error occurred either at the protocol level or a connection failure occurred. The shutdown was not clean. It can also occur of action is need to continue the operation for non-blocking BIOs. Call SSL_get_error() with the return value ret to find out the reason.</p> </li> </ul>"},{"location":"man3/SSL_connect/#see-also","title":"SEE ALSO","text":"<p>SSL_get_error(3), SSL_accept(3), SSL_shutdown(3), ssl(3), bio(3), SSL_set_connect_state(3), SSL_do_handshake(3), SSL_CTX_new(3)</p>"},{"location":"man3/SSL_do_handshake/","title":"SSL_do_handshake","text":""},{"location":"man3/SSL_do_handshake/#name","title":"NAME","text":"<p>SSL_do_handshake - perform a TLS/SSL handshake</p>"},{"location":"man3/SSL_do_handshake/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_do_handshake(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_do_handshake/#description","title":"DESCRIPTION","text":"<p>SSL_do_handshake() will wait for a SSL/TLS handshake to take place. If the connection is in client mode, the handshake will be started. The handshake routines may have to be explicitly set in advance using either SSL_set_connect_state(3) or SSL_set_accept_state(3).</p>"},{"location":"man3/SSL_do_handshake/#notes","title":"NOTES","text":"<p>The behaviour of SSL_do_handshake() depends on the underlying BIO.</p> <p>If the underlying BIO is blocking, SSL_do_handshake() will only return once the handshake has been finished or an error occurred.</p> <p>If the underlying BIO is non-blocking, SSL_do_handshake() will also return when the underlying BIO could not satisfy the needs of SSL_do_handshake() to continue the handshake. In this case a call to SSL_get_error() with the return value of SSL_do_handshake() will yield SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process then must repeat the call after taking appropriate action to satisfy the needs of SSL_do_handshake(). The action depends on the underlying BIO. When using a non-blocking socket, nothing is to be done, but select() can be used to check for the required condition. When using a buffering BIO, like a BIO pair, data must be written into or retrieved out of the BIO before being able to continue.</p>"},{"location":"man3/SSL_do_handshake/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>0</p> <p>The TLS/SSL handshake was not successful but was shut down controlled and by the specifications of the TLS/SSL protocol. Call SSL_get_error() with the return value ret to find out the reason.</p> </li> <li> <p>1</p> <p>The TLS/SSL handshake was successfully completed, a TLS/SSL connection has been established.</p> </li> <li> <p>&lt;0</p> <p>The TLS/SSL handshake was not successful because a fatal error occurred either at the protocol level or a connection failure occurred. The shutdown was not clean. It can also occur of action is need to continue the operation for non-blocking BIOs. Call SSL_get_error() with the return value ret to find out the reason.</p> </li> </ul>"},{"location":"man3/SSL_do_handshake/#see-also","title":"SEE ALSO","text":"<p>SSL_get_error(3), SSL_connect(3), SSL_accept(3), ssl(3), bio(3), SSL_set_connect_state(3)</p>"},{"location":"man3/SSL_export_keying_material/","title":"SSL_export_keying_material","text":""},{"location":"man3/SSL_export_keying_material/#name","title":"NAME","text":"<p>SSL_export_keying_material - obtain keying material for application use</p>"},{"location":"man3/SSL_export_keying_material/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_export_keying_material(SSL *s, unsigned char *out, size_t olen,\n                               const char *label, size_t llen,\n                               const unsigned char *context,\n                               size_t contextlen, int use_context);\n</code></pre>"},{"location":"man3/SSL_export_keying_material/#description","title":"DESCRIPTION","text":"<p>During the creation of a TLS or DTLS connection shared keying material is established between the two endpoints. The function SSL_export_keying_material() enables an application to use some of this keying material for its own purposes in accordance with RFC5705.</p> <p>An application may need to securely establish the context within which this keying material will be used. For example this may include identifiers for the application session, application algorithms or parameters, or the lifetime of the context. The context value is left to the application but must be the same on both sides of the communication.</p> <p>For a given SSL connection s, olen bytes of data will be written to out. The application specific context should be supplied in the location pointed to by context and should be contextlen bytes long. Provision of a context is optional. If the context should be omitted entirely then use_context should be set to 0. Otherwise it should be any other value. If use_context is 0 then the values of context and contextlen are ignored. Note that a zero length context is treated differently to no context at all, and will result in different keying material being returned.</p> <p>An application specific label should be provided in the location pointed to by label and should be llen bytes long. Typically this will be a value from the IANA Exporter Label Registry (https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#exporter-labels). Alternatively labels beginning with \"EXPERIMENTAL\" are permitted by the standard to be used without registration.</p> <p>Note that this function is only defined for TLSv1.0 and above, and DTLSv1.0 and above. Attempting to use it in SSLv3 will result in an error.</p>"},{"location":"man3/SSL_export_keying_material/#return-values","title":"RETURN VALUES","text":"<p>SSL_export_keying_material() returns 0 or -1 on failure or 1 on success.</p>"},{"location":"man3/SSL_export_keying_material/#copyright","title":"COPYRIGHT","text":"<p>Copyright 2017 The OpenSSL Project Authors. All Rights Reserved.</p> <p>Licensed under the OpenSSL license (the \"License\").  You may not use this file except in compliance with the License.  You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html.</p>"},{"location":"man3/SSL_free/","title":"SSL_free","text":""},{"location":"man3/SSL_free/#name","title":"NAME","text":"<p>SSL_free - free an allocated SSL structure</p>"},{"location":"man3/SSL_free/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_free(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_free/#description","title":"DESCRIPTION","text":"<p>SSL_free() decrements the reference count of ssl, and removes the SSL structure pointed to by ssl and frees up the allocated memory if the reference count has reached 0.</p>"},{"location":"man3/SSL_free/#notes","title":"NOTES","text":"<p>SSL_free() also calls the free()ing procedures for indirectly affected items, if applicable: the buffering BIO, the read and write BIOs, cipher lists specially created for this ssl, the SSL_SESSION. Do not explicitly free these indirectly freed up items before or after calling SSL_free(), as trying to free things twice may lead to program failure.</p> <p>The ssl session has reference counts from two users: the SSL object, for which the reference count is removed by SSL_free() and the internal session cache. If the session is considered bad, because SSL_shutdown(3) was not called for the connection and SSL_set_shutdown(3) was not used to set the SSL_SENT_SHUTDOWN state, the session will also be removed from the session cache as required by RFC2246.</p>"},{"location":"man3/SSL_free/#return-values","title":"RETURN VALUES","text":"<p>SSL_free() does not provide diagnostic information.</p> <p>SSL_new(3), SSL_clear(3), SSL_shutdown(3), SSL_set_shutdown(3), ssl(3)</p>"},{"location":"man3/SSL_get_SSL_CTX/","title":"SSL_get_SSL_CTX","text":""},{"location":"man3/SSL_get_SSL_CTX/#name","title":"NAME","text":"<p>SSL_get_SSL_CTX - get the SSL_CTX from which an SSL is created</p>"},{"location":"man3/SSL_get_SSL_CTX/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nSSL_CTX *SSL_get_SSL_CTX(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_get_SSL_CTX/#description","title":"DESCRIPTION","text":"<p>SSL_get_SSL_CTX() returns a pointer to the SSL_CTX object, from which ssl was created with SSL_new(3).</p>"},{"location":"man3/SSL_get_SSL_CTX/#return-values","title":"RETURN VALUES","text":"<p>The pointer to the SSL_CTX object is returned.</p>"},{"location":"man3/SSL_get_SSL_CTX/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_new(3)</p>"},{"location":"man3/SSL_get_ciphers/","title":"SSL_get_ciphers","text":""},{"location":"man3/SSL_get_ciphers/#name","title":"NAME","text":"<p>SSL_get_ciphers, SSL_get_cipher_list, SSL_get_shared_ciphers - get list of available SSL_CIPHERs</p>"},{"location":"man3/SSL_get_ciphers/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nSTACK_OF(SSL_CIPHER) *SSL_get_ciphers(const SSL *ssl);\nconst char *SSL_get_cipher_list(const SSL *ssl, int priority);\nchar *SSL_get_shared_ciphers(const SSL *s, char *buf, int size);\n</code></pre>"},{"location":"man3/SSL_get_ciphers/#description","title":"DESCRIPTION","text":"<p>SSL_get_ciphers() returns the stack of available SSL_CIPHERs for ssl, sorted by preference. If ssl is NULL or no ciphers are available, NULL is returned.</p> <p>SSL_get_cipher_list() returns a pointer to the name of the SSL_CIPHER listed for ssl with priority. If ssl is NULL, no ciphers are available, or there are less ciphers than priority available, NULL is returned.</p> <p>SSL_get_shared_ciphers() creates a colon separated and NUL terminated list of SSL_CIPHER names that are available in both the client and the server. buf is the buffer that should be populated with the list of names and size is the size of that buffer. A pointer to buf is returned on success or NULL on error. If the supplied buffer is not large enough to contain the complete list of names then a truncated list of names will be returned. Note that just because a ciphersuite is available (i.e. it is configured in the cipher list) and shared by both the client and the server it does not mean that it is enabled (for example some ciphers may not be usable by a server if there is not a suitable certificate configured). This function will return available shared ciphersuites whether or not they are enabled. This is a server side function only and must only be called after the completion of the initial handshake.</p>"},{"location":"man3/SSL_get_ciphers/#notes","title":"NOTES","text":"<p>The details of the ciphers obtained by SSL_get_ciphers() can be obtained using the SSL_CIPHER_get_name(3) family of functions.</p> <p>Call SSL_get_cipher_list() with priority starting from 0 to obtain the sorted list of available ciphers, until NULL is returned.</p>"},{"location":"man3/SSL_get_ciphers/#return-values","title":"RETURN VALUES","text":"<p>See DESCRIPTION</p>"},{"location":"man3/SSL_get_ciphers/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_cipher_list(3), SSL_CIPHER_get_name(3)</p>"},{"location":"man3/SSL_get_client_CA_list/","title":"SSL_get_client_CA_list","text":""},{"location":"man3/SSL_get_client_CA_list/#name","title":"NAME","text":"<p>SSL_get_client_CA_list, SSL_CTX_get_client_CA_list - get list of client CAs</p>"},{"location":"man3/SSL_get_client_CA_list/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nSTACK_OF(X509_NAME) *SSL_get_client_CA_list(const SSL *s);\nSTACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(const SSL_CTX *ctx);\n</code></pre>"},{"location":"man3/SSL_get_client_CA_list/#description","title":"DESCRIPTION","text":"<p>SSL_CTX_get_client_CA_list() returns the list of client CAs explicitly set for ctx using SSL_CTX_set_client_CA_list(3).</p> <p>SSL_get_client_CA_list() returns the list of client CAs explicitly set for ssl using SSL_set_client_CA_list() or ssl's SSL_CTX object with SSL_CTX_set_client_CA_list(3), when in server mode. In client mode, SSL_get_client_CA_list returns the list of client CAs sent from the server, if any.</p>"},{"location":"man3/SSL_get_client_CA_list/#return-values","title":"RETURN VALUES","text":"<p>SSL_CTX_set_client_CA_list() and SSL_set_client_CA_list() do not return diagnostic information.</p> <p>SSL_CTX_add_client_CA() and SSL_add_client_CA() have the following return values:</p> <ul> <li> <p>STACK_OF(X509_NAMES)</p> <p>List of CA names explicitly set (for ctx or in server mode) or send by the server (client mode).</p> </li> <li> <p>NULL</p> <p>No client CA list was explicitly set (for ctx or in server mode) or the server did not send a list of CAs (client mode).</p> </li> </ul>"},{"location":"man3/SSL_get_client_CA_list/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_client_CA_list(3), SSL_CTX_set_client_cert_cb(3)</p>"},{"location":"man3/SSL_get_current_cipher/","title":"SSL_get_current_cipher","text":""},{"location":"man3/SSL_get_current_cipher/#name","title":"NAME","text":"<p>SSL_get_current_cipher, SSL_get_cipher, SSL_get_cipher_name, SSL_get_cipher_bits, SSL_get_cipher_version - get SSL_CIPHER of a connection</p>"},{"location":"man3/SSL_get_current_cipher/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nSSL_CIPHER *SSL_get_current_cipher(const SSL *ssl);\n#define SSL_get_cipher(s) \\\n               SSL_CIPHER_get_name(SSL_get_current_cipher(s))\n#define SSL_get_cipher_name(s) \\\n               SSL_CIPHER_get_name(SSL_get_current_cipher(s))\n#define SSL_get_cipher_bits(s,np) \\\n               SSL_CIPHER_get_bits(SSL_get_current_cipher(s),np)\n#define SSL_get_cipher_version(s) \\\n               SSL_CIPHER_get_version(SSL_get_current_cipher(s))\n</code></pre>"},{"location":"man3/SSL_get_current_cipher/#description","title":"DESCRIPTION","text":"<p>SSL_get_current_cipher() returns a pointer to an SSL_CIPHER object containing the description of the actually used cipher of a connection established with the ssl object.</p> <p>SSL_get_cipher() and SSL_get_cipher_name() are identical macros to obtain the name of the currently used cipher. SSL_get_cipher_bits() is a macro to obtain the number of secret/algorithm bits used and  SSL_get_cipher_version() returns the protocol name. See SSL_CIPHER_get_name(3) for more details.</p>"},{"location":"man3/SSL_get_current_cipher/#return-values","title":"RETURN VALUES","text":"<p>SSL_get_current_cipher() returns the cipher actually used or NULL, when no session has been established.</p>"},{"location":"man3/SSL_get_current_cipher/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CIPHER_get_name(3)</p>"},{"location":"man3/SSL_get_default_timeout/","title":"SSL_get_default_timeout","text":""},{"location":"man3/SSL_get_default_timeout/#name","title":"NAME","text":"<p>SSL_get_default_timeout - get default session timeout value</p>"},{"location":"man3/SSL_get_default_timeout/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_get_default_timeout(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_get_default_timeout/#description","title":"DESCRIPTION","text":"<p>SSL_get_default_timeout() returns the default timeout value assigned to SSL_SESSION objects negotiated for the protocol valid for ssl.</p>"},{"location":"man3/SSL_get_default_timeout/#notes","title":"NOTES","text":"<p>Whenever a new session is negotiated, it is assigned a timeout value, after which it will not be accepted for session reuse. If the timeout value was not explicitly set using SSL_CTX_set_timeout(3), the hardcoded default timeout for the protocol will be used.</p> <p>SSL_get_default_timeout() return this hardcoded value, which is 300 seconds for all currently supported protocols (SSLv2, SSLv3, and TLSv1).</p>"},{"location":"man3/SSL_get_default_timeout/#return-values","title":"RETURN VALUES","text":"<p>See description.</p>"},{"location":"man3/SSL_get_default_timeout/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_session_cache_mode(3), SSL_SESSION_get_time(3), SSL_CTX_flush_sessions(3), SSL_get_default_timeout(3)</p>"},{"location":"man3/SSL_get_error/","title":"SSL_get_error","text":""},{"location":"man3/SSL_get_error/#name","title":"NAME","text":"<p>SSL_get_error - obtain result code for TLS/SSL I/O operation</p>"},{"location":"man3/SSL_get_error/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_get_error(const SSL *ssl, int ret);\n</code></pre>"},{"location":"man3/SSL_get_error/#description","title":"DESCRIPTION","text":"<p>SSL_get_error() returns a result code (suitable for the C \"switch\" statement) for a preceding call to SSL_connect(), SSL_accept(), SSL_do_handshake(), SSL_read(), SSL_peek(), or SSL_write() on ssl.  The value returned by that TLS/SSL I/O function must be passed to SSL_get_error() in parameter ret.</p> <p>In addition to ssl and ret, SSL_get_error() inspects the current thread's OpenSSL error queue.  Thus, SSL_get_error() must be used in the same thread that performed the TLS/SSL I/O operation, and no other OpenSSL function calls should appear in between.  The current thread's error queue must be empty before the TLS/SSL I/O operation is attempted, or SSL_get_error() will not work reliably.</p>"},{"location":"man3/SSL_get_error/#return-values","title":"RETURN VALUES","text":"<p>The following return values can currently occur:</p> <ul> <li> <p>SSL_ERROR_NONE</p> <p>The TLS/SSL I/O operation completed.  This result code is returned if and only if ret &gt; 0.</p> </li> <li> <p>SSL_ERROR_ZERO_RETURN</p> <p>The TLS/SSL connection has been closed. If the protocol version is SSL 3.0 or higher, this result code is returned only if a closure alert has occurred in the protocol, i.e. if the connection has been closed cleanly. Note that in this case SSL_ERROR_ZERO_RETURN does not necessarily indicate that the underlying transport has been closed.</p> </li> <li> <p>SSL_ERROR_WANT_READ, SSL_ERROR_WANT_WRITE</p> <p>The operation did not complete; the same TLS/SSL I/O function should be called again later.  If, by then, the underlying BIO has data available for reading (if the result code is SSL_ERROR_WANT_READ) or allows writing data (SSL_ERROR_WANT_WRITE), then some TLS/SSL protocol progress will take place, i.e. at least part of an TLS/SSL record will be read or written.  Note that the retry may again lead to a SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE condition. There is no fixed upper limit for the number of iterations that may be necessary until progress becomes visible at application protocol level.</p> <p>For socket BIOs (e.g. when SSL_set_fd() was used), select() or poll() on the underlying socket can be used to find out when the TLS/SSL I/O function should be retried.</p> <p>Caveat: Any TLS/SSL I/O function can lead to either of SSL_ERROR_WANT_READ and SSL_ERROR_WANT_WRITE.  In particular, SSL_read() or SSL_peek() may want to write data and SSL_write() may want to read data.  This is mainly because TLS/SSL handshakes may occur at any time during the protocol (initiated by either the client or the server); SSL_read(), SSL_peek(), and SSL_write() will handle any pending handshakes.</p> </li> <li> <p>SSL_ERROR_WANT_CONNECT, SSL_ERROR_WANT_ACCEPT</p> <p>The operation did not complete; the same TLS/SSL I/O function should be called again later. The underlying BIO was not connected yet to the peer and the call would block in connect()/accept(). The SSL function should be called again when the connection is established. These messages can only appear with a BIO_s_connect() or BIO_s_accept() BIO, respectively. In order to find out, when the connection has been successfully established, on many platforms select() or poll() for writing on the socket file descriptor can be used.</p> </li> <li> <p>SSL_ERROR_WANT_X509_LOOKUP</p> <p>The operation did not complete because an application callback set by SSL_CTX_set_client_cert_cb() has asked to be called again. The TLS/SSL I/O function should be called again later. Details depend on the application.</p> </li> <li> <p>SSL_ERROR_SYSCALL</p> <p>Some non-recoverable, fatal I/O error occurred. The OpenSSL error queue may contain more information on the error. For socket I/O on Unix systems, consult errno for details. If this error occurs then no further I/O operations should be performed on the connection and SSL_shutdown() must not be called.</p> </li> <li> <p>SSL_ERROR_SSL</p> <p>A non-recoverable, fatal error in the SSL library occurred, usually a protocol error.  The OpenSSL error queue contains more information on the error. If this error occurs then no further I/O operations should be performed on the connection and SSL_shutdown() must not be called.</p> </li> </ul>"},{"location":"man3/SSL_get_error/#see-also","title":"SEE ALSO","text":"<p>ssl(3), err(3)</p>"},{"location":"man3/SSL_get_error/#history","title":"HISTORY","text":"<p>SSL_get_error() was added in SSLeay 0.8.</p>"},{"location":"man3/SSL_get_ex_data_X509_STORE_CTX_idx/","title":"SSL_get_ex_data_X509_STORE_CTX_idx","text":""},{"location":"man3/SSL_get_ex_data_X509_STORE_CTX_idx/#name","title":"NAME","text":"<p>SSL_get_ex_data_X509_STORE_CTX_idx - get ex_data index to access SSL structure from X509_STORE_CTX</p>"},{"location":"man3/SSL_get_ex_data_X509_STORE_CTX_idx/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_get_ex_data_X509_STORE_CTX_idx(void);\n</code></pre>"},{"location":"man3/SSL_get_ex_data_X509_STORE_CTX_idx/#description","title":"DESCRIPTION","text":"<p>SSL_get_ex_data_X509_STORE_CTX_idx() returns the index number under which the pointer to the SSL object is stored into the X509_STORE_CTX object.</p>"},{"location":"man3/SSL_get_ex_data_X509_STORE_CTX_idx/#notes","title":"NOTES","text":"<p>Whenever a X509_STORE_CTX object is created for the verification of the peers certificate during a handshake, a pointer to the SSL object is stored into the X509_STORE_CTX object to identify the connection affected. To retrieve this pointer the X509_STORE_CTX_get_ex_data() function can be used with the correct index. This index is globally the same for all X509_STORE_CTX objects and can be retrieved using SSL_get_ex_data_X509_STORE_CTX_idx(). The index value is set when SSL_get_ex_data_X509_STORE_CTX_idx() is first called either by the application program directly or indirectly during other SSL setup functions or during the handshake.</p> <p>The value depends on other index values defined for X509_STORE_CTX objects before the SSL index is created.</p>"},{"location":"man3/SSL_get_ex_data_X509_STORE_CTX_idx/#return-values","title":"RETURN VALUES","text":"<ul> <li> <p>&gt;=0</p> <p>The index value to access the pointer.</p> </li> <li> <p>&lt;0</p> <p>An error occurred, check the error stack for a detailed error message.</p> </li> </ul>"},{"location":"man3/SSL_get_ex_data_X509_STORE_CTX_idx/#examples","title":"EXAMPLES","text":"<p>The index returned from SSL_get_ex_data_X509_STORE_CTX_idx() allows to access the SSL object for the connection to be accessed during the verify_callback() when checking the peers certificate. Please check the example in SSL_CTX_set_verify(3),</p>"},{"location":"man3/SSL_get_ex_data_X509_STORE_CTX_idx/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_verify(3), CRYPTO_set_ex_data(3)</p>"},{"location":"man3/SSL_get_ex_new_index/","title":"SSL_get_ex_new_index","text":""},{"location":"man3/SSL_get_ex_new_index/#name","title":"NAME","text":"<p>SSL_get_ex_new_index, SSL_set_ex_data, SSL_get_ex_data - internal application specific data functions</p>"},{"location":"man3/SSL_get_ex_new_index/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_get_ex_new_index(long argl, void *argp,\n               CRYPTO_EX_new *new_func,\n               CRYPTO_EX_dup *dup_func,\n               CRYPTO_EX_free *free_func);\n\nint SSL_set_ex_data(SSL *ssl, int idx, void *arg);\n\nvoid *SSL_get_ex_data(const SSL *ssl, int idx);\n\ntypedef int new_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n               int idx, long argl, void *argp);\ntypedef void free_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n               int idx, long argl, void *argp);\ntypedef int dup_func(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d,\n               int idx, long argl, void *argp);\n</code></pre>"},{"location":"man3/SSL_get_ex_new_index/#description","title":"DESCRIPTION","text":"<p>Several OpenSSL structures can have application specific data attached to them. These functions are used internally by OpenSSL to manipulate application specific data attached to a specific structure.</p> <p>SSL_get_ex_new_index() is used to register a new index for application specific data.</p> <p>SSL_set_ex_data() is used to store application data at arg for idx into the ssl object.</p> <p>SSL_get_ex_data() is used to retrieve the information for idx from ssl.</p> <p>A detailed description for the *_get_ex_new_index() functionality can be found in RSA_get_ex_new_index(3). The *_get_ex_data() and *_set_ex_data() functionality is described in CRYPTO_set_ex_data(3).</p>"},{"location":"man3/SSL_get_ex_new_index/#examples","title":"EXAMPLES","text":"<p>An example on how to use the functionality is included in the example verify_callback() in SSL_CTX_set_verify(3).</p>"},{"location":"man3/SSL_get_ex_new_index/#see-also","title":"SEE ALSO","text":"<p>ssl(3), RSA_get_ex_new_index(3), CRYPTO_set_ex_data(3), SSL_CTX_set_verify(3)</p>"},{"location":"man3/SSL_get_fd/","title":"SSL_get_fd","text":""},{"location":"man3/SSL_get_fd/#name","title":"NAME","text":"<p>SSL_get_fd - get file descriptor linked to an SSL object</p>"},{"location":"man3/SSL_get_fd/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_get_fd(const SSL *ssl);\nint SSL_get_rfd(const SSL *ssl);\nint SSL_get_wfd(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_get_fd/#description","title":"DESCRIPTION","text":"<p>SSL_get_fd() returns the file descriptor which is linked to ssl. SSL_get_rfd() and SSL_get_wfd() return the file descriptors for the read or the write channel, which can be different. If the read and the write channel are different, SSL_get_fd() will return the file descriptor of the read channel.</p>"},{"location":"man3/SSL_get_fd/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>-1</p> <p>The operation failed, because the underlying BIO is not of the correct type (suitable for file descriptors).</p> </li> <li> <p>&gt;=0</p> <p>The file descriptor linked to ssl.</p> </li> </ul>"},{"location":"man3/SSL_get_fd/#see-also","title":"SEE ALSO","text":"<p>SSL_set_fd(3), ssl(3) , bio(3)</p>"},{"location":"man3/SSL_get_peer_cert_chain/","title":"SSL_get_peer_cert_chain","text":""},{"location":"man3/SSL_get_peer_cert_chain/#name","title":"NAME","text":"<p>SSL_get_peer_cert_chain - get the X509 certificate chain of the peer</p>"},{"location":"man3/SSL_get_peer_cert_chain/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nSTACK_OF(X509) *SSL_get_peer_cert_chain(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_get_peer_cert_chain/#description","title":"DESCRIPTION","text":"<p>SSL_get_peer_cert_chain() returns a pointer to STACK_OF(X509) certificates forming the certificate chain of the peer. If called on the client side, the stack also contains the peer's certificate; if called on the server side, the peer's certificate must be obtained separately using SSL_get_peer_certificate(3). If the peer did not present a certificate, NULL is returned.</p>"},{"location":"man3/SSL_get_peer_cert_chain/#notes","title":"NOTES","text":"<p>The peer certificate chain is not necessarily available after reusing a session, in which case a NULL pointer is returned.</p> <p>The reference count of the STACK_OF(X509) object is not incremented. If the corresponding session is freed, the pointer must not be used any longer.</p>"},{"location":"man3/SSL_get_peer_cert_chain/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>NULL</p> <p>No certificate was presented by the peer or no connection was established or the certificate chain is no longer available when a session is reused.</p> </li> <li> <p>Pointer to a STACK_OF(X509)</p> <p>The return value points to the certificate chain presented by the peer.</p> </li> </ul>"},{"location":"man3/SSL_get_peer_cert_chain/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_get_peer_certificate(3)</p>"},{"location":"man3/SSL_get_peer_certificate/","title":"SSL_get_peer_certificate","text":""},{"location":"man3/SSL_get_peer_certificate/#name","title":"NAME","text":"<p>SSL_get_peer_certificate - get the X509 certificate of the peer</p>"},{"location":"man3/SSL_get_peer_certificate/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nX509 *SSL_get_peer_certificate(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_get_peer_certificate/#description","title":"DESCRIPTION","text":"<p>SSL_get_peer_certificate() returns a pointer to the X509 certificate the peer presented. If the peer did not present a certificate, NULL is returned.</p>"},{"location":"man3/SSL_get_peer_certificate/#notes","title":"NOTES","text":"<p>Due to the protocol definition, a TLS/SSL server will always send a certificate, if present. A client will only send a certificate when explicitly requested to do so by the server (see SSL_CTX_set_verify(3)). If an anonymous cipher is used, no certificates are sent.</p> <p>That a certificate is returned does not indicate information about the verification state, use SSL_get_verify_result(3) to check the verification state.</p> <p>The reference count of the X509 object is incremented by one, so that it will not be destroyed when the session containing the peer certificate is freed. The X509 object must be explicitly freed using X509_free().</p>"},{"location":"man3/SSL_get_peer_certificate/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>NULL</p> <p>No certificate was presented by the peer or no connection was established.</p> </li> <li> <p>Pointer to an X509 certificate</p> <p>The return value points to the certificate presented by the peer.</p> </li> </ul>"},{"location":"man3/SSL_get_peer_certificate/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_get_verify_result(3), SSL_CTX_set_verify(3)</p>"},{"location":"man3/SSL_get_psk_identity/","title":"SSL_get_psk_identity","text":""},{"location":"man3/SSL_get_psk_identity/#name","title":"NAME","text":"<p>SSL_get_psk_identity, SSL_get_psk_identity_hint - get PSK client identity and hint</p>"},{"location":"man3/SSL_get_psk_identity/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nconst char *SSL_get_psk_identity_hint(const SSL *ssl);\nconst char *SSL_get_psk_identity(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_get_psk_identity/#description","title":"DESCRIPTION","text":"<p>SSL_get_psk_identity_hint() is used to retrieve the PSK identity hint used during the connection setup related to SSL object ssl. Similarly, SSL_get_psk_identity() is used to retrieve the PSK identity used during the connection setup.</p>"},{"location":"man3/SSL_get_psk_identity/#return-values","title":"RETURN VALUES","text":"<p>If non-NULL, SSL_get_psk_identity_hint() returns the PSK identity hint and SSL_get_psk_identity() returns the PSK identity. Both are NULL-terminated. SSL_get_psk_identity_hint() may return NULL if no PSK identity hint was used during the connection setup.</p> <p>Note that the return value is valid only during the lifetime of the SSL object ssl.</p>"},{"location":"man3/SSL_get_rbio/","title":"SSL_get_rbio","text":""},{"location":"man3/SSL_get_rbio/#name","title":"NAME","text":"<p>SSL_get_rbio - get BIO linked to an SSL object</p>"},{"location":"man3/SSL_get_rbio/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nBIO *SSL_get_rbio(SSL *ssl);\nBIO *SSL_get_wbio(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_get_rbio/#description","title":"DESCRIPTION","text":"<p>SSL_get_rbio() and SSL_get_wbio() return pointers to the BIOs for the read or the write channel, which can be different. The reference count of the BIO is not incremented.</p>"},{"location":"man3/SSL_get_rbio/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>NULL</p> <p>No BIO was connected to the SSL object</p> </li> <li> <p>Any other pointer</p> <p>The BIO linked to ssl.</p> </li> </ul>"},{"location":"man3/SSL_get_rbio/#see-also","title":"SEE ALSO","text":"<p>SSL_set_bio(3), ssl(3) , bio(3)</p>"},{"location":"man3/SSL_get_session/","title":"SSL_get_session","text":""},{"location":"man3/SSL_get_session/#name","title":"NAME","text":"<p>SSL_get_session - retrieve TLS/SSL session data</p>"},{"location":"man3/SSL_get_session/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nSSL_SESSION *SSL_get_session(const SSL *ssl);\nSSL_SESSION *SSL_get0_session(const SSL *ssl);\nSSL_SESSION *SSL_get1_session(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_get_session/#description","title":"DESCRIPTION","text":"<p>SSL_get_session() returns a pointer to the SSL_SESSION actually used in ssl. The reference count of the SSL_SESSION is not incremented, so that the pointer can become invalid by other operations.</p> <p>SSL_get0_session() is the same as SSL_get_session().</p> <p>SSL_get1_session() is the same as SSL_get_session(), but the reference count of the SSL_SESSION is incremented by one.</p>"},{"location":"man3/SSL_get_session/#notes","title":"NOTES","text":"<p>The ssl session contains all information required to re-establish the connection without a new handshake.</p> <p>A session will be automatically removed from the session cache and marked as non-resumable if the connection is not closed down cleanly, e.g. if a fatal error occurs on the connection or SSL_shutdown(3) is not called prior to SSL_free(3).</p> <p>SSL_get0_session() returns a pointer to the actual session. As the reference counter is not incremented, the pointer is only valid while the connection is in use. If SSL_clear(3) or SSL_free(3) is called, the session may be removed completely (if considered bad), and the pointer obtained will become invalid. Even if the session is valid, it can be removed at any time due to timeout during SSL_CTX_flush_sessions(3).</p> <p>If the data is to be kept, SSL_get1_session() will increment the reference count, so that the session will not be implicitly removed by other operations but stays in memory. In order to remove the session SSL_SESSION_free(3) must be explicitly called once to decrement the reference count again.</p> <p>SSL_SESSION objects keep internal link information about the session cache list, when being inserted into one SSL_CTX object's session cache. One SSL_SESSION object, regardless of its reference count, must therefore only be used with one SSL_CTX object (and the SSL objects created from this SSL_CTX object).</p>"},{"location":"man3/SSL_get_session/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>NULL</p> <p>There is no session available in ssl.</p> </li> <li> <p>Pointer to an SSL</p> <p>The return value points to the data of an SSL session.</p> </li> </ul>"},{"location":"man3/SSL_get_session/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_free(3), SSL_clear(3), SSL_SESSION_free(3)</p>"},{"location":"man3/SSL_get_verify_result/","title":"SSL_get_verify_result","text":""},{"location":"man3/SSL_get_verify_result/#name","title":"NAME","text":"<p>SSL_get_verify_result - get result of peer certificate verification</p>"},{"location":"man3/SSL_get_verify_result/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nlong SSL_get_verify_result(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_get_verify_result/#description","title":"DESCRIPTION","text":"<p>SSL_get_verify_result() returns the result of the verification of the X509 certificate presented by the peer, if any.</p>"},{"location":"man3/SSL_get_verify_result/#notes","title":"NOTES","text":"<p>SSL_get_verify_result() can only return one error code while the verification of a certificate can fail because of many reasons at the same time. Only the last verification error that occurred during the processing is available from SSL_get_verify_result().</p> <p>The verification result is part of the established session and is restored when a session is reused.</p>"},{"location":"man3/SSL_get_verify_result/#bugs","title":"BUGS","text":"<p>If no peer certificate was presented, the returned result code is X509_V_OK. This is because no verification error occurred, it does however not indicate success. SSL_get_verify_result() is only useful in connection with SSL_get_peer_certificate(3).</p>"},{"location":"man3/SSL_get_verify_result/#return-values","title":"RETURN VALUES","text":"<p>The following return values can currently occur:</p> <ul> <li> <p>X509_V_OK</p> <p>The verification succeeded or no peer certificate was presented.</p> </li> <li> <p>Any other value</p> <p>Documented in verify(1).</p> </li> </ul>"},{"location":"man3/SSL_get_verify_result/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_set_verify_result(3), SSL_get_peer_certificate(3), verify(1)</p>"},{"location":"man3/SSL_get_version/","title":"SSL_get_version","text":""},{"location":"man3/SSL_get_version/#name","title":"NAME","text":"<p>SSL_get_version - get the protocol version of a connection.</p>"},{"location":"man3/SSL_get_version/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nconst char *SSL_get_version(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_get_version/#description","title":"DESCRIPTION","text":"<p>SSL_get_version() returns the name of the protocol used for the connection ssl. It should only be called after the initial handshake has been completed. Prior to that the results returned from this function may be unreliable.</p>"},{"location":"man3/SSL_get_version/#return-values","title":"RETURN VALUES","text":"<p>The following strings can be returned:</p> <ul> <li> <p>SSLv2</p> <p>The connection uses the SSLv2 protocol.</p> </li> <li> <p>SSLv3</p> <p>The connection uses the SSLv3 protocol.</p> </li> <li> <p>TLSv1</p> <p>The connection uses the TLSv1.0 protocol.</p> </li> <li> <p>TLSv1.1</p> <p>The connection uses the TLSv1.1 protocol.</p> </li> <li> <p>TLSv1.2</p> <p>The connection uses the TLSv1.2 protocol.</p> </li> <li> <p>unknown</p> <p>This indicates an unknown protocol version.</p> </li> </ul>"},{"location":"man3/SSL_get_version/#see-also","title":"SEE ALSO","text":"<p>ssl(3)</p>"},{"location":"man3/SSL_library_init/","title":"SSL_library_init","text":""},{"location":"man3/SSL_library_init/#name","title":"NAME","text":"<p>SSL_library_init, OpenSSL_add_ssl_algorithms, SSLeay_add_ssl_algorithms - initialize SSL library by registering algorithms</p>"},{"location":"man3/SSL_library_init/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_library_init(void);\n#define OpenSSL_add_ssl_algorithms()    SSL_library_init()\n#define SSLeay_add_ssl_algorithms()     SSL_library_init()\n</code></pre>"},{"location":"man3/SSL_library_init/#description","title":"DESCRIPTION","text":"<p>SSL_library_init() registers the available SSL/TLS ciphers and digests.</p> <p>OpenSSL_add_ssl_algorithms() and SSLeay_add_ssl_algorithms() are synonyms for SSL_library_init().</p>"},{"location":"man3/SSL_library_init/#notes","title":"NOTES","text":"<p>SSL_library_init() must be called before any other action takes place. SSL_library_init() is not reentrant. </p>"},{"location":"man3/SSL_library_init/#warning","title":"WARNING","text":"<p>SSL_library_init() adds ciphers and digests used directly and indirectly by SSL/TLS.</p>"},{"location":"man3/SSL_library_init/#examples","title":"EXAMPLES","text":"<p>A typical TLS/SSL application will start with the library initialization, and provide readable error messages.</p> <pre><code>SSL_load_error_strings();                /* readable error messages */\nSSL_library_init();                      /* initialize library */\n</code></pre>"},{"location":"man3/SSL_library_init/#return-values","title":"RETURN VALUES","text":"<p>SSL_library_init() always returns \"1\", so it is safe to discard the return value.</p>"},{"location":"man3/SSL_library_init/#notes_1","title":"NOTES","text":"<p>OpenSSL 0.9.8o and 1.0.0a and later added SHA2 algorithms to SSL_library_init(). Applications which need to use SHA2 in earlier versions of OpenSSL should call OpenSSL_add_all_algorithms() as well.</p>"},{"location":"man3/SSL_library_init/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_load_error_strings(3), RAND_add(3)</p>"},{"location":"man3/SSL_load_client_CA_file/","title":"SSL_load_client_CA_file","text":""},{"location":"man3/SSL_load_client_CA_file/#name","title":"NAME","text":"<p>SSL_load_client_CA_file - load certificate names from file</p>"},{"location":"man3/SSL_load_client_CA_file/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nSTACK_OF(X509_NAME) *SSL_load_client_CA_file(const char *file);\n</code></pre>"},{"location":"man3/SSL_load_client_CA_file/#description","title":"DESCRIPTION","text":"<p>SSL_load_client_CA_file() reads certificates from file and returns a STACK_OF(X509_NAME) with the subject names found.</p>"},{"location":"man3/SSL_load_client_CA_file/#notes","title":"NOTES","text":"<p>SSL_load_client_CA_file() reads a file of PEM formatted certificates and extracts the X509_NAMES of the certificates found. While the name suggests the specific usage as support function for SSL_CTX_set_client_CA_list(3), it is not limited to CA certificates.</p>"},{"location":"man3/SSL_load_client_CA_file/#examples","title":"EXAMPLES","text":"<p>Load names of CAs from file and use it as a client CA list:</p> <pre><code>SSL_CTX *ctx;\nSTACK_OF(X509_NAME) *cert_names;\n\n... \ncert_names = SSL_load_client_CA_file(\"/path/to/CAfile.pem\");\nif (cert_names != NULL)\n  SSL_CTX_set_client_CA_list(ctx, cert_names);\nelse\n  error_handling();\n...\n</code></pre>"},{"location":"man3/SSL_load_client_CA_file/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>NULL</p> <p>The operation failed, check out the error stack for the reason.</p> </li> <li> <p>Pointer to STACK_OF(X509_NAME)</p> <p>Pointer to the subject names of the successfully read certificates.</p> </li> </ul>"},{"location":"man3/SSL_load_client_CA_file/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_client_CA_list(3)</p>"},{"location":"man3/SSL_new/","title":"SSL_new","text":""},{"location":"man3/SSL_new/#name","title":"NAME","text":"<p>SSL_new - create a new SSL structure for a connection</p>"},{"location":"man3/SSL_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nSSL *SSL_new(SSL_CTX *ctx);\n</code></pre>"},{"location":"man3/SSL_new/#description","title":"DESCRIPTION","text":"<p>SSL_new() creates a new SSL structure which is needed to hold the data for a TLS/SSL connection. The new structure inherits the settings of the underlying context ctx: connection method (SSLv2/v3/TLSv1), options, verification settings, timeout settings.</p>"},{"location":"man3/SSL_new/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>NULL</p> <p>The creation of a new SSL structure failed. Check the error stack to find out the reason.</p> </li> <li> <p>Pointer to an SSL structure</p> <p>The return value points to an allocated SSL structure.</p> </li> </ul>"},{"location":"man3/SSL_new/#see-also","title":"SEE ALSO","text":"<p>SSL_free(3), SSL_clear(3), SSL_CTX_set_options(3), SSL_get_SSL_CTX(3), ssl(3)</p>"},{"location":"man3/SSL_pending/","title":"SSL_pending","text":""},{"location":"man3/SSL_pending/#name","title":"NAME","text":"<p>SSL_pending - obtain number of readable bytes buffered in an SSL object</p>"},{"location":"man3/SSL_pending/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_pending(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_pending/#description","title":"DESCRIPTION","text":"<p>SSL_pending() returns the number of bytes which are available inside ssl for immediate read.</p>"},{"location":"man3/SSL_pending/#notes","title":"NOTES","text":"<p>Data are received in blocks from the peer. Therefore data can be buffered inside ssl and are ready for immediate retrieval with SSL_read(3).</p>"},{"location":"man3/SSL_pending/#return-values","title":"RETURN VALUES","text":"<p>The number of bytes pending is returned.</p>"},{"location":"man3/SSL_pending/#bugs","title":"BUGS","text":"<p>SSL_pending() takes into account only bytes from the TLS/SSL record that is currently being processed (if any).  If the SSL object's read_ahead flag is set (see SSL_CTX_set_read_ahead(3)), additional protocol bytes may have been read containing more TLS/SSL records; these are ignored by SSL_pending().</p> <p>Up to OpenSSL 0.9.6, SSL_pending() does not check if the record type of pending data is application data.</p>"},{"location":"man3/SSL_pending/#see-also","title":"SEE ALSO","text":"<p>SSL_read(3), SSL_CTX_set_read_ahead(3), ssl(3)</p>"},{"location":"man3/SSL_read/","title":"SSL_read","text":""},{"location":"man3/SSL_read/#name","title":"NAME","text":"<p>SSL_read - read bytes from a TLS/SSL connection.</p>"},{"location":"man3/SSL_read/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_read(SSL *ssl, void *buf, int num);\n</code></pre>"},{"location":"man3/SSL_read/#description","title":"DESCRIPTION","text":"<p>SSL_read() tries to read num bytes from the specified ssl into the buffer buf.</p>"},{"location":"man3/SSL_read/#notes","title":"NOTES","text":"<p>If necessary, SSL_read() will negotiate a TLS/SSL session, if not already explicitly performed by SSL_connect(3) or SSL_accept(3). If the peer requests a re-negotiation, it will be performed transparently during the SSL_read() operation. The behaviour of SSL_read() depends on the underlying BIO. </p> <p>For the transparent negotiation to succeed, the ssl must have been initialized to client or server mode. This is being done by calling SSL_set_connect_state(3) or SSL_set_accept_state() before the first call to an SSL_read() or SSL_write(3) function.</p> <p>SSL_read() works based on the SSL/TLS records. The data are received in records (with a maximum record size of 16kB for SSLv3/TLSv1). Only when a record has been completely received, it can be processed (decryption and check of integrity). Therefore data that was not retrieved at the last call of SSL_read() can still be buffered inside the SSL layer and will be retrieved on the next call to SSL_read(). If num is higher than the number of bytes buffered, SSL_read() will return with the bytes buffered. If no more bytes are in the buffer, SSL_read() will trigger the processing of the next record. Only when the record has been received and processed completely, SSL_read() will return reporting success. At most the contents of the record will be returned. As the size of an SSL/TLS record may exceed the maximum packet size of the underlying transport (e.g. TCP), it may be necessary to read several packets from the transport layer before the record is complete and SSL_read() can succeed.</p> <p>If the underlying BIO is blocking, SSL_read() will only return, once the read operation has been finished or an error occurred, except when a renegotiation take place, in which case a SSL_ERROR_WANT_READ may occur.  This behaviour can be controlled with the SSL_MODE_AUTO_RETRY flag of the SSL_CTX_set_mode(3) call.</p> <p>If the underlying BIO is non-blocking, SSL_read() will also return when the underlying BIO could not satisfy the needs of SSL_read() to continue the operation. In this case a call to SSL_get_error(3) with the return value of SSL_read() will yield SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. As at any time a re-negotiation is possible, a call to SSL_read() can also cause write operations! The calling process then must repeat the call after taking appropriate action to satisfy the needs of SSL_read(). The action depends on the underlying BIO. When using a non-blocking socket, nothing is to be done, but select() can be used to check for the required condition. When using a buffering BIO, like a BIO pair, data must be written into or retrieved out of the BIO before being able to continue.</p> <p>SSL_pending(3) can be used to find out whether there are buffered bytes available for immediate retrieval. In this case SSL_read() can be called without blocking or actually receiving new data from the underlying socket.</p>"},{"location":"man3/SSL_read/#warning","title":"WARNING","text":"<p>When an SSL_read() operation has to be repeated because of SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE, it must be repeated with the same arguments.</p>"},{"location":"man3/SSL_read/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>&gt; 0</p> <p>The read operation was successful. The return value is the number of bytes actually read from the TLS/SSL connection.</p> </li> <li> <p>&lt;= 0</p> </li> <li> <p>&lt;0</p> <p>The read operation was not successful, because either the connection was closed, an error occurred or action must be taken by the calling process. Call SSL_get_error(3) with the return value ret to find out the reason.</p> <p>SSLv2 (deprecated) does not support a shutdown alert protocol, so it can only be detected, whether the underlying connection was closed. It cannot be checked, whether the closure was initiated by the peer or by something else.</p> <p>Old documentation indicated a difference between 0 and -1, and that -1 was retryable. You should instead call SSL_get_error() to find out if it's retryable.</p> </li> </ul>"},{"location":"man3/SSL_read/#see-also","title":"SEE ALSO","text":"<p>SSL_get_error(3), SSL_write(3), SSL_CTX_set_mode(3), SSL_CTX_new(3), SSL_connect(3), SSL_accept(3) SSL_set_connect_state(3), SSL_pending(3), SSL_shutdown(3), SSL_set_shutdown(3), ssl(3), bio(3)</p>"},{"location":"man3/SSL_rstate_string/","title":"SSL_rstate_string","text":""},{"location":"man3/SSL_rstate_string/#name","title":"NAME","text":"<p>SSL_rstate_string, SSL_rstate_string_long - get textual description of state of an SSL object during read operation</p>"},{"location":"man3/SSL_rstate_string/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nconst char *SSL_rstate_string(SSL *ssl);\nconst char *SSL_rstate_string_long(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_rstate_string/#description","title":"DESCRIPTION","text":"<p>SSL_rstate_string() returns a 2 letter string indicating the current read state of the SSL object ssl.</p> <p>SSL_rstate_string_long() returns a string indicating the current read state of the SSL object ssl.</p>"},{"location":"man3/SSL_rstate_string/#notes","title":"NOTES","text":"<p>When performing a read operation, the SSL/TLS engine must parse the record, consisting of header and body. When working in a blocking environment, SSL_rstate_string[_long]() should always return \"RD\"/\"read done\".</p> <p>This function should only seldom be needed in applications.</p>"},{"location":"man3/SSL_rstate_string/#return-values","title":"RETURN VALUES","text":"<p>SSL_rstate_string() and SSL_rstate_string_long() can return the following values:</p> <ul> <li> <p>\"RH\"/\"read header\"</p> <p>The header of the record is being evaluated.</p> </li> <li> <p>\"RB\"/\"read body\"</p> <p>The body of the record is being evaluated.</p> </li> <li> <p>\"RD\"/\"read done\"</p> <p>The record has been completely processed.</p> </li> <li> <p>\"unknown\"/\"unknown\"</p> <p>The read state is unknown. This should never happen.</p> </li> </ul>"},{"location":"man3/SSL_rstate_string/#see-also","title":"SEE ALSO","text":"<p>ssl(3)</p>"},{"location":"man3/SSL_session_reused/","title":"SSL_session_reused","text":""},{"location":"man3/SSL_session_reused/#name","title":"NAME","text":"<p>SSL_session_reused - query whether a reused session was negotiated during handshake</p>"},{"location":"man3/SSL_session_reused/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_session_reused(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_session_reused/#description","title":"DESCRIPTION","text":"<p>Query, whether a reused session was negotiated during the handshake.</p>"},{"location":"man3/SSL_session_reused/#notes","title":"NOTES","text":"<p>During the negotiation, a client can propose to reuse a session. The server then looks up the session in its cache. If both client and server agree on the session, it will be reused and a flag is being set that can be queried by the application.</p>"},{"location":"man3/SSL_session_reused/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>0</p> <p>A new session was negotiated.</p> </li> <li> <p>1</p> <p>A session was reused.</p> </li> </ul>"},{"location":"man3/SSL_session_reused/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_set_session(3), SSL_CTX_set_session_cache_mode(3)</p>"},{"location":"man3/SSL_set_bio/","title":"SSL_set_bio","text":""},{"location":"man3/SSL_set_bio/#name","title":"NAME","text":"<p>SSL_set_bio - connect the SSL object with a BIO</p>"},{"location":"man3/SSL_set_bio/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_set_bio(SSL *ssl, BIO *rbio, BIO *wbio);\n</code></pre>"},{"location":"man3/SSL_set_bio/#description","title":"DESCRIPTION","text":"<p>SSL_set_bio() connects the BIOs rbio and wbio for the read and write operations of the TLS/SSL (encrypted) side of ssl.</p> <p>The SSL engine inherits the behaviour of rbio and wbio, respectively. If a BIO is non-blocking, the ssl will also have non-blocking behaviour.</p> <p>If there was already a BIO connected to ssl, BIO_free() will be called (for both the reading and writing side, if different).</p>"},{"location":"man3/SSL_set_bio/#return-values","title":"RETURN VALUES","text":"<p>SSL_set_bio() cannot fail.</p>"},{"location":"man3/SSL_set_bio/#see-also","title":"SEE ALSO","text":"<p>SSL_get_rbio(3), SSL_connect(3), SSL_accept(3), SSL_shutdown(3), ssl(3), bio(3)</p>"},{"location":"man3/SSL_set_connect_state/","title":"SSL_set_connect_state","text":""},{"location":"man3/SSL_set_connect_state/#name","title":"NAME","text":"<p>SSL_set_connect_state, SSL_get_accept_state - prepare SSL object to work in client or server mode</p>"},{"location":"man3/SSL_set_connect_state/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_set_connect_state(SSL *ssl);\n\nvoid SSL_set_accept_state(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_set_connect_state/#description","title":"DESCRIPTION","text":"<p>SSL_set_connect_state() sets ssl to work in client mode.</p> <p>SSL_set_accept_state() sets ssl to work in server mode.</p>"},{"location":"man3/SSL_set_connect_state/#notes","title":"NOTES","text":"<p>When the SSL_CTX object was created with SSL_CTX_new(3), it was either assigned a dedicated client method, a dedicated server method, or a generic method, that can be used for both client and server connections. (The method might have been changed with SSL_CTX_set_ssl_version(3) or SSL_set_ssl_method(3).)</p> <p>When beginning a new handshake, the SSL engine must know whether it must call the connect (client) or accept (server) routines. Even though it may be clear from the method chosen, whether client or server mode was requested, the handshake routines must be explicitly set.</p> <p>When using the SSL_connect(3) or SSL_accept(3) routines, the correct handshake routines are automatically set. When performing a transparent negotiation using SSL_write(3) or SSL_read(3), the handshake routines must be explicitly set in advance using either SSL_set_connect_state() or SSL_set_accept_state().</p>"},{"location":"man3/SSL_set_connect_state/#return-values","title":"RETURN VALUES","text":"<p>SSL_set_connect_state() and SSL_set_accept_state() do not return diagnostic information.</p>"},{"location":"man3/SSL_set_connect_state/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_new(3), SSL_CTX_new(3), SSL_connect(3), SSL_accept(3), SSL_write(3), SSL_read(3), SSL_do_handshake(3), SSL_CTX_set_ssl_version(3)</p>"},{"location":"man3/SSL_set_fd/","title":"SSL_set_fd","text":""},{"location":"man3/SSL_set_fd/#name","title":"NAME","text":"<p>SSL_set_fd - connect the SSL object with a file descriptor</p>"},{"location":"man3/SSL_set_fd/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_set_fd(SSL *ssl, int fd);\nint SSL_set_rfd(SSL *ssl, int fd);\nint SSL_set_wfd(SSL *ssl, int fd);\n</code></pre>"},{"location":"man3/SSL_set_fd/#description","title":"DESCRIPTION","text":"<p>SSL_set_fd() sets the file descriptor fd as the input/output facility for the TLS/SSL (encrypted) side of ssl. fd will typically be the socket file descriptor of a network connection.</p> <p>When performing the operation, a socket BIO is automatically created to interface between the ssl and fd. The BIO and hence the SSL engine inherit the behaviour of fd. If fd is non-blocking, the ssl will also have non-blocking behaviour.</p> <p>If there was already a BIO connected to ssl, BIO_free() will be called (for both the reading and writing side, if different).</p> <p>SSL_set_rfd() and SSL_set_wfd() perform the respective action, but only for the read channel or the write channel, which can be set independently.</p>"},{"location":"man3/SSL_set_fd/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>0</p> <p>The operation failed. Check the error stack to find out why.</p> </li> <li> <p>1</p> <p>The operation succeeded.</p> </li> </ul>"},{"location":"man3/SSL_set_fd/#see-also","title":"SEE ALSO","text":"<p>SSL_get_fd(3), SSL_set_bio(3), SSL_connect(3), SSL_accept(3), SSL_shutdown(3), ssl(3) , bio(3)</p>"},{"location":"man3/SSL_set_session/","title":"SSL_set_session","text":""},{"location":"man3/SSL_set_session/#name","title":"NAME","text":"<p>SSL_set_session - set a TLS/SSL session to be used during TLS/SSL connect</p>"},{"location":"man3/SSL_set_session/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_set_session(SSL *ssl, SSL_SESSION *session);\n</code></pre>"},{"location":"man3/SSL_set_session/#description","title":"DESCRIPTION","text":"<p>SSL_set_session() sets session to be used when the TLS/SSL connection is to be established. SSL_set_session() is only useful for TLS/SSL clients. When the session is set, the reference count of session is incremented by 1. If the session is not reused, the reference count is decremented again during SSL_connect(). Whether the session was reused can be queried with the SSL_session_reused(3) call.</p> <p>If there is already a session set inside ssl (because it was set with SSL_set_session() before or because the same ssl was already used for a connection), SSL_SESSION_free() will be called for that session.</p>"},{"location":"man3/SSL_set_session/#notes","title":"NOTES","text":"<p>SSL_SESSION objects keep internal link information about the session cache list, when being inserted into one SSL_CTX object's session cache. One SSL_SESSION object, regardless of its reference count, must therefore only be used with one SSL_CTX object (and the SSL objects created from this SSL_CTX object).</p>"},{"location":"man3/SSL_set_session/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>0</p> <p>The operation failed; check the error stack to find out the reason.</p> </li> <li> <p>1</p> <p>The operation succeeded.</p> </li> </ul>"},{"location":"man3/SSL_set_session/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_SESSION_free(3), SSL_get_session(3), SSL_session_reused(3), SSL_CTX_set_session_cache_mode(3)</p>"},{"location":"man3/SSL_set_shutdown/","title":"SSL_set_shutdown","text":""},{"location":"man3/SSL_set_shutdown/#name","title":"NAME","text":"<p>SSL_set_shutdown, SSL_get_shutdown - manipulate shutdown state of an SSL connection</p>"},{"location":"man3/SSL_set_shutdown/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_set_shutdown(SSL *ssl, int mode);\n\nint SSL_get_shutdown(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_set_shutdown/#description","title":"DESCRIPTION","text":"<p>SSL_set_shutdown() sets the shutdown state of ssl to mode.</p> <p>SSL_get_shutdown() returns the shutdown mode of ssl.</p>"},{"location":"man3/SSL_set_shutdown/#notes","title":"NOTES","text":"<p>The shutdown state of an ssl connection is a bitmask of:</p> <ul> <li> <p>0</p> <p>No shutdown setting, yet.</p> </li> <li> <p>SSL_SENT_SHUTDOWN</p> <p>A \"close notify\" shutdown alert was sent to the peer, the connection is being considered closed and the session is closed and correct.</p> </li> <li> <p>SSL_RECEIVED_SHUTDOWN</p> <p>A shutdown alert was received form the peer, either a normal \"close notify\" or a fatal error.</p> </li> </ul> <p>SSL_SENT_SHUTDOWN and SSL_RECEIVED_SHUTDOWN can be set at the same time.</p> <p>The shutdown state of the connection is used to determine the state of the ssl session. If the session is still open, when SSL_clear(3) or SSL_free(3) is called, it is considered bad and removed according to RFC2246. The actual condition for a correctly closed session is SSL_SENT_SHUTDOWN (according to the TLS RFC, it is acceptable to only send the \"close notify\" alert but to not wait for the peer's answer, when the underlying connection is closed). SSL_set_shutdown() can be used to set this state without sending a close alert to the peer (see SSL_shutdown(3)).</p> <p>If a \"close notify\" was received, SSL_RECEIVED_SHUTDOWN will be set, for setting SSL_SENT_SHUTDOWN the application must however still call SSL_shutdown(3) or SSL_set_shutdown() itself.</p>"},{"location":"man3/SSL_set_shutdown/#return-values","title":"RETURN VALUES","text":"<p>SSL_set_shutdown() does not return diagnostic information.</p> <p>SSL_get_shutdown() returns the current setting.</p>"},{"location":"man3/SSL_set_shutdown/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_shutdown(3), SSL_CTX_set_quiet_shutdown(3), SSL_clear(3), SSL_free(3)</p>"},{"location":"man3/SSL_set_verify_result/","title":"SSL_set_verify_result","text":""},{"location":"man3/SSL_set_verify_result/#name","title":"NAME","text":"<p>SSL_set_verify_result - override result of peer certificate verification</p>"},{"location":"man3/SSL_set_verify_result/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nvoid SSL_set_verify_result(SSL *ssl, long verify_result);\n</code></pre>"},{"location":"man3/SSL_set_verify_result/#description","title":"DESCRIPTION","text":"<p>SSL_set_verify_result() sets verify_result of the object ssl to be the result of the verification of the X509 certificate presented by the peer, if any.</p>"},{"location":"man3/SSL_set_verify_result/#notes","title":"NOTES","text":"<p>SSL_set_verify_result() overrides the verification result. It only changes the verification result of the ssl object. It does not become part of the established session, so if the session is to be reused later, the original value will reappear.</p> <p>The valid codes for verify_result are documented in verify(1).</p>"},{"location":"man3/SSL_set_verify_result/#return-values","title":"RETURN VALUES","text":"<p>SSL_set_verify_result() does not provide a return value.</p>"},{"location":"man3/SSL_set_verify_result/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_get_verify_result(3), SSL_get_peer_certificate(3), verify(1)</p>"},{"location":"man3/SSL_shutdown/","title":"SSL_shutdown","text":""},{"location":"man3/SSL_shutdown/#name","title":"NAME","text":"<p>SSL_shutdown - shut down a TLS/SSL connection</p>"},{"location":"man3/SSL_shutdown/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_shutdown(SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_shutdown/#description","title":"DESCRIPTION","text":"<p>SSL_shutdown() shuts down an active TLS/SSL connection. It sends the  \"close notify\" shutdown alert to the peer.</p>"},{"location":"man3/SSL_shutdown/#notes","title":"NOTES","text":"<p>SSL_shutdown() tries to send the \"close notify\" shutdown alert to the peer. Whether the operation succeeds or not, the SSL_SENT_SHUTDOWN flag is set and a currently open session is considered closed and good and will be kept in the session cache for further reuse.</p> <p>Note that SSL_shutdown() must not be called if a previous fatal error has occurred on a connection i.e. if SSL_get_error() has returned SSL_ERROR_SYSCALL or SSL_ERROR_SSL.</p> <p>The shutdown procedure consists of 2 steps: the sending of the \"close notify\" shutdown alert and the reception of the peer's \"close notify\" shutdown alert. According to the TLS standard, it is acceptable for an application to only send its shutdown alert and then close the underlying connection without waiting for the peer's response (this way resources can be saved, as the process can already terminate or serve another connection). When the underlying connection shall be used for more communications, the complete shutdown procedure (bidirectional \"close notify\" alerts) must be performed, so that the peers stay synchronized.</p> <p>SSL_shutdown() supports both uni- and bidirectional shutdown by its 2 step behaviour.</p> <ul> <li>When the application is the first party to send the \"close notify\" alert, SSL_shutdown() will only send the alert and then set the SSL_SENT_SHUTDOWN flag (so that the session is considered good and will be kept in cache). SSL_shutdown() will then return with 0. If a unidirectional shutdown is enough (the underlying connection shall be closed anyway), this first call to SSL_shutdown() is sufficient. In order to complete the bidirectional shutdown handshake, SSL_shutdown() must be called again. The second call will make SSL_shutdown() wait for the peer's \"close notify\" shutdown alert. On success, the second call to SSL_shutdown() will return with 1.</li> <li>If the peer already sent the \"close notify\" alert and it was already processed implicitly inside another function (SSL_read(3)), the SSL_RECEIVED_SHUTDOWN flag is set. SSL_shutdown() will send the \"close notify\" alert, set the SSL_SENT_SHUTDOWN flag and will immediately return with 1. Whether SSL_RECEIVED_SHUTDOWN is already set can be checked using the SSL_get_shutdown() (see also SSL_set_shutdown(3) call.</li> </ul> <p>It is therefore recommended, to check the return value of SSL_shutdown() and call SSL_shutdown() again, if the bidirectional shutdown is not yet complete (return value of the first call is 0). As the shutdown is not specially handled in the SSLv2 protocol, SSL_shutdown() will succeed on the first call.</p> <p>The behaviour of SSL_shutdown() additionally depends on the underlying BIO. </p> <p>If the underlying BIO is blocking, SSL_shutdown() will only return once the handshake step has been finished or an error occurred.</p> <p>If the underlying BIO is non-blocking, SSL_shutdown() will also return when the underlying BIO could not satisfy the needs of SSL_shutdown() to continue the handshake. In this case a call to SSL_get_error() with the return value of SSL_shutdown() will yield SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process then must repeat the call after taking appropriate action to satisfy the needs of SSL_shutdown(). The action depends on the underlying BIO. When using a non-blocking socket, nothing is to be done, but select() can be used to check for the required condition. When using a buffering BIO, like a BIO pair, data must be written into or retrieved out of the BIO before being able to continue.</p> <p>SSL_shutdown() can be modified to only set the connection to \"shutdown\" state but not actually send the \"close notify\" alert messages, see SSL_CTX_set_quiet_shutdown(3). When \"quiet shutdown\" is enabled, SSL_shutdown() will always succeed and return 1.</p>"},{"location":"man3/SSL_shutdown/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>0</p> <p>The shutdown is not yet finished. Call SSL_shutdown() for a second time, if a bidirectional shutdown shall be performed. The output of SSL_get_error(3) may be misleading, as an erroneous SSL_ERROR_SYSCALL may be flagged even though no error occurred.</p> </li> <li> <p>1</p> <p>The shutdown was successfully completed. The \"close notify\" alert was sent and the peer's \"close notify\" alert was received.</p> </li> <li> <p>&lt;0</p> <p>The shutdown was not successful because a fatal error occurred either at the protocol level or a connection failure occurred. It can also occur if action is need to continue the operation for non-blocking BIOs. Call SSL_get_error(3) with the return value ret to find out the reason.</p> </li> </ul>"},{"location":"man3/SSL_shutdown/#see-also","title":"SEE ALSO","text":"<p>SSL_get_error(3), SSL_connect(3), SSL_accept(3), SSL_set_shutdown(3), SSL_CTX_set_quiet_shutdown(3), SSL_clear(3), SSL_free(3), ssl(3), bio(3)</p>"},{"location":"man3/SSL_state_string/","title":"SSL_state_string","text":""},{"location":"man3/SSL_state_string/#name","title":"NAME","text":"<p>SSL_state_string, SSL_state_string_long - get textual description of state of an SSL object</p>"},{"location":"man3/SSL_state_string/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nconst char *SSL_state_string(const SSL *ssl);\nconst char *SSL_state_string_long(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_state_string/#description","title":"DESCRIPTION","text":"<p>SSL_state_string() returns a 6 letter string indicating the current state of the SSL object ssl.</p> <p>SSL_state_string_long() returns a string indicating the current state of the SSL object ssl.</p>"},{"location":"man3/SSL_state_string/#notes","title":"NOTES","text":"<p>During its use, an SSL objects passes several states. The state is internally maintained. Querying the state information is not very informative before or when a connection has been established. It however can be of significant interest during the handshake.</p> <p>When using non-blocking sockets, the function call performing the handshake may return with SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE condition, so that SSL_state_string[_long]() may be called.</p> <p>For both blocking or non-blocking sockets, the details state information can be used within the info_callback function set with the SSL_set_info_callback() call.</p>"},{"location":"man3/SSL_state_string/#return-values","title":"RETURN VALUES","text":"<p>Detailed description of possible states to be included later.</p>"},{"location":"man3/SSL_state_string/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_CTX_set_info_callback(3)</p>"},{"location":"man3/SSL_want/","title":"SSL_want","text":""},{"location":"man3/SSL_want/#name","title":"NAME","text":"<p>SSL_want, SSL_want_nothing, SSL_want_read, SSL_want_write, SSL_want_x509_lookup - obtain state information TLS/SSL I/O operation</p>"},{"location":"man3/SSL_want/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_want(const SSL *ssl);\nint SSL_want_nothing(const SSL *ssl);\nint SSL_want_read(const SSL *ssl);\nint SSL_want_write(const SSL *ssl);\nint SSL_want_x509_lookup(const SSL *ssl);\n</code></pre>"},{"location":"man3/SSL_want/#description","title":"DESCRIPTION","text":"<p>SSL_want() returns state information for the SSL object ssl.</p> <p>The other SSL_want_*() calls are shortcuts for the possible states returned by SSL_want().</p>"},{"location":"man3/SSL_want/#notes","title":"NOTES","text":"<p>SSL_want() examines the internal state information of the SSL object. Its return values are similar to that of SSL_get_error(3). Unlike SSL_get_error(3), which also evaluates the error queue, the results are obtained by examining an internal state flag only. The information must therefore only be used for normal operation under non-blocking I/O. Error conditions are not handled and must be treated using SSL_get_error(3).</p> <p>The result returned by SSL_want() should always be consistent with the result of SSL_get_error(3).</p>"},{"location":"man3/SSL_want/#return-values","title":"RETURN VALUES","text":"<p>The following return values can currently occur for SSL_want():</p> <ul> <li> <p>SSL_NOTHING</p> <p>There is no data to be written or to be read.</p> </li> <li> <p>SSL_WRITING</p> <p>There are data in the SSL buffer that must be written to the underlying BIO layer in order to complete the actual SSL_*() operation. A call to SSL_get_error(3) should return SSL_ERROR_WANT_WRITE.</p> </li> <li> <p>SSL_READING</p> <p>More data must be read from the underlying BIO layer in order to complete the actual SSL_*() operation. A call to SSL_get_error(3) should return SSL_ERROR_WANT_READ.</p> </li> <li> <p>SSL_X509_LOOKUP</p> <p>The operation did not complete because an application callback set by SSL_CTX_set_client_cert_cb() has asked to be called again. A call to SSL_get_error(3) should return SSL_ERROR_WANT_X509_LOOKUP.</p> </li> </ul> <p>SSL_want_nothing(), SSL_want_read(), SSL_want_write(), SSL_want_x509_lookup() return 1, when the corresponding condition is true or 0 otherwise.</p>"},{"location":"man3/SSL_want/#see-also","title":"SEE ALSO","text":"<p>ssl(3), err(3), SSL_get_error(3)</p>"},{"location":"man3/SSL_write/","title":"SSL_write","text":""},{"location":"man3/SSL_write/#name","title":"NAME","text":"<p>SSL_write - write bytes to a TLS/SSL connection.</p>"},{"location":"man3/SSL_write/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nint SSL_write(SSL *ssl, const void *buf, int num);\n</code></pre>"},{"location":"man3/SSL_write/#description","title":"DESCRIPTION","text":"<p>SSL_write() writes num bytes from the buffer buf into the specified ssl connection.</p>"},{"location":"man3/SSL_write/#notes","title":"NOTES","text":"<p>If necessary, SSL_write() will negotiate a TLS/SSL session, if not already explicitly performed by SSL_connect(3) or SSL_accept(3). If the peer requests a re-negotiation, it will be performed transparently during the SSL_write() operation. The behaviour of SSL_write() depends on the underlying BIO. </p> <p>For the transparent negotiation to succeed, the ssl must have been initialized to client or server mode. This is being done by calling SSL_set_connect_state(3) or SSL_set_accept_state() before the first call to an SSL_read(3) or SSL_write() function.</p> <p>If the underlying BIO is blocking, SSL_write() will only return, once the write operation has been finished or an error occurred, except when a renegotiation take place, in which case a SSL_ERROR_WANT_READ may occur.  This behaviour can be controlled with the SSL_MODE_AUTO_RETRY flag of the SSL_CTX_set_mode(3) call.</p> <p>If the underlying BIO is non-blocking, SSL_write() will also return, when the underlying BIO could not satisfy the needs of SSL_write() to continue the operation. In this case a call to SSL_get_error(3) with the return value of SSL_write() will yield SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. As at any time a re-negotiation is possible, a call to SSL_write() can also cause read operations! The calling process then must repeat the call after taking appropriate action to satisfy the needs of SSL_write(). The action depends on the underlying BIO. When using a non-blocking socket, nothing is to be done, but select() can be used to check for the required condition. When using a buffering BIO, like a BIO pair, data must be written into or retrieved out of the BIO before being able to continue.</p> <p>SSL_write() will only return with success, when the complete contents of buf of length num has been written. This default behaviour can be changed with the SSL_MODE_ENABLE_PARTIAL_WRITE option of SSL_CTX_set_mode(3). When this flag is set, SSL_write() will also return with success, when a partial write has been successfully completed. In this case the SSL_write() operation is considered completed. The bytes are sent and a new SSL_write() operation with a new buffer (with the already sent bytes removed) must be started. A partial write is performed with the size of a message block, which is 16kB for SSLv3/TLSv1.</p>"},{"location":"man3/SSL_write/#warning","title":"WARNING","text":"<p>When an SSL_write() operation has to be repeated because of SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE, it must be repeated with the same arguments.</p> <p>When calling SSL_write() with num=0 bytes to be sent the behaviour is undefined.</p>"},{"location":"man3/SSL_write/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>&gt; 0</p> <p>The write operation was successful, the return value is the number of bytes actually written to the TLS/SSL connection.</p> </li> <li> <p>&lt;= 0</p> <p>The write operation was not successful, because either the connection was closed, an error occurred or action must be taken by the calling process. Call SSL_get_error() with the return value ret to find out the reason.</p> <p>SSLv2 (deprecated) does not support a shutdown alert protocol, so it can only be detected, whether the underlying connection was closed. It cannot be checked, why the closure happened.</p> <p>Old documentation indicated a difference between 0 and -1, and that -1 was retryable. You should instead call SSL_get_error() to find out if it's retryable.</p> </li> </ul>"},{"location":"man3/SSL_write/#see-also","title":"SEE ALSO","text":"<p>SSL_get_error(3), SSL_read(3), SSL_CTX_set_mode(3), SSL_CTX_new(3), SSL_connect(3), SSL_accept(3) SSL_set_connect_state(3), ssl(3), bio(3)</p>"},{"location":"man3/SSLeay_version/","title":"SSLeay_version","text":""},{"location":"man3/SSLeay_version/#name","title":"NAME","text":"<p>SSLeay_version - retrieve version/build information about OpenSSL library</p>"},{"location":"man3/SSLeay_version/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/crypto.h&gt;\n\nconst char *SSLeay_version(int type);\n</code></pre>"},{"location":"man3/SSLeay_version/#description","title":"DESCRIPTION","text":"<p>SSLeay_version() returns a pointer to a constant string describing the version of the OpenSSL library or giving information about the library build.</p> <p>The following type values are supported:</p> <ul> <li> <p>SSLEAY_VERSION</p> <p>The version of the OpenSSL library including the release date.</p> </li> <li> <p>SSLEAY_CFLAGS</p> <p>The compiler flags set for the compilation process in the form \"compiler: ...\"  if available or \"compiler: information not available\" otherwise.</p> </li> <li> <p>SSLEAY_BUILT_ON</p> <p>The date of the build process in the form \"built on: ...\" if available or \"built on: date not available\" otherwise.</p> </li> <li> <p>SSLEAY_PLATFORM</p> <p>The \"Configure\" target of the library build in the form \"platform: ...\" if available or \"platform: information not available\" otherwise.</p> </li> <li> <p>SSLEAY_DIR</p> <p>The \"OPENSSLDIR\" setting of the library build in the form \"OPENSSLDIR: \"...\"\" if available or \"OPENSSLDIR: N/A\" otherwise.</p> </li> </ul>"},{"location":"man3/SSLeay_version/#return-values","title":"RETURN VALUES","text":"<p>The following return values can occur:</p> <ul> <li> <p>\"not available\"</p> <p>An invalid value for type was given.</p> </li> <li> <p>Pointer to constant string</p> <p>Textual description.</p> </li> </ul>"},{"location":"man3/SSLeay_version/#see-also","title":"SEE ALSO","text":"<p>crypto(3)</p>"},{"location":"man3/SSLeay_version/#history","title":"HISTORY","text":"<p>SSLEAY_DIR was added in OpenSSL 0.9.7.</p>"},{"location":"man3/X509_NAME_ENTRY_get_object/","title":"X509_NAME_ENTRY_get_object","text":""},{"location":"man3/X509_NAME_ENTRY_get_object/#name","title":"NAME","text":"<p>X509_NAME_ENTRY_get_object, X509_NAME_ENTRY_get_data, X509_NAME_ENTRY_set_object, X509_NAME_ENTRY_set_data, X509_NAME_ENTRY_create_by_txt, X509_NAME_ENTRY_create_by_NID, X509_NAME_ENTRY_create_by_OBJ - X509_NAME_ENTRY utility functions</p>"},{"location":"man3/X509_NAME_ENTRY_get_object/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nASN1_OBJECT * X509_NAME_ENTRY_get_object(X509_NAME_ENTRY *ne);\nASN1_STRING * X509_NAME_ENTRY_get_data(X509_NAME_ENTRY *ne);\n\nint X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne, ASN1_OBJECT *obj);\nint X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *ne, int type, const unsigned char *bytes, int len);\n\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne, const char *field, int type, const unsigned char *bytes, int len);\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne, int nid, int type,unsigned char *bytes, int len);\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne, ASN1_OBJECT *obj, int type, const unsigned char *bytes, int len);\n</code></pre>"},{"location":"man3/X509_NAME_ENTRY_get_object/#description","title":"DESCRIPTION","text":"<p>X509_NAME_ENTRY_get_object() retrieves the field name of ne in and ASN1_OBJECT structure.</p> <p>X509_NAME_ENTRY_get_data() retrieves the field value of ne in and ASN1_STRING structure.</p> <p>X509_NAME_ENTRY_set_object() sets the field name of ne to obj.</p> <p>X509_NAME_ENTRY_set_data() sets the field value of ne to string type type and value determined by bytes and len.</p> <p>X509_NAME_ENTRY_create_by_txt(), X509_NAME_ENTRY_create_by_NID() and X509_NAME_ENTRY_create_by_OBJ() create and return an  X509_NAME_ENTRY structure.</p>"},{"location":"man3/X509_NAME_ENTRY_get_object/#notes","title":"NOTES","text":"<p>X509_NAME_ENTRY_get_object() and X509_NAME_ENTRY_get_data() can be used to examine an X509_NAME_ENTRY function as returned by  X509_NAME_get_entry() for example.</p> <p>X509_NAME_ENTRY_create_by_txt(), X509_NAME_ENTRY_create_by_OBJ(), X509_NAME_ENTRY_create_by_NID() and X509_NAME_ENTRY_set_data() are seldom used in practice because X509_NAME_ENTRY structures are almost always part of X509_NAME structures and the corresponding X509_NAME functions are typically used to create and add new entries in a single operation.</p> <p>The arguments of these functions support similar options to the similarly named ones of the corresponding X509_NAME functions such as X509_NAME_add_entry_by_txt(). So for example type can be set to MBSTRING_ASC but in the case of X509_set_data() the field name must be set first so the relevant field information can be looked up internally.</p>"},{"location":"man3/X509_NAME_ENTRY_get_object/#return-values","title":"RETURN VALUES","text":""},{"location":"man3/X509_NAME_ENTRY_get_object/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), d2i_X509_NAME(3), OBJ_nid2obj(3)</p>"},{"location":"man3/X509_NAME_ENTRY_get_object/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/X509_NAME_add_entry_by_txt/","title":"X509_NAME_add_entry_by_txt","text":""},{"location":"man3/X509_NAME_add_entry_by_txt/#name","title":"NAME","text":"<p>X509_NAME_add_entry_by_txt, X509_NAME_add_entry_by_OBJ, X509_NAME_add_entry_by_NID, X509_NAME_add_entry, X509_NAME_delete_entry - X509_NAME modification functions</p>"},{"location":"man3/X509_NAME_add_entry_by_txt/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nint X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type, const unsigned char *bytes, int len, int loc, int set);\n\nint X509_NAME_add_entry_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, int type, unsigned char *bytes, int len, int loc, int set);\n\nint X509_NAME_add_entry_by_NID(X509_NAME *name, int nid, int type, unsigned char *bytes, int len, int loc, int set);\n\nint X509_NAME_add_entry(X509_NAME *name,X509_NAME_ENTRY *ne, int loc, int set);\n\nX509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc);\n</code></pre>"},{"location":"man3/X509_NAME_add_entry_by_txt/#description","title":"DESCRIPTION","text":"<p>X509_NAME_add_entry_by_txt(), X509_NAME_add_entry_by_OBJ() and X509_NAME_add_entry_by_NID() add a field whose name is defined by a string field, an object obj or a NID nid respectively. The field value to be added is in bytes of length len. If len is -1 then the field length is calculated internally using strlen(bytes).</p> <p>The type of field is determined by type which can either be a definition of the type of bytes (such as MBSTRING_ASC) or a standard ASN1 type (such as V_ASN1_IA5STRING). The new entry is added to a position determined by loc and set.</p> <p>X509_NAME_add_entry() adds a copy of X509_NAME_ENTRY structure ne to name. The new entry is added to a position determined by loc and set. Since a copy of ne is added ne must be freed up after the call.</p> <p>X509_NAME_delete_entry() deletes an entry from name at position loc. The deleted entry is returned and must be freed up.</p>"},{"location":"man3/X509_NAME_add_entry_by_txt/#notes","title":"NOTES","text":"<p>The use of string types such as MBSTRING_ASC or MBSTRING_UTF8 is strongly recommended for the type parameter. This allows the internal code to correctly determine the type of the field and to apply length checks according to the relevant standards. This is done using ASN1_STRING_set_by_NID().</p> <p>If instead an ASN1 type is used no checks are performed and the supplied data in bytes is used directly.</p> <p>In X509_NAME_add_entry_by_txt() the field string represents the field name using OBJ_txt2obj(field, 0).</p> <p>The loc and set parameters determine where a new entry should be added. For almost all applications loc can be set to -1 and set to 0. This adds a new entry to the end of name as a single valued RelativeDistinguishedName (RDN).</p> <p>loc actually determines the index where the new entry is inserted: if it is -1 it is appended. </p> <p>set determines how the new type is added. If it is zero a new RDN is created.</p> <p>If set is -1 or 1 it is added to the previous or next RDN structure respectively. This will then be a multivalued RDN: since multivalues RDNs are very seldom used set is almost always set to zero.</p>"},{"location":"man3/X509_NAME_add_entry_by_txt/#examples","title":"EXAMPLES","text":"<p>Create an X509_NAME structure:</p> <p>\"C=UK, O=Disorganized Organization, CN=Joe Bloggs\"</p> <pre><code>X509_NAME *nm;\nnm = X509_NAME_new();\nif (nm == NULL)\n       /* Some error */\nif (!X509_NAME_add_entry_by_txt(nm, \"C\", MBSTRING_ASC, \n                       \"UK\", -1, -1, 0))\n       /* Error */\nif (!X509_NAME_add_entry_by_txt(nm, \"O\", MBSTRING_ASC,\n                       \"Disorganized Organization\", -1, -1, 0))\n       /* Error */\nif (!X509_NAME_add_entry_by_txt(nm, \"CN\", MBSTRING_ASC,\n                       \"Joe Bloggs\", -1, -1, 0))\n       /* Error */\n</code></pre>"},{"location":"man3/X509_NAME_add_entry_by_txt/#return-values","title":"RETURN VALUES","text":"<p>X509_NAME_add_entry_by_txt(), X509_NAME_add_entry_by_OBJ(), X509_NAME_add_entry_by_NID() and X509_NAME_add_entry() return 1 for success of 0 if an error occurred.</p> <p>X509_NAME_delete_entry() returns either the deleted X509_NAME_ENTRY structure of NULL if an error occurred.</p>"},{"location":"man3/X509_NAME_add_entry_by_txt/#bugs","title":"BUGS","text":"<p>type can still be set to V_ASN1_APP_CHOOSE to use a different algorithm to determine field types. Since this form does not understand multicharacter types, performs no length checks and can result in invalid field types its use is strongly discouraged.</p>"},{"location":"man3/X509_NAME_add_entry_by_txt/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), d2i_X509_NAME(3)</p>"},{"location":"man3/X509_NAME_add_entry_by_txt/#history","title":"HISTORY","text":""},{"location":"man3/X509_NAME_get_index_by_NID/","title":"X509_NAME_get_index_by_NID","text":""},{"location":"man3/X509_NAME_get_index_by_NID/#name","title":"NAME","text":"<p>X509_NAME_get_index_by_NID, X509_NAME_get_index_by_OBJ, X509_NAME_get_entry, X509_NAME_entry_count, X509_NAME_get_text_by_NID, X509_NAME_get_text_by_OBJ - X509_NAME lookup and enumeration functions</p>"},{"location":"man3/X509_NAME_get_index_by_NID/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nint X509_NAME_get_index_by_NID(X509_NAME *name,int nid,int lastpos);\nint X509_NAME_get_index_by_OBJ(X509_NAME *name,ASN1_OBJECT *obj, int lastpos);\n\nint X509_NAME_entry_count(X509_NAME *name);\nX509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *name, int loc);\n\nint X509_NAME_get_text_by_NID(X509_NAME *name, int nid, char *buf,int len);\nint X509_NAME_get_text_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, char *buf,int len);\n</code></pre>"},{"location":"man3/X509_NAME_get_index_by_NID/#description","title":"DESCRIPTION","text":"<p>These functions allow an X509_NAME structure to be examined. The X509_NAME structure is the same as the Name type defined in RFC2459 (and elsewhere) and used for example in certificate subject and issuer names.</p> <p>X509_NAME_get_index_by_NID() and X509_NAME_get_index_by_OBJ() retrieve the next index matching nid or obj after lastpos. lastpos should initially be set to -1. If there are no more entries -1 is returned. If nid is invalid (doesn't correspond to a valid OID) then -2 is returned.</p> <p>X509_NAME_entry_count() returns the total number of entries in name.</p> <p>X509_NAME_get_entry() retrieves the X509_NAME_ENTRY from name corresponding to index loc. Acceptable values for loc run from 0 to (X509_NAME_entry_count(name) - 1). The value returned is an internal pointer which must not be freed.</p> <p>X509_NAME_get_text_by_NID(), X509_NAME_get_text_by_OBJ() retrieve the \"text\" from the first entry in name which matches nid or obj, if no such entry exists -1 is returned. At most len bytes will be written and the text written to buf will be null terminated. The length of the output string written is returned excluding the terminating null. If buf is &lt;NULL&gt; then the amount of space needed in buf (excluding the final null) is returned. </p>"},{"location":"man3/X509_NAME_get_index_by_NID/#notes","title":"NOTES","text":"<p>X509_NAME_get_text_by_NID() and X509_NAME_get_text_by_OBJ() are legacy functions which have various limitations which make them of minimal use in practice. They can only find the first matching entry and will copy the contents of the field verbatim: this can be highly confusing if the target is a muticharacter string type like a BMPString or a UTF8String.</p> <p>For a more general solution X509_NAME_get_index_by_NID() or X509_NAME_get_index_by_OBJ() should be used followed by X509_NAME_get_entry() on any matching indices and then the various X509_NAME_ENTRY utility functions on the result.</p> <p>The list of all relevant NID_* and OBJ_* codes can be found in the source code header files &lt;openssl/obj_mac.h&gt; and/or &lt;openssl/objects.h&gt;.</p> <p>Applications which could pass invalid NIDs to X509_NAME_get_index_by_NID() should check for the return value of -2. Alternatively the NID validity can be determined first by checking OBJ_nid2obj(nid) is not NULL.</p>"},{"location":"man3/X509_NAME_get_index_by_NID/#examples","title":"EXAMPLES","text":"<p>Process all entries:</p> <pre><code>int i;\nX509_NAME_ENTRY *e;\n\nfor (i = 0; i &lt; X509_NAME_entry_count(nm); i++)\n       {\n       e = X509_NAME_get_entry(nm, i);\n       /* Do something with e */\n       }\n</code></pre> <p>Process all commonName entries:</p> <pre><code>int lastpos = -1;\nX509_NAME_ENTRY *e;\n\nfor (;;)\n       {\n       lastpos = X509_NAME_get_index_by_NID(nm, NID_commonName, lastpos);\n       if (lastpos == -1)\n               break;\n       e = X509_NAME_get_entry(nm, lastpos);\n       /* Do something with e */\n       }\n</code></pre>"},{"location":"man3/X509_NAME_get_index_by_NID/#return-values","title":"RETURN VALUES","text":"<p>X509_NAME_get_index_by_NID() and X509_NAME_get_index_by_OBJ() return the index of the next matching entry or -1 if not found. X509_NAME_get_index_by_NID() can also return -2 if the supplied NID is invalid.</p> <p>X509_NAME_entry_count() returns the total number of entries.</p> <p>X509_NAME_get_entry() returns an X509_NAME pointer to the requested entry or NULL if the index is invalid.</p>"},{"location":"man3/X509_NAME_get_index_by_NID/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), d2i_X509_NAME(3)</p>"},{"location":"man3/X509_NAME_get_index_by_NID/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/X509_NAME_print_ex/","title":"X509_NAME_print_ex","text":""},{"location":"man3/X509_NAME_print_ex/#name","title":"NAME","text":"<p>X509_NAME_print_ex, X509_NAME_print_ex_fp, X509_NAME_print, X509_NAME_oneline - X509_NAME printing routines.</p>"},{"location":"man3/X509_NAME_print_ex/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nint X509_NAME_print_ex(BIO *out, X509_NAME *nm, int indent, unsigned long flags);\nint X509_NAME_print_ex_fp(FILE *fp, X509_NAME *nm, int indent, unsigned long flags);\nchar * X509_NAME_oneline(X509_NAME *a,char *buf,int size);\nint X509_NAME_print(BIO *bp, X509_NAME *name, int obase);\n</code></pre>"},{"location":"man3/X509_NAME_print_ex/#description","title":"DESCRIPTION","text":"<p>X509_NAME_print_ex() prints a human readable version of nm to BIO out. Each line (for multiline formats) is indented by indent spaces. The output format can be extensively customised by use of the flags parameter.</p> <p>X509_NAME_print_ex_fp() is identical to X509_NAME_print_ex() except the output is written to FILE pointer fp.</p> <p>X509_NAME_oneline() prints an ASCII version of a to buf. If buf is NULL then a buffer is dynamically allocated and returned, and size is ignored. Otherwise, at most size bytes will be written, including the ending '\\0', and buf is returned.</p> <p>X509_NAME_print() prints out name to bp indenting each line by obase  characters. Multiple lines are used if the output (including indent) exceeds 80 characters.</p>"},{"location":"man3/X509_NAME_print_ex/#notes","title":"NOTES","text":"<p>The functions X509_NAME_oneline() and X509_NAME_print() are legacy functions which produce a non standard output form, they don't handle multi character fields and have various quirks and inconsistencies. Their use is strongly discouraged in new applications.</p> <p>Although there are a large number of possible flags for most purposes XN_FLAG_ONELINE, XN_FLAG_MULTILINE or XN_FLAG_RFC2253 will suffice. As noted on the ASN1_STRING_print_ex(3) manual page for UTF8 terminals the ASN1_STRFLGS_ESC_MSB should be unset: so for example XN_FLAG_ONELINE &amp; ~ASN1_STRFLGS_ESC_MSB would be used.</p> <p>The complete set of the flags supported by X509_NAME_print_ex() is listed below.</p> <p>Several options can be ored together.</p> <p>The options XN_FLAG_SEP_COMMA_PLUS, XN_FLAG_SEP_CPLUS_SPC, XN_FLAG_SEP_SPLUS_SPC and XN_FLAG_SEP_MULTILINE determine the field separators to use. Two distinct separators are used between distinct RelativeDistinguishedName components and separate values in the same RDN for a multi-valued RDN. Multi-valued RDNs are currently very rare so the second separator will hardly ever be used.</p> <p>XN_FLAG_SEP_COMMA_PLUS uses comma and plus as separators. XN_FLAG_SEP_CPLUS_SPC uses comma and plus with spaces: this is more readable that plain comma and plus. XN_FLAG_SEP_SPLUS_SPC uses spaced semicolon and plus. XN_FLAG_SEP_MULTILINE uses spaced newline and plus respectively.</p> <p>If XN_FLAG_DN_REV is set the whole DN is printed in reversed order.</p> <p>The fields XN_FLAG_FN_SN, XN_FLAG_FN_LN, XN_FLAG_FN_OID, XN_FLAG_FN_NONE determine how a field name is displayed. It will use the short name (e.g. CN) the long name (e.g. commonName) always use OID numerical form (normally OIDs are only used if the field name is not recognised) and no field name respectively.</p> <p>If XN_FLAG_SPC_EQ is set then spaces will be placed around the '=' character separating field names and values.</p> <p>If XN_FLAG_DUMP_UNKNOWN_FIELDS is set then the encoding of unknown fields is printed instead of the values.</p> <p>If XN_FLAG_FN_ALIGN is set then field names are padded to 20 characters: this is only of use for multiline format.</p> <p>Additionally all the options supported by ASN1_STRING_print_ex() can be used to  control how each field value is displayed.</p> <p>In addition a number options can be set for commonly used formats.</p> <p>XN_FLAG_RFC2253 sets options which produce an output compatible with RFC2253 it is equivalent to:  ASN1_STRFLGS_RFC2253 | XN_FLAG_SEP_COMMA_PLUS | XN_FLAG_DN_REV | XN_FLAG_FN_SN | XN_FLAG_DUMP_UNKNOWN_FIELDS</p> <p>XN_FLAG_ONELINE is a more readable one line format which is the same as:  ASN1_STRFLGS_RFC2253 | ASN1_STRFLGS_ESC_QUOTE | XN_FLAG_SEP_CPLUS_SPC | XN_FLAG_SPC_EQ | XN_FLAG_FN_SN</p> <p>XN_FLAG_MULTILINE is a multiline format which is the same as:  ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | XN_FLAG_SEP_MULTILINE | XN_FLAG_SPC_EQ | XN_FLAG_FN_LN | XN_FLAG_FN_ALIGN</p> <p>XN_FLAG_COMPAT uses a format identical to X509_NAME_print(): in fact it calls X509_NAME_print() internally.</p>"},{"location":"man3/X509_NAME_print_ex/#see-also","title":"SEE ALSO","text":"<p>ASN1_STRING_print_ex(3)</p>"},{"location":"man3/X509_NAME_print_ex/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/X509_STORE_CTX_get_error/","title":"X509_STORE_CTX_get_error","text":""},{"location":"man3/X509_STORE_CTX_get_error/#name","title":"NAME","text":"<p>X509_STORE_CTX_get_error, X509_STORE_CTX_set_error, X509_STORE_CTX_get_error_depth, X509_STORE_CTX_get_current_cert, X509_STORE_CTX_get1_chain, X509_verify_cert_error_string - get or set certificate verification status information</p>"},{"location":"man3/X509_STORE_CTX_get_error/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n#include &lt;openssl/x509_vfy.h&gt;\n\nint    X509_STORE_CTX_get_error(X509_STORE_CTX *ctx);\nvoid   X509_STORE_CTX_set_error(X509_STORE_CTX *ctx,int s);\nint    X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx);\nX509 * X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx);\n\nSTACK_OF(X509) *X509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx);\n\nconst char *X509_verify_cert_error_string(long n);\n</code></pre>"},{"location":"man3/X509_STORE_CTX_get_error/#description","title":"DESCRIPTION","text":"<p>These functions are typically called after X509_verify_cert() has indicated an error or in a verification callback to determine the nature of an error.</p> <p>X509_STORE_CTX_get_error() returns the error code of ctx, see the ERROR CODES section for a full description of all error codes.</p> <p>X509_STORE_CTX_set_error() sets the error code of ctx to s. For example it might be used in a verification callback to set an error based on additional checks.</p> <p>X509_STORE_CTX_get_error_depth() returns the depth of the error. This is a non-negative integer representing where in the certificate chain the error occurred. If it is zero it occurred in the end entity certificate, one if it is the certificate which signed the end entity certificate and so on.</p> <p>X509_STORE_CTX_get_current_cert() returns the certificate in ctx which caused the error or NULL if no certificate is relevant.</p> <p>X509_STORE_CTX_get1_chain() returns a complete validate chain if a previous call to X509_verify_cert() is successful. If the call to X509_verify_cert() is not successful the returned chain may be incomplete or invalid. The returned chain persists after the ctx structure is freed, when it is no longer needed it should be free up using:</p> <pre><code>sk_X509_pop_free(chain, X509_free);\n</code></pre> <p>X509_verify_cert_error_string() returns a human readable error string for verification error n.</p>"},{"location":"man3/X509_STORE_CTX_get_error/#return-values","title":"RETURN VALUES","text":"<p>X509_STORE_CTX_get_error() returns X509_V_OK or an error code.</p> <p>X509_STORE_CTX_get_error_depth() returns a non-negative error depth.</p> <p>X509_STORE_CTX_get_current_cert() returns the cerificate which caused the error or NULL if no certificate is relevant to the error.</p> <p>X509_verify_cert_error_string() returns a human readable error string for verification error n.</p>"},{"location":"man3/X509_STORE_CTX_get_error/#error-codes","title":"ERROR CODES","text":"<p>A list of error codes and messages is shown below.  Some of the error codes are defined but currently never returned: these are described as \"unused\".</p> <ul> <li> <p>X509_V_OK: ok</p> <p>the operation was successful.</p> </li> <li> <p>X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: unable to get issuer certificate</p> <p>the issuer certificate could not be found: this occurs if the issuer certificate of an untrusted certificate cannot be found.</p> </li> <li> <p>X509_V_ERR_UNABLE_TO_GET_CRL: unable to get certificate CRL</p> <p>the CRL of a certificate could not be found.</p> </li> <li> <p>X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: unable to decrypt certificate's signature</p> <p>the certificate signature could not be decrypted. This means that the actual signature value could not be determined rather than it not matching the expected value, this is only meaningful for RSA keys.</p> </li> <li> <p>X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE: unable to decrypt CRL's signature</p> <p>the CRL signature could not be decrypted: this means that the actual signature value could not be determined rather than it not matching the expected value. Unused.</p> </li> <li> <p>X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: unable to decode issuer public key</p> <p>the public key in the certificate SubjectPublicKeyInfo could not be read.</p> </li> <li> <p>X509_V_ERR_CERT_SIGNATURE_FAILURE: certificate signature failure</p> <p>the signature of the certificate is invalid.</p> </li> <li> <p>X509_V_ERR_CRL_SIGNATURE_FAILURE: CRL signature failure</p> <p>the signature of the certificate is invalid.</p> </li> <li> <p>X509_V_ERR_CERT_NOT_YET_VALID: certificate is not yet valid</p> <p>the certificate is not yet valid: the notBefore date is after the current time.</p> </li> <li> <p>X509_V_ERR_CERT_HAS_EXPIRED: certificate has expired</p> <p>the certificate has expired: that is the notAfter date is before the current time.</p> </li> <li> <p>X509_V_ERR_CRL_NOT_YET_VALID: CRL is not yet valid</p> <p>the CRL is not yet valid.</p> </li> <li> <p>X509_V_ERR_CRL_HAS_EXPIRED: CRL has expired</p> <p>the CRL has expired.</p> </li> <li> <p>X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: format error in certificate's notBefore field</p> <p>the certificate notBefore field contains an invalid time.</p> </li> <li> <p>X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: format error in certificate's notAfter field</p> <p>the certificate notAfter field contains an invalid time.</p> </li> <li> <p>X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: format error in CRL's lastUpdate field</p> <p>the CRL lastUpdate field contains an invalid time.</p> </li> <li> <p>X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD: format error in CRL's nextUpdate field</p> <p>the CRL nextUpdate field contains an invalid time.</p> </li> <li> <p>X509_V_ERR_OUT_OF_MEM: out of memory</p> <p>an error occurred trying to allocate memory. This should never happen.</p> </li> <li> <p>X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: self signed certificate</p> <p>the passed certificate is self signed and the same certificate cannot be found in the list of trusted certificates.</p> </li> <li> <p>X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN: self signed certificate in certificate chain</p> <p>the certificate chain could be built up using the untrusted certificates but the root could not be found locally.</p> </li> <li> <p>X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: unable to get local issuer certificate</p> <p>the issuer certificate of a locally looked up certificate could not be found. This normally means the list of trusted certificates is not complete.</p> </li> <li> <p>X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: unable to verify the first certificate</p> <p>no signatures could be verified because the chain contains only one certificate and it is not self signed.</p> </li> <li> <p>X509_V_ERR_CERT_CHAIN_TOO_LONG: certificate chain too long</p> <p>the certificate chain length is greater than the supplied maximum depth. Unused.</p> </li> <li> <p>X509_V_ERR_CERT_REVOKED: certificate revoked</p> <p>the certificate has been revoked.</p> </li> <li> <p>X509_V_ERR_INVALID_CA: invalid CA certificate</p> <p>a CA certificate is invalid. Either it is not a CA or its extensions are not consistent with the supplied purpose.</p> </li> <li> <p>X509_V_ERR_PATH_LENGTH_EXCEEDED: path length constraint exceeded</p> <p>the basicConstraints pathlength parameter has been exceeded.</p> </li> <li> <p>X509_V_ERR_INVALID_PURPOSE: unsupported certificate purpose</p> <p>the supplied certificate cannot be used for the specified purpose.</p> </li> <li> <p>X509_V_ERR_CERT_UNTRUSTED: certificate not trusted</p> <p>the root CA is not marked as trusted for the specified purpose.</p> </li> <li> <p>X509_V_ERR_CERT_REJECTED: certificate rejected</p> <p>the root CA is marked to reject the specified purpose.</p> </li> <li> <p>X509_V_ERR_SUBJECT_ISSUER_MISMATCH: subject issuer mismatch</p> <p>the current candidate issuer certificate was rejected because its subject name did not match the issuer name of the current certificate. This is only set if issuer check debugging is enabled it is used for status notification and is not in itself an error.</p> </li> <li> <p>X509_V_ERR_AKID_SKID_MISMATCH: authority and subject key identifier mismatch</p> <p>the current candidate issuer certificate was rejected because its subject key identifier was present and did not match the authority key identifier current certificate. This is only set if issuer check debugging is enabled it is used for status notification and is not in itself an error.</p> </li> <li> <p>X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH: authority and issuer serial number mismatch</p> <p>the current candidate issuer certificate was rejected because its issuer name and serial number was present and did not match the authority key identifier of the current certificate. This is only set if issuer check debugging is enabled it is used for status notification and is not in itself an error.</p> </li> <li> <p>X509_V_ERR_KEYUSAGE_NO_CERTSIGN:key usage does not include certificate signing</p> <p>the current candidate issuer certificate was rejected because its keyUsage extension does not permit certificate signing. This is only set if issuer check debugging is enabled it is used for status notification and is not in itself an error.</p> </li> <li> <p>X509_V_ERR_INVALID_EXTENSION: invalid or inconsistent certificate extension</p> <p>A certificate extension had an invalid value (for example an incorrect encoding) or some value inconsistent with other extensions.</p> </li> <li> <p>X509_V_ERR_INVALID_POLICY_EXTENSION: invalid or inconsistent certificate policy extension</p> <p>A certificate policies extension had an invalid value (for example an incorrect encoding) or some value inconsistent with other extensions. This error only occurs if policy processing is enabled.</p> </li> <li> <p>X509_V_ERR_NO_EXPLICIT_POLICY: no explicit policy</p> <p>The verification flags were set to require and explicit policy but none was present.</p> </li> <li> <p>X509_V_ERR_DIFFERENT_CRL_SCOPE: Different CRL scope</p> <p>The only CRLs that could be found did not match the scope of the certificate.</p> </li> <li> <p>X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE: Unsupported extension feature</p> <p>Some feature of a certificate extension is not supported. Unused.</p> </li> <li> <p>X509_V_ERR_PERMITTED_VIOLATION: permitted subtree violation</p> <p>A name constraint violation occurred in the permitted subtrees.</p> </li> <li> <p>X509_V_ERR_EXCLUDED_VIOLATION: excluded subtree violation</p> <p>A name constraint violation occurred in the excluded subtrees.</p> </li> <li> <p>X509_V_ERR_SUBTREE_MINMAX: name constraints minimum and maximum not supported</p> <p>A certificate name constraints extension included a minimum or maximum field: this is not supported.</p> </li> <li> <p>X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE: unsupported name constraint type</p> <p>An unsupported name constraint type was encountered. OpenSSL currently only supports directory name, DNS name, email and URI types.</p> </li> <li> <p>X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX: unsupported or invalid name constraint syntax</p> <p>The format of the name constraint is not recognised: for example an email address format of a form not mentioned in RFC3280. This could be caused by a garbage extension or some new feature not currently supported.</p> </li> <li> <p>X509_V_ERR_CRL_PATH_VALIDATION_ERROR: CRL path validation error</p> <p>An error occurred when attempting to verify the CRL path. This error can only happen if extended CRL checking is enabled.</p> </li> <li> <p>X509_V_ERR_APPLICATION_VERIFICATION: application verification failure</p> <p>an application specific error. This will never be returned unless explicitly set by an application.</p> </li> </ul>"},{"location":"man3/X509_STORE_CTX_get_error/#notes","title":"NOTES","text":"<p>The above functions should be used instead of directly referencing the fields in the X509_VERIFY_CTX structure.</p> <p>In versions of OpenSSL before 1.0 the current certificate returned by X509_STORE_CTX_get_current_cert() was never NULL. Applications should check the return value before printing out any debugging information relating to the current certificate.</p> <p>If an unrecognised error code is passed to X509_verify_cert_error_string() the numerical value of the unknown code is returned in a static buffer. This is not thread safe but will never happen unless an invalid code is passed.</p>"},{"location":"man3/X509_STORE_CTX_get_error/#see-also","title":"SEE ALSO","text":"<p>X509_verify_cert(3)</p>"},{"location":"man3/X509_STORE_CTX_get_error/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/X509_STORE_CTX_get_ex_new_index/","title":"X509_STORE_CTX_get_ex_new_index","text":""},{"location":"man3/X509_STORE_CTX_get_ex_new_index/#name","title":"NAME","text":"<p>X509_STORE_CTX_get_ex_new_index, X509_STORE_CTX_set_ex_data, X509_STORE_CTX_get_ex_data - add application specific data to X509_STORE_CTX structures</p>"},{"location":"man3/X509_STORE_CTX_get_ex_new_index/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509_vfy.h&gt;\n\nint X509_STORE_CTX_get_ex_new_index(long argl, void *argp,\n               CRYPTO_EX_new *new_func,\n               CRYPTO_EX_dup *dup_func,\n               CRYPTO_EX_free *free_func);\n\nint X509_STORE_CTX_set_ex_data(X509_STORE_CTX *d, int idx, void *arg);\n\nvoid *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *d, int idx);\n</code></pre>"},{"location":"man3/X509_STORE_CTX_get_ex_new_index/#description","title":"DESCRIPTION","text":"<p>These functions handle application specific data in X509_STORE_CTX structures. Their usage is identical to that of RSA_get_ex_new_index(), RSA_set_ex_data() and RSA_get_ex_data() as described in RSA_get_ex_new_index(3).</p>"},{"location":"man3/X509_STORE_CTX_get_ex_new_index/#notes","title":"NOTES","text":"<p>This mechanism is used internally by the ssl library to store the SSL structure associated with a verification operation in an X509_STORE_CTX structure. </p>"},{"location":"man3/X509_STORE_CTX_get_ex_new_index/#see-also","title":"SEE ALSO","text":"<p>RSA_get_ex_new_index(3)</p>"},{"location":"man3/X509_STORE_CTX_get_ex_new_index/#history","title":"HISTORY","text":"<p>X509_STORE_CTX_get_ex_new_index(), X509_STORE_CTX_set_ex_data() and X509_STORE_CTX_get_ex_data() are available since OpenSSL 0.9.5.</p>"},{"location":"man3/X509_STORE_CTX_new/","title":"X509_STORE_CTX_new","text":""},{"location":"man3/X509_STORE_CTX_new/#name","title":"NAME","text":"<p>X509_STORE_CTX_new, X509_STORE_CTX_cleanup, X509_STORE_CTX_free, X509_STORE_CTX_init, X509_STORE_CTX_trusted_stack, X509_STORE_CTX_set_cert, X509_STORE_CTX_set_chain, X509_STORE_CTX_set0_crls, X509_STORE_CTX_get0_param, X509_STORE_CTX_set0_param, X509_STORE_CTX_set_default - X509_STORE_CTX initialisation</p>"},{"location":"man3/X509_STORE_CTX_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509_vfy.h&gt;\n\nX509_STORE_CTX *X509_STORE_CTX_new(void);\nvoid X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx);\nvoid X509_STORE_CTX_free(X509_STORE_CTX *ctx);\n\nint X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store,\n                        X509 *x509, STACK_OF(X509) *chain);\n\nvoid X509_STORE_CTX_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk);\n\nvoid   X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx,X509 *x);\nvoid   X509_STORE_CTX_set_chain(X509_STORE_CTX *ctx,STACK_OF(X509) *sk);\nvoid   X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx, STACK_OF(X509_CRL) *sk);\n\nX509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx);\nvoid X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param);\nint X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name);\n</code></pre>"},{"location":"man3/X509_STORE_CTX_new/#description","title":"DESCRIPTION","text":"<p>These functions initialise an X509_STORE_CTX structure for subsequent use by X509_verify_cert().</p> <p>X509_STORE_CTX_new() returns a newly initialised X509_STORE_CTX structure.</p> <p>X509_STORE_CTX_cleanup() internally cleans up an X509_STORE_CTX structure. The context can then be reused with an new call to X509_STORE_CTX_init().</p> <p>X509_STORE_CTX_free() completely frees up ctx. After this call ctx is no longer valid.</p> <p>X509_STORE_CTX_init() sets up ctx for a subsequent verification operation. It must be called before each call to X509_verify_cert(), i.e. a ctx is only good for one call to X509_verify_cert(); if you want to verify a second certificate with the same ctx then you must call X509_STORE_CTX_cleanup() and then X509_STORE_CTX_init() again before the second call to X509_verify_cert(). The trusted certificate store is set to store, the end entity certificate to be verified is set to x509 and a set of additional certificates (which will be untrusted but may be used to build the chain) in chain. Any or all of the store, x509 and chain parameters can be NULL.</p> <p>X509_STORE_CTX_trusted_stack() sets the set of trusted certificates of ctx to sk. This is an alternative way of specifying trusted certificates  instead of using an X509_STORE.</p> <p>X509_STORE_CTX_set_cert() sets the certificate to be vertified in ctx to x.</p> <p>X509_STORE_CTX_set_chain() sets the additional certificate chain used by ctx to sk.</p> <p>X509_STORE_CTX_set0_crls() sets a set of CRLs to use to aid certificate verification to sk. These CRLs will only be used if CRL verification is enabled in the associated X509_VERIFY_PARAM structure. This might be used where additional \"useful\" CRLs are supplied as part of a protocol, for example in a PKCS#7 structure.</p> <p>X509_VERIFY_PARAM *X509_STORE_CTX_get0_param() retrieves an intenal pointer to the verification parameters associated with ctx.</p> <p>X509_STORE_CTX_set0_param() sets the intenal verification parameter pointer to param. After this call param should not be used.</p> <p>X509_STORE_CTX_set_default() looks up and sets the default verification method to name. This uses the function X509_VERIFY_PARAM_lookup() to find an appropriate set of parameters from name.</p>"},{"location":"man3/X509_STORE_CTX_new/#notes","title":"NOTES","text":"<p>The certificates and CRLs in a store are used internally and should not be freed up until after the associated X509_STORE_CTX is freed. Legacy applications might implicitly use an X509_STORE_CTX like this:</p> <pre><code>X509_STORE_CTX ctx;\nX509_STORE_CTX_init(&amp;ctx, store, cert, chain);\n</code></pre> <p>this is not recommended in new applications they should instead do:</p> <pre><code>X509_STORE_CTX *ctx;\nctx = X509_STORE_CTX_new();\nif (ctx == NULL)\n      /* Bad error */\nX509_STORE_CTX_init(ctx, store, cert, chain);\n</code></pre>"},{"location":"man3/X509_STORE_CTX_new/#bugs","title":"BUGS","text":"<p>The certificates and CRLs in a context are used internally and should not be freed up until after the associated X509_STORE_CTX is freed. Copies should be made or reference counts increased instead.</p>"},{"location":"man3/X509_STORE_CTX_new/#return-values","title":"RETURN VALUES","text":"<p>X509_STORE_CTX_new() returns an newly allocates context or NULL is an error occurred.</p> <p>X509_STORE_CTX_init() returns 1 for success or 0 if an error occurred.</p> <p>X509_STORE_CTX_get0_param() returns a pointer to an X509_VERIFY_PARAM structure or NULL if an error occurred.</p> <p>X509_STORE_CTX_cleanup(), X509_STORE_CTX_free(), X509_STORE_CTX_trusted_stack(), X509_STORE_CTX_set_cert(), X509_STORE_CTX_set_chain(), X509_STORE_CTX_set0_crls() and X509_STORE_CTX_set0_param() do not return values.</p> <p>X509_STORE_CTX_set_default() returns 1 for success or 0 if an error occurred.</p>"},{"location":"man3/X509_STORE_CTX_new/#see-also","title":"SEE ALSO","text":"<p>X509_verify_cert(3) X509_VERIFY_PARAM_set_flags(3)</p>"},{"location":"man3/X509_STORE_CTX_new/#history","title":"HISTORY","text":"<p>X509_STORE_CTX_set0_crls() was first added to OpenSSL 1.0.0</p>"},{"location":"man3/X509_STORE_CTX_set_verify_cb/","title":"X509_STORE_CTX_set_verify_cb","text":""},{"location":"man3/X509_STORE_CTX_set_verify_cb/#name","title":"NAME","text":"<p>X509_STORE_CTX_set_verify_cb - set verification callback</p>"},{"location":"man3/X509_STORE_CTX_set_verify_cb/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509_vfy.h&gt;\n\nvoid X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,\n                               int (*verify_cb)(int ok, X509_STORE_CTX *ctx));\n</code></pre>"},{"location":"man3/X509_STORE_CTX_set_verify_cb/#description","title":"DESCRIPTION","text":"<p>X509_STORE_CTX_set_verify_cb() sets the verification callback of ctx to verify_cb overwriting any existing callback.</p> <p>The verification callback can be used to customise the operation of certificate verification, either by overriding error conditions or logging errors for debugging purposes.</p> <p>However a verification callback is not essential and the default operation is often sufficient.</p> <p>The ok parameter to the callback indicates the value the callback should return to retain the default behaviour. If it is zero then and error condition is indicated. If it is 1 then no error occurred. If the flag X509_V_FLAG_NOTIFY_POLICY is set then ok is set to 2 to indicate the policy checking is complete.</p> <p>The ctx parameter to the callback is the X509_STORE_CTX structure that is performing the verification operation. A callback can examine this structure and receive additional information about the error, for example by calling X509_STORE_CTX_get_current_cert(). Additional application data can be passed to the callback via the ex_data mechanism.</p>"},{"location":"man3/X509_STORE_CTX_set_verify_cb/#warning","title":"WARNING","text":"<p>In general a verification callback should NOT unconditionally return 1 in all circumstances because this will allow verification to succeed no matter what the error. This effectively removes all security from the application because any certificate (including untrusted generated ones) will be accepted.</p>"},{"location":"man3/X509_STORE_CTX_set_verify_cb/#notes","title":"NOTES","text":"<p>The verification callback can be set and inherited from the parent structure performing the operation. In some cases (such as S/MIME verification) the X509_STORE_CTX structure is created and destroyed internally and the only way to set a custom verification callback is by inheriting it from the associated X509_STORE.</p>"},{"location":"man3/X509_STORE_CTX_set_verify_cb/#return-values","title":"RETURN VALUES","text":"<p>X509_STORE_CTX_set_verify_cb() does not return a value.</p>"},{"location":"man3/X509_STORE_CTX_set_verify_cb/#examples","title":"EXAMPLES","text":"<p>Default callback operation:</p> <pre><code>int verify_callback(int ok, X509_STORE_CTX *ctx)\n       {\n       return ok;\n       }\n</code></pre> <p>Simple example, suppose a certificate in the chain is expired and we wish to continue after this error:</p> <pre><code>int verify_callback(int ok, X509_STORE_CTX *ctx)\n       {\n       /* Tolerate certificate expiration */\n       if (X509_STORE_CTX_get_error(ctx) == X509_V_ERR_CERT_HAS_EXPIRED)\n                       return 1;\n       /* Otherwise don't override */\n       return ok;\n       }\n</code></pre> <p>More complex example, we don't wish to continue after any certificate has expired just one specific case:</p> <pre><code>int verify_callback(int ok, X509_STORE_CTX *ctx)\n       {\n       int err = X509_STORE_CTX_get_error(ctx);\n       X509 *err_cert = X509_STORE_CTX_get_current_cert(ctx);\n       if (err == X509_V_ERR_CERT_HAS_EXPIRED)\n               {\n               if (check_is_acceptable_expired_cert(err_cert)\n                       return 1;\n               }\n       return ok;\n       }\n</code></pre> <p>Full featured logging callback. In this case the bio_err is assumed to be a global logging BIO, an alternative would to store a BIO in ctx using ex_data.</p> <pre><code>int verify_callback(int ok, X509_STORE_CTX *ctx)\n       {\n       X509 *err_cert;\n       int err,depth;\n\n       err_cert = X509_STORE_CTX_get_current_cert(ctx);\n       err =   X509_STORE_CTX_get_error(ctx);\n       depth = X509_STORE_CTX_get_error_depth(ctx);\n\n       BIO_printf(bio_err,\"depth=%d \",depth);\n       if (err_cert)\n               {\n               X509_NAME_print_ex(bio_err, X509_get_subject_name(err_cert),\n                                       0, XN_FLAG_ONELINE);\n               BIO_puts(bio_err, \"\\n\");\n               }\n       else\n               BIO_puts(bio_err, \"&lt;no cert&gt;\\n\");\n       if (!ok)\n               BIO_printf(bio_err,\"verify error:num=%d:%s\\n\",err,\n                       X509_verify_cert_error_string(err));\n       switch (err)\n               {\n       case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n               BIO_puts(bio_err,\"issuer= \");\n               X509_NAME_print_ex(bio_err, X509_get_issuer_name(err_cert),\n                                       0, XN_FLAG_ONELINE);\n               BIO_puts(bio_err, \"\\n\");\n               break;\n       case X509_V_ERR_CERT_NOT_YET_VALID:\n       case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\n               BIO_printf(bio_err,\"notBefore=\");\n               ASN1_TIME_print(bio_err,X509_get_notBefore(err_cert));\n               BIO_printf(bio_err,\"\\n\");\n               break;\n       case X509_V_ERR_CERT_HAS_EXPIRED:\n       case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\n               BIO_printf(bio_err,\"notAfter=\");\n               ASN1_TIME_print(bio_err,X509_get_notAfter(err_cert));\n               BIO_printf(bio_err,\"\\n\");\n               break;\n       case X509_V_ERR_NO_EXPLICIT_POLICY:\n               policies_print(bio_err, ctx);\n               break;\n               }\n       if (err == X509_V_OK &amp;&amp; ok == 2)\n               /* print out policies */\n\n       BIO_printf(bio_err,\"verify return:%d\\n\",ok);\n       return(ok);\n       }\n</code></pre>"},{"location":"man3/X509_STORE_CTX_set_verify_cb/#see-also","title":"SEE ALSO","text":"<p>X509_STORE_CTX_get_error(3) X509_STORE_set_verify_cb_func(3) X509_STORE_CTX_get_ex_new_index(3)</p>"},{"location":"man3/X509_STORE_CTX_set_verify_cb/#history","title":"HISTORY","text":"<p>X509_STORE_CTX_set_verify_cb() is available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/X509_STORE_set_verify_cb_func/","title":"X509_STORE_set_verify_cb_func","text":""},{"location":"man3/X509_STORE_set_verify_cb_func/#name","title":"NAME","text":"<p>X509_STORE_set_verify_cb_func, X509_STORE_set_verify_cb - set verification callback</p>"},{"location":"man3/X509_STORE_set_verify_cb_func/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509_vfy.h&gt;\n\nvoid X509_STORE_set_verify_cb(X509_STORE *st,\n                               int (*verify_cb)(int ok, X509_STORE_CTX *ctx));\n\nvoid X509_STORE_set_verify_cb_func(X509_STORE *st,\n                               int (*verify_cb)(int ok, X509_STORE_CTX *ctx));\n</code></pre>"},{"location":"man3/X509_STORE_set_verify_cb_func/#description","title":"DESCRIPTION","text":"<p>X509_STORE_set_verify_cb() sets the verification callback of ctx to verify_cb overwriting any existing callback.</p> <p>X509_STORE_set_verify_cb_func() also sets the verification callback but it is implemented as a macro.</p>"},{"location":"man3/X509_STORE_set_verify_cb_func/#notes","title":"NOTES","text":"<p>The verification callback from an X509_STORE is inherited by  the corresponding X509_STORE_CTX structure when it is initialized. This can be used to set the verification callback when the X509_STORE_CTX is  otherwise inaccessible (for example during S/MIME verification).</p>"},{"location":"man3/X509_STORE_set_verify_cb_func/#bugs","title":"BUGS","text":"<p>The macro version of this function was the only one available before  OpenSSL 1.0.0.</p>"},{"location":"man3/X509_STORE_set_verify_cb_func/#return-values","title":"RETURN VALUES","text":"<p>X509_STORE_set_verify_cb() and X509_STORE_set_verify_cb_func() do not return a value.</p>"},{"location":"man3/X509_STORE_set_verify_cb_func/#see-also","title":"SEE ALSO","text":"<p>X509_STORE_CTX_set_verify_cb(3) CMS_verify(3)</p>"},{"location":"man3/X509_STORE_set_verify_cb_func/#history","title":"HISTORY","text":"<p>X509_STORE_set_verify_cb_func() is available in all versions of SSLeay and OpenSSL.</p> <p>X509_STORE_set_verify_cb() was added to OpenSSL 1.0.0.</p>"},{"location":"man3/X509_VERIFY_PARAM_set_flags/","title":"X509_VERIFY_PARAM_set_flags","text":""},{"location":"man3/X509_VERIFY_PARAM_set_flags/#name","title":"NAME","text":"<p>X509_VERIFY_PARAM_set_flags, X509_VERIFY_PARAM_clear_flags, X509_VERIFY_PARAM_get_flags, X509_VERIFY_PARAM_set_purpose, X509_VERIFY_PARAM_set_trust, X509_VERIFY_PARAM_set_depth, X509_VERIFY_PARAM_get_depth, X509_VERIFY_PARAM_set_time, X509_VERIFY_PARAM_add0_policy, X509_VERIFY_PARAM_set1_policies, X509_VERIFY_PARAM_set1_host, X509_VERIFY_PARAM_add1_host, X509_VERIFY_PARAM_set_hostflags, X509_VERIFY_PARAM_get0_peername, X509_VERIFY_PARAM_set1_email, X509_VERIFY_PARAM_set1_ip, X509_VERIFY_PARAM_set1_ip_asc - X509 verification parameters</p>"},{"location":"man3/X509_VERIFY_PARAM_set_flags/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509_vfy.h&gt;\n\nint X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param, unsigned long flags);\nint X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *param,\n                                                       unsigned long flags);\nunsigned long X509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM *param);\n\nint X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param, int purpose);\nint X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param, int trust);\n\nvoid X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param, time_t t);\n\nint X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param,\n                                               ASN1_OBJECT *policy);\nint X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *param, \n                                       STACK_OF(ASN1_OBJECT) *policies);\n\nvoid X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param, int depth);\nint X509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *param);\n\nint X509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *param,\n                                const char *name, size_t namelen);\nint X509_VERIFY_PARAM_add1_host(X509_VERIFY_PARAM *param,\n                                const char *name, size_t namelen);\nvoid X509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM *param,\n                                     unsigned int flags);\nchar *X509_VERIFY_PARAM_get0_peername(X509_VERIFY_PARAM *param);\nint X509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *param,\n                                const char *email, size_t emaillen);\nint X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *param,\n                              const unsigned char *ip, size_t iplen);\nint X509_VERIFY_PARAM_set1_ip_asc(X509_VERIFY_PARAM *param, const char *ipasc);\n</code></pre>"},{"location":"man3/X509_VERIFY_PARAM_set_flags/#description","title":"DESCRIPTION","text":"<p>These functions manipulate the X509_VERIFY_PARAM structure associated with a certificate verification operation. </p> <p>The X509_VERIFY_PARAM_set_flags() function sets the flags in param by oring it with flags. See the VERIFICATION FLAGS section for a complete description of values the flags parameter can take.</p> <p>X509_VERIFY_PARAM_get_flags() returns the flags in param.</p> <p>X509_VERIFY_PARAM_clear_flags() clears the flags flags in param.</p> <p>X509_VERIFY_PARAM_set_purpose() sets the verification purpose in param to purpose. This determines the acceptable purpose of the certificate chain, for example SSL client or SSL server.</p> <p>X509_VERIFY_PARAM_set_trust() sets the trust setting in param to  trust.</p> <p>X509_VERIFY_PARAM_set_time() sets the verification time in param to t. Normally the current time is used.</p> <p>X509_VERIFY_PARAM_add0_policy() enables policy checking (it is disabled by default) and adds policy to the acceptable policy set.</p> <p>X509_VERIFY_PARAM_set1_policies() enables policy checking (it is disabled by default) and sets the acceptable policy set to policies. Any existing policy set is cleared. The policies parameter can be NULL to clear an existing policy set.</p> <p>X509_VERIFY_PARAM_set_depth() sets the maximum verification depth to depth. That is the maximum number of untrusted CA certificates that can appear in a chain.</p> <p>X509_VERIFY_PARAM_set1_host() sets the expected DNS hostname to name clearing any previously specified host name or names.  If name is NULL, or empty the list of hostnames is cleared, and name checks are not performed on the peer certificate.  If name is NUL-terminated, namelen may be zero, otherwise namelen must be set to the length of name.  When a hostname is specified, certificate verification automatically invokes X509_check_host(3) with flags equal to the flags argument given to X509_VERIFY_PARAM_set_hostflags() (default zero).  Applications are strongly advised to use this interface in preference to explicitly calling X509_check_host(3), hostname checks are out of scope with the DANE-EE(3) certificate usage, and the internal check will be suppressed as appropriate when DANE support is added to OpenSSL.</p> <p>X509_VERIFY_PARAM_add1_host() adds name as an additional reference identifer that can match the peer's certificate.  Any previous names set via X509_VERIFY_PARAM_set1_host() or X509_VERIFY_PARAM_add1_host() are retained, no change is made if name is NULL or empty.  When multiple names are configured, the peer is considered verified when any name matches.</p> <p>X509_VERIFY_PARAM_get0_peername() returns the DNS hostname or subject CommonName from the peer certificate that matched one of the reference identifiers.  When wildcard matching is not disabled, or when a reference identifier specifies a parent domain (starts with \".\") rather than a hostname, the peer name may be a wildcard name or a sub-domain of the reference identifier respectively.  The return string is allocated by the library and is no longer valid once the associated param argument is freed.  Applications must not free the return value.</p> <p>X509_VERIFY_PARAM_set1_email() sets the expected RFC822 email address to email.  If email is NUL-terminated, emaillen may be zero, otherwise emaillen must be set to the length of email.  When an email address is specified, certificate verification automatically invokes X509_check_email(3).</p> <p>X509_VERIFY_PARAM_set1_ip() sets the expected IP address to ip. The ip argument is in binary format, in network byte-order and iplen must be set to 4 for IPv4 and 16 for IPv6.  When an IP address is specified, certificate verification automatically invokes X509_check_ip(3).</p> <p>X509_VERIFY_PARAM_set1_ip_asc() sets the expected IP address to ipasc.  The ipasc argument is a NUL-terminal ASCII string: dotted decimal quad for IPv4 and colon-separated hexadecimal for IPv6.  The condensed \"::\" notation is supported for IPv6 addresses.</p>"},{"location":"man3/X509_VERIFY_PARAM_set_flags/#return-values","title":"RETURN VALUES","text":"<p>X509_VERIFY_PARAM_set_flags(), X509_VERIFY_PARAM_clear_flags(), X509_VERIFY_PARAM_set_purpose(), X509_VERIFY_PARAM_set_trust(), X509_VERIFY_PARAM_add0_policy() X509_VERIFY_PARAM_set1_policies(), X509_VERIFY_PARAM_set1_host(), X509_VERIFY_PARAM_set_hostflags(), X509_VERIFY_PARAM_set1_email(), X509_VERIFY_PARAM_set1_ip() and X509_VERIFY_PARAM_set1_ip_asc() return 1 for success and 0 for failure.</p> <p>X509_VERIFY_PARAM_get_flags() returns the current verification flags.</p> <p>X509_VERIFY_PARAM_set_time() and X509_VERIFY_PARAM_set_depth() do not return values.</p> <p>X509_VERIFY_PARAM_get_depth() returns the current verification depth.</p>"},{"location":"man3/X509_VERIFY_PARAM_set_flags/#verification-flags","title":"VERIFICATION FLAGS","text":"<p>The verification flags consists of zero or more of the following flags ored together.</p> <p>X509_V_FLAG_CRL_CHECK enables CRL checking for the certificate chain leaf certificate. An error occurs if a suitable CRL cannot be found. </p> <p>X509_V_FLAG_CRL_CHECK_ALL enables CRL checking for the entire certificate chain.</p> <p>X509_V_FLAG_IGNORE_CRITICAL disabled critical extension checking. By default any unhandled critical extensions in certificates or (if checked) CRLs results in a fatal error. If this flag is set unhandled critical extensions are ignored. WARNING setting this option for anything other than debugging purposes can be a security risk. Finer control over which extensions are supported can be performed in the verification callback.</p> <p>THe X509_V_FLAG_X509_STRICT flag disables workarounds for some broken certificates and makes the verification strictly apply X509 rules.</p> <p>X509_V_FLAG_ALLOW_PROXY_CERTS enables proxy certificate verification.</p> <p>X509_V_FLAG_POLICY_CHECK enables certificate policy checking, by default no policy checking is peformed. Additional information is sent to the  verification callback relating to policy checking.</p> <p>X509_V_FLAG_EXPLICIT_POLICY, X509_V_FLAG_INHIBIT_ANY and X509_V_FLAG_INHIBIT_MAP set the require explicit policy, inhibit any policy and inhibit policy mapping flags respectively as defined in RFC3280. Policy checking is automatically enabled if any of these flags are set.</p> <p>If X509_V_FLAG_NOTIFY_POLICY is set and the policy checking is successful a special status code is set to the verification callback. This permits it to examine the valid policy tree and perform additional checks or simply log it for debugging purposes.</p> <p>By default some additional features such as indirect CRLs and CRLs signed by different keys are disabled. If X509_V_FLAG_EXTENDED_CRL_SUPPORT is set they are enabled.</p> <p>If X509_V_FLAG_USE_DELTAS ise set delta CRLs (if present) are used to determine certificate status. If not set deltas are ignored.</p> <p>X509_V_FLAG_CHECK_SS_SIGNATURE enables checking of the root CA self signed cerificate signature. By default this check is disabled because it doesn't add any additional security but in some cases applications might want to check the signature anyway. A side effect of not checking the root CA signature is that disabled or unsupported message digests on the root CA are not treated as fatal errors.</p> <p>The X509_V_FLAG_CB_ISSUER_CHECK flag enables debugging of certificate issuer checks. It is not needed unless you are logging certificate verification. If this flag is set then additional status codes will be sent to the verification callback and it must be prepared to handle such cases without assuming they are hard errors.</p> <p>The X509_V_FLAG_NO_ALT_CHAINS flag suppresses checking for alternative chains. By default, when building a certificate chain, if the first certificate chain found is not trusted, then OpenSSL will continue to check to see if an alternative chain can be found that is trusted. With this flag set the behaviour will match that of OpenSSL versions prior to 1.0.2b.</p> <p>The X509_V_FLAG_TRUSTED_FIRST flag causes chain construction to look for issuers in the trust store before looking at the untrusted certificates provided as part of the the peer chain. Though it is not on by default in OpenSSL 1.0.2, applications should generally set this flag. Local issuer certificates are often more likely to satisfy local security requirements and lead to a locally trusted root. This is especially important When some certificates in the trust store have explicit trust settings (see \"TRUST SETTINGS\" in x509(1)).</p> <p>The X509_V_FLAG_PARTIAL_CHAIN flag causes intermediate certificates in the trust store to be treated as trust-anchors, in the same way as the self-signed root CA certificates. This makes it possible to trust certificates issued by an intermediate CA without having to trust its ancestor root CA. With OpenSSL 1.0.2, chain construction continues as long as there are additional trusted issuers in the trust store, and the last trusted issuer becomes the trust-anchor. Thus, even when an intermediate certificate is found in the trust store, the verified chain passed to callbacks may still be anchored by a root CA.</p>"},{"location":"man3/X509_VERIFY_PARAM_set_flags/#notes","title":"NOTES","text":"<p>The above functions should be used to manipulate verification parameters instead of legacy functions which work in specific structures such as X509_STORE_CTX_set_flags().</p>"},{"location":"man3/X509_VERIFY_PARAM_set_flags/#bugs","title":"BUGS","text":"<p>Delta CRL checking is currently primitive. Only a single delta can be used and (partly due to limitations of X509_STORE) constructed CRLs are not  maintained.</p> <p>If CRLs checking is enable CRLs are expected to be available in the corresponding X509_STORE structure. No attempt is made to download CRLs from the CRL distribution points extension.</p>"},{"location":"man3/X509_VERIFY_PARAM_set_flags/#example","title":"EXAMPLE","text":"<p>Enable CRL checking when performing certificate verification during SSL  connections associated with an SSL_CTX structure ctx:</p> <pre><code>X509_VERIFY_PARAM *param;\nparam = X509_VERIFY_PARAM_new();\nX509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\nSSL_CTX_set1_param(ctx, param);\nX509_VERIFY_PARAM_free(param);\n</code></pre>"},{"location":"man3/X509_VERIFY_PARAM_set_flags/#see-also","title":"SEE ALSO","text":"<p>X509_verify_cert(3), X509_check_host(3), X509_check_email(3), X509_check_ip(3), x509(1)</p>"},{"location":"man3/X509_VERIFY_PARAM_set_flags/#history","title":"HISTORY","text":"<p>The X509_V_FLAG_NO_ALT_CHAINS flag was added in OpenSSL 1.0.2b</p>"},{"location":"man3/X509_check_host/","title":"X509_check_host","text":""},{"location":"man3/X509_check_host/#name","title":"NAME","text":"<p>X509_check_host, X509_check_email, X509_check_ip, X509_check_ip_asc - X.509 certificate matching</p>"},{"location":"man3/X509_check_host/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nint X509_check_host(X509 *, const char *name, size_t namelen,\n                    unsigned int flags, char **peername);\nint X509_check_email(X509 *, const char *address, size_t addresslen,\n                     unsigned int flags);\nint X509_check_ip(X509 *, const unsigned char *address, size_t addresslen,\n                  unsigned int flags);\nint X509_check_ip_asc(X509 *, const char *address, unsigned int flags);\n</code></pre>"},{"location":"man3/X509_check_host/#description","title":"DESCRIPTION","text":"<p>The certificate matching functions are used to check whether a certificate matches a given host name, email address, or IP address. The validity of the certificate and its trust level has to be checked by other means.</p> <p>X509_check_host() checks if the certificate Subject Alternative Name (SAN) or Subject CommonName (CN) matches the specified host name, which must be encoded in the preferred name syntax described in section 3.5 of RFC 1034.  By default, wildcards are supported and they match  only in the left-most label; but they may match part of that label with an explicit prefix or suffix.  For example, by default, the host name \"www.example.com\" would match a certificate with a SAN or CN value of \"*.example.com\", \"w*.example.com\" or \"*w.example.com\".</p> <p>Per section 6.4.2 of RFC 6125, name values representing international domain names must be given in A-label form.  The namelen argument must be the number of characters in the name string or zero in which case the length is calculated with strlen(name).  When name starts with a dot (e.g \".example.com\"), it will be matched by a certificate valid for any sub-domain of name, (see also X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS below).</p> <p>When the certificate is matched, and peername is not NULL, a pointer to a copy of the matching SAN or CN from the peer certificate is stored at the address passed in peername.  The application is responsible for freeing the peername via OPENSSL_free() when it is no longer needed.</p> <p>X509_check_email() checks if the certificate matches the specified email address.  Only the mailbox syntax of RFC 822 is supported, comments are not allowed, and no attempt is made to normalize quoted characters.  The addresslen argument must be the number of characters in the address string or zero in which case the length is calculated with strlen(address).</p> <p>X509_check_ip() checks if the certificate matches a specified IPv4 or IPv6 address.  The address array is in binary format, in network byte order.  The length is either 4 (IPv4) or 16 (IPv6).  Only explicitly marked addresses in the certificates are considered; IP addresses stored in DNS names and Common Names are ignored.</p> <p>X509_check_ip_asc() is similar, except that the NUL-terminated string address is first converted to the internal representation.</p> <p>The flags argument is usually 0.  It can be the bitwise OR of the flags:</p> <ul> <li>X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT,</li> <li>X509_CHECK_FLAG_NO_WILDCARDS,</li> <li>X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS,</li> <li>X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS.</li> <li>X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS.</li> </ul> <p>The X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT flag causes the function to consider the subject DN even if the certificate contains at least one subject alternative name of the right type (DNS name or email address as appropriate); the default is to ignore the subject DN when at least one corresponding subject alternative names is present.</p> <p>If set, X509_CHECK_FLAG_NO_WILDCARDS disables wildcard expansion; this only applies to X509_check_host.</p> <p>If set, X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS suppresses support for \"*\" as wildcard pattern in labels that have a prefix or suffix, such as: \"www*\" or \"*www\"; this only aplies to X509_check_host.</p> <p>If set, X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS allows a \"*\" that constitutes the complete label of a DNS name (e.g. \"*.example.com\") to match more than one label in name; this flag only applies to X509_check_host.</p> <p>If set, X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS restricts name values which start with \".\", that would otherwise match any sub-domain in the peer certificate, to only match direct child sub-domains. Thus, for instance, with this flag set a name of \".example.com\" would match a peer certificate with a DNS name of \"www.example.com\", but would not match a peer certificate with a DNS name of \"www.sub.example.com\"; this flag only applies to X509_check_host.</p>"},{"location":"man3/X509_check_host/#return-values","title":"RETURN VALUES","text":"<p>The functions return 1 for a successful match, 0 for a failed match and -1 for an internal error: typically a memory allocation failure or an ASN.1 decoding error.</p> <p>All functions can also return -2 if the input is malformed. For example, X509_check_host() returns -2 if the provided name contains embedded NULs.</p>"},{"location":"man3/X509_check_host/#notes","title":"NOTES","text":"<p>Applications are encouraged to use X509_VERIFY_PARAM_set1_host() rather than explicitly calling X509_check_host(3). Host name checks are out of scope with the DANE-EE(3) certificate usage, and the internal checks will be suppressed as appropriate when DANE support is added to OpenSSL.</p>"},{"location":"man3/X509_check_host/#see-also","title":"SEE ALSO","text":"<p>SSL_get_verify_result(3), X509_VERIFY_PARAM_set1_host(3), X509_VERIFY_PARAM_add1_host(3), X509_VERIFY_PARAM_set1_email(3), X509_VERIFY_PARAM_set1_ip(3), X509_VERIFY_PARAM_set1_ipasc(3)</p>"},{"location":"man3/X509_check_host/#history","title":"HISTORY","text":"<p>These functions were added in OpenSSL 1.0.2.</p>"},{"location":"man3/X509_check_private_key/","title":"X509_check_private_key","text":""},{"location":"man3/X509_check_private_key/#name","title":"NAME","text":"<p>X509_check_private_key, X509_REQ_check_private_key - check the consistency of a private key with the public key in an X509 certificate or certificate request</p>"},{"location":"man3/X509_check_private_key/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nint X509_check_private_key(X509 *x, EVP_PKEY *k);\n\nint X509_REQ_check_private_key(X509_REQ *x, EVP_PKEY *k);\n</code></pre>"},{"location":"man3/X509_check_private_key/#description","title":"DESCRIPTION","text":"<p>X509_check_private_key() function checks the consistency of private key k with the public key in x.</p> <p>X509_REQ_check_private_key() is equivalent to X509_check_private_key() except that x represents a certificate request of structure X509_REQ.</p>"},{"location":"man3/X509_check_private_key/#return-value","title":"RETURN VALUE","text":"<p>X509_check_private_key() and X509_REQ_check_private_key() return 1 if the keys match each other, and 0 if not.</p> <p>If the key is invalid or an error occurred, the reason code can be obtained using ERR_get_error(3).</p>"},{"location":"man3/X509_check_private_key/#bugs","title":"BUGS","text":"<p>The check_private_key functions don't check if k itself is indeed a private key or not. It merely compares the public materials (e.g. exponent and modulus of an RSA key) and/or key parameters (e.g. EC params of an EC key) of a key pair. So if you pass a public key to these functions in k, it will return success.</p>"},{"location":"man3/X509_check_private_key/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3)</p>"},{"location":"man3/X509_check_private_key/#copyright","title":"COPYRIGHT","text":"<p>Copyright 2017 The OpenSSL Project Authors. All Rights Reserved.</p> <p>Licensed under the OpenSSL license (the \"License\").  You may not use this file except in compliance with the License.  You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html.</p>"},{"location":"man3/X509_cmp_time/","title":"X509_cmp_time","text":""},{"location":"man3/X509_cmp_time/#name","title":"NAME","text":"<p>X509_cmp_time - X509 time functions</p>"},{"location":"man3/X509_cmp_time/#synopsis","title":"SYNOPSIS","text":"<pre><code>X509_cmp_time(const ASN1_TIME *asn1_time, time_t *cmp_time);\n</code></pre>"},{"location":"man3/X509_cmp_time/#description","title":"DESCRIPTION","text":"<p>X509_cmp_time() compares the ASN1_TIME in asn1_time with the time in &lt;cmp_time&gt;.</p> <p>asn1_time must satisfy the ASN1_TIME format mandated by RFC 5280, i.e., its format must be either YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ.</p> <p>If cmp_time is NULL the current time is used.</p>"},{"location":"man3/X509_cmp_time/#bugs","title":"BUGS","text":"<p>Unlike many standard comparison functions, X509_cmp_time returns 0 on error.</p>"},{"location":"man3/X509_cmp_time/#return-values","title":"RETURN VALUES","text":"<p>X509_cmp_time() returns -1 if asn1_time is earlier than, or equal to, cmp_time, and 1 otherwise. It returns 0 on error.</p>"},{"location":"man3/X509_cmp_time/#copyright","title":"COPYRIGHT","text":"<p>Copyright 2017-2019 The OpenSSL Project Authors. All Rights Reserved.</p> <p>Licensed under the OpenSSL license (the \"License\").  You may not use this file except in compliance with the License.  You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html.</p>"},{"location":"man3/X509_new/","title":"X509_new","text":""},{"location":"man3/X509_new/#name","title":"NAME","text":"<p>X509_new, X509_free - X509 certificate ASN1 allocation functions</p>"},{"location":"man3/X509_new/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nX509 *X509_new(void);\nvoid X509_free(X509 *a);\n</code></pre>"},{"location":"man3/X509_new/#description","title":"DESCRIPTION","text":"<p>The X509 ASN1 allocation routines, allocate and free an X509 structure, which represents an X509 certificate.</p> <p>X509_new() allocates and initializes a X509 structure.</p> <p>X509_free() frees up the X509 structure a.</p>"},{"location":"man3/X509_new/#return-values","title":"RETURN VALUES","text":"<p>If the allocation fails, X509_new() returns NULL and sets an error code that can be obtained by ERR_get_error(3). Otherwise it returns a pointer to the newly allocated structure.</p> <p>X509_free() returns no value.</p>"},{"location":"man3/X509_new/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), d2i_X509(3)</p>"},{"location":"man3/X509_new/#history","title":"HISTORY","text":"<p>X509_new() and X509_free() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/X509_verify_cert/","title":"X509_verify_cert","text":""},{"location":"man3/X509_verify_cert/#name","title":"NAME","text":"<p>X509_verify_cert - discover and verify X509 certificte chain</p>"},{"location":"man3/X509_verify_cert/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nint X509_verify_cert(X509_STORE_CTX *ctx);\n</code></pre>"},{"location":"man3/X509_verify_cert/#description","title":"DESCRIPTION","text":"<p>The X509_verify_cert() function attempts to discover and validate a certificate chain based on parameters in ctx. A complete description of the process is contained in the verify(1) manual page.</p>"},{"location":"man3/X509_verify_cert/#return-values","title":"RETURN VALUES","text":"<p>If a complete chain can be built and validated this function returns 1, otherwise it return zero, in exceptional circumstances it can also return a negative code.</p> <p>If the function fails additional error information can be obtained by examining ctx using, for example X509_STORE_CTX_get_error().</p>"},{"location":"man3/X509_verify_cert/#notes","title":"NOTES","text":"<p>Applications rarely call this function directly but it is used by OpenSSL internally for certificate validation, in both the S/MIME and SSL/TLS code.</p> <p>A negative return value from X509_verify_cert() can occur if it is invoked incorrectly, such as with no certificate set in ctx, or when it is called twice in succession without reinitialising ctx for the second call. A negative return value can also happen due to internal resource problems or if a retry operation is requested during internal lookups (which never happens with standard lookup methods). Applications must check for &lt;= 0 return value on error.</p>"},{"location":"man3/X509_verify_cert/#bugs","title":"BUGS","text":"<p>This function uses the header x509.h as opposed to most chain verification functiosn which use x509_vfy.h.</p>"},{"location":"man3/X509_verify_cert/#see-also","title":"SEE ALSO","text":"<p>X509_STORE_CTX_get_error(3)</p>"},{"location":"man3/X509_verify_cert/#history","title":"HISTORY","text":"<p>X509_verify_cert() is available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/bio/","title":"bio","text":""},{"location":"man3/bio/#name","title":"NAME","text":"<p>bio - I/O abstraction</p>"},{"location":"man3/bio/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bio.h&gt;\n</code></pre> <p>TBA</p>"},{"location":"man3/bio/#description","title":"DESCRIPTION","text":"<p>A BIO is an I/O abstraction, it hides many of the underlying I/O details from an application. If an application uses a BIO for its I/O it can transparently handle SSL connections, unencrypted network connections and file I/O.</p> <p>There are two type of BIO, a source/sink BIO and a filter BIO.</p> <p>As its name implies a source/sink BIO is a source and/or sink of data, examples include a socket BIO and a file BIO.</p> <p>A filter BIO takes data from one BIO and passes it through to another, or the application. The data may be left unmodified (for example a message digest BIO) or translated (for example an encryption BIO). The effect of a filter BIO may change according to the I/O operation it is performing: for example an encryption BIO will encrypt data if it is being written to and decrypt data if it is being read from.</p> <p>BIOs can be joined together to form a chain (a single BIO is a chain with one component). A chain normally consist of one source/sink BIO and one or more filter BIOs. Data read from or written to the first BIO then traverses the chain to the end (normally a source/sink BIO).</p>"},{"location":"man3/bio/#see-also","title":"SEE ALSO","text":"<p>BIO_ctrl(3), BIO_f_base64(3), BIO_f_buffer(3), BIO_f_cipher(3), BIO_f_md(3), BIO_f_null(3), BIO_f_ssl(3), BIO_find_type(3), BIO_new(3), BIO_new_bio_pair(3), BIO_push(3), BIO_read(3), BIO_s_accept(3), BIO_s_bio(3), BIO_s_connect(3), BIO_s_fd(3), BIO_s_file(3), BIO_s_mem(3), BIO_s_null(3), BIO_s_socket(3), BIO_set_callback(3), BIO_should_retry(3)</p>"},{"location":"man3/blowfish/","title":"blowfish","text":""},{"location":"man3/blowfish/#name","title":"NAME","text":"<p>blowfish, BF_set_key, BF_encrypt, BF_decrypt, BF_ecb_encrypt, BF_cbc_encrypt, BF_cfb64_encrypt, BF_ofb64_encrypt, BF_options - Blowfish encryption</p>"},{"location":"man3/blowfish/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/blowfish.h&gt;\n\nvoid BF_set_key(BF_KEY *key, int len, const unsigned char *data);\n\nvoid BF_ecb_encrypt(const unsigned char *in, unsigned char *out,\n        BF_KEY *key, int enc);\nvoid BF_cbc_encrypt(const unsigned char *in, unsigned char *out,\n        long length, BF_KEY *schedule, unsigned char *ivec, int enc);\nvoid BF_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n        long length, BF_KEY *schedule, unsigned char *ivec, int *num,\n        int enc);\nvoid BF_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n        long length, BF_KEY *schedule, unsigned char *ivec, int *num);\nconst char *BF_options(void);\n\nvoid BF_encrypt(BF_LONG *data,const BF_KEY *key);\nvoid BF_decrypt(BF_LONG *data,const BF_KEY *key);\n</code></pre>"},{"location":"man3/blowfish/#description","title":"DESCRIPTION","text":"<p>This library implements the Blowfish cipher, which was invented and described by Counterpane (see http://www.counterpane.com/blowfish.html ).</p> <p>Blowfish is a block cipher that operates on 64 bit (8 byte) blocks of data. It uses a variable size key, but typically, 128 bit (16 byte) keys are considered good for strong encryption.  Blowfish can be used in the same modes as DES (see des_modes(7)).  Blowfish is currently one of the faster block ciphers.  It is quite a bit faster than DES, and much faster than IDEA or RC2.</p> <p>Blowfish consists of a key setup phase and the actual encryption or decryption phase.</p> <p>BF_set_key() sets up the BF_KEY key using the len bytes long key at data.</p> <p>BF_ecb_encrypt() is the basic Blowfish encryption and decryption function. It encrypts or decrypts the first 64 bits of in using the key key, putting the result in out.  enc decides if encryption (BF_ENCRYPT) or decryption (BF_DECRYPT) shall be performed.  The vector pointed at by in and out must be 64 bits in length, no less.  If they are larger, everything after the first 64 bits is ignored.</p> <p>The mode functions BF_cbc_encrypt(), BF_cfb64_encrypt() and BF_ofb64_encrypt() all operate on variable length data.  They all take an initialization vector ivec which needs to be passed along into the next call of the same function  for the same message.  ivec may be initialized with anything, but the recipient needs to know what it was initialized with, or it won't be able to decrypt.  Some programs and protocols simplify this, like SSH, where ivec is simply initialized to zero. BF_cbc_encrypt() operates on data that is a multiple of 8 bytes long, while BF_cfb64_encrypt() and BF_ofb64_encrypt() are used to encrypt an variable number of bytes (the amount does not have to be an exact multiple of 8).  The purpose of the latter two is to simulate stream ciphers, and therefore, they need the parameter num, which is a pointer to an integer where the current offset in ivec is stored between calls.  This integer must be initialized to zero when ivec is initialized.</p> <p>BF_cbc_encrypt() is the Cipher Block Chaining function for Blowfish.  It encrypts or decrypts the 64 bits chunks of in using the key schedule, putting the result in out.  enc decides if encryption (BF_ENCRYPT) or decryption (BF_DECRYPT) shall be performed.  ivec must point at an 8 byte long initialization vector.</p> <p>BF_cfb64_encrypt() is the CFB mode for Blowfish with 64 bit feedback. It encrypts or decrypts the bytes in in using the key schedule, putting the result in out.  enc decides if encryption (BF_ENCRYPT) or decryption (BF_DECRYPT) shall be performed.  ivec must point at an 8 byte long initialization vector. num must point at an integer which must be initially zero.</p> <p>BF_ofb64_encrypt() is the OFB mode for Blowfish with 64 bit feedback. It uses the same parameters as BF_cfb64_encrypt(), which must be initialized the same way.</p> <p>BF_encrypt() and BF_decrypt() are the lowest level functions for Blowfish encryption.  They encrypt/decrypt the first 64 bits of the vector pointed by data, using the key key.  These functions should not be used unless you implement 'modes' of Blowfish.  The alternative is to use BF_ecb_encrypt(). If you still want to use these functions, you should be aware that they take each 32-bit chunk in host-byte order, which is little-endian on little-endian platforms and big-endian on big-endian ones.</p>"},{"location":"man3/blowfish/#return-values","title":"RETURN VALUES","text":"<p>None of the functions presented here return any value.</p>"},{"location":"man3/blowfish/#note","title":"NOTE","text":"<p>Applications should use the higher level functions EVP_EncryptInit(3) etc. instead of calling the blowfish functions directly.</p>"},{"location":"man3/blowfish/#see-also","title":"SEE ALSO","text":"<p>des_modes(7)</p>"},{"location":"man3/blowfish/#history","title":"HISTORY","text":"<p>The Blowfish functions are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/bn/","title":"bn","text":""},{"location":"man3/bn/#name","title":"NAME","text":"<p>bn - multiprecision integer arithmetics</p>"},{"location":"man3/bn/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nBIGNUM *BN_new(void);\nvoid BN_free(BIGNUM *a);\nvoid BN_init(BIGNUM *);\nvoid BN_clear(BIGNUM *a);\nvoid BN_clear_free(BIGNUM *a);\n\nBN_CTX *BN_CTX_new(void);\nvoid BN_CTX_init(BN_CTX *c);\nvoid BN_CTX_free(BN_CTX *c);\n\nBIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);\nBIGNUM *BN_dup(const BIGNUM *a);\n\nBIGNUM *BN_swap(BIGNUM *a, BIGNUM *b);\n\nint BN_num_bytes(const BIGNUM *a);\nint BN_num_bits(const BIGNUM *a);\nint BN_num_bits_word(BN_ULONG w);\n\nvoid BN_set_negative(BIGNUM *a, int n);\nint  BN_is_negative(const BIGNUM *a);\n\nint BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\nint BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\nint BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\nint BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);\nint BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d,\n        BN_CTX *ctx);\nint BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\nint BN_nnmod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\nint BN_mod_add(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n        BN_CTX *ctx);\nint BN_mod_sub(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n        BN_CTX *ctx);\nint BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n        BN_CTX *ctx);\nint BN_mod_sqr(BIGNUM *ret, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\nint BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);\nint BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,\n        const BIGNUM *m, BN_CTX *ctx);\nint BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\n\nint BN_add_word(BIGNUM *a, BN_ULONG w);\nint BN_sub_word(BIGNUM *a, BN_ULONG w);\nint BN_mul_word(BIGNUM *a, BN_ULONG w);\nBN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w);\nBN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w);\n\nint BN_cmp(BIGNUM *a, BIGNUM *b);\nint BN_ucmp(BIGNUM *a, BIGNUM *b);\nint BN_is_zero(BIGNUM *a);\nint BN_is_one(BIGNUM *a);\nint BN_is_word(BIGNUM *a, BN_ULONG w);\nint BN_is_odd(BIGNUM *a);\n\nint BN_zero(BIGNUM *a);\nint BN_one(BIGNUM *a);\nconst BIGNUM *BN_value_one(void);\nint BN_set_word(BIGNUM *a, unsigned long w);\nunsigned long BN_get_word(BIGNUM *a);\n\nint BN_rand(BIGNUM *rnd, int bits, int top, int bottom);\nint BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);\nint BN_rand_range(BIGNUM *rnd, BIGNUM *range);\nint BN_pseudo_rand_range(BIGNUM *rnd, BIGNUM *range);\n\nBIGNUM *BN_generate_prime(BIGNUM *ret, int bits,int safe, BIGNUM *add,\n        BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);\nint BN_is_prime(const BIGNUM *p, int nchecks,\n        void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg);\n\nint BN_set_bit(BIGNUM *a, int n);\nint BN_clear_bit(BIGNUM *a, int n);\nint BN_is_bit_set(const BIGNUM *a, int n);\nint BN_mask_bits(BIGNUM *a, int n);\nint BN_lshift(BIGNUM *r, const BIGNUM *a, int n);\nint BN_lshift1(BIGNUM *r, BIGNUM *a);\nint BN_rshift(BIGNUM *r, BIGNUM *a, int n);\nint BN_rshift1(BIGNUM *r, BIGNUM *a);\n\nint BN_bn2bin(const BIGNUM *a, unsigned char *to);\nBIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);\nchar *BN_bn2hex(const BIGNUM *a);\nchar *BN_bn2dec(const BIGNUM *a);\nint BN_hex2bn(BIGNUM **a, const char *str);\nint BN_dec2bn(BIGNUM **a, const char *str);\nint BN_print(BIO *fp, const BIGNUM *a);\nint BN_print_fp(FILE *fp, const BIGNUM *a);\nint BN_bn2mpi(const BIGNUM *a, unsigned char *to);\nBIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret);\n\nBIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n,\n    BN_CTX *ctx);\n\nBN_RECP_CTX *BN_RECP_CTX_new(void);\nvoid BN_RECP_CTX_init(BN_RECP_CTX *recp);\nvoid BN_RECP_CTX_free(BN_RECP_CTX *recp);\nint BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *m, BN_CTX *ctx);\nint BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n       BN_RECP_CTX *recp, BN_CTX *ctx);\n\nBN_MONT_CTX *BN_MONT_CTX_new(void);\nvoid BN_MONT_CTX_init(BN_MONT_CTX *ctx);\nvoid BN_MONT_CTX_free(BN_MONT_CTX *mont);\nint BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx);\nBN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from);\nint BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n        BN_MONT_CTX *mont, BN_CTX *ctx);\nint BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,\n        BN_CTX *ctx);\nint BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,\n        BN_CTX *ctx);\n\nBN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai,\n       BIGNUM *mod);\nvoid BN_BLINDING_free(BN_BLINDING *b);\nint BN_BLINDING_update(BN_BLINDING *b,BN_CTX *ctx);\nint BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\nint BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\nint BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b,\n       BN_CTX *ctx);\nint BN_BLINDING_invert_ex(BIGNUM *n,const BIGNUM *r,BN_BLINDING *b,\n       BN_CTX *ctx);\nunsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *);\nvoid BN_BLINDING_set_thread_id(BN_BLINDING *, unsigned long);\nunsigned long BN_BLINDING_get_flags(const BN_BLINDING *);\nvoid BN_BLINDING_set_flags(BN_BLINDING *, unsigned long);\nBN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,\n       const BIGNUM *e, BIGNUM *m, BN_CTX *ctx,\n       int (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx),\n       BN_MONT_CTX *m_ctx);\n</code></pre>"},{"location":"man3/bn/#description","title":"DESCRIPTION","text":"<p>This library performs arithmetic operations on integers of arbitrary size. It was written for use in public key cryptography, such as RSA and Diffie-Hellman.</p> <p>It uses dynamic memory allocation for storing its data structures. That means that there is no limit on the size of the numbers manipulated by these functions, but return values must always be checked in case a memory allocation error has occurred.</p> <p>The basic object in this library is a BIGNUM. It is used to hold a single large integer. This type should be considered opaque and fields should not be modified or accessed directly.</p> <p>The creation of BIGNUM objects is described in BN_new(3); BN_add(3) describes most of the arithmetic operations. Comparison is described in BN_cmp(3); BN_zero(3) describes certain assignments, BN_rand(3) the generation of random numbers, BN_generate_prime(3) deals with prime numbers and BN_set_bit(3) with bit operations. The conversion of BIGNUMs to external formats is described in BN_bn2bin(3).</p>"},{"location":"man3/bn/#see-also","title":"SEE ALSO","text":"<p>bn_internal(3), dh(3), err(3), rand(3), rsa(3), BN_new(3), BN_CTX_new(3), BN_copy(3), BN_swap(3), BN_num_bytes(3), BN_add(3), BN_add_word(3), BN_cmp(3), BN_zero(3), BN_rand(3), BN_generate_prime(3), BN_set_bit(3), BN_bn2bin(3), BN_mod_inverse(3), BN_mod_mul_reciprocal(3), BN_mod_mul_montgomery(3), BN_BLINDING_new(3)</p>"},{"location":"man3/bn_internal/","title":"bn_internal","text":""},{"location":"man3/bn_internal/#name","title":"NAME","text":"<p>bn_mul_words, bn_mul_add_words, bn_sqr_words, bn_div_words, bn_add_words, bn_sub_words, bn_mul_comba4, bn_mul_comba8, bn_sqr_comba4, bn_sqr_comba8, bn_cmp_words, bn_mul_normal, bn_mul_low_normal, bn_mul_recursive, bn_mul_part_recursive, bn_mul_low_recursive, bn_mul_high, bn_sqr_normal, bn_sqr_recursive, bn_expand, bn_wexpand, bn_expand2, bn_fix_top, bn_check_top, bn_print, bn_dump, bn_set_max, bn_set_high, bn_set_low - BIGNUM library internal functions</p>"},{"location":"man3/bn_internal/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/bn.h&gt;\n\nBN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w);\nBN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num,\n  BN_ULONG w);\nvoid     bn_sqr_words(BN_ULONG *rp, BN_ULONG *ap, int num);\nBN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d);\nBN_ULONG bn_add_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,\n  int num);\nBN_ULONG bn_sub_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,\n  int num);\n\nvoid bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);\nvoid bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);\nvoid bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a);\nvoid bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a);\n\nint bn_cmp_words(BN_ULONG *a, BN_ULONG *b, int n);\n\nvoid bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b,\n  int nb);\nvoid bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n);\nvoid bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,\n  int dna,int dnb,BN_ULONG *tmp);\nvoid bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,\n  int n, int tna,int tnb, BN_ULONG *tmp);\nvoid bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,\n  int n2, BN_ULONG *tmp);\nvoid bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l,\n  int n2, BN_ULONG *tmp);\n\nvoid bn_sqr_normal(BN_ULONG *r, BN_ULONG *a, int n, BN_ULONG *tmp);\nvoid bn_sqr_recursive(BN_ULONG *r, BN_ULONG *a, int n2, BN_ULONG *tmp);\n\nvoid mul(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);\nvoid mul_add(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);\nvoid sqr(BN_ULONG r0, BN_ULONG r1, BN_ULONG a);\n\nBIGNUM *bn_expand(BIGNUM *a, int bits);\nBIGNUM *bn_wexpand(BIGNUM *a, int n);\nBIGNUM *bn_expand2(BIGNUM *a, int n);\nvoid bn_fix_top(BIGNUM *a);\n\nvoid bn_check_top(BIGNUM *a);\nvoid bn_print(BIGNUM *a);\nvoid bn_dump(BN_ULONG *d, int n);\nvoid bn_set_max(BIGNUM *a);\nvoid bn_set_high(BIGNUM *r, BIGNUM *a, int n);\nvoid bn_set_low(BIGNUM *r, BIGNUM *a, int n);\n</code></pre>"},{"location":"man3/bn_internal/#description","title":"DESCRIPTION","text":"<p>This page documents the internal functions used by the OpenSSL BIGNUM implementation. They are described here to facilitate debugging and extending the library. They are not to be used by applications.</p>"},{"location":"man3/bn_internal/#the-bignum-structure","title":"The BIGNUM structure","text":"<pre><code>typedef struct bignum_st BIGNUM;\n\nstruct bignum_st\n       {\n       BN_ULONG *d;    /* Pointer to an array of 'BN_BITS2' bit chunks. */\n       int top;        /* Index of last used d +1. */\n       /* The next are internal book keeping for bn_expand. */\n       int dmax;       /* Size of the d array. */\n       int neg;        /* one if the number is negative */\n       int flags;\n       };\n</code></pre> <p>The integer value is stored in d, a malloc()ed array of words (BN_ULONG), least significant word first. A BN_ULONG can be either 16, 32 or 64 bits in size, depending on the 'number of bits' (BITS2) specified in <code>openssl/bn.h</code>.</p> <p>dmax is the size of the d array that has been allocated.  top is the number of words being used, so for a value of 4, bn.d[0]=4 and bn.top=1.  neg is 1 if the number is negative.  When a BIGNUM is 0, the d field can be NULL and top == 0.</p> <p>flags is a bit field of flags which are defined in <code>openssl/bn.h</code>. The  flags begin with BN_FLG_. The macros BN_set_flags(b,n) and  BN_get_flags(b,n) exist to enable or fetch flag(s) n from BIGNUM structure b.</p> <p>Various routines in this library require the use of temporary BIGNUM variables during their execution.  Since dynamic memory allocation to create BIGNUMs is rather expensive when used in conjunction with repeated subroutine calls, the BN_CTX structure is used.  This structure contains BN_CTX_NUM BIGNUMs, see BN_CTX_start(3).</p>"},{"location":"man3/bn_internal/#low-level-arithmetic-operations","title":"Low-level arithmetic operations","text":"<p>These functions are implemented in C and for several platforms in assembly language:</p> <p>bn_mul_words(rp, ap, num, w) operates on the num word arrays rp and ap.  It computes ap * w, places the result in rp, and returns the high word (carry).</p> <p>bn_mul_add_words(rp, ap, num, w) operates on the num word arrays rp and ap.  It computes ap * w + rp, places the result in rp, and returns the high word (carry).</p> <p>bn_sqr_words(rp, ap, n) operates on the num word array ap and the 2*num word array ap.  It computes ap * ap word-wise, and places the low and high bytes of the result in rp.</p> <p>bn_div_words(h, l, d) divides the two word number (h,l) by d and returns the result.</p> <p>bn_add_words(rp, ap, bp, num) operates on the num word arrays ap, bp and rp.  It computes ap + bp, places the result in rp, and returns the high word (carry).</p> <p>bn_sub_words(rp, ap, bp, num) operates on the num word arrays ap, bp and rp.  It computes ap - bp, places the result in rp, and returns the carry (1 if bp &gt; ap, 0 otherwise).</p> <p>bn_mul_comba4(r, a, b) operates on the 4 word arrays a and b and the 8 word array r.  It computes a*b and places the result in r.</p> <p>bn_mul_comba8(r, a, b) operates on the 8 word arrays a and b and the 16 word array r.  It computes a*b and places the result in r.</p> <p>bn_sqr_comba4(r, a, b) operates on the 4 word arrays a and b and the 8 word array r.</p> <p>bn_sqr_comba8(r, a, b) operates on the 8 word arrays a and b and the 16 word array r.</p> <p>The following functions are implemented in C:</p> <p>bn_cmp_words(a, b, n) operates on the n word arrays a and b.  It returns 1, 0 and -1 if a is greater than, equal and less than b.</p> <p>bn_mul_normal(r, a, na, b, nb) operates on the na word array a, the nb word array b and the na+nb word array r.  It computes a*b and places the result in r.</p> <p>bn_mul_low_normal(r, a, b, n) operates on the n word arrays r, a and b.  It computes the n low words of a*b and places the result in r.</p> <p>bn_mul_recursive(r, a, b, n2, dna, dnb, t) operates on the word arrays a and b of length n2+dna and n2+dnb (dna and dnb are currently allowed to be 0 or negative) and the 2*n2 word arrays r and t.  n2 must be a power of 2.  It computes a*b and places the result in r.</p> <p>bn_mul_part_recursive(r, a, b, n, tna, tnb, tmp) operates on the word arrays a and b of length n+tna and n+tnb and the 4*n word arrays r and tmp.</p> <p>bn_mul_low_recursive(r, a, b, n2, tmp) operates on the n2 word arrays r and tmp and the n2/2 word arrays a and b.</p> <p>bn_mul_high(r, a, b, l, n2, tmp) operates on the n2 word arrays r, a, b and l (?) and the 3*n2 word array tmp.</p> <p>BN_mul() calls bn_mul_normal(), or an optimized implementation if the factors have the same size: bn_mul_comba8() is used if they are 8 words long, bn_mul_recursive() if they are larger than BN_MULL_SIZE_NORMAL and the size is an exact multiple of the word size, and bn_mul_part_recursive() for others that are larger than BN_MULL_SIZE_NORMAL.</p> <p>bn_sqr_normal(r, a, n, tmp) operates on the n word array a and the 2*n word arrays tmp and r.</p> <p>The implementations use the following macros which, depending on the architecture, may use \"long long\" C operations or inline assembler. They are defined in <code>bn_lcl.h</code>.</p> <p>mul(r, a, w, c) computes w*a+c and places the low word of the result in r and the high word in c.</p> <p>mul_add(r, a, w, c) computes w*a+r+c and places the low word of the result in r and the high word in c.</p> <p>sqr(r0, r1, a) computes a*a and places the low word of the result in r0 and the high word in r1.</p>"},{"location":"man3/bn_internal/#size-changes","title":"Size changes","text":"<p>bn_expand() ensures that b has enough space for a bits bit number.  bn_wexpand() ensures that b has enough space for an n word number.  If the number has to be expanded, both macros call bn_expand2(), which allocates a new d array and copies the data.  They return NULL on error, b otherwise.</p> <p>The bn_fix_top() macro reduces a-&gt;top to point to the most significant non-zero word plus one when a has shrunk.</p>"},{"location":"man3/bn_internal/#debugging","title":"Debugging","text":"<p>bn_check_top() verifies that <code>((a)-&gt;top &gt;= 0 &amp;&amp; (a)-&gt;top &lt;= (a)-&gt;dmax)</code>.  A violation will cause the program to abort.</p> <p>bn_print() prints a to stderr. bn_dump() prints n words at d (in reverse order, i.e. most significant word first) to stderr.</p> <p>bn_set_max() makes a a static number with a dmax of its current size. This is used by bn_set_low() and bn_set_high() to make r a read-only BIGNUM that contains the n low or high words of a.</p> <p>If BN_DEBUG is not defined, bn_check_top(), bn_print(), bn_dump() and bn_set_max() are defined as empty macros.</p>"},{"location":"man3/bn_internal/#see-also","title":"SEE ALSO","text":"<p>bn(3)</p>"},{"location":"man3/buffer/","title":"buffer","text":""},{"location":"man3/buffer/#name","title":"NAME","text":"<p>BUF_MEM_new, BUF_MEM_new_ex, BUF_MEM_free, BUF_MEM_grow - simple character array structure</p> <p>BUF_strdup, BUF_strndup, BUF_memdup, BUF_strlcpy, BUF_strlcat - standard C library equivalents</p>"},{"location":"man3/buffer/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/buffer.h&gt;\n\nBUF_MEM *BUF_MEM_new(void);\n\nvoid   BUF_MEM_free(BUF_MEM *a);\n\nint    BUF_MEM_grow(BUF_MEM *str, int len);\n\nchar *BUF_strdup(const char *str);\n\nchar *BUF_strndup(const char *str, size_t siz);\n\nvoid *BUF_memdup(const void *data, size_t siz);\n\nsize_t BUF_strlcpy(char *dst, const char *src, size_t size);\n\nsize_t BUF_strlcat(char *dst, const char *src, size_t size);\n\nsize_t BUF_strnlen(const char *str, size_t maxlen);\n</code></pre>"},{"location":"man3/buffer/#description","title":"DESCRIPTION","text":"<p>The buffer library handles simple character arrays. Buffers are used for various purposes in the library, most notably memory BIOs.</p> <p>BUF_MEM_new() allocates a new buffer of zero size.</p> <p>BUF_MEM_free() frees up an already existing buffer. The data is zeroed before freeing up in case the buffer contains sensitive data.</p> <p>BUF_MEM_grow() changes the size of an already existing buffer to len. Any data already in the buffer is preserved if it increases in size.</p> <p>BUF_strdup(), BUF_strndup(), BUF_memdup(), BUF_strlcpy(), BUF_strlcat() and BUF_strnlen are equivalents of the standard C library functions. The dup() functions use OPENSSL_malloc() underneath and so should be used in preference to the standard library for memory leak checking or replacing the malloc() function.</p> <p>Memory allocated from these functions should be freed up using the OPENSSL_free() function.</p> <p>BUF_strndup makes the explicit guarantee that it will never read past the first siz bytes of str.</p>"},{"location":"man3/buffer/#return-values","title":"RETURN VALUES","text":"<p>BUF_MEM_new() returns the buffer or NULL on error.</p> <p>BUF_MEM_free() has no return value.</p> <p>BUF_MEM_grow() returns zero on error or the new size (i.e. len).</p>"},{"location":"man3/buffer/#see-also","title":"SEE ALSO","text":"<p>bio(3)</p>"},{"location":"man3/buffer/#history","title":"HISTORY","text":"<p>BUF_MEM_new(), BUF_MEM_free() and BUF_MEM_grow() are available in all versions of SSLeay and OpenSSL. BUF_strdup() was added in SSLeay 0.8.</p>"},{"location":"man3/crypto/","title":"crypto","text":""},{"location":"man3/crypto/#name","title":"NAME","text":"<p>crypto - OpenSSL cryptographic library</p>"},{"location":"man3/crypto/#synopsis","title":"SYNOPSIS","text":""},{"location":"man3/crypto/#description","title":"DESCRIPTION","text":"<p>The OpenSSL crypto library implements a wide range of cryptographic algorithms used in various Internet standards. The services provided by this library are used by the OpenSSL implementations of SSL, TLS and S/MIME, and they have also been used to implement SSH, OpenPGP, and other cryptographic standards.</p>"},{"location":"man3/crypto/#overview","title":"OVERVIEW","text":"<p>libcrypto consists of a number of sub-libraries that implement the individual algorithms.</p> <p>The functionality includes symmetric encryption, public key cryptography and key agreement, certificate handling, cryptographic hash functions and a cryptographic pseudo-random number generator.</p> <ul> <li> <p>SYMMETRIC CIPHERS</p> <p>blowfish(3), cast(3), des(3), idea(3), rc2(3), rc4(3), rc5(3) </p> </li> <li> <p>PUBLIC KEY CRYPTOGRAPHY AND KEY AGREEMENT</p> <p>dsa(3), dh(3), rsa(3)</p> </li> <li> <p>CERTIFICATES</p> <p>x509(3), x509v3(3)</p> </li> <li> <p>AUTHENTICATION CODES, HASH FUNCTIONS</p> <p>hmac(3), md2(3), md4(3), md5(3), mdc2(3), ripemd(3), sha(3)</p> </li> <li> <p>AUXILIARY FUNCTIONS</p> <p>err(3), threads(3), rand(3), OPENSSL_VERSION_NUMBER(3)</p> </li> <li> <p>INPUT/OUTPUT, DATA ENCODING</p> <p>asn1(3), bio(3), evp(3), pem(3), pkcs7(3), pkcs12(3) </p> </li> <li> <p>INTERNAL FUNCTIONS</p> <p>bn(3), buffer(3), ec(3), lhash(3), objects(3), stack(3), txt_db(3) </p> </li> </ul>"},{"location":"man3/crypto/#notes","title":"NOTES","text":"<p>Some of the newer functions follow a naming convention using the numbers 0 and 1. For example the functions:</p> <pre><code>int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);\nint X509_add1_trust_object(X509 *x, ASN1_OBJECT *obj);\n</code></pre> <p>The 0 version uses the supplied structure pointer directly in the parent and it will be freed up when the parent is freed. In the above example crl would be freed but rev would not.</p> <p>The 1 function uses a copy of the supplied structure pointer (or in some cases increases its link count) in the parent and so both (x and obj above) should be freed up.</p>"},{"location":"man3/crypto/#see-also","title":"SEE ALSO","text":"<p>openssl(1), ssl(3)</p>"},{"location":"man3/d2i_ASN1_OBJECT/","title":"d2i_ASN1_OBJECT","text":""},{"location":"man3/d2i_ASN1_OBJECT/#name","title":"NAME","text":"<p>d2i_ASN1_OBJECT, i2d_ASN1_OBJECT - ASN1 OBJECT IDENTIFIER functions</p>"},{"location":"man3/d2i_ASN1_OBJECT/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/objects.h&gt;\n\nASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, unsigned char **pp, long length);\nint i2d_ASN1_OBJECT(ASN1_OBJECT *a, unsigned char **pp);\n</code></pre>"},{"location":"man3/d2i_ASN1_OBJECT/#description","title":"DESCRIPTION","text":"<p>These functions decode and encode an ASN1 OBJECT IDENTIFIER.</p> <p>Othewise these behave in a similar way to d2i_X509() and i2d_X509() described in the d2i_X509(3) manual page.</p>"},{"location":"man3/d2i_ASN1_OBJECT/#see-also","title":"SEE ALSO","text":"<p>d2i_X509(3)</p>"},{"location":"man3/d2i_ASN1_OBJECT/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/d2i_CMS_ContentInfo/","title":"d2i_CMS_ContentInfo","text":""},{"location":"man3/d2i_CMS_ContentInfo/#name","title":"NAME","text":"<p>d2i_CMS_ContentInfo, i2d_CMS_ContentInfo - CMS ContentInfo functions</p>"},{"location":"man3/d2i_CMS_ContentInfo/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nCMS_ContentInfo *d2i_CMS_ContentInfo(CMS_ContentInfo **a, unsigned char **pp, long length);\nint i2d_CMS_ContentInfo(CMS_ContentInfo *a, unsigned char **pp);\n</code></pre>"},{"location":"man3/d2i_CMS_ContentInfo/#description","title":"DESCRIPTION","text":"<p>These functions decode and encode an CMS ContentInfo structure.</p> <p>Otherwise they behave in a similar way to d2i_X509() and i2d_X509() described in the d2i_X509(3) manual page.</p>"},{"location":"man3/d2i_CMS_ContentInfo/#see-also","title":"SEE ALSO","text":"<p>d2i_X509(3)</p>"},{"location":"man3/d2i_CMS_ContentInfo/#history","title":"HISTORY","text":"<p>These functions were first added to OpenSSL 0.9.8</p>"},{"location":"man3/d2i_DHparams/","title":"d2i_DHparams","text":""},{"location":"man3/d2i_DHparams/#name","title":"NAME","text":"<p>d2i_DHparams, i2d_DHparams - PKCS#3 DH parameter functions.</p>"},{"location":"man3/d2i_DHparams/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dh.h&gt;\n\nDH *d2i_DHparams(DH **a, unsigned char **pp, long length);\nint i2d_DHparams(DH *a, unsigned char **pp);\n</code></pre>"},{"location":"man3/d2i_DHparams/#description","title":"DESCRIPTION","text":"<p>These functions decode and encode PKCS#3 DH parameters using the DHparameter structure described in PKCS#3.</p> <p>Othewise these behave in a similar way to d2i_X509() and i2d_X509() described in the d2i_X509(3) manual page.</p>"},{"location":"man3/d2i_DHparams/#see-also","title":"SEE ALSO","text":"<p>d2i_X509(3)</p>"},{"location":"man3/d2i_DHparams/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/d2i_DSAPublicKey/","title":"d2i_DSAPublicKey","text":""},{"location":"man3/d2i_DSAPublicKey/#name","title":"NAME","text":"<p>d2i_DSAPublicKey, i2d_DSAPublicKey, d2i_DSAPrivateKey, i2d_DSAPrivateKey, d2i_DSA_PUBKEY, i2d_DSA_PUBKEY, d2i_DSAparams, i2d_DSAparams, d2i_DSA_SIG, i2d_DSA_SIG - DSA key encoding and parsing functions.</p>"},{"location":"man3/d2i_DSAPublicKey/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dsa.h&gt;\n#include &lt;openssl/x509.h&gt;\n\nDSA * d2i_DSAPublicKey(DSA **a, const unsigned char **pp, long length);\n\nint i2d_DSAPublicKey(const DSA *a, unsigned char **pp);\n\nDSA * d2i_DSA_PUBKEY(DSA **a, const unsigned char **pp, long length);\n\nint i2d_DSA_PUBKEY(const DSA *a, unsigned char **pp);\n\nDSA * d2i_DSAPrivateKey(DSA **a, const unsigned char **pp, long length);\n\nint i2d_DSAPrivateKey(const DSA *a, unsigned char **pp);\n\nDSA * d2i_DSAparams(DSA **a, const unsigned char **pp, long length);\n\nint i2d_DSAparams(const DSA *a, unsigned char **pp);\n\nDSA * d2i_DSA_SIG(DSA_SIG **a, const unsigned char **pp, long length);\n\nint i2d_DSA_SIG(const DSA_SIG *a, unsigned char **pp);\n</code></pre>"},{"location":"man3/d2i_DSAPublicKey/#description","title":"DESCRIPTION","text":"<p>d2i_DSAPublicKey() and i2d_DSAPublicKey() decode and encode the DSA public key components structure.</p> <p>d2i_DSA_PUBKEY() and i2d_DSA_PUBKEY() decode and encode an DSA public key using a SubjectPublicKeyInfo (certificate public key) structure.</p> <p>d2i_DSAPrivateKey(), i2d_DSAPrivateKey() decode and encode the DSA private key components.</p> <p>d2i_DSAparams(), i2d_DSAparams() decode and encode the DSA parameters using a Dss-Parms structure as defined in RFC2459.</p> <p>d2i_DSA_SIG(), i2d_DSA_SIG() decode and encode a DSA signature using a Dss-Sig-Value structure as defined in RFC2459.</p> <p>The usage of all of these functions is similar to the d2i_X509() and i2d_X509() described in the d2i_X509(3) manual page.</p>"},{"location":"man3/d2i_DSAPublicKey/#notes","title":"NOTES","text":"<p>The DSA structure passed to the private key encoding functions should have all the private key components present.</p> <p>The data encoded by the private key functions is unencrypted and therefore  offers no private key security.</p> <p>The DSA_PUBKEY functions should be used in preference to the DSAPublicKey functions when encoding public keys because they use a standard format.</p> <p>The DSAPublicKey functions use an non standard format the actual data encoded depends on the value of the write_params field of the a key parameter. If write_params is zero then only the pub_key field is encoded as an INTEGER. If write_params is 1 then a SEQUENCE consisting of the p, q, g and pub_key respectively fields are encoded.</p> <p>The DSAPrivateKey functions also use a non standard structure consiting consisting of a SEQUENCE containing the p, q, g and pub_key and priv_key fields respectively.</p>"},{"location":"man3/d2i_DSAPublicKey/#see-also","title":"SEE ALSO","text":"<p>d2i_X509(3)</p>"},{"location":"man3/d2i_DSAPublicKey/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/d2i_ECPKParameters/","title":"d2i_ECPKParameters","text":""},{"location":"man3/d2i_ECPKParameters/#name","title":"NAME","text":"<p>d2i_ECPKParameters, i2d_ECPKParameters, d2i_ECPKParameters_bio, i2d_ECPKParameters_bio, d2i_ECPKParameters_fp, i2d_ECPKParameters_fp, ECPKParameters_print, ECPKParameters_print_fp - Functions for decoding and encoding ASN1 representations of elliptic curve entities</p>"},{"location":"man3/d2i_ECPKParameters/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ec.h&gt;\n\nEC_GROUP *d2i_ECPKParameters(EC_GROUP **px, const unsigned char **in, long len);\nint i2d_ECPKParameters(const EC_GROUP *x, unsigned char **out);\n#define d2i_ECPKParameters_bio(bp,x) ASN1_d2i_bio_of(EC_GROUP,NULL,d2i_ECPKParameters,bp,x)\n#define i2d_ECPKParameters_bio(bp,x) ASN1_i2d_bio_of_const(EC_GROUP,i2d_ECPKParameters,bp,x)\n#define d2i_ECPKParameters_fp(fp,x) (EC_GROUP *)ASN1_d2i_fp(NULL, \\\n               (char *(*)())d2i_ECPKParameters,(fp),(unsigned char **)(x))\n#define i2d_ECPKParameters_fp(fp,x) ASN1_i2d_fp(i2d_ECPKParameters,(fp), \\\n               (unsigned char *)(x))\nint     ECPKParameters_print(BIO *bp, const EC_GROUP *x, int off);\nint     ECPKParameters_print_fp(FILE *fp, const EC_GROUP *x, int off);\n</code></pre>"},{"location":"man3/d2i_ECPKParameters/#description","title":"DESCRIPTION","text":"<p>The ECPKParameters encode and decode routines encode and parse the public parameters for an EC_GROUP structure, which represents a curve.</p> <p>d2i_ECPKParameters() attempts to decode len bytes at *in. If  successful a pointer to the EC_GROUP structure is returned. If an error occurred then NULL is returned. If px is not NULL then the returned structure is written to *px. If *px is not NULL then it is assumed that *px contains a valid EC_GROUP structure and an attempt is made to reuse it. If the call is successful *in is incremented to the byte following the parsed data.</p> <p>i2d_ECPKParameters() encodes the structure pointed to by x into DER format. If out is not NULL is writes the DER encoded data to the buffer at *out, and increments it to point after the data just written. If the return value is negative an error occurred, otherwise it returns the length of the encoded data. </p> <p>If *out is NULL memory will be allocated for a buffer and the encoded data written to it. In this case *out is not incremented and it points to the start of the data just written.</p> <p>d2i_ECPKParameters_bio() is similar to d2i_ECPKParameters() except it attempts to parse data from BIO bp.</p> <p>d2i_ECPKParameters_fp() is similar to d2i_ECPKParameters() except it attempts to parse data from FILE pointer fp.</p> <p>i2d_ECPKParameters_bio() is similar to i2d_ECPKParameters() except it writes the encoding of the structure x to BIO bp and it returns 1 for success and 0 for failure.</p> <p>i2d_ECPKParameters_fp() is similar to i2d_ECPKParameters() except it writes the encoding of the structure x to BIO bp and it returns 1 for success and 0 for failure.</p> <p>These functions are very similar to the X509 functions described in d2i_X509(3), where further notes and examples are available.</p> <p>The ECPKParameters_print and ECPKParameters_print_fp functions print a human-readable output of the public parameters of the EC_GROUP to bp or fp. The output lines are indented by off spaces.</p>"},{"location":"man3/d2i_ECPKParameters/#return-values","title":"RETURN VALUES","text":"<p>d2i_ECPKParameters(), d2i_ECPKParameters_bio() and d2i_ECPKParameters_fp() return a valid EC_GROUP structure or NULL if an error occurs.</p> <p>i2d_ECPKParameters() returns the number of bytes successfully encoded or a negative value if an error occurs.</p> <p>i2d_ECPKParameters_bio(), i2d_ECPKParameters_fp(), ECPKParameters_print and ECPKParameters_print_fp return 1 for success and 0 if an error occurs. </p>"},{"location":"man3/d2i_ECPKParameters/#see-also","title":"SEE ALSO","text":"<p>crypto(3), ec(3), EC_GROUP_new(3), EC_GROUP_copy(3), EC_POINT_new(3), EC_POINT_add(3), EC_KEY_new(3), EC_GFp_simple_method(3), d2i_X509(3)</p>"},{"location":"man3/d2i_ECPrivateKey/","title":"d2i_ECPrivateKey","text":""},{"location":"man3/d2i_ECPrivateKey/#name","title":"NAME","text":"<p>i2d_ECPrivateKey, d2i_ECPrivate_key - Encode and decode functions for saving and reading EC_KEY structures</p>"},{"location":"man3/d2i_ECPrivateKey/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ec.h&gt;\n\nEC_KEY *d2i_ECPrivateKey(EC_KEY **key, const unsigned char **in, long len);\nint i2d_ECPrivateKey(EC_KEY *key, unsigned char **out);\n\nunsigned int EC_KEY_get_enc_flags(const EC_KEY *key);\nvoid EC_KEY_set_enc_flags(EC_KEY *eckey, unsigned int flags);\n</code></pre>"},{"location":"man3/d2i_ECPrivateKey/#description","title":"DESCRIPTION","text":"<p>The ECPrivateKey encode and decode routines encode and parse an EC_KEY structure into a binary format (ASN.1 DER) and back again.</p> <p>These functions are similar to the d2i_X509() functions, and you should refer to that page for a detailed description (see d2i_X509(3)).</p> <p>The format of the external representation of the public key written by i2d_ECPrivateKey (such as whether it is stored in a compressed form or not) is described by the point_conversion_form. See EC_GROUP_copy(3) for a description of point_conversion_form.</p> <p>When reading a private key encoded without an associated public key (e.g. if EC_PKEY_NO_PUBKEY has been used - see below), then d2i_ECPrivateKey generates the missing public key automatically. Private keys encoded without parameters (e.g. if EC_PKEY_NO_PARAMETERS has been used - see below) cannot be loaded using d2i_ECPrivateKey.</p> <p>The functions EC_KEY_get_enc_flags and EC_KEY_set_enc_flags get and set the value of the encoding flags for the key. There are two encoding flags currently defined - EC_PKEY_NO_PARAMETERS and EC_PKEY_NO_PUBKEY.  These flags define the behaviour of how the  key is converted into ASN1 in a call to i2d_ECPrivateKey. If EC_PKEY_NO_PARAMETERS is set then the public parameters for the curve are not encoded along with the private key. If EC_PKEY_NO_PUBKEY is set then the public key is not encoded along with the private key.</p>"},{"location":"man3/d2i_ECPrivateKey/#return-values","title":"RETURN VALUES","text":"<p>d2i_ECPrivateKey() returns a valid EC_KEY structure or NULL if an error occurs. The error code that can be obtained by ERR_get_error(3).</p> <p>i2d_ECPrivateKey() returns the number of bytes successfully encoded or a negative value if an error occurs. The error code can be obtained by ERR_get_error(3).</p> <p>EC_KEY_get_enc_flags returns the value of the current encoding flags for the EC_KEY.</p>"},{"location":"man3/d2i_ECPrivateKey/#see-also","title":"SEE ALSO","text":"<p>crypto(3), ec(3), EC_GROUP_new(3), EC_GROUP_copy(3), EC_POINT_new(3), EC_POINT_add(3), EC_GFp_simple_method(3), d2i_ECPKParameters(3), d2i_ECPrivateKey(3)</p>"},{"location":"man3/d2i_PKCS8PrivateKey/","title":"d2i_PKCS8PrivateKey","text":""},{"location":"man3/d2i_PKCS8PrivateKey/#name","title":"NAME","text":"<p>d2i_PKCS8PrivateKey_bio, d2i_PKCS8PrivateKey_fp, i2d_PKCS8PrivateKey_bio, i2d_PKCS8PrivateKey_fp, i2d_PKCS8PrivateKey_nid_bio, i2d_PKCS8PrivateKey_nid_fp - PKCS#8 format private key functions</p>"},{"location":"man3/d2i_PKCS8PrivateKey/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nEVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u);\nEVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u);\n\nint i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\n                                 char *kstr, int klen,\n                                 pem_password_cb *cb, void *u);\n\nint i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n                                 char *kstr, int klen,\n                                 pem_password_cb *cb, void *u);\n\nint i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,\n                                 char *kstr, int klen,\n                                 pem_password_cb *cb, void *u);\n\nint i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,\n                                 char *kstr, int klen,\n                                 pem_password_cb *cb, void *u);\n</code></pre>"},{"location":"man3/d2i_PKCS8PrivateKey/#description","title":"DESCRIPTION","text":"<p>The PKCS#8 functions encode and decode private keys in PKCS#8 format using both PKCS#5 v1.5 and PKCS#5 v2.0 password based encryption algorithms.</p> <p>Other than the use of DER as opposed to PEM these functions are identical to the corresponding PEM function as described in the pem(3) manual page.</p>"},{"location":"man3/d2i_PKCS8PrivateKey/#notes","title":"NOTES","text":"<p>Before using these functions OpenSSL_add_all_algorithms(3) should be called to initialize the internal algorithm lookup tables otherwise errors about unknown algorithms will occur if an attempt is made to decrypt a private key. </p> <p>These functions are currently the only way to store encrypted private keys using DER format.</p> <p>Currently all the functions use BIOs or FILE pointers, there are no functions which work directly on memory: this can be readily worked around by converting the buffers to memory BIOs, see BIO_s_mem(3) for details.</p>"},{"location":"man3/d2i_PKCS8PrivateKey/#see-also","title":"SEE ALSO","text":"<p>pem(3)</p>"},{"location":"man3/d2i_PrivateKey/","title":"d2i_PrivateKey","text":""},{"location":"man3/d2i_PrivateKey/#name","title":"NAME","text":"<p>d2i_Private_key, d2i_AutoPrivateKey, i2d_PrivateKey - decode and encode functions for reading and saving EVP_PKEY structures.</p>"},{"location":"man3/d2i_PrivateKey/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n\nEVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,\n                         long length);\nEVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,\n                             long length);\nint i2d_PrivateKey(EVP_PKEY *a, unsigned char **pp);\n</code></pre>"},{"location":"man3/d2i_PrivateKey/#description","title":"DESCRIPTION","text":"<p>d2i_PrivateKey() decodes a private key using algorithm type. It attempts to use any key specific format or PKCS#8 unencrypted PrivateKeyInfo format. The type parameter should be a public key algorithm constant such as EVP_PKEY_RSA. An error occurs if the decoded key does not match type.</p> <p>d2i_AutoPrivateKey() is similar to d2i_PrivateKey() except it attempts to automatically detect the private key format.</p> <p>i2d_PrivateKey() encodes key. It uses a key specific format or, if none is defined for that key type, PKCS#8 unencrypted PrivateKeyInfo format.</p> <p>These functions are similar to the d2i_X509() functions, and you should refer to that page for a detailed description (see d2i_X509(3)).</p>"},{"location":"man3/d2i_PrivateKey/#notes","title":"NOTES","text":"<p>All these functions use DER format and unencrypted keys. Applications wishing to encrypt or decrypt private keys should use other functions such as d2i_PKC8PrivateKey() instead.</p> <p>If the *a is not NULL when calling d2i_PrivateKey() or d2i_AutoPrivateKey() (i.e. an existing structure is being reused) and the key format is PKCS#8 then *a will be freed and replaced on a successful call.</p>"},{"location":"man3/d2i_PrivateKey/#return-values","title":"RETURN VALUES","text":"<p>d2i_PrivateKey() and d2i_AutoPrivateKey() return a valid EVP_KEY structure or NULL if an error occurs. The error code can be obtained by calling ERR_get_error(3).</p> <p>i2d_PrivateKey() returns the number of bytes successfully encoded or a negative value if an error occurs. The error code can be obtained by calling ERR_get_error(3).</p>"},{"location":"man3/d2i_PrivateKey/#see-also","title":"SEE ALSO","text":"<p>crypto(3), d2i_PKCS8PrivateKey(3)</p>"},{"location":"man3/d2i_RSAPublicKey/","title":"d2i_RSAPublicKey","text":""},{"location":"man3/d2i_RSAPublicKey/#name","title":"NAME","text":"<p>d2i_RSAPublicKey, i2d_RSAPublicKey, d2i_RSAPrivateKey, i2d_RSAPrivateKey, d2i_RSA_PUBKEY, i2d_RSA_PUBKEY, i2d_Netscape_RSA, d2i_Netscape_RSA - RSA public and private key encoding functions.</p>"},{"location":"man3/d2i_RSAPublicKey/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n#include &lt;openssl/x509.h&gt;\n\nRSA * d2i_RSAPublicKey(RSA **a, const unsigned char **pp, long length);\n\nint i2d_RSAPublicKey(RSA *a, unsigned char **pp);\n\nRSA * d2i_RSA_PUBKEY(RSA **a, const unsigned char **pp, long length);\n\nint i2d_RSA_PUBKEY(RSA *a, unsigned char **pp);\n\nRSA * d2i_RSAPrivateKey(RSA **a, const unsigned char **pp, long length);\n\nint i2d_RSAPrivateKey(RSA *a, unsigned char **pp);\n\nint i2d_Netscape_RSA(RSA *a, unsigned char **pp, int (*cb)());\n\nRSA * d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length, int (*cb)());\n</code></pre>"},{"location":"man3/d2i_RSAPublicKey/#description","title":"DESCRIPTION","text":"<p>d2i_RSAPublicKey() and i2d_RSAPublicKey() decode and encode a PKCS#1 RSAPublicKey structure.</p> <p>d2i_RSA_PUBKEY() and i2d_RSA_PUBKEY() decode and encode an RSA public key using a SubjectPublicKeyInfo (certificate public key) structure.</p> <p>d2i_RSAPrivateKey(), i2d_RSAPrivateKey() decode and encode a PKCS#1 RSAPrivateKey structure.</p> <p>d2i_Netscape_RSA(), i2d_Netscape_RSA() decode and encode an RSA private key in NET format.</p> <p>The usage of all of these functions is similar to the d2i_X509() and i2d_X509() described in the d2i_X509(3) manual page.</p>"},{"location":"man3/d2i_RSAPublicKey/#notes","title":"NOTES","text":"<p>The RSA structure passed to the private key encoding functions should have all the PKCS#1 private key components present.</p> <p>The data encoded by the private key functions is unencrypted and therefore  offers no private key security. </p> <p>The NET format functions are present to provide compatibility with certain very old software. This format has some severe security weaknesses and should be avoided if possible.</p>"},{"location":"man3/d2i_RSAPublicKey/#see-also","title":"SEE ALSO","text":"<p>d2i_X509(3)</p>"},{"location":"man3/d2i_RSAPublicKey/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/d2i_SSL_SESSION/","title":"d2i_SSL_SESSION","text":""},{"location":"man3/d2i_SSL_SESSION/#name","title":"NAME","text":"<p>d2i_SSL_SESSION, i2d_SSL_SESSION - convert SSL_SESSION object from/to ASN1 representation</p>"},{"location":"man3/d2i_SSL_SESSION/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ssl.h&gt;\n\nSSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp, long length);\nint i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp);\n</code></pre>"},{"location":"man3/d2i_SSL_SESSION/#description","title":"DESCRIPTION","text":"<p>d2i_SSL_SESSION() transforms the external ASN1 representation of an SSL/TLS session, stored as binary data at location pp with length length, into an SSL_SESSION object.</p> <p>i2d_SSL_SESSION() transforms the SSL_SESSION object in into the ASN1 representation and stores it into the memory location pointed to by pp. The length of the resulting ASN1 representation is returned. If pp is the NULL pointer, only the length is calculated and returned.</p>"},{"location":"man3/d2i_SSL_SESSION/#notes","title":"NOTES","text":"<p>The SSL_SESSION object is built from several malloc()ed parts, it can therefore not be moved, copied or stored directly. In order to store session data on disk or into a database, it must be transformed into a binary ASN1 representation.</p> <p>When using d2i_SSL_SESSION(), the SSL_SESSION object is automatically allocated. The reference count is 1, so that the session must be explicitly removed using SSL_SESSION_free(3), unless the SSL_SESSION object is completely taken over, when being called inside the get_session_cb() (see SSL_CTX_sess_set_get_cb(3)).</p> <p>SSL_SESSION objects keep internal link information about the session cache list, when being inserted into one SSL_CTX object's session cache. One SSL_SESSION object, regardless of its reference count, must therefore only be used with one SSL_CTX object (and the SSL objects created from this SSL_CTX object).</p> <p>When using i2d_SSL_SESSION(), the memory location pointed to by pp must be large enough to hold the binary representation of the session. There is no known limit on the size of the created ASN1 representation, so the necessary amount of space should be obtained by first calling i2d_SSL_SESSION() with pp=NULL, and obtain the size needed, then allocate the memory and call i2d_SSL_SESSION() again. Note that this will advance the value contained in *pp so it is necessary to save a copy of the original allocation. For example:  int i,j;  char *p, *temp;  i = i2d_SSL_SESSION(sess, NULL);  p = temp = malloc(i);  j = i2d_SSL_SESSION(sess, &amp;temp);  assert(i == j);  assert(p+i == temp);</p>"},{"location":"man3/d2i_SSL_SESSION/#return-values","title":"RETURN VALUES","text":"<p>d2i_SSL_SESSION() returns a pointer to the newly allocated SSL_SESSION object. In case of failure the NULL-pointer is returned and the error message can be retrieved from the error stack.</p> <p>i2d_SSL_SESSION() returns the size of the ASN1 representation in bytes. When the session is not valid, 0 is returned and no operation is performed.</p>"},{"location":"man3/d2i_SSL_SESSION/#see-also","title":"SEE ALSO","text":"<p>ssl(3), SSL_SESSION_free(3), SSL_CTX_sess_set_get_cb(3)</p>"},{"location":"man3/d2i_X509/","title":"d2i_X509","text":""},{"location":"man3/d2i_X509/#name","title":"NAME","text":"<p>d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio, i2d_X509_fp - X509 encode and decode functions</p>"},{"location":"man3/d2i_X509/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nX509 *d2i_X509(X509 **px, const unsigned char **in, long len);\nX509 *d2i_X509_AUX(X509 **px, const unsigned char **in, long len);\nint i2d_X509(X509 *x, unsigned char **out);\nint i2d_X509_AUX(X509 *x, unsigned char **out);\n\nX509 *d2i_X509_bio(BIO *bp, X509 **x);\nX509 *d2i_X509_fp(FILE *fp, X509 **x);\n\nint i2d_X509_bio(BIO *bp, X509 *x);\nint i2d_X509_fp(FILE *fp, X509 *x);\n\nint i2d_re_X509_tbs(X509 *x, unsigned char **out);\n</code></pre>"},{"location":"man3/d2i_X509/#description","title":"DESCRIPTION","text":"<p>The X509 encode and decode routines encode and parse an X509 structure, which represents an X509 certificate.</p> <p>d2i_X509() attempts to decode len bytes at *in. If  successful a pointer to the X509 structure is returned. If an error occurred then NULL is returned. If px is not NULL then the returned structure is written to *px. If *px is not NULL then it is assumed that *px contains a valid X509 structure and an attempt is made to reuse it. This \"reuse\" capability is present for historical compatibility but its use is strongly discouraged (see BUGS below, and the discussion in the RETURN VALUES section).</p> <p>If the call is successful *in is incremented to the byte following the parsed data.</p> <p>d2i_X509_AUX() is similar to d2i_X509() but the input is expected to consist of an X509 certificate followed by auxiliary trust information. This is used by the PEM routines to read \"TRUSTED CERTIFICATE\" objects. This function should not be called on untrusted input.</p> <p>i2d_X509() encodes the structure pointed to by x into DER format. If out is not NULL is writes the DER encoded data to the buffer at *out, and increments it to point after the data just written. If the return value is negative an error occurred, otherwise it returns the length of the encoded data. </p> <p>For OpenSSL 0.9.7 and later if *out is NULL memory will be allocated for a buffer and the encoded data written to it. In this case *out is not incremented and it points to the start of the data just written.</p> <p>i2d_X509_AUX() is similar to i2d_X509(), but the encoded output contains both the certificate and any auxiliary trust information. This is used by the PEM routines to write \"TRUSTED CERTIFICATE\" objects. Note, this is a non-standard OpenSSL-specific data format.</p> <p>d2i_X509_bio() is similar to d2i_X509() except it attempts to parse data from BIO bp.</p> <p>d2i_X509_fp() is similar to d2i_X509() except it attempts to parse data from FILE pointer fp.</p> <p>i2d_X509_bio() is similar to i2d_X509() except it writes the encoding of the structure x to BIO bp and it returns 1 for success and 0 for failure.</p> <p>i2d_X509_fp() is similar to i2d_X509() except it writes the encoding of the structure x to BIO bp and it returns 1 for success and 0 for failure.</p> <p>i2d_re_X509_tbs() is similar to i2d_X509() except it encodes only the TBSCertificate portion of the certificate.</p>"},{"location":"man3/d2i_X509/#notes","title":"NOTES","text":"<p>The letters i and d in for example i2d_X509 stand for \"internal\" (that is an internal C structure) and \"DER\". So i2d_X509 converts from internal to DER. The \"re\" in i2d_re_X509_tbs stands for \"re-encode\", and ensures that a fresh encoding is generated in case the object has been modified after creation (see the BUGS section).</p> <p>The functions can also understand BER forms.</p> <p>The actual X509 structure passed to i2d_X509() must be a valid populated X509 structure it can not simply be fed with an empty structure such as that returned by X509_new().</p> <p>The encoded data is in binary form and may contain embedded zeroes. Therefore any FILE pointers or BIOs should be opened in binary mode. Functions such as strlen() will not return the correct length of the encoded structure.</p> <p>The ways that *in and *out are incremented after the operation can trap the unwary. See the WARNINGS section for some common errors.</p> <p>The reason for the auto increment behaviour is to reflect a typical usage of ASN1 functions: after one structure is encoded or decoded another will processed after it.</p>"},{"location":"man3/d2i_X509/#examples","title":"EXAMPLES","text":"<p>Allocate and encode the DER encoding of an X509 structure:</p> <pre><code>int len;\nunsigned char *buf, *p;\n\nlen = i2d_X509(x, NULL);\n\nbuf = OPENSSL_malloc(len);\n\nif (buf == NULL)\n       /* error */\n\np = buf;\n\ni2d_X509(x, &amp;p);\n</code></pre> <p>If you are using OpenSSL 0.9.7 or later then this can be simplified to:</p> <pre><code>int len;\nunsigned char *buf;\n\nbuf = NULL;\n\nlen = i2d_X509(x, &amp;buf);\n\nif (len &lt; 0)\n       /* error */\n</code></pre> <p>Attempt to decode a buffer:</p> <pre><code>X509 *x;\n\nunsigned char *buf, *p;\n\nint len;\n\n/* Something to setup buf and len */\n\np = buf;\n\nx = d2i_X509(NULL, &amp;p, len);\n\nif (x == NULL)\n   /* Some error */\n</code></pre> <p>Alternative technique:</p> <pre><code>X509 *x;\n\nunsigned char *buf, *p;\n\nint len;\n\n/* Something to setup buf and len */\n\np = buf;\n\nx = NULL;\n\nif(!d2i_X509(&amp;x, &amp;p, len))\n   /* Some error */\n</code></pre>"},{"location":"man3/d2i_X509/#warnings","title":"WARNINGS","text":"<p>The use of temporary variable is mandatory. A common mistake is to attempt to use a buffer directly as follows:</p> <pre><code>int len;\nunsigned char *buf;\n\nlen = i2d_X509(x, NULL);\n\nbuf = OPENSSL_malloc(len);\n\nif (buf == NULL)\n       /* error */\n\ni2d_X509(x, &amp;buf);\n\n/* Other stuff ... */\n\nOPENSSL_free(buf);\n</code></pre> <p>This code will result in buf apparently containing garbage because it was incremented after the call to point after the data just written. Also buf will no longer contain the pointer allocated by OPENSSL_malloc() and the subsequent call to OPENSSL_free() may well crash.</p> <p>The auto allocation feature (setting buf to NULL) only works on OpenSSL 0.9.7 and later. Attempts to use it on earlier versions will typically cause a segmentation violation.</p> <p>Another trap to avoid is misuse of the xp argument to d2i_X509():</p> <pre><code>X509 *x;\n\nif (!d2i_X509(&amp;x, &amp;p, len))\n       /* Some error */\n</code></pre> <p>This will probably crash somewhere in d2i_X509(). The reason for this is that the variable x is uninitialized and an attempt will be made to interpret its (invalid) value as an X509 structure, typically causing a segmentation violation. If x is set to NULL first then this will not happen.</p>"},{"location":"man3/d2i_X509/#bugs","title":"BUGS","text":"<p>In some versions of OpenSSL the \"reuse\" behaviour of d2i_X509() when  *px is valid is broken and some parts of the reused structure may persist if they are not present in the new one. As a result the use of this \"reuse\" behaviour is strongly discouraged.</p> <p>i2d_X509() will not return an error in many versions of OpenSSL, if mandatory fields are not initialized due to a programming error then the encoded structure may contain invalid data or omit the fields entirely and will not be parsed by d2i_X509(). This may be fixed in future so code should not assume that i2d_X509() will always succeed.</p> <p>The encoding of the TBSCertificate portion of a certificate is cached in the X509 structure internally to improve encoding performance and to ensure certificate signatures are verified correctly in some certificates with broken (non-DER) encodings.</p> <p>Any function which encodes an X509 structure such as i2d_X509(), i2d_X509_fp() or i2d_X509_bio() may return a stale encoding if the X509 structure has been modified after deserialization or previous serialization.</p> <p>If, after modification, the X509 object is re-signed with X509_sign(), the encoding is automatically renewed. Otherwise, the encoding of the TBSCertificate portion of the X509 can be manually renewed by calling i2d_re_X509_tbs().</p>"},{"location":"man3/d2i_X509/#return-values","title":"RETURN VALUES","text":"<p>d2i_X509(), d2i_X509_bio() and d2i_X509_fp() return a valid X509 structure or NULL if an error occurs. The error code that can be obtained by ERR_get_error(3). If the \"reuse\" capability has been used with a valid X509 structure being passed in via px then the object is not freed in the event of error but may be in a potentially invalid or inconsistent state.</p> <p>i2d_X509() returns the number of bytes successfully encoded or a negative value if an error occurs. The error code can be obtained by ERR_get_error(3). </p> <p>i2d_X509_bio() and i2d_X509_fp() return 1 for success and 0 if an error  occurs The error code can be obtained by ERR_get_error(3). </p>"},{"location":"man3/d2i_X509/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3)</p>"},{"location":"man3/d2i_X509/#history","title":"HISTORY","text":"<p>d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio and i2d_X509_fp are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/d2i_X509_ALGOR/","title":"d2i_X509_ALGOR","text":""},{"location":"man3/d2i_X509_ALGOR/#name","title":"NAME","text":"<p>d2i_X509_ALGOR, i2d_X509_ALGOR - AlgorithmIdentifier functions.</p>"},{"location":"man3/d2i_X509_ALGOR/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nX509_ALGOR *d2i_X509_ALGOR(X509_ALGOR **a, unsigned char **pp, long length);\nint i2d_X509_ALGOR(X509_ALGOR *a, unsigned char **pp);\n</code></pre>"},{"location":"man3/d2i_X509_ALGOR/#description","title":"DESCRIPTION","text":"<p>These functions decode and encode an X509_ALGOR structure which is equivalent to the AlgorithmIdentifier structure.</p> <p>Othewise these behave in a similar way to d2i_X509() and i2d_X509() described in the d2i_X509(3) manual page.</p>"},{"location":"man3/d2i_X509_ALGOR/#see-also","title":"SEE ALSO","text":"<p>d2i_X509(3)</p>"},{"location":"man3/d2i_X509_ALGOR/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/d2i_X509_CRL/","title":"d2i_X509_CRL","text":""},{"location":"man3/d2i_X509_CRL/#name","title":"NAME","text":"<p>d2i_X509_CRL, i2d_X509_CRL, d2i_X509_CRL_bio, d2i_X509_CRL_fp, i2d_X509_CRL_bio, i2d_X509_CRL_fp - PKCS#10 certificate request functions.</p>"},{"location":"man3/d2i_X509_CRL/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nX509_CRL *d2i_X509_CRL(X509_CRL **a, const unsigned char **pp, long length);\nint i2d_X509_CRL(X509_CRL *a, unsigned char **pp);\n\nX509_CRL *d2i_X509_CRL_bio(BIO *bp, X509_CRL **x);\nX509_CRL *d2i_X509_CRL_fp(FILE *fp, X509_CRL **x);\n\nint i2d_X509_CRL_bio(BIO *bp, X509_CRL *x);\nint i2d_X509_CRL_fp(FILE *fp, X509_CRL *x);\n</code></pre>"},{"location":"man3/d2i_X509_CRL/#description","title":"DESCRIPTION","text":"<p>These functions decode and encode an X509 CRL (certificate revocation list).</p> <p>Othewise the functions behave in a similar way to d2i_X509() and i2d_X509() described in the d2i_X509(3) manual page.</p>"},{"location":"man3/d2i_X509_CRL/#see-also","title":"SEE ALSO","text":"<p>d2i_X509(3)</p>"},{"location":"man3/d2i_X509_CRL/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/d2i_X509_NAME/","title":"d2i_X509_NAME","text":""},{"location":"man3/d2i_X509_NAME/#name","title":"NAME","text":"<p>d2i_X509_NAME, i2d_X509_NAME - X509_NAME encoding functions</p>"},{"location":"man3/d2i_X509_NAME/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nX509_NAME *d2i_X509_NAME(X509_NAME **a, unsigned char **pp, long length);\nint i2d_X509_NAME(X509_NAME *a, unsigned char **pp);\n</code></pre>"},{"location":"man3/d2i_X509_NAME/#description","title":"DESCRIPTION","text":"<p>These functions decode and encode an X509_NAME structure which is the same as the Name type defined in RFC2459 (and elsewhere) and used for example in certificate subject and issuer names.</p> <p>Othewise the functions behave in a similar way to d2i_X509() and i2d_X509() described in the d2i_X509(3) manual page.</p>"},{"location":"man3/d2i_X509_NAME/#see-also","title":"SEE ALSO","text":"<p>d2i_X509(3)</p>"},{"location":"man3/d2i_X509_NAME/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/d2i_X509_REQ/","title":"d2i_X509_REQ","text":""},{"location":"man3/d2i_X509_REQ/#name","title":"NAME","text":"<p>d2i_X509_REQ, i2d_X509_REQ, d2i_X509_REQ_bio, d2i_X509_REQ_fp, i2d_X509_REQ_bio, i2d_X509_REQ_fp - PKCS#10 certificate request functions.</p>"},{"location":"man3/d2i_X509_REQ/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nX509_REQ *d2i_X509_REQ(X509_REQ **a, const unsigned char **pp, long length);\nint i2d_X509_REQ(X509_REQ *a, unsigned char **pp);\n\nX509_REQ *d2i_X509_REQ_bio(BIO *bp, X509_REQ **x);\nX509_REQ *d2i_X509_REQ_fp(FILE *fp, X509_REQ **x);\n\nint i2d_X509_REQ_bio(BIO *bp, X509_REQ *x);\nint i2d_X509_REQ_fp(FILE *fp, X509_REQ *x);\n</code></pre>"},{"location":"man3/d2i_X509_REQ/#description","title":"DESCRIPTION","text":"<p>These functions decode and encode a PKCS#10 certificate request.</p> <p>Othewise these behave in a similar way to d2i_X509() and i2d_X509() described in the d2i_X509(3) manual page.</p>"},{"location":"man3/d2i_X509_REQ/#see-also","title":"SEE ALSO","text":"<p>d2i_X509(3)</p>"},{"location":"man3/d2i_X509_REQ/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/d2i_X509_SIG/","title":"d2i_X509_SIG","text":""},{"location":"man3/d2i_X509_SIG/#name","title":"NAME","text":"<p>d2i_X509_SIG, i2d_X509_SIG - DigestInfo functions.</p>"},{"location":"man3/d2i_X509_SIG/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n\nX509_SIG *d2i_X509_SIG(X509_SIG **a, unsigned char **pp, long length);\nint i2d_X509_SIG(X509_SIG *a, unsigned char **pp);\n</code></pre>"},{"location":"man3/d2i_X509_SIG/#description","title":"DESCRIPTION","text":"<p>These functions decode and encode an X509_SIG structure which is equivalent to the DigestInfo structure defined in PKCS#1 and PKCS#7.</p> <p>Othewise these behave in a similar way to d2i_X509() and i2d_X509() described in the d2i_X509(3) manual page.</p>"},{"location":"man3/d2i_X509_SIG/#see-also","title":"SEE ALSO","text":"<p>d2i_X509(3)</p>"},{"location":"man3/d2i_X509_SIG/#history","title":"HISTORY","text":"<p>TBA</p>"},{"location":"man3/des/","title":"des","text":""},{"location":"man3/des/#name","title":"NAME","text":"<p>DES_random_key, DES_set_key, DES_key_sched, DES_set_key_checked, DES_set_key_unchecked, DES_set_odd_parity, DES_is_weak_key, DES_ecb_encrypt, DES_ecb2_encrypt, DES_ecb3_encrypt, DES_ncbc_encrypt, DES_cfb_encrypt, DES_ofb_encrypt, DES_pcbc_encrypt, DES_cfb64_encrypt, DES_ofb64_encrypt, DES_xcbc_encrypt, DES_ede2_cbc_encrypt, DES_ede2_cfb64_encrypt, DES_ede2_ofb64_encrypt, DES_ede3_cbc_encrypt, DES_ede3_cbcm_encrypt, DES_ede3_cfb64_encrypt, DES_ede3_ofb64_encrypt, DES_cbc_cksum, DES_quad_cksum, DES_string_to_key, DES_string_to_2keys, DES_fcrypt, DES_crypt, DES_enc_read, DES_enc_write - DES encryption</p>"},{"location":"man3/des/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/des.h&gt;\n\nvoid DES_random_key(DES_cblock *ret);\n\nint DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule);\nint DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule);\nint DES_set_key_checked(const_DES_cblock *key,\n       DES_key_schedule *schedule);\nvoid DES_set_key_unchecked(const_DES_cblock *key,\n       DES_key_schedule *schedule);\n\nvoid DES_set_odd_parity(DES_cblock *key);\nint DES_is_weak_key(const_DES_cblock *key);\n\nvoid DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output, \n       DES_key_schedule *ks, int enc);\nvoid DES_ecb2_encrypt(const_DES_cblock *input, DES_cblock *output, \n       DES_key_schedule *ks1, DES_key_schedule *ks2, int enc);\nvoid DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output, \n       DES_key_schedule *ks1, DES_key_schedule *ks2, \n       DES_key_schedule *ks3, int enc);\n\nvoid DES_ncbc_encrypt(const unsigned char *input, unsigned char *output, \n       long length, DES_key_schedule *schedule, DES_cblock *ivec, \n       int enc);\nvoid DES_cfb_encrypt(const unsigned char *in, unsigned char *out,\n       int numbits, long length, DES_key_schedule *schedule,\n       DES_cblock *ivec, int enc);\nvoid DES_ofb_encrypt(const unsigned char *in, unsigned char *out,\n       int numbits, long length, DES_key_schedule *schedule,\n       DES_cblock *ivec);\nvoid DES_pcbc_encrypt(const unsigned char *input, unsigned char *output, \n       long length, DES_key_schedule *schedule, DES_cblock *ivec, \n       int enc);\nvoid DES_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n       long length, DES_key_schedule *schedule, DES_cblock *ivec,\n       int *num, int enc);\nvoid DES_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n       long length, DES_key_schedule *schedule, DES_cblock *ivec,\n       int *num);\n\nvoid DES_xcbc_encrypt(const unsigned char *input, unsigned char *output, \n       long length, DES_key_schedule *schedule, DES_cblock *ivec, \n       const_DES_cblock *inw, const_DES_cblock *outw, int enc);\n\nvoid DES_ede2_cbc_encrypt(const unsigned char *input,\n       unsigned char *output, long length, DES_key_schedule *ks1,\n       DES_key_schedule *ks2, DES_cblock *ivec, int enc);\nvoid DES_ede2_cfb64_encrypt(const unsigned char *in,\n       unsigned char *out, long length, DES_key_schedule *ks1,\n       DES_key_schedule *ks2, DES_cblock *ivec, int *num, int enc);\nvoid DES_ede2_ofb64_encrypt(const unsigned char *in,\n       unsigned char *out, long length, DES_key_schedule *ks1,\n       DES_key_schedule *ks2, DES_cblock *ivec, int *num);\n\nvoid DES_ede3_cbc_encrypt(const unsigned char *input,\n       unsigned char *output, long length, DES_key_schedule *ks1,\n       DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec,\n       int enc);\nvoid DES_ede3_cbcm_encrypt(const unsigned char *in, unsigned char *out, \n       long length, DES_key_schedule *ks1, DES_key_schedule *ks2, \n       DES_key_schedule *ks3, DES_cblock *ivec1, DES_cblock *ivec2, \n       int enc);\nvoid DES_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out, \n       long length, DES_key_schedule *ks1, DES_key_schedule *ks2,\n       DES_key_schedule *ks3, DES_cblock *ivec, int *num, int enc);\nvoid DES_ede3_ofb64_encrypt(const unsigned char *in, unsigned char *out, \n       long length, DES_key_schedule *ks1, \n       DES_key_schedule *ks2, DES_key_schedule *ks3, \n       DES_cblock *ivec, int *num);\n\nDES_LONG DES_cbc_cksum(const unsigned char *input, DES_cblock *output, \n       long length, DES_key_schedule *schedule, \n       const_DES_cblock *ivec);\nDES_LONG DES_quad_cksum(const unsigned char *input, DES_cblock output[], \n       long length, int out_count, DES_cblock *seed);\nvoid DES_string_to_key(const char *str, DES_cblock *key);\nvoid DES_string_to_2keys(const char *str, DES_cblock *key1,\n       DES_cblock *key2);\n\nchar *DES_fcrypt(const char *buf, const char *salt, char *ret);\nchar *DES_crypt(const char *buf, const char *salt);\n\nint DES_enc_read(int fd, void *buf, int len, DES_key_schedule *sched,\n       DES_cblock *iv);\nint DES_enc_write(int fd, const void *buf, int len,\n       DES_key_schedule *sched, DES_cblock *iv);\n</code></pre>"},{"location":"man3/des/#description","title":"DESCRIPTION","text":"<p>This library contains a fast implementation of the DES encryption algorithm.</p> <p>There are two phases to the use of DES encryption.  The first is the generation of a DES_key_schedule from a key, the second is the actual encryption.  A DES key is of type DES_cblock. This type is consists of 8 bytes with odd parity.  The least significant bit in each byte is the parity bit.  The key schedule is an expanded form of the key; it is used to speed the encryption process.</p> <p>DES_random_key() generates a random key.  The PRNG must be seeded prior to using this function (see rand(3)).  If the PRNG could not generate a secure key, 0 is returned.</p> <p>Before a DES key can be used, it must be converted into the architecture dependent DES_key_schedule via the DES_set_key_checked() or DES_set_key_unchecked() function.</p> <p>DES_set_key_checked() will check that the key passed is of odd parity and is not a weak or semi-weak key.  If the parity is wrong, then -1 is returned.  If the key is a weak key, then -2 is returned.  If an error is returned, the key schedule is not generated.</p> <p>DES_set_key() works like DES_set_key_checked() if the DES_check_key flag is non-zero, otherwise like DES_set_key_unchecked().  These functions are available for compatibility; it is recommended to use a function that does not depend on a global variable.</p> <p>DES_set_odd_parity() sets the parity of the passed key to odd.</p> <p>DES_is_weak_key() returns 1 if the passed key is a weak key, 0 if it is ok.  </p> <p>The following routines mostly operate on an input and output stream of _DES_cblock_s.</p> <p>DES_ecb_encrypt() is the basic DES encryption routine that encrypts or decrypts a single 8-byte DES_cblock in electronic code book (ECB) mode.  It always transforms the input data, pointed to by input, into the output data, pointed to by the output argument. If the encrypt argument is non-zero (DES_ENCRYPT), the input (cleartext) is encrypted in to the output (ciphertext) using the key_schedule specified by the schedule argument, previously set via DES_set_key. If encrypt is zero (DES_DECRYPT), the input (now ciphertext) is decrypted into the output (now cleartext).  Input and output may overlap.  DES_ecb_encrypt() does not return a value.</p> <p>DES_ecb3_encrypt() encrypts/decrypts the input block by using three-key Triple-DES encryption in ECB mode.  This involves encrypting the input with ks1, decrypting with the key schedule ks2, and then encrypting with ks3.  This routine greatly reduces the chances of brute force breaking of DES and has the advantage of if ks1, ks2 and ks3 are the same, it is equivalent to just encryption using ECB mode and ks1 as the key.</p> <p>The macro DES_ecb2_encrypt() is provided to perform two-key Triple-DES encryption by using ks1 for the final encryption.</p> <p>DES_ncbc_encrypt() encrypts/decrypts using the cipher-block-chaining (CBC) mode of DES.  If the encrypt argument is non-zero, the routine cipher-block-chain encrypts the cleartext data pointed to by the input argument into the ciphertext pointed to by the output argument, using the key schedule provided by the schedule argument, and initialization vector provided by the ivec argument.  If the length argument is not an integral multiple of eight bytes, the last block is copied to a temporary area and zero filled.  The output is always an integral multiple of eight bytes.</p> <p>DES_xcbc_encrypt() is RSA's DESX mode of DES.  It uses inw and outw to 'whiten' the encryption.  inw and outw are secret (unlike the iv) and are as such, part of the key.  So the key is sort of 24 bytes.  This is much better than CBC DES.</p> <p>DES_ede3_cbc_encrypt() implements outer triple CBC DES encryption with three keys. This means that each DES operation inside the CBC mode is an <code>C=E(ks3,D(ks2,E(ks1,M)))</code>.  This mode is used by SSL.</p> <p>The DES_ede2_cbc_encrypt() macro implements two-key Triple-DES by reusing ks1 for the final encryption.  <code>C=E(ks1,D(ks2,E(ks1,M)))</code>. This form of Triple-DES is used by the RSAREF library.</p> <p>DES_pcbc_encrypt() encrypt/decrypts using the propagating cipher block chaining mode used by Kerberos v4. Its parameters are the same as DES_ncbc_encrypt().</p> <p>DES_cfb_encrypt() encrypt/decrypts using cipher feedback mode.  This method takes an array of characters as input and outputs and array of characters.  It does not require any padding to 8 character groups. Note: the ivec variable is changed and the new changed value needs to be passed to the next call to this function.  Since this function runs a complete DES ECB encryption per numbits, this function is only suggested for use when sending small numbers of characters.</p> <p>DES_cfb64_encrypt() implements CFB mode of DES with 64bit feedback.  Why is this useful you ask?  Because this routine will allow you to encrypt an arbitrary number of bytes, no 8 byte padding.  Each call to this routine will encrypt the input bytes to output and then update ivec and num.  num contains 'how far' we are though ivec.  If this does not make much sense, read more about cfb mode of DES :-).</p> <p>DES_ede3_cfb64_encrypt() and DES_ede2_cfb64_encrypt() is the same as DES_cfb64_encrypt() except that Triple-DES is used.</p> <p>DES_ofb_encrypt() encrypts using output feedback mode.  This method takes an array of characters as input and outputs and array of characters.  It does not require any padding to 8 character groups. Note: the ivec variable is changed and the new changed value needs to be passed to the next call to this function.  Since this function runs a complete DES ECB encryption per numbits, this function is only suggested for use when sending small numbers of characters.</p> <p>DES_ofb64_encrypt() is the same as DES_cfb64_encrypt() using Output Feed Back mode.</p> <p>DES_ede3_ofb64_encrypt() and DES_ede2_ofb64_encrypt() is the same as DES_ofb64_encrypt(), using Triple-DES.</p> <p>The following functions are included in the DES library for compatibility with the MIT Kerberos library.</p> <p>DES_cbc_cksum() produces an 8 byte checksum based on the input stream (via CBC encryption).  The last 4 bytes of the checksum are returned and the complete 8 bytes are placed in output. This function is used by Kerberos v4.  Other applications should use EVP_DigestInit(3) etc. instead.</p> <p>DES_quad_cksum() is a Kerberos v4 function.  It returns a 4 byte checksum from the input bytes.  The algorithm can be iterated over the input, depending on out_count, 1, 2, 3 or 4 times.  If output is non-NULL, the 8 bytes generated by each pass are written into output.</p> <p>The following are DES-based transformations:</p> <p>DES_fcrypt() is a fast version of the Unix crypt(3) function.  This version takes only a small amount of space relative to other fast crypt() implementations.  This is different to the normal crypt in that the third parameter is the buffer that the return value is written into.  It needs to be at least 14 bytes long.  This function is thread safe, unlike the normal crypt.</p> <p>DES_crypt() is a faster replacement for the normal system crypt(). This function calls DES_fcrypt() with a static array passed as the third parameter.  This emulates the normal non-thread safe semantics of crypt(3).</p> <p>DES_enc_write() writes len bytes to file descriptor fd from buffer buf. The data is encrypted via pcbc_encrypt (default) using sched for the key and iv as a starting vector.  The actual data send down fd consists of 4 bytes (in network byte order) containing the length of the following encrypted data.  The encrypted data then follows, padded with random data out to a multiple of 8 bytes.</p> <p>DES_enc_read() is used to read len bytes from file descriptor fd into buffer buf. The data being read from fd is assumed to have come from DES_enc_write() and is decrypted using sched for the key schedule and iv for the initial vector.</p> <p>Warning: The data format used by DES_enc_write() and DES_enc_read() has a cryptographic weakness: When asked to write more than MAXWRITE bytes, DES_enc_write() will split the data into several chunks that are all encrypted using the same IV.  So don't use these functions unless you are sure you know what you do (in which case you might not want to use them anyway).  They cannot handle non-blocking sockets. DES_enc_read() uses an internal state and thus cannot be used on multiple files.</p> <p>DES_rw_mode is used to specify the encryption mode to use with DES_enc_read() and DES_end_write().  If set to DES_PCBC_MODE (the default), DES_pcbc_encrypt is used.  If set to DES_CBC_MODE DES_cbc_encrypt is used.</p>"},{"location":"man3/des/#notes","title":"NOTES","text":"<p>Single-key DES is insecure due to its short key size.  ECB mode is not suitable for most applications; see des_modes(7).</p> <p>The evp(3) library provides higher-level encryption functions.</p>"},{"location":"man3/des/#bugs","title":"BUGS","text":"<p>DES_3cbc_encrypt() is flawed and must not be used in applications.</p> <p>DES_cbc_encrypt() does not modify ivec; use DES_ncbc_encrypt() instead.</p> <p>DES_cfb_encrypt() and DES_ofb_encrypt() operates on input of 8 bits. What this means is that if you set numbits to 12, and length to 2, the first 12 bits will come from the 1st input byte and the low half of the second input byte.  The second 12 bits will have the low 8 bits taken from the 3rd input byte and the top 4 bits taken from the 4th input byte.  The same holds for output.  This function has been implemented this way because most people will be using a multiple of 8 and because once you get into pulling bytes input bytes apart things get ugly!</p> <p>DES_string_to_key() is available for backward compatibility with the MIT library.  New applications should use a cryptographic hash function. The same applies for DES_string_to_2key().</p>"},{"location":"man3/des/#conforming-to","title":"CONFORMING TO","text":"<p>ANSI X3.106</p> <p>The des library was written to be source code compatible with the MIT Kerberos library.</p>"},{"location":"man3/des/#see-also","title":"SEE ALSO","text":"<p>crypt(3), des_modes(7), evp(3), rand(3)</p>"},{"location":"man3/des/#history","title":"HISTORY","text":"<p>In OpenSSL 0.9.7, all des_ functions were renamed to DES_ to avoid clashes with older versions of libdes.  Compatibility des_ functions are provided for a short while, as well as crypt(). Declarations for these are in &lt;openssl/des_old.h&gt;. There is no DES_ variant for des_random_seed(). This will happen to other functions as well if they are deemed redundant (des_random_seed() just calls RAND_seed() and is present for backward compatibility only), buggy or already scheduled for removal.</p> <p>des_cbc_cksum(), des_cbc_encrypt(), des_ecb_encrypt(), des_is_weak_key(), des_key_sched(), des_pcbc_encrypt(), des_quad_cksum(), des_random_key() and des_string_to_key() are available in the MIT Kerberos library; des_check_key_parity(), des_fixup_key_parity() and des_is_weak_key() are available in newer versions of that library.</p> <p>des_set_key_checked() and des_set_key_unchecked() were added in OpenSSL 0.9.5.</p> <p>des_generate_random_block(), des_init_random_number_generator(), des_new_random_key(), des_set_random_generator_seed() and des_set_sequence_number() and des_rand_data() are used in newer versions of Kerberos but are not implemented here.</p> <p>des_random_key() generated cryptographically weak random data in SSLeay and in OpenSSL prior version 0.9.5, as well as in the original MIT library.</p>"},{"location":"man3/des/#author","title":"AUTHOR","text":"<p>Eric Young (eay@cryptsoft.com). Modified for the OpenSSL project (http://www.openssl.org).</p>"},{"location":"man3/des_modes/","title":"des_modes","text":""},{"location":"man3/des_modes/#name","title":"NAME","text":"<p>des_modes - the variants of DES and other crypto algorithms of OpenSSL</p>"},{"location":"man3/des_modes/#description","title":"DESCRIPTION","text":"<p>Several crypto algorithms for OpenSSL can be used in a number of modes.  Those are used for using block ciphers in a way similar to stream ciphers, among other things.</p>"},{"location":"man3/des_modes/#overview","title":"OVERVIEW","text":""},{"location":"man3/des_modes/#electronic-codebook-mode-ecb","title":"Electronic Codebook Mode (ECB)","text":"<p>Normally, this is found as the function algorithm_ecb_encrypt().</p> <ul> <li>64 bits are enciphered at a time.</li> <li>The order of the blocks can be rearranged without detection.</li> <li>The same plaintext block always produces the same ciphertext block (for the same key) making it vulnerable to a 'dictionary attack'.</li> <li>An error will only affect one ciphertext block.</li> </ul>"},{"location":"man3/des_modes/#cipher-block-chaining-mode-cbc","title":"Cipher Block Chaining Mode (CBC)","text":"<p>Normally, this is found as the function algorithm_cbc_encrypt(). Be aware that des_cbc_encrypt() is not really DES CBC (it does not update the IV); use des_ncbc_encrypt() instead.</p> <ul> <li>a multiple of 64 bits are enciphered at a time.</li> <li>The CBC mode produces the same ciphertext whenever the same plaintext is encrypted using the same key and starting variable.</li> <li>The chaining operation makes the ciphertext blocks dependent on the current and all preceding plaintext blocks and therefore blocks can not be rearranged.</li> <li>The use of different starting variables prevents the same plaintext enciphering to the same ciphertext.</li> <li>An error will affect the current and the following ciphertext blocks.</li> </ul>"},{"location":"man3/des_modes/#cipher-feedback-mode-cfb","title":"Cipher Feedback Mode (CFB)","text":"<p>Normally, this is found as the function algorithm_cfb_encrypt().</p> <ul> <li>a number of bits (j) &lt;= 64 are enciphered at a time.</li> <li>The CFB mode produces the same ciphertext whenever the same plaintext is encrypted using the same key and starting variable.</li> <li>The chaining operation makes the ciphertext variables dependent on the current and all preceding variables and therefore j-bit variables are chained together and can not be rearranged.</li> <li>The use of different starting variables prevents the same plaintext enciphering to the same ciphertext.</li> <li>The strength of the CFB mode depends on the size of k (maximal if j == k).  In my implementation this is always the case.</li> <li>Selection of a small value for j will require more cycles through the encipherment algorithm per unit of plaintext and thus cause greater processing overheads.</li> <li>Only multiples of j bits can be enciphered.</li> <li>An error will affect the current and the following ciphertext variables.</li> </ul>"},{"location":"man3/des_modes/#output-feedback-mode-ofb","title":"Output Feedback Mode (OFB)","text":"<p>Normally, this is found as the function algorithm_ofb_encrypt().</p> <ul> <li>a number of bits (j) &lt;= 64 are enciphered at a time.</li> <li>The OFB mode produces the same ciphertext whenever the same plaintext enciphered using the same key and starting variable.  More over, in the OFB mode the same key stream is produced when the same key and start variable are used.  Consequently, for security reasons a specific start variable should be used only once for a given key.</li> <li>The absence of chaining makes the OFB more vulnerable to specific attacks.</li> <li>The use of different start variables values prevents the same plaintext enciphering to the same ciphertext, by producing different key streams.</li> <li>Selection of a small value for j will require more cycles through the encipherment algorithm per unit of plaintext and thus cause greater processing overheads.</li> <li>Only multiples of j bits can be enciphered.</li> <li>OFB mode of operation does not extend ciphertext errors in the resultant plaintext output.  Every bit error in the ciphertext causes only one bit to be in error in the deciphered plaintext.</li> <li>OFB mode is not self-synchronizing.  If the two operation of encipherment and decipherment get out of synchronism, the system needs to be re-initialized.</li> <li>Each re-initialization should use a value of the start variable different from the start variable values used before with the same key.  The reason for this is that an identical bit stream would be produced each time from the same parameters.  This would be susceptible to a 'known plaintext' attack.</li> </ul>"},{"location":"man3/des_modes/#triple-ecb-mode","title":"Triple ECB Mode","text":"<p>Normally, this is found as the function algorithm_ecb3_encrypt().</p> <ul> <li>Encrypt with key1, decrypt with key2 and encrypt with key3 again.</li> <li>As for ECB encryption but increases the key length to 168 bits. There are theoretic attacks that can be used that make the effective key length 112 bits, but this attack also requires 2^56 blocks of memory, not very likely, even for the NSA.</li> <li>If both keys are the same it is equivalent to encrypting once with just one key.</li> <li>If the first and last key are the same, the key length is 112 bits. There are attacks that could reduce the effective key strength to only slightly more than 56 bits, but these require a lot of memory.</li> <li>If all 3 keys are the same, this is effectively the same as normal ecb mode.</li> </ul>"},{"location":"man3/des_modes/#triple-cbc-mode","title":"Triple CBC Mode","text":"<p>Normally, this is found as the function algorithm_ede3_cbc_encrypt().</p> <ul> <li>Encrypt with key1, decrypt with key2 and then encrypt with key3.</li> <li>As for CBC encryption but increases the key length to 168 bits with the same restrictions as for triple ecb mode.</li> </ul>"},{"location":"man3/des_modes/#notes","title":"NOTES","text":"<p>This text was been written in large parts by Eric Young in his original documentation for SSLeay, the predecessor of OpenSSL.  In turn, he attributed it to:</p> <pre><code>    AS 2805.5.2\n    Australian Standard\n    Electronic funds transfer - Requirements for interfaces,\n    Part 5.2: Modes of operation for an n-bit block cipher algorithm\n    Appendix A\n</code></pre>"},{"location":"man3/des_modes/#see-also","title":"SEE ALSO","text":"<p>blowfish(3), des(3), idea(3), rc2(3)</p>"},{"location":"man3/dh/","title":"dh","text":""},{"location":"man3/dh/#name","title":"NAME","text":"<p>dh - Diffie-Hellman key agreement</p>"},{"location":"man3/dh/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dh.h&gt;\n#include &lt;openssl/engine.h&gt;\n\nDH *   DH_new(void);\nvoid   DH_free(DH *dh);\n\nint    DH_size(const DH *dh);\n\nDH *   DH_generate_parameters(int prime_len, int generator,\n               void (*callback)(int, int, void *), void *cb_arg);\nint    DH_check(const DH *dh, int *codes);\n\nint    DH_generate_key(DH *dh);\nint    DH_compute_key(unsigned char *key, BIGNUM *pub_key, DH *dh);\n\nvoid DH_set_default_method(const DH_METHOD *meth);\nconst DH_METHOD *DH_get_default_method(void);\nint DH_set_method(DH *dh, const DH_METHOD *meth);\nDH *DH_new_method(ENGINE *engine);\nconst DH_METHOD *DH_OpenSSL(void);\n\nint DH_get_ex_new_index(long argl, char *argp, int (*new_func)(),\n            int (*dup_func)(), void (*free_func)());\nint DH_set_ex_data(DH *d, int idx, char *arg);\nchar *DH_get_ex_data(DH *d, int idx);\n\nDH *   d2i_DHparams(DH **a, unsigned char **pp, long length);\nint    i2d_DHparams(const DH *a, unsigned char **pp);\n\nint    DHparams_print_fp(FILE *fp, const DH *x);\nint    DHparams_print(BIO *bp, const DH *x);\n</code></pre>"},{"location":"man3/dh/#description","title":"DESCRIPTION","text":"<p>These functions implement the Diffie-Hellman key agreement protocol. The generation of shared DH parameters is described in DH_generate_parameters(3); DH_generate_key(3) describes how to perform a key agreement.</p> <p>The DH structure consists of several BIGNUM components.</p> <pre><code>struct\n       {\n       BIGNUM *p;              // prime number (shared)\n       BIGNUM *g;              // generator of Z_p (shared)\n       BIGNUM *priv_key;       // private DH value x\n       BIGNUM *pub_key;        // public DH value g^x\n       // ...\n       };\nDH\n</code></pre> <p>Note that DH keys may use non-standard DH_METHOD implementations, either directly or by the use of ENGINE modules. In some cases (eg. an ENGINE providing support for hardware-embedded keys), these BIGNUM values will not be used by the implementation or may be used for alternative data storage. For this reason, applications should generally avoid using DH structure elements directly and instead use API functions to query or modify keys.</p>"},{"location":"man3/dh/#see-also","title":"SEE ALSO","text":"<p>dhparam(1), bn(3), dsa(3), err(3), rand(3), rsa(3), engine(3), DH_set_method(3), DH_new(3), DH_get_ex_new_index(3), DH_generate_parameters(3), DH_compute_key(3), d2i_DHparams(3), RSA_print(3) </p>"},{"location":"man3/dsa/","title":"dsa","text":""},{"location":"man3/dsa/#name","title":"NAME","text":"<p>dsa - Digital Signature Algorithm</p>"},{"location":"man3/dsa/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/dsa.h&gt;\n#include &lt;openssl/engine.h&gt;\n\nDSA *  DSA_new(void);\nvoid   DSA_free(DSA *dsa);\n\nint    DSA_size(const DSA *dsa);\n\nDSA *  DSA_generate_parameters(int bits, unsigned char *seed,\n               int seed_len, int *counter_ret, unsigned long *h_ret,\n               void (*callback)(int, int, void *), void *cb_arg);\n\nDH *   DSA_dup_DH(const DSA *r);\n\nint    DSA_generate_key(DSA *dsa);\n\nint    DSA_sign(int dummy, const unsigned char *dgst, int len,\n               unsigned char *sigret, unsigned int *siglen, DSA *dsa);\nint    DSA_sign_setup(DSA *dsa, BN_CTX *ctx, BIGNUM **kinvp,\n               BIGNUM **rp);\nint    DSA_verify(int dummy, const unsigned char *dgst, int len,\n               const unsigned char *sigbuf, int siglen, DSA *dsa);\n\nvoid DSA_set_default_method(const DSA_METHOD *meth);\nconst DSA_METHOD *DSA_get_default_method(void);\nint DSA_set_method(DSA *dsa, const DSA_METHOD *meth);\nDSA *DSA_new_method(ENGINE *engine);\nconst DSA_METHOD *DSA_OpenSSL(void);\n\nint DSA_get_ex_new_index(long argl, char *argp, int (*new_func)(),\n            int (*dup_func)(), void (*free_func)());\nint DSA_set_ex_data(DSA *d, int idx, char *arg);\nchar *DSA_get_ex_data(DSA *d, int idx);\n\nDSA_SIG *DSA_SIG_new(void);\nvoid   DSA_SIG_free(DSA_SIG *a);\nint    i2d_DSA_SIG(const DSA_SIG *a, unsigned char **pp);\nDSA_SIG *d2i_DSA_SIG(DSA_SIG **v, unsigned char **pp, long length);\n\nDSA_SIG *DSA_do_sign(const unsigned char *dgst, int dlen, DSA *dsa);\nint    DSA_do_verify(const unsigned char *dgst, int dgst_len,\n            DSA_SIG *sig, DSA *dsa);\n\nDSA *  d2i_DSAPublicKey(DSA **a, unsigned char **pp, long length);\nDSA *  d2i_DSAPrivateKey(DSA **a, unsigned char **pp, long length);\nDSA *  d2i_DSAparams(DSA **a, unsigned char **pp, long length);\nint    i2d_DSAPublicKey(const DSA *a, unsigned char **pp);\nint    i2d_DSAPrivateKey(const DSA *a, unsigned char **pp);\nint    i2d_DSAparams(const DSA *a,unsigned char **pp);\n\nint    DSAparams_print(BIO *bp, const DSA *x);\nint    DSAparams_print_fp(FILE *fp, const DSA *x);\nint    DSA_print(BIO *bp, const DSA *x, int off);\nint    DSA_print_fp(FILE *bp, const DSA *x, int off);\n</code></pre>"},{"location":"man3/dsa/#description","title":"DESCRIPTION","text":"<p>These functions implement the Digital Signature Algorithm (DSA).  The generation of shared DSA parameters is described in DSA_generate_parameters(3); DSA_generate_key(3) describes how to generate a signature key. Signature generation and verification are described in DSA_sign(3).</p> <p>The DSA structure consists of several BIGNUM components.</p> <pre><code>struct\n       {\n       BIGNUM *p;              // prime number (public)\n       BIGNUM *q;              // 160-bit subprime, q | p-1 (public)\n       BIGNUM *g;              // generator of subgroup (public)\n       BIGNUM *priv_key;       // private key x\n       BIGNUM *pub_key;        // public key y = g^x\n       // ...\n       }\nDSA;\n</code></pre> <p>In public keys, priv_key is NULL.</p> <p>Note that DSA keys may use non-standard DSA_METHOD implementations, either directly or by the use of ENGINE modules. In some cases (eg. an ENGINE providing support for hardware-embedded keys), these BIGNUM values will not be used by the implementation or may be used for alternative data storage. For this reason, applications should generally avoid using DSA structure elements directly and instead use API functions to query or modify keys.</p>"},{"location":"man3/dsa/#conforming-to","title":"CONFORMING TO","text":"<p>US Federal Information Processing Standard FIPS 186 (Digital Signature Standard, DSS), ANSI X9.30</p>"},{"location":"man3/dsa/#see-also","title":"SEE ALSO","text":"<p>bn(3), dh(3), err(3), rand(3), rsa(3), sha(3), engine(3), DSA_new(3), DSA_size(3), DSA_generate_parameters(3), DSA_dup_DH(3), DSA_generate_key(3), DSA_sign(3), DSA_set_method(3), DSA_get_ex_new_index(3), RSA_print(3)</p>"},{"location":"man3/ec/","title":"ec","text":""},{"location":"man3/ec/#name","title":"NAME","text":"<p>ec - Elliptic Curve functions</p>"},{"location":"man3/ec/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ec.h&gt;\n#include &lt;openssl/bn.h&gt;\n\nconst EC_METHOD *EC_GFp_simple_method(void);\nconst EC_METHOD *EC_GFp_mont_method(void);\nconst EC_METHOD *EC_GFp_nist_method(void);\nconst EC_METHOD *EC_GFp_nistp224_method(void);\nconst EC_METHOD *EC_GFp_nistp256_method(void);\nconst EC_METHOD *EC_GFp_nistp521_method(void);\n\nconst EC_METHOD *EC_GF2m_simple_method(void);\n\nEC_GROUP *EC_GROUP_new(const EC_METHOD *meth);\nvoid EC_GROUP_free(EC_GROUP *group);\nvoid EC_GROUP_clear_free(EC_GROUP *group);\nint EC_GROUP_copy(EC_GROUP *dst, const EC_GROUP *src);\nEC_GROUP *EC_GROUP_dup(const EC_GROUP *src);\nconst EC_METHOD *EC_GROUP_method_of(const EC_GROUP *group);\nint EC_METHOD_get_field_type(const EC_METHOD *meth);\nint EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator, const BIGNUM *order, const BIGNUM *cofactor);\nconst EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group);\nint EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx);\nint EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor, BN_CTX *ctx);\nvoid EC_GROUP_set_curve_name(EC_GROUP *group, int nid);\nint EC_GROUP_get_curve_name(const EC_GROUP *group);\nvoid EC_GROUP_set_asn1_flag(EC_GROUP *group, int flag);\nint EC_GROUP_get_asn1_flag(const EC_GROUP *group);\nvoid EC_GROUP_set_point_conversion_form(EC_GROUP *group, point_conversion_form_t form);\npoint_conversion_form_t EC_GROUP_get_point_conversion_form(const EC_GROUP *);\nunsigned char *EC_GROUP_get0_seed(const EC_GROUP *x);\nsize_t EC_GROUP_get_seed_len(const EC_GROUP *);\nsize_t EC_GROUP_set_seed(EC_GROUP *, const unsigned char *, size_t len);\nint EC_GROUP_set_curve_GFp(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);\nint EC_GROUP_get_curve_GFp(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\nint EC_GROUP_set_curve_GF2m(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);\nint EC_GROUP_get_curve_GF2m(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\nint EC_GROUP_get_degree(const EC_GROUP *group);\nint EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx);\nint EC_GROUP_check_discriminant(const EC_GROUP *group, BN_CTX *ctx);\nint EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx);\nEC_GROUP *EC_GROUP_new_curve_GFp(const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);\nEC_GROUP *EC_GROUP_new_curve_GF2m(const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);\nEC_GROUP *EC_GROUP_new_by_curve_name(int nid);\n\nsize_t EC_get_builtin_curves(EC_builtin_curve *r, size_t nitems);\n\nEC_POINT *EC_POINT_new(const EC_GROUP *group);\nvoid EC_POINT_free(EC_POINT *point);\nvoid EC_POINT_clear_free(EC_POINT *point);\nint EC_POINT_copy(EC_POINT *dst, const EC_POINT *src);\nEC_POINT *EC_POINT_dup(const EC_POINT *src, const EC_GROUP *group);\nconst EC_METHOD *EC_POINT_method_of(const EC_POINT *point);\nint EC_POINT_set_to_infinity(const EC_GROUP *group, EC_POINT *point);\nint EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,\n       const BIGNUM *x, const BIGNUM *y, const BIGNUM *z, BN_CTX *ctx);\nint EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group,\n       const EC_POINT *p, BIGNUM *x, BIGNUM *y, BIGNUM *z, BN_CTX *ctx);\nint EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,\n       const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx);\nint EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *group,\n       const EC_POINT *p, BIGNUM *x, BIGNUM *y, BN_CTX *ctx);\nint EC_POINT_set_compressed_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,\n       const BIGNUM *x, int y_bit, BN_CTX *ctx);\nint EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group, EC_POINT *p,\n       const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx);\nint EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *group,\n       const EC_POINT *p, BIGNUM *x, BIGNUM *y, BN_CTX *ctx);\nint EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *group, EC_POINT *p,\n       const BIGNUM *x, int y_bit, BN_CTX *ctx);\nsize_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *p,\n       point_conversion_form_t form,\n       unsigned char *buf, size_t len, BN_CTX *ctx);\nint EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *p,\n       const unsigned char *buf, size_t len, BN_CTX *ctx);\nBIGNUM *EC_POINT_point2bn(const EC_GROUP *, const EC_POINT *,\n       point_conversion_form_t form, BIGNUM *, BN_CTX *);\nEC_POINT *EC_POINT_bn2point(const EC_GROUP *, const BIGNUM *,\n       EC_POINT *, BN_CTX *);\nchar *EC_POINT_point2hex(const EC_GROUP *, const EC_POINT *,\n       point_conversion_form_t form, BN_CTX *);\nEC_POINT *EC_POINT_hex2point(const EC_GROUP *, const char *,\n       EC_POINT *, BN_CTX *);\n\nint EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx);\nint EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, BN_CTX *ctx);\nint EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx);\nint EC_POINT_is_at_infinity(const EC_GROUP *group, const EC_POINT *p);\nint EC_POINT_is_on_curve(const EC_GROUP *group, const EC_POINT *point, BN_CTX *ctx);\nint EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx);\nint EC_POINT_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx);\nint EC_POINTs_make_affine(const EC_GROUP *group, size_t num, EC_POINT *points[], BN_CTX *ctx);\nint EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n, size_t num, const EC_POINT *p[], const BIGNUM *m[], BN_CTX *ctx);\nint EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n, const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);\nint EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx);\nint EC_GROUP_have_precompute_mult(const EC_GROUP *group);\n\nint EC_GROUP_get_basis_type(const EC_GROUP *);\nint EC_GROUP_get_trinomial_basis(const EC_GROUP *, unsigned int *k);\nint EC_GROUP_get_pentanomial_basis(const EC_GROUP *, unsigned int *k1, \n       unsigned int *k2, unsigned int *k3);\nEC_GROUP *d2i_ECPKParameters(EC_GROUP **, const unsigned char **in, long len);\nint i2d_ECPKParameters(const EC_GROUP *, unsigned char **out);\n#define d2i_ECPKParameters_bio(bp,x) ASN1_d2i_bio_of(EC_GROUP,NULL,d2i_ECPKParameters,bp,x)\n#define i2d_ECPKParameters_bio(bp,x) ASN1_i2d_bio_of_const(EC_GROUP,i2d_ECPKParameters,bp,x)\n#define d2i_ECPKParameters_fp(fp,x) (EC_GROUP *)ASN1_d2i_fp(NULL, \\\n               (char *(*)())d2i_ECPKParameters,(fp),(unsigned char **)(x))\n#define i2d_ECPKParameters_fp(fp,x) ASN1_i2d_fp(i2d_ECPKParameters,(fp), \\\n               (unsigned char *)(x))\nint     ECPKParameters_print(BIO *bp, const EC_GROUP *x, int off);\nint     ECPKParameters_print_fp(FILE *fp, const EC_GROUP *x, int off);\n\nEC_KEY *EC_KEY_new(void);\nint EC_KEY_get_flags(const EC_KEY *key);\nvoid EC_KEY_set_flags(EC_KEY *key, int flags);\nvoid EC_KEY_clear_flags(EC_KEY *key, int flags);\nEC_KEY *EC_KEY_new_by_curve_name(int nid);\nvoid EC_KEY_free(EC_KEY *key);\nEC_KEY *EC_KEY_copy(EC_KEY *dst, const EC_KEY *src);\nEC_KEY *EC_KEY_dup(const EC_KEY *src);\nint EC_KEY_up_ref(EC_KEY *key);\nconst EC_GROUP *EC_KEY_get0_group(const EC_KEY *key);\nint EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group);\nconst BIGNUM *EC_KEY_get0_private_key(const EC_KEY *key);\nint EC_KEY_set_private_key(EC_KEY *key, const BIGNUM *prv);\nconst EC_POINT *EC_KEY_get0_public_key(const EC_KEY *key);\nint EC_KEY_set_public_key(EC_KEY *key, const EC_POINT *pub);\nunsigned EC_KEY_get_enc_flags(const EC_KEY *key);\nvoid EC_KEY_set_enc_flags(EC_KEY *eckey, unsigned int flags);\npoint_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *key);\nvoid EC_KEY_set_conv_form(EC_KEY *eckey, point_conversion_form_t cform);\nvoid *EC_KEY_get_key_method_data(EC_KEY *key, \n       void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *));\nvoid EC_KEY_insert_key_method_data(EC_KEY *key, void *data,\n       void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *));\nvoid EC_KEY_set_asn1_flag(EC_KEY *eckey, int asn1_flag);\nint EC_KEY_precompute_mult(EC_KEY *key, BN_CTX *ctx);\nint EC_KEY_generate_key(EC_KEY *key);\nint EC_KEY_check_key(const EC_KEY *key);\nint EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x, BIGNUM *y);\n\nEC_KEY *d2i_ECPrivateKey(EC_KEY **key, const unsigned char **in, long len);\nint i2d_ECPrivateKey(EC_KEY *key, unsigned char **out);\n\nEC_KEY *d2i_ECParameters(EC_KEY **key, const unsigned char **in, long len);\nint i2d_ECParameters(EC_KEY *key, unsigned char **out);\n\nEC_KEY *o2i_ECPublicKey(EC_KEY **key, const unsigned char **in, long len);\nint i2o_ECPublicKey(EC_KEY *key, unsigned char **out);\nint    ECParameters_print(BIO *bp, const EC_KEY *key);\nint    EC_KEY_print(BIO *bp, const EC_KEY *key, int off);\nint    ECParameters_print_fp(FILE *fp, const EC_KEY *key);\nint    EC_KEY_print_fp(FILE *fp, const EC_KEY *key, int off);\n#define ECParameters_dup(x) ASN1_dup_of(EC_KEY,i2d_ECParameters,d2i_ECParameters,x)\n#define EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx, nid) \\\n       EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, EVP_PKEY_OP_PARAMGEN, \\\n                               EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID, nid, NULL)\n</code></pre>"},{"location":"man3/ec/#description","title":"DESCRIPTION","text":"<p>This library provides an extensive set of functions for performing operations on elliptic curves over finite fields. In general an elliptic curve is one with an equation of the form:</p> <p>y^2 = x^3 + ax + b</p> <p>An EC_GROUP structure is used to represent the definition of an elliptic curve. Points on a curve are stored using an EC_POINT structure. An EC_KEY is used to hold a private/public key pair, where a private key is simply a BIGNUM and a public key is a point on a curve (represented by an EC_POINT).</p> <p>The library contains a number of alternative implementations of the different functions. Each implementation is optimised for different scenarios. No matter which implementation is being used, the interface remains the same. The library handles calling the correct implementation when an interface function is invoked. An implementation is represented by an EC_METHOD structure.</p> <p>The creation and destruction of EC_GROUP objects is described in EC_GROUP_new(3). Functions for manipulating EC_GROUP objects are described in EC_GROUP_copy(3).</p> <p>Functions for creating, destroying and manipulating EC_POINT objects are explained in EC_POINT_new(3), whilst functions for performing mathematical operations and tests on EC_POINTs are coverd in EC_POINT_add(3).</p> <p>For working with private and public keys refer to EC_KEY_new(3). Implementations are covered in EC_GFp_simple_method(3).</p> <p>For information on encoding and decoding curve parameters to and from ASN1 see d2i_ECPKParameters(3).</p>"},{"location":"man3/ec/#see-also","title":"SEE ALSO","text":"<p>crypto(3), EC_GROUP_new(3), EC_GROUP_copy(3), EC_POINT_new(3), EC_POINT_add(3), EC_KEY_new(3), EC_GFp_simple_method(3), d2i_ECPKParameters(3)</p>"},{"location":"man3/ecdsa/","title":"ecdsa","text":""},{"location":"man3/ecdsa/#name","title":"NAME","text":"<p>ECDSA_SIG_new, ECDSA_SIG_free, i2d_ECDSA_SIG, d2i_ECDSA_SIG, ECDSA_size, ECDSA_sign_setup, ECDSA_sign, ECDSA_sign_ex, ECDSA_verify, ECDSA_do_sign, ECDSA_do_sign_ex, ECDSA_do_verify - Elliptic Curve Digital Signature Algorithm</p>"},{"location":"man3/ecdsa/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ecdsa.h&gt;\n\nECDSA_SIG*     ECDSA_SIG_new(void);\nvoid           ECDSA_SIG_free(ECDSA_SIG *sig);\nint            i2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp);\nECDSA_SIG*     d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, \n               long len);\n\nECDSA_SIG*     ECDSA_do_sign(const unsigned char *dgst, int dgst_len,\n                       EC_KEY *eckey);\nECDSA_SIG*     ECDSA_do_sign_ex(const unsigned char *dgst, int dgstlen, \n                       const BIGNUM *kinv, const BIGNUM *rp,\n                       EC_KEY *eckey);\nint            ECDSA_do_verify(const unsigned char *dgst, int dgst_len,\n                       const ECDSA_SIG *sig, EC_KEY* eckey);\nint            ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx,\n                       BIGNUM **kinv, BIGNUM **rp);\nint            ECDSA_sign(int type, const unsigned char *dgst,\n                       int dgstlen, unsigned char *sig,\n                       unsigned int *siglen, EC_KEY *eckey);\nint            ECDSA_sign_ex(int type, const unsigned char *dgst,\n                       int dgstlen, unsigned char *sig,\n                       unsigned int *siglen, const BIGNUM *kinv, \n                       const BIGNUM *rp, EC_KEY *eckey);\nint            ECDSA_verify(int type, const unsigned char *dgst,\n                       int dgstlen, const unsigned char *sig,\n                       int siglen, EC_KEY *eckey);\nint            ECDSA_size(const EC_KEY *eckey);\n\nconst ECDSA_METHOD*    ECDSA_OpenSSL(void);\nvoid           ECDSA_set_default_method(const ECDSA_METHOD *meth);\nconst ECDSA_METHOD*    ECDSA_get_default_method(void);\nint            ECDSA_set_method(EC_KEY *eckey,const ECDSA_METHOD *meth);\n\nint            ECDSA_get_ex_new_index(long argl, void *argp,\n                       CRYPTO_EX_new *new_func,\n                       CRYPTO_EX_dup *dup_func,\n                       CRYPTO_EX_free *free_func);\nint            ECDSA_set_ex_data(EC_KEY *d, int idx, void *arg);\nvoid*          ECDSA_get_ex_data(EC_KEY *d, int idx);\n</code></pre>"},{"location":"man3/ecdsa/#description","title":"DESCRIPTION","text":"<p>The ECDSA_SIG structure consists of two BIGNUMs for the r and s value of a ECDSA signature (see X9.62 or FIPS 186-2).</p> <pre><code>struct\n       {\n       BIGNUM *r;\n       BIGNUM *s;\n} ECDSA_SIG;\n</code></pre> <p>ECDSA_SIG_new() allocates a new ECDSA_SIG structure (note: this function also allocates the BIGNUMs) and initialize it.</p> <p>ECDSA_SIG_free() frees the ECDSA_SIG structure sig.</p> <p>i2d_ECDSA_SIG() creates the DER encoding of the ECDSA signature sig and writes the encoded signature to *pp (note: if pp is NULL i2d_ECDSA_SIG returns the expected length in bytes of  the DER encoded signature). i2d_ECDSA_SIG returns the length of the DER encoded signature (or 0 on error).</p> <p>d2i_ECDSA_SIG() decodes a DER encoded ECDSA signature and returns the decoded signature in a newly allocated ECDSA_SIG structure. *sig points to the buffer containing the DER encoded signature of size len.</p> <p>ECDSA_size() returns the maximum length of a DER encoded ECDSA signature created with the private EC key eckey.</p> <p>ECDSA_sign_setup() may be used to precompute parts of the signing operation. eckey is the private EC key and ctx is a pointer to BN_CTX structure (or NULL). The precomputed values or returned in kinv and rp and can be used in a later call to ECDSA_sign_ex or ECDSA_do_sign_ex.</p> <p>ECDSA_sign() is wrapper function for ECDSA_sign_ex with kinv and rp set to NULL.</p> <p>ECDSA_sign_ex() computes a digital signature of the dgstlen bytes hash value dgst using the private EC key eckey and the optional pre-computed values kinv and rp. The DER encoded signatures is stored in sig and it's length is returned in sig_len. Note: sig must point to ECDSA_size bytes of memory. The parameter type is ignored.</p> <p>ECDSA_verify() verifies that the signature in sig of size siglen is a valid ECDSA signature of the hash value dgst of size dgstlen using the public key eckey. The parameter type is ignored.</p> <p>ECDSA_do_sign() is wrapper function for ECDSA_do_sign_ex with kinv and rp set to NULL.</p> <p>ECDSA_do_sign_ex() computes a digital signature of the dgst_len bytes hash value dgst using the private key eckey and the optional pre-computed values kinv and rp. The signature is returned in a newly allocated ECDSA_SIG structure (or NULL on error).</p> <p>ECDSA_do_verify() verifies that the signature sig is a valid ECDSA signature of the hash value dgst of size dgst_len using the public key eckey.</p>"},{"location":"man3/ecdsa/#return-values","title":"RETURN VALUES","text":"<p>ECDSA_SIG_new() returns NULL if the allocation fails.</p> <p>ECDSA_size() returns the maximum length signature or 0 on error.</p> <p>ECDSA_sign_setup() and ECDSA_sign() return 1 if successful or 0 on error.</p> <p>ECDSA_verify() and ECDSA_do_verify() return 1 for a valid signature, 0 for an invalid signature and -1 on error. The error codes can be obtained by ERR_get_error(3).</p>"},{"location":"man3/ecdsa/#examples","title":"EXAMPLES","text":"<p>Creating a ECDSA signature of given SHA-1 hash value using the named curve secp192k1.</p> <p>First step: create a EC_KEY object (note: this part is not ECDSA specific)</p> <pre><code>int        ret;\nECDSA_SIG *sig;\nEC_KEY    *eckey;\neckey = EC_KEY_new_by_curve_name(NID_secp192k1);\nif (eckey == NULL)\n       {\n       /* error */\n       }\nif (!EC_KEY_generate_key(eckey))\n       {\n       /* error */\n       }\n</code></pre> <p>Second step: compute the ECDSA signature of a SHA-1 hash value  using ECDSA_do_sign </p> <pre><code>sig = ECDSA_do_sign(digest, 20, eckey);\nif (sig == NULL)\n       {\n       /* error */\n       }\n</code></pre> <p>or using ECDSA_sign</p> <pre><code>unsigned char *buffer, *pp;\nint            buf_len;\nbuf_len = ECDSA_size(eckey);\nbuffer  = OPENSSL_malloc(buf_len);\npp = buffer;\nif (!ECDSA_sign(0, dgst, dgstlen, pp, &amp;buf_len, eckey);\n       {\n       /* error */\n       }\n</code></pre> <p>Third step: verify the created ECDSA signature using ECDSA_do_verify</p> <pre><code>ret = ECDSA_do_verify(digest, 20, sig, eckey);\n</code></pre> <p>or using ECDSA_verify</p> <pre><code>ret = ECDSA_verify(0, digest, 20, buffer, buf_len, eckey);\n</code></pre> <p>and finally evaluate the return value:</p> <pre><code>if (ret == -1)\n       {\n       /* error */\n       }\nelse if (ret == 0)\n       {\n       /* incorrect signature */\n       }\nelse   /* ret == 1 */\n       {\n       /* signature ok */\n       }\n</code></pre>"},{"location":"man3/ecdsa/#conforming-to","title":"CONFORMING TO","text":"<p>ANSI X9.62, US Federal Information Processing Standard FIPS 186-2 (Digital Signature Standard, DSS)</p>"},{"location":"man3/ecdsa/#see-also","title":"SEE ALSO","text":"<p>dsa(3), rsa(3)</p>"},{"location":"man3/ecdsa/#history","title":"HISTORY","text":"<p>The ecdsa implementation was first introduced in OpenSSL 0.9.8</p>"},{"location":"man3/ecdsa/#author","title":"AUTHOR","text":"<p>Nils Larsch for the OpenSSL project (http://www.openssl.org).</p>"},{"location":"man3/engine/","title":"engine","text":""},{"location":"man3/engine/#name","title":"NAME","text":"<p>engine - ENGINE cryptographic module support</p>"},{"location":"man3/engine/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/engine.h&gt;\n\nENGINE *ENGINE_get_first(void);\nENGINE *ENGINE_get_last(void);\nENGINE *ENGINE_get_next(ENGINE *e);\nENGINE *ENGINE_get_prev(ENGINE *e);\n\nint ENGINE_add(ENGINE *e);\nint ENGINE_remove(ENGINE *e);\n\nENGINE *ENGINE_by_id(const char *id);\n\nint ENGINE_init(ENGINE *e);\nint ENGINE_finish(ENGINE *e);\n\nvoid ENGINE_load_openssl(void);\nvoid ENGINE_load_dynamic(void);\n#ifndef OPENSSL_NO_STATIC_ENGINE\nvoid ENGINE_load_4758cca(void);\nvoid ENGINE_load_aep(void);\nvoid ENGINE_load_atalla(void);\nvoid ENGINE_load_chil(void);\nvoid ENGINE_load_cswift(void);\nvoid ENGINE_load_gmp(void);\nvoid ENGINE_load_nuron(void);\nvoid ENGINE_load_sureware(void);\nvoid ENGINE_load_ubsec(void);\n#endif\nvoid ENGINE_load_cryptodev(void);\nvoid ENGINE_load_builtin_engines(void);\n\nvoid ENGINE_cleanup(void);\n\nENGINE *ENGINE_get_default_RSA(void);\nENGINE *ENGINE_get_default_DSA(void);\nENGINE *ENGINE_get_default_ECDH(void);\nENGINE *ENGINE_get_default_ECDSA(void);\nENGINE *ENGINE_get_default_DH(void);\nENGINE *ENGINE_get_default_RAND(void);\nENGINE *ENGINE_get_cipher_engine(int nid);\nENGINE *ENGINE_get_digest_engine(int nid);\n\nint ENGINE_set_default_RSA(ENGINE *e);\nint ENGINE_set_default_DSA(ENGINE *e);\nint ENGINE_set_default_ECDH(ENGINE *e);\nint ENGINE_set_default_ECDSA(ENGINE *e);\nint ENGINE_set_default_DH(ENGINE *e);\nint ENGINE_set_default_RAND(ENGINE *e);\nint ENGINE_set_default_ciphers(ENGINE *e);\nint ENGINE_set_default_digests(ENGINE *e);\nint ENGINE_set_default_string(ENGINE *e, const char *list);\n\nint ENGINE_set_default(ENGINE *e, unsigned int flags);\n\nunsigned int ENGINE_get_table_flags(void);\nvoid ENGINE_set_table_flags(unsigned int flags);\n\nint ENGINE_register_RSA(ENGINE *e);\nvoid ENGINE_unregister_RSA(ENGINE *e);\nvoid ENGINE_register_all_RSA(void);\nint ENGINE_register_DSA(ENGINE *e);\nvoid ENGINE_unregister_DSA(ENGINE *e);\nvoid ENGINE_register_all_DSA(void);\nint ENGINE_register_ECDH(ENGINE *e);\nvoid ENGINE_unregister_ECDH(ENGINE *e);\nvoid ENGINE_register_all_ECDH(void);\nint ENGINE_register_ECDSA(ENGINE *e);\nvoid ENGINE_unregister_ECDSA(ENGINE *e);\nvoid ENGINE_register_all_ECDSA(void);\nint ENGINE_register_DH(ENGINE *e);\nvoid ENGINE_unregister_DH(ENGINE *e);\nvoid ENGINE_register_all_DH(void);\nint ENGINE_register_RAND(ENGINE *e);\nvoid ENGINE_unregister_RAND(ENGINE *e);\nvoid ENGINE_register_all_RAND(void);\nint ENGINE_register_STORE(ENGINE *e);\nvoid ENGINE_unregister_STORE(ENGINE *e);\nvoid ENGINE_register_all_STORE(void);\nint ENGINE_register_ciphers(ENGINE *e);\nvoid ENGINE_unregister_ciphers(ENGINE *e);\nvoid ENGINE_register_all_ciphers(void);\nint ENGINE_register_digests(ENGINE *e);\nvoid ENGINE_unregister_digests(ENGINE *e);\nvoid ENGINE_register_all_digests(void);\nint ENGINE_register_complete(ENGINE *e);\nint ENGINE_register_all_complete(void);\n\nint ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void));\nint ENGINE_cmd_is_executable(ENGINE *e, int cmd);\nint ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,\n        long i, void *p, void (*f)(void), int cmd_optional);\nint ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,\n        int cmd_optional);\n\nint ENGINE_set_ex_data(ENGINE *e, int idx, void *arg);\nvoid *ENGINE_get_ex_data(const ENGINE *e, int idx);\n\nint ENGINE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\n        CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);\n\nENGINE *ENGINE_new(void);\nint ENGINE_free(ENGINE *e);\nint ENGINE_up_ref(ENGINE *e);\n\nint ENGINE_set_id(ENGINE *e, const char *id);\nint ENGINE_set_name(ENGINE *e, const char *name);\nint ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth);\nint ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth);\nint ENGINE_set_ECDH(ENGINE *e, const ECDH_METHOD *dh_meth);\nint ENGINE_set_ECDSA(ENGINE *e, const ECDSA_METHOD *dh_meth);\nint ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth);\nint ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth);\nint ENGINE_set_STORE(ENGINE *e, const STORE_METHOD *rand_meth);\nint ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f);\nint ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f);\nint ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR finish_f);\nint ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f);\nint ENGINE_set_load_privkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpriv_f);\nint ENGINE_set_load_pubkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpub_f);\nint ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f);\nint ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f);\nint ENGINE_set_flags(ENGINE *e, int flags);\nint ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns);\n\nconst char *ENGINE_get_id(const ENGINE *e);\nconst char *ENGINE_get_name(const ENGINE *e);\nconst RSA_METHOD *ENGINE_get_RSA(const ENGINE *e);\nconst DSA_METHOD *ENGINE_get_DSA(const ENGINE *e);\nconst ECDH_METHOD *ENGINE_get_ECDH(const ENGINE *e);\nconst ECDSA_METHOD *ENGINE_get_ECDSA(const ENGINE *e);\nconst DH_METHOD *ENGINE_get_DH(const ENGINE *e);\nconst RAND_METHOD *ENGINE_get_RAND(const ENGINE *e);\nconst STORE_METHOD *ENGINE_get_STORE(const ENGINE *e);\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e);\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e);\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e);\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e);\nENGINE_LOAD_KEY_PTR ENGINE_get_load_privkey_function(const ENGINE *e);\nENGINE_LOAD_KEY_PTR ENGINE_get_load_pubkey_function(const ENGINE *e);\nENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e);\nENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e);\nconst EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid);\nconst EVP_MD *ENGINE_get_digest(ENGINE *e, int nid);\nint ENGINE_get_flags(const ENGINE *e);\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e);\n\nEVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,\n    UI_METHOD *ui_method, void *callback_data);\nEVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char *key_id,\n    UI_METHOD *ui_method, void *callback_data);\n\nvoid ENGINE_add_conf_module(void);\n</code></pre>"},{"location":"man3/engine/#description","title":"DESCRIPTION","text":"<p>These functions create, manipulate, and use cryptographic modules in the form of ENGINE objects. These objects act as containers for implementations of cryptographic algorithms, and support a reference-counted mechanism to allow them to be dynamically loaded in and out of the running application.</p> <p>The cryptographic functionality that can be provided by an ENGINE implementation includes the following abstractions;</p> <pre><code>RSA_METHOD - for providing alternative RSA implementations\nDSA_METHOD, DH_METHOD, RAND_METHOD, ECDH_METHOD, ECDSA_METHOD,\n      STORE_METHOD - similarly for other OpenSSL APIs\nEVP_CIPHER - potentially multiple cipher algorithms (indexed by 'nid')\nEVP_DIGEST - potentially multiple hash algorithms (indexed by 'nid')\nkey-loading - loading public and/or private EVP_PKEY keys\n</code></pre>"},{"location":"man3/engine/#reference-counting-and-handles","title":"Reference counting and handles","text":"<p>Due to the modular nature of the ENGINE API, pointers to ENGINEs need to be treated as handles - ie. not only as pointers, but also as references to the underlying ENGINE object. Ie. one should obtain a new reference when making copies of an ENGINE pointer if the copies will be used (and released) independently.</p> <p>ENGINE objects have two levels of reference-counting to match the way in which the objects are used. At the most basic level, each ENGINE pointer is inherently a structural reference - a structural reference is required to use the pointer value at all, as this kind of reference is a guarantee that the structure can not be deallocated until the reference is released.</p> <p>However, a structural reference provides no guarantee that the ENGINE is initialised and able to use any of its cryptographic implementations. Indeed it's quite possible that most ENGINEs will not initialise at all in typical environments, as ENGINEs are typically used to support specialised hardware. To use an ENGINE's functionality, you need a functional reference. This kind of reference can be considered a specialised form of structural reference, because each functional reference implicitly contains a structural reference as well - however to avoid difficult-to-find programming bugs, it is recommended to treat the two kinds of reference independently. If you have a functional reference to an ENGINE, you have a guarantee that the ENGINE has been initialised and is ready to perform cryptographic operations, and will remain initialised until after you have released your reference.</p> <p>Structural references</p> <p>This basic type of reference is used for instantiating new ENGINEs, iterating across OpenSSL's internal linked-list of loaded ENGINEs, reading information about an ENGINE, etc. Essentially a structural reference is sufficient if you only need to query or manipulate the data of an ENGINE implementation rather than use its functionality.</p> <p>The ENGINE_new() function returns a structural reference to a new (empty) ENGINE object. There are other ENGINE API functions that return structural references such as; ENGINE_by_id(), ENGINE_get_first(), ENGINE_get_last(), ENGINE_get_next(), ENGINE_get_prev(). All structural references should be released by a corresponding to call to the ENGINE_free() function - the ENGINE object itself will only actually be cleaned up and deallocated when the last structural reference is released.</p> <p>It should also be noted that many ENGINE API function calls that accept a structural reference will internally obtain another reference - typically this happens whenever the supplied ENGINE will be needed by OpenSSL after the function has returned. Eg. the function to add a new ENGINE to OpenSSL's internal list is ENGINE_add() - if this function returns success, then OpenSSL will have stored a new structural reference internally so the caller is still responsible for freeing their own reference with ENGINE_free() when they are finished with it. In a similar way, some functions will automatically release the structural reference passed to it if part of the function's job is to do so. Eg. the ENGINE_get_next() and ENGINE_get_prev() functions are used for iterating across the internal ENGINE list - they will return a new structural reference to the next (or previous) ENGINE in the list or NULL if at the end (or beginning) of the list, but in either case the structural reference passed to the function is released on behalf of the caller.</p> <p>To clarify a particular function's handling of references, one should always consult that function's documentation \"man\" page, or failing that the openssl/engine.h header file includes some hints.</p> <p>Functional references</p> <p>As mentioned, functional references exist when the cryptographic functionality of an ENGINE is required to be available. A functional reference can be obtained in one of two ways; from an existing structural reference to the required ENGINE, or by asking OpenSSL for the default operational ENGINE for a given cryptographic purpose.</p> <p>To obtain a functional reference from an existing structural reference, call the ENGINE_init() function. This returns zero if the ENGINE was not already operational and couldn't be successfully initialised (eg. lack of system drivers, no special hardware attached, etc), otherwise it will return non-zero to indicate that the ENGINE is now operational and will have allocated a new functional reference to the ENGINE. All functional references are released by calling ENGINE_finish() (which removes the implicit structural reference as well).</p> <p>The second way to get a functional reference is by asking OpenSSL for a default implementation for a given task, eg. by ENGINE_get_default_RSA(), ENGINE_get_default_cipher_engine(), etc. These are discussed in the next section, though they are not usually required by application programmers as they are used automatically when creating and using the relevant algorithm-specific types in OpenSSL, such as RSA, DSA, EVP_CIPHER_CTX, etc.</p>"},{"location":"man3/engine/#default-implementations","title":"Default implementations","text":"<p>For each supported abstraction, the ENGINE code maintains an internal table of state to control which implementations are available for a given abstraction and which should be used by default. These implementations are registered in the tables and indexed by an 'nid' value, because abstractions like EVP_CIPHER and EVP_DIGEST support many distinct algorithms and modes, and ENGINEs can support arbitrarily many of them. In the case of other abstractions like RSA, DSA, etc, there is only one \"algorithm\" so all implementations implicitly register using the same 'nid' index.</p> <p>When a default ENGINE is requested for a given abstraction/algorithm/mode, (eg. when calling RSA_new_method(NULL)), a \"get_default\" call will be made to the ENGINE subsystem to process the corresponding state table and return a functional reference to an initialised ENGINE whose implementation should be used. If no ENGINE should (or can) be used, it will return NULL and the caller will operate with a NULL ENGINE handle - this usually equates to using the conventional software implementation. In the latter case, OpenSSL will from then on behave the way it used to before the ENGINE API existed.</p> <p>Each state table has a flag to note whether it has processed this \"get_default\" query since the table was last modified, because to process this question it must iterate across all the registered ENGINEs in the table trying to initialise each of them in turn, in case one of them is operational. If it returns a functional reference to an ENGINE, it will also cache another reference to speed up processing future queries (without needing to iterate across the table). Likewise, it will cache a NULL response if no ENGINE was available so that future queries won't repeat the same iteration unless the state table changes. This behaviour can also be changed; if the ENGINE_TABLE_FLAG_NOINIT flag is set (using ENGINE_set_table_flags()), no attempted initialisations will take place, instead the only way for the state table to return a non-NULL ENGINE to the \"get_default\" query will be if one is expressly set in the table. Eg. ENGINE_set_default_RSA() does the same job as ENGINE_register_RSA() except that it also sets the state table's cached response for the \"get_default\" query. In the case of abstractions like EVP_CIPHER, where implementations are indexed by 'nid', these flags and cached-responses are distinct for each 'nid' value.</p>"},{"location":"man3/engine/#application-requirements","title":"Application requirements","text":"<p>This section will explain the basic things an application programmer should support to make the most useful elements of the ENGINE functionality available to the user. The first thing to consider is whether the programmer wishes to make alternative ENGINE modules available to the application and user. OpenSSL maintains an internal linked list of \"visible\" ENGINEs from which it has to operate - at start-up, this list is empty and in fact if an application does not call any ENGINE API calls and it uses static linking against openssl, then the resulting application binary will not contain any alternative ENGINE code at all. So the first consideration is whether any/all available ENGINE implementations should be made visible to OpenSSL - this is controlled by calling the various \"load\" functions, eg.</p> <pre><code>/* Make the \"dynamic\" ENGINE available */\nvoid ENGINE_load_dynamic(void);\n/* Make the CryptoSwift hardware acceleration support available */\nvoid ENGINE_load_cswift(void);\n/* Make support for nCipher's \"CHIL\" hardware available */\nvoid ENGINE_load_chil(void);\n...\n/* Make ALL ENGINE implementations bundled with OpenSSL available */\nvoid ENGINE_load_builtin_engines(void);\n</code></pre> <p>Having called any of these functions, ENGINE objects would have been dynamically allocated and populated with these implementations and linked into OpenSSL's internal linked list. At this point it is important to mention an important API function;</p> <pre><code>void ENGINE_cleanup(void);\n</code></pre> <p>If no ENGINE API functions are called at all in an application, then there are no inherent memory leaks to worry about from the ENGINE functionality, however if any ENGINEs are loaded, even if they are never registered or used, it is necessary to use the ENGINE_cleanup() function to correspondingly cleanup before program exit, if the caller wishes to avoid memory leaks. This mechanism uses an internal callback registration table so that any ENGINE API functionality that knows it requires cleanup can register its cleanup details to be called during ENGINE_cleanup(). This approach allows ENGINE_cleanup() to clean up after any ENGINE functionality at all that your program uses, yet doesn't automatically create linker dependencies to all possible ENGINE functionality - only the cleanup callbacks required by the functionality you do use will be required by the linker.</p> <p>The fact that ENGINEs are made visible to OpenSSL (and thus are linked into the program and loaded into memory at run-time) does not mean they are \"registered\" or called into use by OpenSSL automatically - that behaviour is something for the application to control. Some applications will want to allow the user to specify exactly which ENGINE they want used if any is to be used at all. Others may prefer to load all support and have OpenSSL automatically use at run-time any ENGINE that is able to successfully initialise - ie. to assume that this corresponds to acceleration hardware attached to the machine or some such thing. There are probably numerous other ways in which applications may prefer to handle things, so we will simply illustrate the consequences as they apply to a couple of simple cases and leave developers to consider these and the source code to openssl's builtin utilities as guides.</p> <p>Using a specific ENGINE implementation</p> <p>Here we'll assume an application has been configured by its user or admin to want to use the \"ACME\" ENGINE if it is available in the version of OpenSSL the application was compiled with. If it is available, it should be used by default for all RSA, DSA, and symmetric cipher operations, otherwise OpenSSL should use its builtin software as per usual. The following code illustrates how to approach this;</p> <pre><code>ENGINE *e;\nconst char *engine_id = \"ACME\";\nENGINE_load_builtin_engines();\ne = ENGINE_by_id(engine_id);\nif(!e)\n    /* the engine isn't available */\n    return;\nif(!ENGINE_init(e)) {\n    /* the engine couldn't initialise, release 'e' */\n    ENGINE_free(e);\n    return;\n}\nif(!ENGINE_set_default_RSA(e))\n    /* This should only happen when 'e' can't initialise, but the previous\n     * statement suggests it did. */\n    abort();\nENGINE_set_default_DSA(e);\nENGINE_set_default_ciphers(e);\n/* Release the functional reference from ENGINE_init() */\nENGINE_finish(e);\n/* Release the structural reference from ENGINE_by_id() */\nENGINE_free(e);\n</code></pre> <p>Automatically using builtin ENGINE implementations</p> <p>Here we'll assume we want to load and register all ENGINE implementations bundled with OpenSSL, such that for any cryptographic algorithm required by OpenSSL - if there is an ENGINE that implements it and can be initialised, it should be used. The following code illustrates how this can work;</p> <pre><code>/* Load all bundled ENGINEs into memory and make them visible */\nENGINE_load_builtin_engines();\n/* Register all of them for every algorithm they collectively implement */\nENGINE_register_all_complete();\n</code></pre> <p>That's all that's required. Eg. the next time OpenSSL tries to set up an RSA key, any bundled ENGINEs that implement RSA_METHOD will be passed to ENGINE_init() and if any of those succeed, that ENGINE will be set as the default for RSA use from then on.</p>"},{"location":"man3/engine/#advanced-configuration-support","title":"Advanced configuration support","text":"<p>There is a mechanism supported by the ENGINE framework that allows each ENGINE implementation to define an arbitrary set of configuration \"commands\" and expose them to OpenSSL and any applications based on OpenSSL. This mechanism is entirely based on the use of name-value pairs and assumes ASCII input (no unicode or UTF for now!), so it is ideal if applications want to provide a transparent way for users to provide arbitrary configuration \"directives\" directly to such ENGINEs. It is also possible for the application to dynamically interrogate the loaded ENGINE implementations for the names, descriptions, and input flags of their available \"control commands\", providing a more flexible configuration scheme. However, if the user is expected to know which ENGINE device he/she is using (in the case of specialised hardware, this goes without saying) then applications may not need to concern themselves with discovering the supported control commands and simply prefer to pass settings into ENGINEs exactly as they are provided by the user.</p> <p>Before illustrating how control commands work, it is worth mentioning what they are typically used for. Broadly speaking there are two uses for control commands; the first is to provide the necessary details to the implementation (which may know nothing at all specific to the host system) so that it can be initialised for use. This could include the path to any driver or config files it needs to load, required network addresses, smart-card identifiers, passwords to initialise protected devices, logging information, etc etc. This class of commands typically needs to be passed to an ENGINE before attempting to initialise it, ie. before calling ENGINE_init(). The other class of commands consist of settings or operations that tweak certain behaviour or cause certain operations to take place, and these commands may work either before or after ENGINE_init(), or in some cases both. ENGINE implementations should provide indications of this in the descriptions attached to builtin control commands and/or in external product documentation.</p> <p>Issuing control commands to an ENGINE</p> <p>Let's illustrate by example; a function for which the caller supplies the name of the ENGINE it wishes to use, a table of string-pairs for use before initialisation, and another table for use after initialisation. Note that the string-pairs used for control commands consist of a command \"name\" followed by the command \"parameter\" - the parameter could be NULL in some cases but the name can not. This function should initialise the ENGINE (issuing the \"pre\" commands beforehand and the \"post\" commands afterwards) and set it as the default for everything except RAND and then return a boolean success or failure.</p> <pre><code>int generic_load_engine_fn(const char *engine_id,\n                           const char **pre_cmds, int pre_num,\n                           const char **post_cmds, int post_num)\n{\n    ENGINE *e = ENGINE_by_id(engine_id);\n    if(!e) return 0;\n    while(pre_num--) {\n        if(!ENGINE_ctrl_cmd_string(e, pre_cmds[0], pre_cmds[1], 0)) {\n            fprintf(stderr, \"Failed command (%s - %s:%s)\\n\", engine_id,\n                pre_cmds[0], pre_cmds[1] ? pre_cmds[1] : \"(NULL)\");\n            ENGINE_free(e);\n            return 0;\n        }\n        pre_cmds += 2;\n    }\n    if(!ENGINE_init(e)) {\n        fprintf(stderr, \"Failed initialisation\\n\");\n        ENGINE_free(e);\n        return 0;\n    }\n    /* ENGINE_init() returned a functional reference, so free the structural\n     * reference from ENGINE_by_id(). */\n    ENGINE_free(e);\n    while(post_num--) {\n        if(!ENGINE_ctrl_cmd_string(e, post_cmds[0], post_cmds[1], 0)) {\n            fprintf(stderr, \"Failed command (%s - %s:%s)\\n\", engine_id,\n                post_cmds[0], post_cmds[1] ? post_cmds[1] : \"(NULL)\");\n            ENGINE_finish(e);\n            return 0;\n        }\n        post_cmds += 2;\n    }\n    ENGINE_set_default(e, ENGINE_METHOD_ALL &amp; ~ENGINE_METHOD_RAND);\n    /* Success */\n    return 1;\n}\n</code></pre> <p>Note that ENGINE_ctrl_cmd_string() accepts a boolean argument that can relax the semantics of the function - if set non-zero it will only return failure if the ENGINE supported the given command name but failed while executing it, if the ENGINE doesn't support the command name it will simply return success without doing anything. In this case we assume the user is only supplying commands specific to the given ENGINE so we set this to FALSE.</p> <p>Discovering supported control commands</p> <p>It is possible to discover at run-time the names, numerical-ids, descriptions and input parameters of the control commands supported by an ENGINE using a structural reference. Note that some control commands are defined by OpenSSL itself and it will intercept and handle these control commands on behalf of the ENGINE, ie. the ENGINE's ctrl() handler is not used for the control command. openssl/engine.h defines an index, ENGINE_CMD_BASE, that all control commands implemented by ENGINEs should be numbered from. Any command value lower than this symbol is considered a \"generic\" command is handled directly by the OpenSSL core routines.</p> <p>It is using these \"core\" control commands that one can discover the the control commands implemented by a given ENGINE, specifically the commands;</p> <pre><code>#define ENGINE_HAS_CTRL_FUNCTION               10\n#define ENGINE_CTRL_GET_FIRST_CMD_TYPE         11\n#define ENGINE_CTRL_GET_NEXT_CMD_TYPE          12\n#define ENGINE_CTRL_GET_CMD_FROM_NAME          13\n#define ENGINE_CTRL_GET_NAME_LEN_FROM_CMD      14\n#define ENGINE_CTRL_GET_NAME_FROM_CMD          15\n#define ENGINE_CTRL_GET_DESC_LEN_FROM_CMD      16\n#define ENGINE_CTRL_GET_DESC_FROM_CMD          17\n#define ENGINE_CTRL_GET_CMD_FLAGS              18\n</code></pre> <p>Whilst these commands are automatically processed by the OpenSSL framework code, they use various properties exposed by each ENGINE to process these queries. An ENGINE has 3 properties it exposes that can affect how this behaves; it can supply a ctrl() handler, it can specify ENGINE_FLAGS_MANUAL_CMD_CTRL in the ENGINE's flags, and it can expose an array of control command descriptions. If an ENGINE specifies the ENGINE_FLAGS_MANUAL_CMD_CTRL flag, then it will simply pass all these \"core\" control commands directly to the ENGINE's ctrl() handler (and thus, it must have supplied one), so it is up to the ENGINE to reply to these \"discovery\" commands itself. If that flag is not set, then the OpenSSL framework code will work with the following rules;</p> <pre><code>if no ctrl() handler supplied;\n    ENGINE_HAS_CTRL_FUNCTION returns FALSE (zero),\n    all other commands fail.\nif a ctrl() handler was supplied but no array of control commands;\n    ENGINE_HAS_CTRL_FUNCTION returns TRUE,\n    all other commands fail.\nif a ctrl() handler and array of control commands was supplied;\n    ENGINE_HAS_CTRL_FUNCTION returns TRUE,\n    all other commands proceed processing ...\n</code></pre> <p>If the ENGINE's array of control commands is empty then all other commands will fail, otherwise; ENGINE_CTRL_GET_FIRST_CMD_TYPE returns the identifier of the first command supported by the ENGINE, ENGINE_GET_NEXT_CMD_TYPE takes the identifier of a command supported by the ENGINE and returns the next command identifier or fails if there are no more, ENGINE_CMD_FROM_NAME takes a string name for a command and returns the corresponding identifier or fails if no such command name exists, and the remaining commands take a command identifier and return properties of the corresponding commands. All except ENGINE_CTRL_GET_FLAGS return the string length of a command name or description, or populate a supplied character buffer with a copy of the command name or description. ENGINE_CTRL_GET_FLAGS returns a bitwise-OR'd mask of the following possible values;</p> <pre><code>#define ENGINE_CMD_FLAG_NUMERIC                (unsigned int)0x0001\n#define ENGINE_CMD_FLAG_STRING                 (unsigned int)0x0002\n#define ENGINE_CMD_FLAG_NO_INPUT               (unsigned int)0x0004\n#define ENGINE_CMD_FLAG_INTERNAL               (unsigned int)0x0008\n</code></pre> <p>If the ENGINE_CMD_FLAG_INTERNAL flag is set, then any other flags are purely informational to the caller - this flag will prevent the command being usable for any higher-level ENGINE functions such as ENGINE_ctrl_cmd_string(). \"INTERNAL\" commands are not intended to be exposed to text-based configuration by applications, administrations, users, etc. These can support arbitrary operations via ENGINE_ctrl(), including passing to and/or from the control commands data of any arbitrary type. These commands are supported in the discovery mechanisms simply to allow applications determinie if an ENGINE supports certain specific commands it might want to use (eg. application \"foo\" might query various ENGINEs to see if they implement \"FOO_GET_VENDOR_LOGO_GIF\" - and ENGINE could therefore decide whether or not to support this \"foo\"-specific extension).</p>"},{"location":"man3/engine/#future-developments","title":"Future developments","text":"<p>The ENGINE API and internal architecture is currently being reviewed. Slated for possible release in 0.9.8 is support for transparent loading of \"dynamic\" ENGINEs (built as self-contained shared-libraries). This would allow ENGINE implementations to be provided independently of OpenSSL libraries and/or OpenSSL-based applications, and would also remove any requirement for applications to explicitly use the \"dynamic\" ENGINE to bind to shared-library implementations.</p>"},{"location":"man3/engine/#see-also","title":"SEE ALSO","text":"<p>rsa(3), dsa(3), dh(3), rand(3)</p>"},{"location":"man3/err/","title":"err","text":""},{"location":"man3/err/#name","title":"NAME","text":"<p>err - error codes</p>"},{"location":"man3/err/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/err.h&gt;\n\nunsigned long ERR_get_error(void);\nunsigned long ERR_peek_error(void);\nunsigned long ERR_get_error_line(const char **file, int *line);\nunsigned long ERR_peek_error_line(const char **file, int *line);\nunsigned long ERR_get_error_line_data(const char **file, int *line,\n        const char **data, int *flags);\nunsigned long ERR_peek_error_line_data(const char **file, int *line,\n        const char **data, int *flags);\n\nint ERR_GET_LIB(unsigned long e);\nint ERR_GET_FUNC(unsigned long e);\nint ERR_GET_REASON(unsigned long e);\n\nvoid ERR_clear_error(void);\n\nchar *ERR_error_string(unsigned long e, char *buf);\nconst char *ERR_lib_error_string(unsigned long e);\nconst char *ERR_func_error_string(unsigned long e);\nconst char *ERR_reason_error_string(unsigned long e);\n\nvoid ERR_print_errors(BIO *bp);\nvoid ERR_print_errors_fp(FILE *fp);\n\nvoid ERR_load_crypto_strings(void);\nvoid ERR_free_strings(void);\n\nvoid ERR_remove_state(unsigned long pid);\n\nvoid ERR_put_error(int lib, int func, int reason, const char *file,\n        int line);\nvoid ERR_add_error_data(int num, ...);\n\nvoid ERR_load_strings(int lib,ERR_STRING_DATA str[]);\nunsigned long ERR_PACK(int lib, int func, int reason);\nint ERR_get_next_error_library(void);\n</code></pre>"},{"location":"man3/err/#description","title":"DESCRIPTION","text":"<p>When a call to the OpenSSL library fails, this is usually signalled by the return value, and an error code is stored in an error queue associated with the current thread. The err library provides functions to obtain these error codes and textual error messages.</p> <p>The ERR_get_error(3) manpage describes how to access error codes.</p> <p>Error codes contain information about where the error occurred, and what went wrong. ERR_GET_LIB(3) describes how to extract this information. A method to obtain human-readable error messages is described in ERR_error_string(3).</p> <p>ERR_clear_error(3) can be used to clear the error queue.</p> <p>Note that ERR_remove_state(3) should be used to avoid memory leaks when threads are terminated.</p>"},{"location":"man3/err/#adding-new-error-codes-to-openssl","title":"ADDING NEW ERROR CODES TO OPENSSL","text":"<p>See ERR_put_error(3) if you want to record error codes in the OpenSSL error system from within your application.</p> <p>The remainder of this section is of interest only if you want to add new error codes to OpenSSL or add error codes from external libraries.</p>"},{"location":"man3/err/#reporting-errors","title":"Reporting errors","text":"<p>Each sub-library has a specific macro XXXerr() that is used to report errors. Its first argument is a function code XXX_F_..., the second argument is a reason code XXX_R_.... Function codes are derived from the function names; reason codes consist of textual error descriptions. For example, the function ssl23_read() reports a \"handshake failure\" as follows:</p> <pre><code>SSLerr(SSL_F_SSL23_READ, SSL_R_SSL_HANDSHAKE_FAILURE);\n</code></pre> <p>Function and reason codes should consist of upper case characters, numbers and underscores only. The error file generation script translates function codes into function names by looking in the header files for an appropriate function name, if none is found it just uses the capitalized form such as \"SSL23_READ\" in the above example.</p> <p>The trailing section of a reason code (after the \"_R_\") is translated into lower case and underscores changed to spaces.</p> <p>When you are using new function or reason codes, run make errors. The necessary #defines will then automatically be added to the sub-library's header file.</p> <p>Although a library will normally report errors using its own specific XXXerr macro, another library's macro can be used. This is normally only done when a library wants to include ASN1 code which must use the ASN1err() macro.</p>"},{"location":"man3/err/#adding-new-libraries","title":"Adding new libraries","text":"<p>When adding a new sub-library to OpenSSL, assign it a library number ERR_LIB_XXX, define a macro XXXerr() (both in err.h), add its name to ERR_str_libraries[] (in crypto/err/err.c), and add <code>ERR_load_XXX_strings()</code> to the ERR_load_crypto_strings() function (in crypto/err/err_all.c). Finally, add an entry</p> <pre><code>L      XXX     xxx.h   xxx_err.c\n</code></pre> <p>to crypto/err/openssl.ec, and add xxx_err.c to the Makefile. Running make errors will then generate a file xxx_err.c, and add all error codes used in the library to xxx.h.</p> <p>Additionally the library include file must have a certain form. Typically it will initially look like this:</p> <pre><code>#ifndef HEADER_XXX_H\n#define HEADER_XXX_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Include files */\n\n#include &lt;openssl/bio.h&gt;\n#include &lt;openssl/x509.h&gt;\n\n/* Macros, structures and function prototypes */\n\n\n/* BEGIN ERROR CODES */\n</code></pre> <p>The BEGIN ERROR CODES sequence is used by the error code generation script as the point to place new error codes, any text after this point will be overwritten when make errors is run. The closing #endif etc will be automatically added by the script.</p> <p>The generated C error code file xxx_err.c will load the header files stdio.h, openssl/err.h and openssl/xxx.h so the header file must load any additional header files containing any definitions it uses.</p>"},{"location":"man3/err/#using-error-codes-in-external-libraries","title":"USING ERROR CODES IN EXTERNAL LIBRARIES","text":"<p>It is also possible to use OpenSSL's error code scheme in external libraries. The library needs to load its own codes and call the OpenSSL error code insertion script mkerr.pl explicitly to add codes to the header file and generate the C error code file. This will normally be done if the external library needs to generate new ASN1 structures but it can also be used to add more general purpose error code handling.</p> <p>TBA more details</p>"},{"location":"man3/err/#internals","title":"INTERNALS","text":"<p>The error queues are stored in a hash table with one ERR_STATE entry for each pid. ERR_get_state() returns the current thread's ERR_STATE. An ERR_STATE can hold up to ERR_NUM_ERRORS error codes. When more error codes are added, the old ones are overwritten, on the assumption that the most recent errors are most important.</p> <p>Error strings are also stored in hash table. The hash tables can be obtained by calling ERR_get_err_state_table(void) and ERR_get_string_table(void) respectively.</p>"},{"location":"man3/err/#see-also","title":"SEE ALSO","text":"<p>CRYPTO_set_locking_callback(3), ERR_get_error(3), ERR_GET_LIB(3), ERR_clear_error(3), ERR_error_string(3), ERR_print_errors(3), ERR_load_crypto_strings(3), ERR_remove_state(3), ERR_put_error(3), ERR_load_strings(3), SSL_get_error(3)</p>"},{"location":"man3/evp/","title":"evp","text":""},{"location":"man3/evp/#name","title":"NAME","text":"<p>evp - high-level cryptographic functions</p>"},{"location":"man3/evp/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/evp.h&gt;\n</code></pre>"},{"location":"man3/evp/#description","title":"DESCRIPTION","text":"<p>The EVP library provides a high-level interface to cryptographic functions.</p> <p>EVP_Seal... and EVP_Open... provide public key encryption and decryption to implement digital \"envelopes\".</p> <p>The EVP_DigestSign... and EVP_DigestVerify... functions implement digital signatures and Message Authentication Codes (MACs). Also see the older EVP_Sign... and EVP_Verify... functions.</p> <p>Symmetric encryption is available with the EVP_Encrypt... functions.  The EVP_Digest... functions provide message digests.</p> <p>The EVP_PKEY... functions provide a high level interface to asymmetric algorithms. To create a new EVP_PKEY see EVP_PKEY_new(3). EVP_PKEYs can be associated with a private key of a particular algorithm by using the functions described on the EVP_PKEY_set1_RSA(3) page, or new keys can be generated using EVP_PKEY_keygen(3). EVP_PKEYs can be compared using EVP_PKEY_cmp(3), or printed using EVP_PKEY_print_private(3).</p> <p>The EVP_PKEY functions support the full range of asymmetric algorithm operations:</p> <ul> <li>For key agreement see EVP_PKEY_derive(3)</li> <li>For signing and verifying see EVP_PKEY_sign(3), EVP_PKEY_verify(3) and EVP_PKEY_verify_recover(3). However, note that these functions do not perform a digest of the data to be signed. Therefore normally you would use the EVP_DigestSign... functions for this purpose.</li> <li>For encryption and decryption see EVP_PKEY_encrypt(3) and EVP_PKEY_decrypt(3) respectively. However, note that these functions perform encryption and decryption only. As public key encryption is an expensive operation, normally you would wrap an encrypted message in a \"digital envelope\" using the EVP_Seal... and EVP_Open... functions.</li> </ul> <p>The EVP_BytesToKey(3) function provides some limited support for password based encryption. Careful selection of the parameters will provide a PKCS#5 PBKDF1 compatible implementation. However, new applications should not typically use this (preferring, for example, PBKDF2 from PCKS#5).</p> <p>The EVP_Encode... and EVP_Decode... functions implement base 64 encoding and decoding.</p> <p>Algorithms are loaded with OpenSSL_add_all_algorithms(3).</p> <p>All the symmetric algorithms (ciphers), digests and asymmetric algorithms (public key algorithms) can be replaced by ENGINE modules providing alternative implementations. If ENGINE implementations of ciphers or digests are registered as defaults, then the various EVP functions will automatically use those implementations automatically in preference to built in software implementations. For more information, consult the engine(3) man page.</p> <p>Although low level algorithm specific functions exist for many algorithms their use is discouraged. They cannot be used with an ENGINE and ENGINE versions of new algorithms cannot be accessed using the low level functions. Also makes code harder to adapt to new algorithms and some options are not  cleanly supported at the low level and some operations are more efficient using the high level interface.</p>"},{"location":"man3/evp/#see-also","title":"SEE ALSO","text":"<p>EVP_DigestInit(3), EVP_EncryptInit(3), EVP_OpenInit(3), EVP_SealInit(3), EVP_DigestSignInit(3), EVP_SignInit(3), EVP_VerifyInit(3), EVP_EncodeInit(3), EVP_PKEY_new(3), EVP_PKEY_set1_RSA(3), EVP_PKEY_keygen(3), EVP_PKEY_print_private(3), EVP_PKEY_decrypt(3), EVP_PKEY_encrypt(3), EVP_PKEY_sign(3), EVP_PKEY_verify(3), EVP_PKEY_verify_recover(3), EVP_PKEY_derive(3), EVP_BytesToKey(3), OpenSSL_add_all_algorithms(3), engine(3)</p>"},{"location":"man3/hmac/","title":"hmac","text":""},{"location":"man3/hmac/#name","title":"NAME","text":"<p>HMAC, HMAC_CTX_init, HMAC_Init, HMAC_Init_ex, HMAC_Update, HMAC_Final, HMAC_CTX_cleanup, HMAC_cleanup - HMAC message authentication code</p>"},{"location":"man3/hmac/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/hmac.h&gt;\n\nunsigned char *HMAC(const EVP_MD *evp_md, const void *key,\n              int key_len, const unsigned char *d, int n,\n              unsigned char *md, unsigned int *md_len);\n\nvoid HMAC_CTX_init(HMAC_CTX *ctx);\n\nint HMAC_Init(HMAC_CTX *ctx, const void *key, int key_len,\n              const EVP_MD *md);\nint HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int key_len,\n                  const EVP_MD *md, ENGINE *impl);\nint HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, int len);\nint HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len);\n\nvoid HMAC_CTX_cleanup(HMAC_CTX *ctx);\nvoid HMAC_cleanup(HMAC_CTX *ctx);\n</code></pre>"},{"location":"man3/hmac/#description","title":"DESCRIPTION","text":"<p>HMAC is a MAC (message authentication code), i.e. a keyed hash function used for message authentication, which is based on a hash function.</p> <p>HMAC() computes the message authentication code of the n bytes at d using the hash function evp_md and the key key which is key_len bytes long.</p> <p>It places the result in md (which must have space for the output of the hash function, which is no more than EVP_MAX_MD_SIZE bytes). If md is NULL, the digest is placed in a static array.  The size of the output is placed in md_len, unless it is NULL. Note: passing a NULL value for md  to use the static array is not thread safe.</p> <p>evp_md can be EVP_sha1(), EVP_ripemd160() etc.</p> <p>HMAC_CTX_init() initialises a HMAC_CTX before first use. It must be called.</p> <p>HMAC_CTX_cleanup() erases the key and other data from the HMAC_CTX and releases any associated resources. It must be called when an HMAC_CTX is no longer required.</p> <p>HMAC_cleanup() is an alias for HMAC_CTX_cleanup() included for back compatibility with 0.9.6b, it is deprecated.</p> <p>The following functions may be used if the message is not completely stored in memory:</p> <p>HMAC_Init() initializes a HMAC_CTX structure to use the hash function evp_md and the key key which is key_len bytes long. It is deprecated and only included for backward compatibility with OpenSSL 0.9.6b.</p> <p>HMAC_Init_ex() initializes or reuses a HMAC_CTX structure to use the hash function evp_md and key key. If both are NULL (or evp_md is the same as the previous digest used by ctx and key is NULL) the existing key is reused. ctx must have been created with HMAC_CTX_new() before the first use of an HMAC_CTX in this function. N.B. HMAC_Init() had this undocumented behaviour in previous versions of OpenSSL - failure to switch to HMAC_Init_ex() in programs that expect it will cause them to stop working.</p> <p>NB: if HMAC_Init_ex() is called with key NULL and evp_md is not the same as the previous digest used by ctx then an error is returned because reuse of an existing key with a different digest is not supported.</p> <p>HMAC_Update() can be called repeatedly with chunks of the message to be authenticated (len bytes at data).</p> <p>HMAC_Final() places the message authentication code in md, which must have space for the hash function output.</p>"},{"location":"man3/hmac/#return-values","title":"RETURN VALUES","text":"<p>HMAC() returns a pointer to the message authentication code or NULL if an error occurred.</p> <p>HMAC_Init_ex(), HMAC_Update() and HMAC_Final() return 1 for success or 0 if an error occurred.</p> <p>HMAC_CTX_init() and HMAC_CTX_cleanup() do not return values.</p>"},{"location":"man3/hmac/#conforming-to","title":"CONFORMING TO","text":"<p>RFC 2104</p>"},{"location":"man3/hmac/#see-also","title":"SEE ALSO","text":"<p>sha(3), evp(3)</p>"},{"location":"man3/hmac/#history","title":"HISTORY","text":"<p>HMAC(), HMAC_Init(), HMAC_Update(), HMAC_Final() and HMAC_cleanup() are available since SSLeay 0.9.0.</p> <p>HMAC_CTX_init(), HMAC_Init_ex() and HMAC_CTX_cleanup() are available since OpenSSL 0.9.7.</p> <p>HMAC_Init_ex(), HMAC_Update() and HMAC_Final() did not return values in versions of OpenSSL before 1.0.0.</p>"},{"location":"man3/i2d_CMS_bio_stream/","title":"i2d_CMS_bio_stream","text":""},{"location":"man3/i2d_CMS_bio_stream/#name","title":"NAME","text":"<pre><code>i2d_CMS_bio_stream - output CMS_ContentInfo structure in BER format.\n</code></pre>"},{"location":"man3/i2d_CMS_bio_stream/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/cms.h&gt;\n\nint i2d_CMS_bio_stream(BIO *out, CMS_ContentInfo *cms, BIO *data, int flags);\n</code></pre>"},{"location":"man3/i2d_CMS_bio_stream/#description","title":"DESCRIPTION","text":"<p>i2d_CMS_bio_stream() outputs a CMS_ContentInfo structure in BER format.</p> <p>It is otherwise identical to the function SMIME_write_CMS().</p>"},{"location":"man3/i2d_CMS_bio_stream/#notes","title":"NOTES","text":"<p>This function is effectively a version of the i2d_CMS_bio() supporting streaming.</p>"},{"location":"man3/i2d_CMS_bio_stream/#bugs","title":"BUGS","text":"<p>The prefix \"i2d\" is arguably wrong because the function outputs BER format.</p>"},{"location":"man3/i2d_CMS_bio_stream/#return-values","title":"RETURN VALUES","text":"<p>i2d_CMS_bio_stream() returns 1 for success or 0 for failure.</p>"},{"location":"man3/i2d_CMS_bio_stream/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), CMS_sign(3), CMS_verify(3), CMS_encrypt(3) CMS_decrypt(3), SMIME_write_CMS(3), PEM_write_bio_CMS_stream(3)</p>"},{"location":"man3/i2d_CMS_bio_stream/#history","title":"HISTORY","text":"<p>i2d_CMS_bio_stream() was added to OpenSSL 1.0.0</p>"},{"location":"man3/i2d_PKCS7_bio_stream/","title":"i2d_PKCS7_bio_stream","text":""},{"location":"man3/i2d_PKCS7_bio_stream/#name","title":"NAME","text":"<p>i2d_PKCS7_bio_stream - output PKCS7 structure in BER format.</p>"},{"location":"man3/i2d_PKCS7_bio_stream/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/pkcs7.h&gt;\n\nint i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *data, int flags);\n</code></pre>"},{"location":"man3/i2d_PKCS7_bio_stream/#description","title":"DESCRIPTION","text":"<p>i2d_PKCS7_bio_stream() outputs a PKCS7 structure in BER format.</p> <p>It is otherwise identical to the function SMIME_write_PKCS7().</p>"},{"location":"man3/i2d_PKCS7_bio_stream/#notes","title":"NOTES","text":"<p>This function is effectively a version of the d2i_PKCS7_bio() supporting streaming.</p>"},{"location":"man3/i2d_PKCS7_bio_stream/#bugs","title":"BUGS","text":"<p>The prefix \"i2d\" is arguably wrong because the function outputs BER format.</p>"},{"location":"man3/i2d_PKCS7_bio_stream/#return-values","title":"RETURN VALUES","text":"<p>i2d_PKCS7_bio_stream() returns 1 for success or 0 for failure.</p>"},{"location":"man3/i2d_PKCS7_bio_stream/#see-also","title":"SEE ALSO","text":"<p>ERR_get_error(3), PKCS7_sign(3), PKCS7_verify(3), PKCS7_encrypt(3) PKCS7_decrypt(3), SMIME_write_PKCS7(3), PEM_write_bio_PKCS7_stream(3)</p>"},{"location":"man3/i2d_PKCS7_bio_stream/#history","title":"HISTORY","text":"<p>i2d_PKCS7_bio_stream() was added to OpenSSL 1.0.0</p>"},{"location":"man3/lh_stats/","title":"lh_stats","text":""},{"location":"man3/lh_stats/#name","title":"NAME","text":"<p>lh_stats, lh_node_stats, lh_node_usage_stats, lh_stats_bio, lh_node_stats_bio, lh_node_usage_stats_bio - LHASH statistics</p>"},{"location":"man3/lh_stats/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/lhash.h&gt;\n\nvoid lh_stats(LHASH *table, FILE *out);\nvoid lh_node_stats(LHASH *table, FILE *out);\nvoid lh_node_usage_stats(LHASH *table, FILE *out);\n\nvoid lh_stats_bio(LHASH *table, BIO *out);\nvoid lh_node_stats_bio(LHASH *table, BIO *out);\nvoid lh_node_usage_stats_bio(LHASH *table, BIO *out);\n</code></pre>"},{"location":"man3/lh_stats/#description","title":"DESCRIPTION","text":"<p>The LHASH structure records statistics about most aspects of accessing the hash table.  This is mostly a legacy of Eric Young writing this library for the reasons of implementing what looked like a nice algorithm rather than for a particular software product.</p> <p>lh_stats() prints out statistics on the size of the hash table, how many entries are in it, and the number and result of calls to the routines in this library.</p> <p>lh_node_stats() prints the number of entries for each 'bucket' in the hash table.</p> <p>lh_node_usage_stats() prints out a short summary of the state of the hash table.  It prints the 'load' and the 'actual load'.  The load is the average number of data items per 'bucket' in the hash table.  The 'actual load' is the average number of items per 'bucket', but only for buckets which contain entries.  So the 'actual load' is the average number of searches that will need to find an item in the hash table, while the 'load' is the average number that will be done to record a miss.</p> <p>lh_stats_bio(), lh_node_stats_bio() and lh_node_usage_stats_bio() are the same as the above, except that the output goes to a BIO.</p>"},{"location":"man3/lh_stats/#return-values","title":"RETURN VALUES","text":"<p>These functions do not return values.</p>"},{"location":"man3/lh_stats/#see-also","title":"SEE ALSO","text":"<p>bio(3), lhash(3)</p>"},{"location":"man3/lh_stats/#history","title":"HISTORY","text":"<p>These functions are available in all versions of SSLeay and OpenSSL.</p> <p>This manpage is derived from the SSLeay documentation.</p>"},{"location":"man3/lhash/","title":"lhash","text":""},{"location":"man3/lhash/#name","title":"NAME","text":"<p>lh_new, lh_free, lh_insert, lh_delete, lh_retrieve, lh_doall, lh_doall_arg, lh_error - dynamic hash table</p>"},{"location":"man3/lhash/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/lhash.h&gt;\n\nDECLARE_LHASH_OF(&lt;type&gt;);\n\nLHASH *lh_&lt;type&gt;_new();\nvoid lh_&lt;type&gt;_free(LHASH_OF(&lt;type&gt; *table);\n\n&lt;type&gt; *lh_&lt;type&gt;_insert(LHASH_OF(&lt;type&gt; *table, &lt;type&gt; *data);\n&lt;type&gt; *lh_&lt;type&gt;_delete(LHASH_OF(&lt;type&gt; *table, &lt;type&gt; *data);\n&lt;type&gt; *lh_retrieve(LHASH_OF&lt;type&gt; *table, &lt;type&gt; *data);\n\nvoid lh_&lt;type&gt;_doall(LHASH_OF(&lt;type&gt; *table, LHASH_DOALL_FN_TYPE func);\nvoid lh_&lt;type&gt;_doall_arg(LHASH_OF(&lt;type&gt; *table, LHASH_DOALL_ARG_FN_TYPE func,\n         &lt;type2&gt;, &lt;type2&gt; *arg);\n\nint lh_&lt;type&gt;_error(LHASH_OF(&lt;type&gt; *table);\n\ntypedef int (*LHASH_COMP_FN_TYPE)(const void *, const void *);\ntypedef unsigned long (*LHASH_HASH_FN_TYPE)(const void *);\ntypedef void (*LHASH_DOALL_FN_TYPE)(const void *);\ntypedef void (*LHASH_DOALL_ARG_FN_TYPE)(const void *, const void *);\n</code></pre>"},{"location":"man3/lhash/#description","title":"DESCRIPTION","text":"<p>This library implements type-checked dynamic hash tables. The hash table entries can be arbitrary structures. Usually they consist of key and value fields.</p> <p>lh_&lt;type&gt;_new() creates a new LHASH_OF(&lt;type&gt; structure to store arbitrary data entries, and provides the 'hash' and 'compare' callbacks to be used in organising the table's entries.  The hash callback takes a pointer to a table entry as its argument and returns an unsigned long hash value for its key field.  The hash value is normally truncated to a power of 2, so make sure that your hash function returns well mixed low order bits.  The compare callback takes two arguments (pointers to two hash table entries), and returns 0 if their keys are equal, non-zero otherwise.  If your hash table will contain items of some particular type and the hash and compare callbacks hash/compare these types, then the DECLARE_LHASH_HASH_FN and IMPLEMENT_LHASH_COMP_FN macros can be used to create callback wrappers of the prototypes required by lh_&lt;type&gt;_new().  These provide per-variable casts before calling the type-specific callbacks written by the application author.  These macros, as well as those used for the \"doall\" callbacks, are defined as;</p> <pre><code>#define DECLARE_LHASH_HASH_FN(name, o_type) \\\n        unsigned long name##_LHASH_HASH(const void *);\n#define IMPLEMENT_LHASH_HASH_FN(name, o_type) \\\n        unsigned long name##_LHASH_HASH(const void *arg) { \\\n                const o_type *a = arg; \\\n                return name##_hash(a); }\n#define LHASH_HASH_FN(name) name##_LHASH_HASH\n\n#define DECLARE_LHASH_COMP_FN(name, o_type) \\\n        int name##_LHASH_COMP(const void *, const void *);\n#define IMPLEMENT_LHASH_COMP_FN(name, o_type) \\\n        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \\\n                const o_type *a = arg1;                    \\\n                const o_type *b = arg2; \\\n                return name##_cmp(a,b); }\n#define LHASH_COMP_FN(name) name##_LHASH_COMP\n\n#define DECLARE_LHASH_DOALL_FN(name, o_type) \\\n        void name##_LHASH_DOALL(void *);\n#define IMPLEMENT_LHASH_DOALL_FN(name, o_type) \\\n        void name##_LHASH_DOALL(void *arg) { \\\n                o_type *a = arg; \\\n                name##_doall(a); }\n#define LHASH_DOALL_FN(name) name##_LHASH_DOALL\n\n#define DECLARE_LHASH_DOALL_ARG_FN(name, o_type, a_type) \\\n        void name##_LHASH_DOALL_ARG(void *, void *);\n#define IMPLEMENT_LHASH_DOALL_ARG_FN(name, o_type, a_type) \\\n        void name##_LHASH_DOALL_ARG(void *arg1, void *arg2) { \\\n                o_type *a = arg1; \\\n                a_type *b = arg2; \\\n                name##_doall_arg(a, b); }\n#define LHASH_DOALL_ARG_FN(name) name##_LHASH_DOALL_ARG\n\nAn example of a hash table storing (pointers to) structures of type 'STUFF'\ncould be defined as follows;\n\n/* Calculates the hash value of 'tohash' (implemented elsewhere) */\nunsigned long STUFF_hash(const STUFF *tohash);\n/* Orders 'arg1' and 'arg2' (implemented elsewhere) */\nint stuff_cmp(const STUFF *arg1, const STUFF *arg2);\n/* Create the type-safe wrapper functions for use in the LHASH internals */\nstatic IMPLEMENT_LHASH_HASH_FN(stuff, STUFF);\nstatic IMPLEMENT_LHASH_COMP_FN(stuff, STUFF);\n/* ... */\nint main(int argc, char *argv[]) {\n        /* Create the new hash table using the hash/compare wrappers */\n        LHASH_OF(STUFF) *hashtable = lh_STUFF_new(LHASH_HASH_FN(STUFF_hash),\n                                  LHASH_COMP_FN(STUFF_cmp));\n        /* ... */\n}\n</code></pre> <p>lh_&lt;type&gt;_free() frees the LHASH_OF(&lt;type&gt; structure table. Allocated hash table entries will not be freed; consider using lh_&lt;type&gt;_doall() to deallocate any remaining entries in the hash table (see below).</p> <p>lh_&lt;type&gt;_insert() inserts the structure pointed to by data into table.  If there already is an entry with the same key, the old value is replaced. Note that lh_&lt;type&gt;_insert() stores pointers, the data are not copied.</p> <p>lh_&lt;type&gt;_delete() deletes an entry from table.</p> <p>lh_&lt;type&gt;_retrieve() looks up an entry in table. Normally, data is a structure with the key field(s) set; the function will return a pointer to a fully populated structure.</p> <p>lh_&lt;type&gt;_doall() will, for every entry in the hash table, call func with the data item as its parameter.  For lh_&lt;type&gt;_doall() and lh_&lt;type&gt;_doall_arg(), function pointer casting should be avoided in the callbacks (see NOTE) - instead use the declare/implement macros to create type-checked wrappers that cast variables prior to calling your type-specific callbacks.  An example of this is illustrated here where the callback is used to cleanup resources for items in the hash table prior to the hashtable itself being deallocated:</p> <pre><code>/* Cleans up resources belonging to 'a' (this is implemented elsewhere) */\nvoid STUFF_cleanup_doall(STUFF *a);\n/* Implement a prototype-compatible wrapper for \"STUFF_cleanup\" */\nIMPLEMENT_LHASH_DOALL_FN(STUFF_cleanup, STUFF)\n        /* ... then later in the code ... */\n/* So to run \"STUFF_cleanup\" against all items in a hash table ... */\nlh_STUFF_doall(hashtable, LHASH_DOALL_FN(STUFF_cleanup));\n/* Then the hash table itself can be deallocated */\nlh_STUFF_free(hashtable);\n</code></pre> <p>When doing this, be careful if you delete entries from the hash table in your callbacks: the table may decrease in size, moving the item that you are currently on down lower in the hash table - this could cause some entries to be skipped during the iteration.  The second best solution to this problem is to set hash-&gt;down_load=0 before you start (which will stop the hash table ever decreasing in size). The best solution is probably to avoid deleting items from the hash table inside a \"doall\" callback!</p> <p>lh_&lt;type&gt;_doall_arg() is the same as lh_&lt;type&gt;_doall() except that func will be called with arg as the second argument and func should be of type LHASH_DOALL_ARG_FN_TYPE (a callback prototype that is passed both the table entry and an extra argument).  As with lh_doall(), you can instead choose to declare your callback with a prototype matching the types you are dealing with and use the declare/implement macros to create compatible wrappers that cast variables before calling your type-specific callbacks.  An example of this is demonstrated here (printing all hash table entries to a BIO that is provided by the caller):</p> <pre><code>/* Prints item 'a' to 'output_bio' (this is implemented elsewhere) */\nvoid STUFF_print_doall_arg(const STUFF *a, BIO *output_bio);\n/* Implement a prototype-compatible wrapper for \"STUFF_print\" */\nstatic IMPLEMENT_LHASH_DOALL_ARG_FN(STUFF, const STUFF, BIO)\n        /* ... then later in the code ... */\n/* Print out the entire hashtable to a particular BIO */\nlh_STUFF_doall_arg(hashtable, LHASH_DOALL_ARG_FN(STUFF_print), BIO,\n                   logging_bio);\n</code></pre> <p>lh_&lt;type&gt;_error() can be used to determine if an error occurred in the last operation. lh_&lt;type&gt;_error() is a macro.</p>"},{"location":"man3/lhash/#return-values","title":"RETURN VALUES","text":"<p>lh_&lt;type&gt;_new() returns NULL on error, otherwise a pointer to the new LHASH structure.</p> <p>When a hash table entry is replaced, lh_&lt;type&gt;_insert() returns the value being replaced. NULL is returned on normal operation and on error.</p> <p>lh_&lt;type&gt;_delete() returns the entry being deleted.  NULL is returned if there is no such value in the hash table.</p> <p>lh_&lt;type&gt;_retrieve() returns the hash table entry if it has been found, NULL otherwise.</p> <p>lh_&lt;type&gt;_error() returns 1 if an error occurred in the last operation, 0 otherwise.</p> <p>lh_&lt;type&gt;_free(), lh_&lt;type&gt;_doall() and lh_&lt;type&gt;_doall_arg() return no values.</p>"},{"location":"man3/lhash/#note","title":"NOTE","text":"<p>The various LHASH macros and callback types exist to make it possible to write type-checked code without resorting to function-prototype casting - an evil that makes application code much harder to audit/verify and also opens the window of opportunity for stack corruption and other hard-to-find bugs.  It also, apparently, violates ANSI-C.</p> <p>The LHASH code regards table entries as constant data.  As such, it internally represents lh_insert()'d items with a \"const void *\" pointer type.  This is why callbacks such as those used by lh_doall() and lh_doall_arg() declare their prototypes with \"const\", even for the parameters that pass back the table items' data pointers - for consistency, user-provided data is \"const\" at all times as far as the LHASH code is concerned.  However, as callers are themselves providing these pointers, they can choose whether they too should be treating all such parameters as constant.</p> <p>As an example, a hash table may be maintained by code that, for reasons of encapsulation, has only \"const\" access to the data being indexed in the hash table (ie. it is returned as \"const\" from elsewhere in their code) - in this case the LHASH prototypes are appropriate as-is.  Conversely, if the caller is responsible for the life-time of the data in question, then they may well wish to make modifications to table item passed back in the lh_doall() or lh_doall_arg() callbacks (see the \"STUFF_cleanup\" example above).  If so, the caller can either cast the \"const\" away (if they're providing the raw callbacks themselves) or use the macros to declare/implement the wrapper functions without \"const\" types.</p> <p>Callers that only have \"const\" access to data they're indexing in a table, yet declare callbacks without constant types (or cast the \"const\" away themselves), are therefore creating their own risks/bugs without being encouraged to do so by the API.  On a related note, those auditing code should pay special attention to any instances of DECLARE/IMPLEMENT_LHASH_DOALL_[ARG_]_FN macros that provide types without any \"const\" qualifiers.</p>"},{"location":"man3/lhash/#bugs","title":"BUGS","text":"<p>lh_&lt;type&gt;_insert() returns NULL both for success and error.</p>"},{"location":"man3/lhash/#internals","title":"INTERNALS","text":"<p>The following description is based on the SSLeay documentation:</p> <p>The lhash library implements a hash table described in the Communications of the ACM in 1991.  What makes this hash table different is that as the table fills, the hash table is increased (or decreased) in size via OPENSSL_realloc().  When a 'resize' is done, instead of all hashes being redistributed over twice as many 'buckets', one bucket is split.  So when an 'expand' is done, there is only a minimal cost to redistribute some values.  Subsequent inserts will cause more single 'bucket' redistributions but there will never be a sudden large cost due to redistributing all the 'buckets'.</p> <p>The state for a particular hash table is kept in the LHASH structure. The decision to increase or decrease the hash table size is made depending on the 'load' of the hash table.  The load is the number of items in the hash table divided by the size of the hash table.  The default values are as follows.  If (hash-&gt;up_load &lt; load) =&gt; expand.  if (hash-&gt;down_load &gt; load) =&gt; contract.  The up_load has a default value of 1 and down_load has a default value of 2.  These numbers can be modified by the application by just playing with the up_load and down_load variables.  The 'load' is kept in a form which is multiplied by 256.  So hash-&gt;up_load=8*256; will cause a load of 8 to be set.</p> <p>If you are interested in performance the field to watch is num_comp_calls.  The hash library keeps track of the 'hash' value for each item so when a lookup is done, the 'hashes' are compared, if there is a match, then a full compare is done, and hash-&gt;num_comp_calls is incremented.  If num_comp_calls is not equal to num_delete plus num_retrieve it means that your hash function is generating hashes that are the same for different values.  It is probably worth changing your hash function if this is the case because even if your hash table has 10 items in a 'bucket', it can be searched with 10 unsigned long compares and 10 linked list traverses.  This will be much less expensive that 10 calls to your compare function.</p> <p>lh_strhash() is a demo string hashing function:</p> <pre><code>unsigned long lh_strhash(const char *c);\n</code></pre> <p>Since the LHASH routines would normally be passed structures, this routine would not normally be passed to lh_&lt;type&gt;_new(), rather it would be used in the function passed to lh_&lt;type&gt;_new().</p>"},{"location":"man3/lhash/#see-also","title":"SEE ALSO","text":"<p>lh_stats(3)</p>"},{"location":"man3/lhash/#history","title":"HISTORY","text":"<p>The lhash library is available in all versions of SSLeay and OpenSSL. lh_error() was added in SSLeay 0.9.1b.</p> <p>This manpage is derived from the SSLeay documentation.</p> <p>In OpenSSL 0.9.7, all lhash functions that were passed function pointers were changed for better type safety, and the function types LHASH_COMP_FN_TYPE, LHASH_HASH_FN_TYPE, LHASH_DOALL_FN_TYPE and LHASH_DOALL_ARG_FN_TYPE  became available.</p> <p>In OpenSSL 1.0.0, the lhash interface was revamped for even better type checking.</p>"},{"location":"man3/md5/","title":"md5","text":""},{"location":"man3/md5/#name","title":"NAME","text":"<p>MD2, MD4, MD5, MD2_Init, MD2_Update, MD2_Final, MD4_Init, MD4_Update, MD4_Final, MD5_Init, MD5_Update, MD5_Final - MD2, MD4, and MD5 hash functions</p>"},{"location":"man3/md5/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/md2.h&gt;\n\nunsigned char *MD2(const unsigned char *d, unsigned long n,\n                 unsigned char *md);\n\nint MD2_Init(MD2_CTX *c);\nint MD2_Update(MD2_CTX *c, const unsigned char *data,\n                 unsigned long len);\nint MD2_Final(unsigned char *md, MD2_CTX *c);\n\n\n#include &lt;openssl/md4.h&gt;\n\nunsigned char *MD4(const unsigned char *d, unsigned long n,\n                 unsigned char *md);\n\nint MD4_Init(MD4_CTX *c);\nint MD4_Update(MD4_CTX *c, const void *data,\n                 unsigned long len);\nint MD4_Final(unsigned char *md, MD4_CTX *c);\n\n\n#include &lt;openssl/md5.h&gt;\n\nunsigned char *MD5(const unsigned char *d, unsigned long n,\n                 unsigned char *md);\n\nint MD5_Init(MD5_CTX *c);\nint MD5_Update(MD5_CTX *c, const void *data,\n                 unsigned long len);\nint MD5_Final(unsigned char *md, MD5_CTX *c);\n</code></pre>"},{"location":"man3/md5/#description","title":"DESCRIPTION","text":"<p>MD2, MD4, and MD5 are cryptographic hash functions with a 128 bit output.</p> <p>MD2(), MD4(), and MD5() compute the MD2, MD4, and MD5 message digest of the n bytes at d and place it in md (which must have space for MD2_DIGEST_LENGTH == MD4_DIGEST_LENGTH == MD5_DIGEST_LENGTH == 16 bytes of output). If md is NULL, the digest is placed in a static array.</p> <p>The following functions may be used if the message is not completely stored in memory:</p> <p>MD2_Init() initializes a MD2_CTX structure.</p> <p>MD2_Update() can be called repeatedly with chunks of the message to be hashed (len bytes at data).</p> <p>MD2_Final() places the message digest in md, which must have space for MD2_DIGEST_LENGTH == 16 bytes of output, and erases the MD2_CTX.</p> <p>MD4_Init(), MD4_Update(), MD4_Final(), MD5_Init(), MD5_Update(), and MD5_Final() are analogous using an MD4_CTX and MD5_CTX structure.</p> <p>Applications should use the higher level functions EVP_DigestInit(3) etc. instead of calling the hash functions directly.</p>"},{"location":"man3/md5/#note","title":"NOTE","text":"<p>MD2, MD4, and MD5 are recommended only for compatibility with existing applications. In new applications, SHA-1 or RIPEMD-160 should be preferred.</p>"},{"location":"man3/md5/#return-values","title":"RETURN VALUES","text":"<p>MD2(), MD4(), and MD5() return pointers to the hash value. </p> <p>MD2_Init(), MD2_Update(), MD2_Final(), MD4_Init(), MD4_Update(), MD4_Final(), MD5_Init(), MD5_Update(), and MD5_Final() return 1 for success, 0 otherwise.</p>"},{"location":"man3/md5/#conforming-to","title":"CONFORMING TO","text":"<p>RFC 1319, RFC 1320, RFC 1321</p>"},{"location":"man3/md5/#see-also","title":"SEE ALSO","text":"<p>sha(3), ripemd(3), EVP_DigestInit(3)</p>"},{"location":"man3/md5/#history","title":"HISTORY","text":"<p>MD2(), MD2_Init(), MD2_Update() MD2_Final(), MD5(), MD5_Init(), MD5_Update() and MD5_Final() are available in all versions of SSLeay and OpenSSL.</p> <p>MD4(), MD4_Init(), and MD4_Update() are available in OpenSSL 0.9.6 and above.</p>"},{"location":"man3/mdc2/","title":"mdc2","text":""},{"location":"man3/mdc2/#name","title":"NAME","text":"<p>MDC2, MDC2_Init, MDC2_Update, MDC2_Final - MDC2 hash function</p>"},{"location":"man3/mdc2/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/mdc2.h&gt;\n\nunsigned char *MDC2(const unsigned char *d, unsigned long n,\n                 unsigned char *md);\n\nint MDC2_Init(MDC2_CTX *c);\nint MDC2_Update(MDC2_CTX *c, const unsigned char *data,\n                 unsigned long len);\nint MDC2_Final(unsigned char *md, MDC2_CTX *c);\n</code></pre>"},{"location":"man3/mdc2/#description","title":"DESCRIPTION","text":"<p>MDC2 is a method to construct hash functions with 128 bit output from block ciphers.  These functions are an implementation of MDC2 with DES.</p> <p>MDC2() computes the MDC2 message digest of the n bytes at d and places it in md (which must have space for MDC2_DIGEST_LENGTH == 16 bytes of output). If md is NULL, the digest is placed in a static array.</p> <p>The following functions may be used if the message is not completely stored in memory:</p> <p>MDC2_Init() initializes a MDC2_CTX structure.</p> <p>MDC2_Update() can be called repeatedly with chunks of the message to be hashed (len bytes at data).</p> <p>MDC2_Final() places the message digest in md, which must have space for MDC2_DIGEST_LENGTH == 16 bytes of output, and erases the MDC2_CTX.</p> <p>Applications should use the higher level functions EVP_DigestInit(3) etc. instead of calling the hash functions directly.</p>"},{"location":"man3/mdc2/#return-values","title":"RETURN VALUES","text":"<p>MDC2() returns a pointer to the hash value. </p> <p>MDC2_Init(), MDC2_Update() and MDC2_Final() return 1 for success, 0 otherwise.</p>"},{"location":"man3/mdc2/#conforming-to","title":"CONFORMING TO","text":"<p>ISO/IEC 10118-2, with DES</p>"},{"location":"man3/mdc2/#see-also","title":"SEE ALSO","text":"<p>sha(3), EVP_DigestInit(3)</p>"},{"location":"man3/mdc2/#history","title":"HISTORY","text":"<p>MDC2(), MDC2_Init(), MDC2_Update() and MDC2_Final() are available since SSLeay 0.8.</p>"},{"location":"man3/pem/","title":"pem","text":""},{"location":"man3/pem/#name","title":"NAME","text":"<p>PEM, PEM_read_bio_PrivateKey, PEM_read_PrivateKey, PEM_write_bio_PrivateKey, PEM_write_PrivateKey, PEM_write_bio_PKCS8PrivateKey, PEM_write_PKCS8PrivateKey, PEM_write_bio_PKCS8PrivateKey_nid, PEM_write_PKCS8PrivateKey_nid, PEM_read_bio_PUBKEY, PEM_read_PUBKEY, PEM_write_bio_PUBKEY, PEM_write_PUBKEY, PEM_read_bio_RSAPrivateKey, PEM_read_RSAPrivateKey, PEM_write_bio_RSAPrivateKey, PEM_write_RSAPrivateKey, PEM_read_bio_RSAPublicKey, PEM_read_RSAPublicKey, PEM_write_bio_RSAPublicKey, PEM_write_RSAPublicKey, PEM_read_bio_RSA_PUBKEY, PEM_read_RSA_PUBKEY, PEM_write_bio_RSA_PUBKEY, PEM_write_RSA_PUBKEY, PEM_read_bio_DSAPrivateKey, PEM_read_DSAPrivateKey, PEM_write_bio_DSAPrivateKey, PEM_write_DSAPrivateKey, PEM_read_bio_DSA_PUBKEY, PEM_read_DSA_PUBKEY, PEM_write_bio_DSA_PUBKEY, PEM_write_DSA_PUBKEY, PEM_read_bio_DSAparams, PEM_read_DSAparams, PEM_write_bio_DSAparams, PEM_write_DSAparams, PEM_read_bio_DHparams, PEM_read_DHparams, PEM_write_bio_DHparams, PEM_write_DHparams, PEM_read_bio_X509, PEM_read_X509, PEM_write_bio_X509, PEM_write_X509, PEM_read_bio_X509_AUX, PEM_read_X509_AUX, PEM_write_bio_X509_AUX, PEM_write_X509_AUX, PEM_read_bio_X509_REQ, PEM_read_X509_REQ, PEM_write_bio_X509_REQ, PEM_write_X509_REQ, PEM_write_bio_X509_REQ_NEW, PEM_write_X509_REQ_NEW, PEM_read_bio_X509_CRL, PEM_read_X509_CRL, PEM_write_bio_X509_CRL, PEM_write_X509_CRL, PEM_read_bio_PKCS7, PEM_read_PKCS7, PEM_write_bio_PKCS7, PEM_write_PKCS7, PEM_read_bio_NETSCAPE_CERT_SEQUENCE, PEM_read_NETSCAPE_CERT_SEQUENCE, PEM_write_bio_NETSCAPE_CERT_SEQUENCE, PEM_write_NETSCAPE_CERT_SEQUENCE - PEM routines</p>"},{"location":"man3/pem/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/pem.h&gt;\n\nEVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,\n                                       pem_password_cb *cb, void *u);\n\nEVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\n                                       unsigned char *kstr, int klen,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n                                       unsigned char *kstr, int klen,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\n                                       char *kstr, int klen,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n                                       char *kstr, int klen,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,\n                                       char *kstr, int klen,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,\n                                       char *kstr, int klen,\n                                       pem_password_cb *cb, void *u);\n\nEVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x,\n                                       pem_password_cb *cb, void *u);\n\nEVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x);\nint PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x);\n\nRSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x,\n                                       pem_password_cb *cb, void *u);\n\nRSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **x,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,\n                                       unsigned char *kstr, int klen,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,\n                                       unsigned char *kstr, int klen,\n                                       pem_password_cb *cb, void *u);\n\nRSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x,\n                                       pem_password_cb *cb, void *u);\n\nRSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x);\n\nint PEM_write_RSAPublicKey(FILE *fp, RSA *x);\n\nRSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x,\n                                       pem_password_cb *cb, void *u);\n\nRSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA **x,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x);\n\nint PEM_write_RSA_PUBKEY(FILE *fp, RSA *x);\n\nDSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x,\n                                       pem_password_cb *cb, void *u);\n\nDSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **x,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,\n                                       unsigned char *kstr, int klen,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,\n                                       unsigned char *kstr, int klen,\n                                       pem_password_cb *cb, void *u);\n\nDSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x,\n                                       pem_password_cb *cb, void *u);\n\nDSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA **x,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x);\n\nint PEM_write_DSA_PUBKEY(FILE *fp, DSA *x);\n\nDSA *PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u);\n\nDSA *PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u);\n\nint PEM_write_bio_DSAparams(BIO *bp, DSA *x);\n\nint PEM_write_DSAparams(FILE *fp, DSA *x);\n\nDH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u);\n\nDH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u);\n\nint PEM_write_bio_DHparams(BIO *bp, DH *x);\n\nint PEM_write_DHparams(FILE *fp, DH *x);\n\nX509 *PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb *cb, void *u);\n\nX509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb, void *u);\n\nint PEM_write_bio_X509(BIO *bp, X509 *x);\n\nint PEM_write_X509(FILE *fp, X509 *x);\n\nX509 *PEM_read_bio_X509_AUX(BIO *bp, X509 **x, pem_password_cb *cb, void *u);\n\nX509 *PEM_read_X509_AUX(FILE *fp, X509 **x, pem_password_cb *cb, void *u);\n\nint PEM_write_bio_X509_AUX(BIO *bp, X509 *x);\n\nint PEM_write_X509_AUX(FILE *fp, X509 *x);\n\nX509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x,\n                                       pem_password_cb *cb, void *u);\n\nX509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ **x,\n                                       pem_password_cb *cb, void *u);\n\nint PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x);\n\nint PEM_write_X509_REQ(FILE *fp, X509_REQ *x);\n\nint PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x);\n\nint PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x);\n\nX509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x,\n                                       pem_password_cb *cb, void *u);\nX509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL **x,\n                                       pem_password_cb *cb, void *u);\nint PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x);\nint PEM_write_X509_CRL(FILE *fp, X509_CRL *x);\n\nPKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void *u);\n\nPKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u);\n\nint PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x);\n\nint PEM_write_PKCS7(FILE *fp, PKCS7 *x);\n\nNETSCAPE_CERT_SEQUENCE *PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp,\n                                               NETSCAPE_CERT_SEQUENCE **x,\n                                               pem_password_cb *cb, void *u);\n\nNETSCAPE_CERT_SEQUENCE *PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp,\n                                               NETSCAPE_CERT_SEQUENCE **x,\n                                               pem_password_cb *cb, void *u);\n\nint PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE *x);\n\nint PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE *x);\n</code></pre>"},{"location":"man3/pem/#description","title":"DESCRIPTION","text":"<p>The PEM functions read or write structures in PEM format. In this sense PEM format is simply base64 encoded data surrounded by header lines.</p> <p>For more details about the meaning of arguments see the PEM FUNCTION ARGUMENTS section.</p> <p>Each operation has four functions associated with it. For clarity the term \"foobar functions\" will be used to collectively refer to the PEM_read_bio_foobar(), PEM_read_foobar(), PEM_write_bio_foobar() and PEM_write_foobar() functions.</p> <p>The PrivateKey functions read or write a private key in PEM format using an EVP_PKEY structure. The write routines use \"traditional\" private key format and can handle both RSA and DSA private keys. The read functions can additionally transparently handle PKCS#8 format encrypted and unencrypted keys too.</p> <p>PEM_write_bio_PKCS8PrivateKey() and PEM_write_PKCS8PrivateKey() write a private key in an EVP_PKEY structure in PKCS#8 EncryptedPrivateKeyInfo format using PKCS#5 v2.0 password based encryption algorithms. The cipher argument specifies the encryption algorithm to use: unlike all other PEM routines the encryption is applied at the PKCS#8 level and not in the PEM headers. If cipher is NULL then no encryption is used and a PKCS#8 PrivateKeyInfo structure is used instead.</p> <p>PEM_write_bio_PKCS8PrivateKey_nid() and PEM_write_PKCS8PrivateKey_nid() also write out a private key as a PKCS#8 EncryptedPrivateKeyInfo however it uses PKCS#5 v1.5 or PKCS#12 encryption algorithms instead. The algorithm to use is specified in the nid parameter and should be the NID of the corresponding OBJECT IDENTIFIER (see NOTES section).</p> <p>The PUBKEY functions process a public key using an EVP_PKEY structure. The public key is encoded as a SubjectPublicKeyInfo structure.</p> <p>The RSAPrivateKey functions process an RSA private key using an RSA structure. It handles the same formats as the PrivateKey functions but an error occurs if the private key is not RSA.</p> <p>The RSAPublicKey functions process an RSA public key using an RSA structure. The public key is encoded using a PKCS#1 RSAPublicKey structure.</p> <p>The RSA_PUBKEY functions also process an RSA public key using an RSA structure. However the public key is encoded using a SubjectPublicKeyInfo structure and an error occurs if the public key is not RSA.</p> <p>The DSAPrivateKey functions process a DSA private key using a DSA structure. It handles the same formats as the PrivateKey functions but an error occurs if the private key is not DSA.</p> <p>The DSA_PUBKEY functions process a DSA public key using a DSA structure. The public key is encoded using a SubjectPublicKeyInfo structure and an error occurs if the public key is not DSA.</p> <p>The DSAparams functions process DSA parameters using a DSA structure. The parameters are encoded using a Dss-Parms structure as defined in RFC2459.</p> <p>The DHparams functions process DH parameters using a DH structure. The parameters are encoded using a PKCS#3 DHparameter structure.</p> <p>The X509 functions process an X509 certificate using an X509 structure. They will also process a trusted X509 certificate but any trust settings are discarded.</p> <p>The X509_AUX functions process a trusted X509 certificate using an X509 structure. </p> <p>The X509_REQ and X509_REQ_NEW functions process a PKCS#10 certificate request using an X509_REQ structure. The X509_REQ write functions use CERTIFICATE REQUEST in the header whereas the X509_REQ_NEW functions use NEW CERTIFICATE REQUEST (as required by some CAs). The X509_REQ read functions will handle either form so there are no X509_REQ_NEW read functions.</p> <p>The X509_CRL functions process an X509 CRL using an X509_CRL structure.</p> <p>The PKCS7 functions process a PKCS#7 ContentInfo using a PKCS7 structure.</p> <p>The NETSCAPE_CERT_SEQUENCE functions process a Netscape Certificate Sequence using a NETSCAPE_CERT_SEQUENCE structure.</p>"},{"location":"man3/pem/#pem-function-arguments","title":"PEM FUNCTION ARGUMENTS","text":"<p>The PEM functions have many common arguments.</p> <p>The bp BIO parameter (if present) specifies the BIO to read from or write to.</p> <p>The fp FILE parameter (if present) specifies the FILE pointer to read from or write to.</p> <p>The PEM read functions all take an argument TYPE **x and return a TYPE * pointer. Where TYPE is whatever structure the function uses. If x is NULL then the parameter is ignored. If x is not NULL but *x is NULL then the structure returned will be written to *x. If neither x nor *x is NULL then an attempt is made to reuse the structure at *x (but see BUGS and EXAMPLES sections). Irrespective of the value of x a pointer to the structure is always returned (or NULL if an error occurred).</p> <p>The PEM functions which write private keys take an enc parameter which specifies the encryption algorithm to use, encryption is done at the PEM level. If this parameter is set to NULL then the private key is written in unencrypted form.</p> <p>The cb argument is the callback to use when querying for the pass phrase used for encrypted PEM structures (normally only private keys).</p> <p>For the PEM write routines if the kstr parameter is not NULL then klen bytes at kstr are used as the passphrase and cb is ignored.</p> <p>If the cb parameters is set to NULL and the u parameter is not NULL then the u parameter is interpreted as a null terminated string to use as the passphrase. If both cb and u are NULL then the default callback routine is used which will typically prompt for the passphrase on the current terminal with echoing turned off.</p> <p>The default passphrase callback is sometimes inappropriate (for example in a GUI application) so an alternative can be supplied. The callback routine has the following form:</p> <pre><code>int cb(char *buf, int size, int rwflag, void *u);\n</code></pre> <p>buf is the buffer to write the passphrase to. size is the maximum length of the passphrase (i.e. the size of buf). rwflag is a flag which is set to 0 when reading and 1 when writing. A typical routine will ask the user to verify the passphrase (for example by prompting for it twice) if rwflag is 1. The u parameter has the same value as the u parameter passed to the PEM routine. It allows arbitrary data to be passed to the callback by the application (for example a window handle in a GUI application). The callback must return the number of characters in the passphrase or -1 if an error occurred.</p>"},{"location":"man3/pem/#examples","title":"EXAMPLES","text":"<p>Although the PEM routines take several arguments in almost all applications most of them are set to 0 or NULL.</p> <p>Read a certificate in PEM format from a BIO:</p> <pre><code>X509 *x;\nx = PEM_read_bio_X509(bp, NULL, 0, NULL);\nif (x == NULL) {\n    /* Error */\n}\n</code></pre> <p>Alternative method:</p> <pre><code>X509 *x = NULL;\nif (!PEM_read_bio_X509(bp, &amp;x, 0, NULL)) {\n    /* Error */\n}\n</code></pre> <p>Write a certificate to a BIO:</p> <pre><code>if (!PEM_write_bio_X509(bp, x)) {\n    /* Error */\n}\n</code></pre> <p>Write an unencrypted private key to a FILE pointer:</p> <pre><code>if (!PEM_write_PrivateKey(fp, key, NULL, NULL, 0, 0, NULL)) {\n    /* Error */\n}\n</code></pre> <p>Write a private key (using traditional format) to a BIO using triple DES encryption, the pass phrase is prompted for:</p> <pre><code>if (!PEM_write_bio_PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, NULL)) {\n    /* Error */\n}\n</code></pre> <p>Write a private key (using PKCS#8 format) to a BIO using triple DES encryption, using the pass phrase \"hello\":</p> <pre><code>if (!PEM_write_bio_PKCS8PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, \"hello\")) {\n    /* Error */\n}\n</code></pre> <p>Read a private key from a BIO using the pass phrase \"hello\":</p> <pre><code>key = PEM_read_bio_PrivateKey(bp, NULL, 0, \"hello\");\nif (key == NULL) {\n    /* Error */\n}\n</code></pre> <p>Read a private key from a BIO using a pass phrase callback:</p> <pre><code>key = PEM_read_bio_PrivateKey(bp, NULL, pass_cb, \"My Private Key\");\nif (key == NULL) {\n    /* Error */\n}\n</code></pre> <p>Skeleton pass phrase callback:</p> <pre><code>int pass_cb(char *buf, int size, int rwflag, void *u)\n{\n\n    /* We'd probably do something else if 'rwflag' is 1 */\n    printf(\"Enter pass phrase for \\\"%s\\\"\\n\", u);\n\n    /* get pass phrase, length 'len' into 'tmp' */\n    char *tmp = \"hello\";\n    if (tmp == NULL) /* An error occurred */\n        return -1;\n\n    size_t len = strlen(tmp);\n\n    if (len &gt; size)\n        len = size;\n    memcpy(buf, tmp, len);\n    return len;\n}\n</code></pre>"},{"location":"man3/pem/#notes","title":"NOTES","text":"<p>The old PrivateKey write routines are retained for compatibility. New applications should write private keys using the PEM_write_bio_PKCS8PrivateKey() or PEM_write_PKCS8PrivateKey() routines because they are more secure (they use an iteration count of 2048 whereas the traditional routines use a count of 1) unless compatibility with older versions of OpenSSL is important.</p> <p>The PrivateKey read routines can be used in all applications because they handle all formats transparently.</p> <p>A frequent cause of problems is attempting to use the PEM routines like this:</p> <pre><code>X509 *x;\nPEM_read_bio_X509(bp, &amp;x, 0, NULL);\n</code></pre> <p>this is a bug because an attempt will be made to reuse the data at x which is an uninitialised pointer.</p>"},{"location":"man3/pem/#pem-encryption-format","title":"PEM ENCRYPTION FORMAT","text":"<p>This old PrivateKey routines use a non standard technique for encryption.</p> <p>The private key (or other data) takes the following form: </p> <pre><code>-----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: DES-EDE3-CBC,3F17F5316E2BAC89\n\n...base64 encoded data...\n-----END RSA PRIVATE KEY-----\n</code></pre> <p>The line beginning DEK-Info contains two comma separated pieces of information: the encryption algorithm name as used by EVP_get_cipherbyname() and an 8 byte salt encoded as a set of hexadecimal digits.</p> <p>After this is the base64 encoded encrypted data.</p> <p>The encryption key is determined using EVP_BytesToKey(), using salt and an iteration count of 1. The IV used is the value of salt and *not* the IV returned by EVP_BytesToKey().</p>"},{"location":"man3/pem/#bugs","title":"BUGS","text":"<p>The PEM read routines in some versions of OpenSSL will not correctly reuse an existing structure. Therefore the following:</p> <pre><code>PEM_read_bio_X509(bp, &amp;x, 0, NULL);\n</code></pre> <p>where x already contains a valid certificate, may not work, whereas: </p> <pre><code>X509_free(x);\nx = PEM_read_bio_X509(bp, NULL, 0, NULL);\n</code></pre> <p>is guaranteed to work.</p>"},{"location":"man3/pem/#return-codes","title":"RETURN CODES","text":"<p>The read routines return either a pointer to the structure read or NULL if an error occurred.</p> <p>The write routines return 1 for success or 0 for failure.</p>"},{"location":"man3/pem/#see-also","title":"SEE ALSO","text":"<p>EVP_get_cipherbyname(3), EVP_BytesToKey(3)</p>"},{"location":"man3/rand/","title":"rand","text":""},{"location":"man3/rand/#name","title":"NAME","text":"<p>rand - pseudo-random number generator</p>"},{"location":"man3/rand/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rand.h&gt;\n\nint  RAND_set_rand_engine(ENGINE *engine);\n\nint  RAND_bytes(unsigned char *buf, int num);\nint  RAND_pseudo_bytes(unsigned char *buf, int num);\n\nvoid RAND_seed(const void *buf, int num);\nvoid RAND_add(const void *buf, int num, double entropy);\nint  RAND_status(void);\n\nint  RAND_load_file(const char *file, long max_bytes);\nint  RAND_write_file(const char *file);\nconst char *RAND_file_name(char *file, size_t num);\n\nint  RAND_egd(const char *path);\n\nvoid RAND_set_rand_method(const RAND_METHOD *meth);\nconst RAND_METHOD *RAND_get_rand_method(void);\nRAND_METHOD *RAND_SSLeay(void);\n\nvoid RAND_cleanup(void);\n\n/* For Win32 only */\nvoid RAND_screen(void);\nint RAND_event(UINT, WPARAM, LPARAM);\n</code></pre>"},{"location":"man3/rand/#description","title":"DESCRIPTION","text":"<p>Since the introduction of the ENGINE API, the recommended way of controlling default implementations is by using the ENGINE API functions. The default RAND_METHOD, as set by RAND_set_rand_method() and returned by RAND_get_rand_method(), is only used if no ENGINE has been set as the default \"rand\" implementation. Hence, these two functions are no longer the recommended way to control defaults.</p> <p>If an alternative RAND_METHOD implementation is being used (either set directly or as provided by an ENGINE module), then it is entirely responsible for the generation and management of a cryptographically secure PRNG stream. The mechanisms described below relate solely to the software PRNG implementation built in to OpenSSL and used by default.</p> <p>These functions implement a cryptographically secure pseudo-random number generator (PRNG). It is used by other library functions for example to generate random keys, and applications can use it when they need randomness.</p> <p>A cryptographic PRNG must be seeded with unpredictable data such as mouse movements or keys pressed at random by the user. This is described in RAND_add(3). Its state can be saved in a seed file (see RAND_load_file(3)) to avoid having to go through the seeding process whenever the application is started.</p> <p>RAND_bytes(3) describes how to obtain random data from the PRNG. </p>"},{"location":"man3/rand/#internals","title":"INTERNALS","text":"<p>The RAND_SSLeay() method implements a PRNG based on a cryptographic hash function.</p> <p>The following description of its design is based on the SSLeay documentation:</p> <p>First up I will state the things I believe I need for a good RNG.</p> <ol> <li>A good hashing algorithm to mix things up and to convert the RNG 'state' to random numbers.</li> <li>An initial source of random 'state'.</li> <li>The state should be very large.  If the RNG is being used to generate 4096 bit RSA keys, 2 2048 bit random strings are required (at a minimum). If your RNG state only has 128 bits, you are obviously limiting the search space to 128 bits, not 2048.  I'm probably getting a little carried away on this last point but it does indicate that it may not be a bad idea to keep quite a lot of RNG state.  It should be easier to break a cipher than guess the RNG seed data.</li> <li>Any RNG seed data should influence all subsequent random numbers generated.  This implies that any random seed data entered will have an influence on all subsequent random numbers generated.</li> <li>When using data to seed the RNG state, the data used should not be extractable from the RNG state.  I believe this should be a requirement because one possible source of 'secret' semi random data would be a private key or a password.  This data must not be disclosed by either subsequent random numbers or a 'core' dump left by a program crash.</li> <li>Given the same initial 'state', 2 systems should deviate in their RNG state (and hence the random numbers generated) over time if at all possible.</li> <li>Given the random number output stream, it should not be possible to determine the RNG state or the next random number.</li> </ol> <p>The algorithm is as follows.</p> <p>There is global state made up of a 1023 byte buffer (the 'state'), a working hash value ('md'), and a counter ('count').</p> <p>Whenever seed data is added, it is inserted into the 'state' as follows.</p> <p>The input is chopped up into units of 20 bytes (or less for the last block).  Each of these blocks is run through the hash function as follows:  The data passed to the hash function is the current 'md', the same number of bytes from the 'state' (the location determined by in incremented looping index) as the current 'block', the new key data 'block', and 'count' (which is incremented after each use). The result of this is kept in 'md' and also xored into the 'state' at the same locations that were used as input into the hash function. I believe this system addresses points 1 (hash function; currently SHA-1), 3 (the 'state'), 4 (via the 'md'), 5 (by the use of a hash function and xor).</p> <p>When bytes are extracted from the RNG, the following process is used. For each group of 10 bytes (or less), we do the following:</p> <p>Input into the hash function the local 'md' (which is initialized from the global 'md' before any bytes are generated), the bytes that are to be overwritten by the random bytes, and bytes from the 'state' (incrementing looping index). From this digest output (which is kept in 'md'), the top (up to) 10 bytes are returned to the caller and the bottom 10 bytes are xored into the 'state'.</p> <p>Finally, after we have finished 'num' random bytes for the caller, 'count' (which is incremented) and the local and global 'md' are fed into the hash function and the results are kept in the global 'md'.</p> <p>I believe the above addressed points 1 (use of SHA-1), 6 (by hashing into the 'state' the 'old' data from the caller that is about to be overwritten) and 7 (by not using the 10 bytes given to the caller to update the 'state', but they are used to update 'md').</p> <p>So of the points raised, only 2 is not addressed (but see RAND_add(3)).</p>"},{"location":"man3/rand/#see-also","title":"SEE ALSO","text":"<p>BN_rand(3), RAND_add(3), RAND_load_file(3), RAND_egd(3), RAND_bytes(3), RAND_set_rand_method(3), RAND_cleanup(3) </p>"},{"location":"man3/rc4/","title":"rc4","text":""},{"location":"man3/rc4/#name","title":"NAME","text":"<p>RC4_set_key, RC4 - RC4 encryption</p>"},{"location":"man3/rc4/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rc4.h&gt;\n\nvoid RC4_set_key(RC4_KEY *key, int len, const unsigned char *data);\n\nvoid RC4(RC4_KEY *key, unsigned long len, const unsigned char *indata,\n         unsigned char *outdata);\n</code></pre>"},{"location":"man3/rc4/#description","title":"DESCRIPTION","text":"<p>This library implements the Alleged RC4 cipher, which is described for example in Applied Cryptography.  It is believed to be compatible with RC4[TM], a proprietary cipher of RSA Security Inc.</p> <p>RC4 is a stream cipher with variable key length.  Typically, 128 bit (16 byte) keys are used for strong encryption, but shorter insecure key sizes have been widely used due to export restrictions.</p> <p>RC4 consists of a key setup phase and the actual encryption or decryption phase.</p> <p>RC4_set_key() sets up the RC4_KEY key using the len bytes long key at data.</p> <p>RC4() encrypts or decrypts the len bytes of data at indata using key and places the result at outdata.  Repeated RC4() calls with the same key yield a continuous key stream.</p> <p>Since RC4 is a stream cipher (the input is XORed with a pseudo-random key stream to produce the output), decryption uses the same function calls as encryption.</p> <p>Applications should use the higher level functions EVP_EncryptInit(3) etc. instead of calling the RC4 functions directly.</p>"},{"location":"man3/rc4/#return-values","title":"RETURN VALUES","text":"<p>RC4_set_key() and RC4() do not return values.</p>"},{"location":"man3/rc4/#note","title":"NOTE","text":"<p>Certain conditions have to be observed to securely use stream ciphers. It is not permissible to perform multiple encryptions using the same key stream.</p>"},{"location":"man3/rc4/#see-also","title":"SEE ALSO","text":"<p>blowfish(3), des(3), rc2(3)</p>"},{"location":"man3/rc4/#history","title":"HISTORY","text":"<p>RC4_set_key() and RC4() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/ripemd/","title":"ripemd","text":""},{"location":"man3/ripemd/#name","title":"NAME","text":"<p>RIPEMD160, RIPEMD160_Init, RIPEMD160_Update, RIPEMD160_Final - RIPEMD-160 hash function</p>"},{"location":"man3/ripemd/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ripemd.h&gt;\n\nunsigned char *RIPEMD160(const unsigned char *d, unsigned long n,\n                 unsigned char *md);\n\nint RIPEMD160_Init(RIPEMD160_CTX *c);\nint RIPEMD160_Update(RIPEMD_CTX *c, const void *data,\n                 unsigned long len);\nint RIPEMD160_Final(unsigned char *md, RIPEMD160_CTX *c);\n</code></pre>"},{"location":"man3/ripemd/#description","title":"DESCRIPTION","text":"<p>RIPEMD-160 is a cryptographic hash function with a 160 bit output.</p> <p>RIPEMD160() computes the RIPEMD-160 message digest of the n bytes at d and places it in md (which must have space for RIPEMD160_DIGEST_LENGTH == 20 bytes of output). If md is NULL, the digest is placed in a static array.</p> <p>The following functions may be used if the message is not completely stored in memory:</p> <p>RIPEMD160_Init() initializes a RIPEMD160_CTX structure.</p> <p>RIPEMD160_Update() can be called repeatedly with chunks of the message to be hashed (len bytes at data).</p> <p>RIPEMD160_Final() places the message digest in md, which must have space for RIPEMD160_DIGEST_LENGTH == 20 bytes of output, and erases the RIPEMD160_CTX.</p> <p>Applications should use the higher level functions EVP_DigestInit(3) etc. instead of calling the hash functions directly.</p>"},{"location":"man3/ripemd/#return-values","title":"RETURN VALUES","text":"<p>RIPEMD160() returns a pointer to the hash value. </p> <p>RIPEMD160_Init(), RIPEMD160_Update() and RIPEMD160_Final() return 1 for success, 0 otherwise.</p>"},{"location":"man3/ripemd/#conforming-to","title":"CONFORMING TO","text":"<p>ISO/IEC 10118-3 (draft) (??)</p>"},{"location":"man3/ripemd/#see-also","title":"SEE ALSO","text":"<p>sha(3), hmac(3), EVP_DigestInit(3)</p>"},{"location":"man3/ripemd/#history","title":"HISTORY","text":"<p>RIPEMD160(), RIPEMD160_Init(), RIPEMD160_Update() and RIPEMD160_Final() are available since SSLeay 0.9.0.</p>"},{"location":"man3/rsa/","title":"rsa","text":""},{"location":"man3/rsa/#name","title":"NAME","text":"<p>rsa - RSA public key cryptosystem</p>"},{"location":"man3/rsa/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/rsa.h&gt;\n#include &lt;openssl/engine.h&gt;\n\nRSA * RSA_new(void);\nvoid RSA_free(RSA *rsa);\n\nint RSA_public_encrypt(int flen, unsigned char *from,\n   unsigned char *to, RSA *rsa, int padding);\nint RSA_private_decrypt(int flen, unsigned char *from,\n   unsigned char *to, RSA *rsa, int padding);\nint RSA_private_encrypt(int flen, unsigned char *from,\n   unsigned char *to, RSA *rsa,int padding);\nint RSA_public_decrypt(int flen, unsigned char *from, \n   unsigned char *to, RSA *rsa,int padding);\n\nint RSA_sign(int type, unsigned char *m, unsigned int m_len,\n   unsigned char *sigret, unsigned int *siglen, RSA *rsa);\nint RSA_verify(int type, unsigned char *m, unsigned int m_len,\n   unsigned char *sigbuf, unsigned int siglen, RSA *rsa);\n\nint RSA_size(const RSA *rsa);\n\nRSA *RSA_generate_key(int num, unsigned long e,\n   void (*callback)(int,int,void *), void *cb_arg);\n\nint RSA_check_key(RSA *rsa);\n\nint RSA_blinding_on(RSA *rsa, BN_CTX *ctx);\nvoid RSA_blinding_off(RSA *rsa);\n\nvoid RSA_set_default_method(const RSA_METHOD *meth);\nconst RSA_METHOD *RSA_get_default_method(void);\nint RSA_set_method(RSA *rsa, const RSA_METHOD *meth);\nconst RSA_METHOD *RSA_get_method(const RSA *rsa);\nRSA_METHOD *RSA_PKCS1_SSLeay(void);\nRSA_METHOD *RSA_null_method(void);\nint RSA_flags(const RSA *rsa);\nRSA *RSA_new_method(ENGINE *engine);\n\nint RSA_print(BIO *bp, RSA *x, int offset);\nint RSA_print_fp(FILE *fp, RSA *x, int offset);\n\nint RSA_get_ex_new_index(long argl, char *argp, int (*new_func)(),\n   int (*dup_func)(), void (*free_func)());\nint RSA_set_ex_data(RSA *r,int idx,char *arg);\nchar *RSA_get_ex_data(RSA *r, int idx);\n\nint RSA_sign_ASN1_OCTET_STRING(int dummy, unsigned char *m,\n   unsigned int m_len, unsigned char *sigret, unsigned int *siglen,\n   RSA *rsa);\nint RSA_verify_ASN1_OCTET_STRING(int dummy, unsigned char *m,\n   unsigned int m_len, unsigned char *sigbuf, unsigned int siglen,\n   RSA *rsa);\n</code></pre>"},{"location":"man3/rsa/#description","title":"DESCRIPTION","text":"<p>These functions implement RSA public key encryption and signatures as defined in PKCS #1 v2.0 [RFC 2437].</p> <p>The RSA structure consists of several BIGNUM components. It can contain public as well as private RSA keys:</p> <pre><code>struct\n       {\n       BIGNUM *n;              // public modulus\n       BIGNUM *e;              // public exponent\n       BIGNUM *d;              // private exponent\n       BIGNUM *p;              // secret prime factor\n       BIGNUM *q;              // secret prime factor\n       BIGNUM *dmp1;           // d mod (p-1)\n       BIGNUM *dmq1;           // d mod (q-1)\n       BIGNUM *iqmp;           // q^-1 mod p\n       // ...\n       };\nRSA\n</code></pre> <p>In public keys, the private exponent and the related secret values are NULL.</p> <p>p, q, dmp1, dmq1 and iqmp may be NULL in private keys, but the RSA operations are much faster when these values are available.</p> <p>Note that RSA keys may use non-standard RSA_METHOD implementations, either directly or by the use of ENGINE modules. In some cases (eg. an ENGINE providing support for hardware-embedded keys), these BIGNUM values will not be used by the implementation or may be used for alternative data storage. For this reason, applications should generally avoid using RSA structure elements directly and instead use API functions to query or modify keys.</p>"},{"location":"man3/rsa/#conforming-to","title":"CONFORMING TO","text":"<p>SSL, PKCS #1 v2.0</p>"},{"location":"man3/rsa/#patents","title":"PATENTS","text":"<p>RSA was covered by a US patent which expired in September 2000.</p>"},{"location":"man3/rsa/#see-also","title":"SEE ALSO","text":"<p>rsa(1), bn(3), dsa(3), dh(3), rand(3), engine(3), RSA_new(3), RSA_public_encrypt(3), RSA_sign(3), RSA_size(3), RSA_generate_key(3), RSA_check_key(3), RSA_blinding_on(3), RSA_set_method(3), RSA_print(3), RSA_get_ex_new_index(3), RSA_private_encrypt(3), RSA_sign_ASN1_OCTET_STRING(3), RSA_padding_add_PKCS1_type_1(3) </p>"},{"location":"man3/sha/","title":"sha","text":""},{"location":"man3/sha/#name","title":"NAME","text":"<p>SHA1, SHA1_Init, SHA1_Update, SHA1_Final, SHA224, SHA224_Init, SHA224_Update, SHA224_Final, SHA256, SHA256_Init, SHA256_Update, SHA256_Final, SHA384, SHA384_Init, SHA384_Update, SHA384_Final, SHA512, SHA512_Init, SHA512_Update, SHA512_Final - Secure Hash Algorithm</p>"},{"location":"man3/sha/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/sha.h&gt;\n\nint SHA1_Init(SHA_CTX *c);\nint SHA1_Update(SHA_CTX *c, const void *data, size_t len);\nint SHA1_Final(unsigned char *md, SHA_CTX *c);\nunsigned char *SHA1(const unsigned char *d, size_t n,\n     unsigned char *md);\n\nint SHA224_Init(SHA256_CTX *c);\nint SHA224_Update(SHA256_CTX *c, const void *data, size_t len);\nint SHA224_Final(unsigned char *md, SHA256_CTX *c);\nunsigned char *SHA224(const unsigned char *d, size_t n,\n     unsigned char *md);\n\nint SHA256_Init(SHA256_CTX *c);\nint SHA256_Update(SHA256_CTX *c, const void *data, size_t len);\nint SHA256_Final(unsigned char *md, SHA256_CTX *c);\nunsigned char *SHA256(const unsigned char *d, size_t n,\n     unsigned char *md);\n\nint SHA384_Init(SHA512_CTX *c);\nint SHA384_Update(SHA512_CTX *c, const void *data, size_t len);\nint SHA384_Final(unsigned char *md, SHA512_CTX *c);\nunsigned char *SHA384(const unsigned char *d, size_t n,\n     unsigned char *md);\n\nint SHA512_Init(SHA512_CTX *c);\nint SHA512_Update(SHA512_CTX *c, const void *data, size_t len);\nint SHA512_Final(unsigned char *md, SHA512_CTX *c);\nunsigned char *SHA512(const unsigned char *d, size_t n,\n     unsigned char *md);\n</code></pre>"},{"location":"man3/sha/#description","title":"DESCRIPTION","text":"<p>Applications should use the higher level functions EVP_DigestInit(3) etc. instead of calling the hash functions directly.</p> <p>SHA-1 (Secure Hash Algorithm) is a cryptographic hash function with a 160 bit output.</p> <p>SHA1() computes the SHA-1 message digest of the n bytes at d and places it in md (which must have space for SHA_DIGEST_LENGTH == 20 bytes of output). If md is NULL, the digest is placed in a static array. Note: setting md to NULL is not thread safe.</p> <p>The following functions may be used if the message is not completely stored in memory:</p> <p>SHA1_Init() initializes a SHA_CTX structure.</p> <p>SHA1_Update() can be called repeatedly with chunks of the message to be hashed (len bytes at data).</p> <p>SHA1_Final() places the message digest in md, which must have space for SHA_DIGEST_LENGTH == 20 bytes of output, and erases the SHA_CTX.</p> <p>The SHA224, SHA256, SHA384 and SHA512 families of functions operate in the same way as for the SHA1 functions. Note that SHA224 and SHA256 use a SHA256_CTX object instead of SHA_CTX. SHA384 and SHA512 use SHA512_CTX. The buffer md must have space for the output from the SHA variant being used (defined by SHA224_DIGEST_LENGTH, SHA256_DIGEST_LENGTH, SHA384_DIGEST_LENGTH and SHA512_DIGEST_LENGTH). Also note that, as for the SHA1() function above, the SHA224(), SHA256(), SHA384() and SHA512() functions are not thread safe if md is NULL.</p> <p>The predecessor of SHA-1, SHA, is also implemented, but it should be used only when backward compatibility is required.</p>"},{"location":"man3/sha/#return-values","title":"RETURN VALUES","text":"<p>SHA1(), SHA224(), SHA256(), SHA384() and SHA512() return a pointer to the hash value. </p> <p>SHA1_Init(), SHA1_Update() and SHA1_Final() and equivalent SHA224, SHA256, SHA384 and SHA512 functions return 1 for success, 0 otherwise.</p>"},{"location":"man3/sha/#conforming-to","title":"CONFORMING TO","text":"<p>US Federal Information Processing Standard FIPS PUB 180-4 (Secure Hash Standard), ANSI X9.30</p>"},{"location":"man3/sha/#see-also","title":"SEE ALSO","text":"<p>ripemd(3), hmac(3), EVP_DigestInit(3)</p>"},{"location":"man3/sha/#history","title":"HISTORY","text":"<p>SHA1(), SHA1_Init(), SHA1_Update() and SHA1_Final() are available in all versions of SSLeay and OpenSSL.</p>"},{"location":"man3/ssl/","title":"ssl","text":""},{"location":"man3/ssl/#name","title":"NAME","text":"<p>SSL - OpenSSL SSL/TLS library</p>"},{"location":"man3/ssl/#synopsis","title":"SYNOPSIS","text":""},{"location":"man3/ssl/#description","title":"DESCRIPTION","text":"<p>The OpenSSL ssl library implements the Secure Sockets Layer (SSL v2/v3) and Transport Layer Security (TLS v1) protocols. It provides a rich API which is documented here.</p> <p>At first the library must be initialized; see SSL_library_init(3).</p> <p>Then an SSL_CTX object is created as a framework to establish TLS/SSL enabled connections (see SSL_CTX_new(3)). Various options regarding certificates, algorithms etc. can be set in this object.</p> <p>When a network connection has been created, it can be assigned to an SSL object. After the SSL object has been created using SSL_new(3), SSL_set_fd(3) or SSL_set_bio(3) can be used to associate the network connection with the object.</p> <p>Then the TLS/SSL handshake is performed using SSL_accept(3) or SSL_connect(3) respectively. SSL_read(3) and SSL_write(3) are used to read and write data on the TLS/SSL connection. SSL_shutdown(3) can be used to shut down the TLS/SSL connection.</p>"},{"location":"man3/ssl/#data-structures","title":"DATA STRUCTURES","text":"<p>Currently the OpenSSL ssl library functions deals with the following data structures:</p> <ul> <li> <p>SSL_METHOD (SSL Method)</p> <p>That's a dispatch structure describing the internal ssl library methods/functions which implement the various protocol versions (SSLv1, SSLv2 and TLSv1). It's needed to create an SSL_CTX.</p> </li> <li> <p>SSL_CIPHER (SSL Cipher)</p> <p>This structure holds the algorithm information for a particular cipher which are a core part of the SSL/TLS protocol. The available ciphers are configured on a SSL_CTX basis and the actually used ones are then part of the SSL_SESSION.</p> </li> <li> <p>SSL_CTX (SSL Context)</p> <p>That's the global context structure which is created by a server or client once per program life-time and which holds mainly default values for the SSL structures which are later created for the connections.</p> </li> <li> <p>SSL_SESSION (SSL Session)</p> <p>This is a structure containing the current TLS/SSL session details for a connection: SSL_CIPHERs, client and server certificates, keys, etc.</p> </li> <li> <p>SSL (SSL Connection)</p> <p>That's the main SSL/TLS structure which is created by a server or client per established connection. This actually is the core structure in the SSL API. Under run-time the application usually deals with this structure which has links to mostly all other structures.</p> </li> </ul>"},{"location":"man3/ssl/#header-files","title":"HEADER FILES","text":"<p>Currently the OpenSSL ssl library provides the following C header files containing the prototypes for the data structures and and functions:</p> <ul> <li> <p>ssl.h</p> <p>That's the common header file for the SSL/TLS API.  Include it into your program to make the API of the ssl library available. It internally includes both more private SSL headers and headers from the crypto library. Whenever you need hard-core details on the internals of the SSL API, look inside this header file.</p> </li> <li> <p>ssl2.h</p> <p>That's the sub header file dealing with the SSLv2 protocol only. Usually you don't have to include it explicitly because it's already included by ssl.h.</p> </li> <li> <p>ssl3.h</p> <p>That's the sub header file dealing with the SSLv3 protocol only. Usually you don't have to include it explicitly because it's already included by ssl.h.</p> </li> <li> <p>ssl23.h</p> <p>That's the sub header file dealing with the combined use of the SSLv2 and SSLv3 protocols. Usually you don't have to include it explicitly because it's already included by ssl.h.</p> </li> <li> <p>tls1.h</p> <p>That's the sub header file dealing with the TLSv1 protocol only. Usually you don't have to include it explicitly because it's already included by ssl.h.</p> </li> </ul>"},{"location":"man3/ssl/#api-functions","title":"API FUNCTIONS","text":"<p>Currently the OpenSSL ssl library exports 214 API functions. They are documented in the following:</p>"},{"location":"man3/ssl/#dealing-with-protocol-methods","title":"DEALING WITH PROTOCOL METHODS","text":"<p>Here we document the various API functions which deal with the SSL/TLS protocol methods defined in SSL_METHOD structures.</p> <ul> <li> <p>const SSL_METHOD *SSLv23_method(void);</p> <p>Constructor for the version-flexible SSL_METHOD structure for clients, servers or both. See SSL_CTX_new(3) for details.</p> </li> <li> <p>const SSL_METHOD *SSLv23_client_method(void);</p> <p>Constructor for the version-flexible SSL_METHOD structure for clients.</p> </li> <li> <p>const SSL_METHOD *SSLv23_client_method(void);</p> <p>Constructor for the version-flexible SSL_METHOD structure for servers.</p> </li> <li> <p>const SSL_METHOD *TLSv1_2_method(void);</p> <p>Constructor for the TLSv1.2 SSL_METHOD structure for clients, servers or both.</p> </li> <li> <p>const SSL_METHOD *TLSv1_2_client_method(void);</p> <p>Constructor for the TLSv1.2 SSL_METHOD structure for clients.</p> </li> <li> <p>const SSL_METHOD *TLSv1_2_server_method(void);</p> <p>Constructor for the TLSv1.2 SSL_METHOD structure for servers.</p> </li> <li> <p>const SSL_METHOD *TLSv1_1_method(void);</p> <p>Constructor for the TLSv1.1 SSL_METHOD structure for clients, servers or both.</p> </li> <li> <p>const SSL_METHOD *TLSv1_1_client_method(void);</p> <p>Constructor for the TLSv1.1 SSL_METHOD structure for clients.</p> </li> <li> <p>const SSL_METHOD *TLSv1_1_server_method(void);</p> <p>Constructor for the TLSv1.1 SSL_METHOD structure for servers.</p> </li> <li> <p>const SSL_METHOD *TLSv1_method(void);</p> <p>Constructor for the TLSv1 SSL_METHOD structure for clients, servers or both.</p> </li> <li> <p>const SSL_METHOD *TLSv1_client_method(void);</p> <p>Constructor for the TLSv1 SSL_METHOD structure for clients.</p> </li> <li> <p>const SSL_METHOD *TLSv1_server_method(void);</p> <p>Constructor for the TLSv1 SSL_METHOD structure for servers.</p> </li> <li> <p>const SSL_METHOD *SSLv3_method(void);</p> <p>Constructor for the SSLv3 SSL_METHOD structure for clients, servers or both.</p> </li> <li> <p>const SSL_METHOD *SSLv3_client_method(void);</p> <p>Constructor for the SSLv3 SSL_METHOD structure for clients.</p> </li> <li> <p>const SSL_METHOD *SSLv3_server_method(void);</p> <p>Constructor for the SSLv3 SSL_METHOD structure for servers.</p> </li> <li> <p>const SSL_METHOD *SSLv2_method(void);</p> <p>Constructor for the SSLv2 SSL_METHOD structure for clients, servers or both.</p> </li> <li> <p>const SSL_METHOD *SSLv2_client_method(void);</p> <p>Constructor for the SSLv2 SSL_METHOD structure for clients.</p> </li> <li> <p>const SSL_METHOD *SSLv2_server_method(void);</p> <p>Constructor for the SSLv2 SSL_METHOD structure for servers.</p> </li> </ul>"},{"location":"man3/ssl/#dealing-with-ciphers","title":"DEALING WITH CIPHERS","text":"<p>Here we document the various API functions which deal with the SSL/TLS ciphers defined in SSL_CIPHER structures.</p> <ul> <li> <p>char *SSL_CIPHER_description(SSL_CIPHER *cipher, char *buf, int len);</p> <p>Write a string to buf (with a maximum size of len) containing a human readable description of cipher. Returns buf.</p> </li> <li> <p>int SSL_CIPHER_get_bits(SSL_CIPHER *cipher, int *alg_bits);</p> <p>Determine the number of bits in cipher. Because of export crippled ciphers there are two bits: The bits the algorithm supports in general (stored to alg_bits) and the bits which are actually used (the return value).</p> </li> <li> <p>const char *SSL_CIPHER_get_name(SSL_CIPHER *cipher);</p> <p>Return the internal name of cipher as a string. These are the various strings defined by the SSL2_TXT_xxx, SSL3_TXT_xxx and TLS1_TXT_xxx definitions in the header files.</p> </li> <li> <p>char *SSL_CIPHER_get_version(SSL_CIPHER *cipher);</p> <p>Returns a string like \"<code>TLSv1/SSLv3</code>\" or \"<code>SSLv2</code>\" which indicates the SSL/TLS protocol version to which cipher belongs (i.e. where it was defined in the specification the first time).</p> </li> </ul>"},{"location":"man3/ssl/#dealing-with-protocol-contexts","title":"DEALING WITH PROTOCOL CONTEXTS","text":"<p>Here we document the various API functions which deal with the SSL/TLS protocol context defined in the SSL_CTX structure.</p> <ul> <li>int SSL_CTX_add_client_CA(SSL_CTX *ctx, X509 *x);</li> <li>long SSL_CTX_add_extra_chain_cert(SSL_CTX *ctx, X509 *x509);</li> <li>int SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *c);</li> <li>int SSL_CTX_check_private_key(const SSL_CTX *ctx);</li> <li>long SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, char *parg);</li> <li>void SSL_CTX_flush_sessions(SSL_CTX *s, long t);</li> <li>void SSL_CTX_free(SSL_CTX *a);</li> <li>char *SSL_CTX_get_app_data(SSL_CTX *ctx);</li> <li>X509_STORE *SSL_CTX_get_cert_store(SSL_CTX *ctx);</li> <li>STACK *SSL_CTX_get_client_CA_list(const SSL_CTX *ctx);</li> <li>int (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))(SSL *ssl, X509 **x509, EVP_PKEY **pkey);</li> <li>void SSL_CTX_get_default_read_ahead(SSL_CTX *ctx);</li> <li>char *SSL_CTX_get_ex_data(const SSL_CTX *s, int idx);</li> <li>int SSL_CTX_get_ex_new_index(long argl, char *argp, int (*new_func);(void), int (*dup_func)(void), void (*free_func)(void))</li> <li>void (*SSL_CTX_get_info_callback(SSL_CTX *ctx))(SSL *ssl, int cb, int ret);</li> <li>int SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx);</li> <li>void SSL_CTX_get_read_ahead(SSL_CTX *ctx);</li> <li>int SSL_CTX_get_session_cache_mode(SSL_CTX *ctx);</li> <li>long SSL_CTX_get_timeout(const SSL_CTX *ctx);</li> <li>int (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int ok, X509_STORE_CTX *ctx);</li> <li>int SSL_CTX_get_verify_mode(SSL_CTX *ctx);</li> <li>int SSL_CTX_load_verify_locations(SSL_CTX *ctx, char *CAfile, char *CApath);</li> <li>long SSL_CTX_need_tmp_RSA(SSL_CTX *ctx);</li> <li>SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth);</li> <li>int SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *c);</li> <li>int SSL_CTX_sess_accept(SSL_CTX *ctx);</li> <li>int SSL_CTX_sess_accept_good(SSL_CTX *ctx);</li> <li>int SSL_CTX_sess_accept_renegotiate(SSL_CTX *ctx);</li> <li>int SSL_CTX_sess_cache_full(SSL_CTX *ctx);</li> <li>int SSL_CTX_sess_cb_hits(SSL_CTX *ctx);</li> <li>int SSL_CTX_sess_connect(SSL_CTX *ctx);</li> <li>int SSL_CTX_sess_connect_good(SSL_CTX *ctx);</li> <li>int SSL_CTX_sess_connect_renegotiate(SSL_CTX *ctx);</li> <li>int SSL_CTX_sess_get_cache_size(SSL_CTX *ctx);</li> <li>SSL_SESSION *(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(SSL *ssl, unsigned char *data, int len, int *copy);</li> <li>int (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx)(SSL *ssl, SSL_SESSION *sess);</li> <li>void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx)(SSL_CTX *ctx, SSL_SESSION *sess);</li> <li>int SSL_CTX_sess_hits(SSL_CTX *ctx);</li> <li>int SSL_CTX_sess_misses(SSL_CTX *ctx);</li> <li>int SSL_CTX_sess_number(SSL_CTX *ctx);</li> <li>void SSL_CTX_sess_set_cache_size(SSL_CTX *ctx,t);</li> <li>void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx, SSL_SESSION *(*cb)(SSL *ssl, unsigned char *data, int len, int *copy));</li> <li>void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx, int (*cb)(SSL *ssl, SSL_SESSION *sess));</li> <li>void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx, void (*cb)(SSL_CTX *ctx, SSL_SESSION *sess));</li> <li>int SSL_CTX_sess_timeouts(SSL_CTX *ctx);</li> <li>LHASH *SSL_CTX_sessions(SSL_CTX *ctx);</li> <li>void SSL_CTX_set_app_data(SSL_CTX *ctx, void *arg);</li> <li>void SSL_CTX_set_cert_store(SSL_CTX *ctx, X509_STORE *cs);</li> <li>void SSL_CTX_set_cert_verify_cb(SSL_CTX *ctx, int (*cb)(), char *arg)</li> <li>int SSL_CTX_set_cipher_list(SSL_CTX *ctx, char *str);</li> <li>void SSL_CTX_set_client_CA_list(SSL_CTX *ctx, STACK *list);</li> <li>void SSL_CTX_set_client_cert_cb(SSL_CTX *ctx, int (*cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey));</li> <li>void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, int (*cb);(void))</li> <li>void SSL_CTX_set_default_read_ahead(SSL_CTX *ctx, int m);</li> <li>int SSL_CTX_set_default_verify_paths(SSL_CTX *ctx);</li> <li>int SSL_CTX_set_ex_data(SSL_CTX *s, int idx, char *arg);</li> <li>void SSL_CTX_set_info_callback(SSL_CTX *ctx, void (*cb)(SSL *ssl, int cb, int ret));</li> <li>void SSL_CTX_set_msg_callback(SSL_CTX *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg));</li> <li>void SSL_CTX_set_msg_callback_arg(SSL_CTX *ctx, void *arg);</li> <li>void SSL_CTX_set_options(SSL_CTX *ctx, unsigned long op);</li> <li>void SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx, int mode);</li> <li>void SSL_CTX_set_read_ahead(SSL_CTX *ctx, int m);</li> <li>void SSL_CTX_set_session_cache_mode(SSL_CTX *ctx, int mode);</li> <li>int SSL_CTX_set_ssl_version(SSL_CTX *ctx, const SSL_METHOD *meth);</li> <li>void SSL_CTX_set_timeout(SSL_CTX *ctx, long t);</li> <li>long SSL_CTX_set_tmp_dh(SSL_CTX* ctx, DH *dh);</li> <li>long SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx, DH *(*cb)(void));</li> <li>long SSL_CTX_set_tmp_rsa(SSL_CTX *ctx, RSA *rsa);</li> <li> <p>SSL_CTX_set_tmp_rsa_callback</p> <p><code>long **SSL_CTX_set_tmp_rsa_callback**(SSL_CTX ***ctx**, RSA *(***cb**)(SSL ***ssl**, int **export**, int **keylength**));</code></p> <p>Sets the callback which will be called when a temporary private key is required. The <code>export</code> flag will be set if the reason for needing a temp key is that an export ciphersuite is in use, in which case, <code>keylength</code> will contain the required keylength in bits. Generate a key of appropriate size (using ???) and return it.</p> </li> <li> <p>SSL_set_tmp_rsa_callback</p> <p>long SSL_set_tmp_rsa_callback(SSL *ssl, RSA *(*cb)(SSL *ssl, int export, int keylength));</p> <p>The same as SSL_CTX_set_tmp_rsa_callback, except it operates on an SSL session instead of a context.</p> </li> <li> <p>void SSL_CTX_set_verify(SSL_CTX *ctx, int mode, int (*cb);(void))</p> </li> <li>int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);</li> <li>int SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx, unsigned char *d, long len);</li> <li>int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, char *file, int type);</li> <li>int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);</li> <li>int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long len);</li> <li>int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, char *file, int type);</li> <li>int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);</li> <li>int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, unsigned char *d);</li> <li>int SSL_CTX_use_certificate_file(SSL_CTX *ctx, char *file, int type);</li> <li>X509 *SSL_CTX_get0_certificate(const SSL_CTX *ctx);</li> <li>EVP_PKEY *SSL_CTX_get0_privatekey(const SSL_CTX *ctx);</li> <li>void SSL_CTX_set_psk_client_callback(SSL_CTX *ctx, unsigned int (*callback)(SSL *ssl, const char *hint, char *identity, unsigned int max_identity_len, unsigned char *psk, unsigned int max_psk_len));</li> <li>int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *hint);</li> <li>void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx, unsigned int (*callback)(SSL *ssl, const char *identity, unsigned char *psk, int max_psk_len));</li> </ul>"},{"location":"man3/ssl/#dealing-with-sessions","title":"DEALING WITH SESSIONS","text":"<p>Here we document the various API functions which deal with the SSL/TLS sessions defined in the SSL_SESSION structures.</p> <ul> <li>int SSL_SESSION_cmp(const SSL_SESSION *a, const SSL_SESSION *b);</li> <li>void SSL_SESSION_free(SSL_SESSION *ss);</li> <li>char *SSL_SESSION_get_app_data(SSL_SESSION *s);</li> <li>char *SSL_SESSION_get_ex_data(const SSL_SESSION *s, int idx);</li> <li>int SSL_SESSION_get_ex_new_index(long argl, char *argp, int (*new_func);(void), int (*dup_func)(void), void (*free_func)(void))</li> <li>long SSL_SESSION_get_time(const SSL_SESSION *s);</li> <li>long SSL_SESSION_get_timeout(const SSL_SESSION *s);</li> <li>unsigned long SSL_SESSION_hash(const SSL_SESSION *a);</li> <li>SSL_SESSION *SSL_SESSION_new(void);</li> <li>int SSL_SESSION_print(BIO *bp, const SSL_SESSION *x);</li> <li>int SSL_SESSION_print_fp(FILE *fp, const SSL_SESSION *x);</li> <li>void SSL_SESSION_set_app_data(SSL_SESSION *s, char *a);</li> <li>int SSL_SESSION_set_ex_data(SSL_SESSION *s, int idx, char *arg);</li> <li>long SSL_SESSION_set_time(SSL_SESSION *s, long t);</li> <li>long SSL_SESSION_set_timeout(SSL_SESSION *s, long t);</li> </ul>"},{"location":"man3/ssl/#dealing-with-connections","title":"DEALING WITH CONNECTIONS","text":"<p>Here we document the various API functions which deal with the SSL/TLS connection defined in the SSL structure.</p> <ul> <li>int SSL_accept(SSL *ssl);</li> <li>int SSL_add_dir_cert_subjects_to_stack(STACK *stack, const char *dir);</li> <li>int SSL_add_file_cert_subjects_to_stack(STACK *stack, const char *file);</li> <li>int SSL_add_client_CA(SSL *ssl, X509 *x);</li> <li>char *SSL_alert_desc_string(int value);</li> <li>char *SSL_alert_desc_string_long(int value);</li> <li>char *SSL_alert_type_string(int value);</li> <li>char *SSL_alert_type_string_long(int value);</li> <li>int SSL_check_private_key(const SSL *ssl);</li> <li>void SSL_clear(SSL *ssl);</li> <li>long SSL_clear_num_renegotiations(SSL *ssl);</li> <li>int SSL_connect(SSL *ssl);</li> <li>void SSL_copy_session_id(SSL *t, const SSL *f);</li> <li>long SSL_ctrl(SSL *ssl, int cmd, long larg, char *parg);</li> <li>int SSL_do_handshake(SSL *ssl);</li> <li>SSL *SSL_dup(SSL *ssl);</li> <li>STACK *SSL_dup_CA_list(STACK *sk);</li> <li>void SSL_free(SSL *ssl);</li> <li>SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl);</li> <li>char *SSL_get_app_data(SSL *ssl);</li> <li>X509 *SSL_get_certificate(const SSL *ssl);</li> <li>const char *SSL_get_cipher(const SSL *ssl);</li> <li>int SSL_get_cipher_bits(const SSL *ssl, int *alg_bits);</li> <li>char *SSL_get_cipher_list(const SSL *ssl, int n);</li> <li>char *SSL_get_cipher_name(const SSL *ssl);</li> <li>char *SSL_get_cipher_version(const SSL *ssl);</li> <li>STACK *SSL_get_ciphers(const SSL *ssl);</li> <li>STACK *SSL_get_client_CA_list(const SSL *ssl);</li> <li>SSL_CIPHER *SSL_get_current_cipher(SSL *ssl);</li> <li>long SSL_get_default_timeout(const SSL *ssl);</li> <li>int SSL_get_error(const SSL *ssl, int i);</li> <li>char *SSL_get_ex_data(const SSL *ssl, int idx);</li> <li>int SSL_get_ex_data_X509_STORE_CTX_idx(void);</li> <li>int SSL_get_ex_new_index(long argl, char *argp, int (*new_func);(void), int (*dup_func)(void), void (*free_func)(void))</li> <li>int SSL_get_fd(const SSL *ssl);</li> <li>void (*SSL_get_info_callback(const SSL *ssl);)()</li> <li>STACK *SSL_get_peer_cert_chain(const SSL *ssl);</li> <li>X509 *SSL_get_peer_certificate(const SSL *ssl);</li> <li>EVP_PKEY *SSL_get_privatekey(const SSL *ssl);</li> <li>int SSL_get_quiet_shutdown(const SSL *ssl);</li> <li>BIO *SSL_get_rbio(const SSL *ssl);</li> <li>int SSL_get_read_ahead(const SSL *ssl);</li> <li>SSL_SESSION *SSL_get_session(const SSL *ssl);</li> <li>char *SSL_get_shared_ciphers(const SSL *ssl, char *buf, int size);</li> <li>int SSL_get_shutdown(const SSL *ssl);</li> <li>const SSL_METHOD *SSL_get_ssl_method(SSL *ssl);</li> <li>int SSL_get_state(const SSL *ssl);</li> <li>long SSL_get_time(const SSL *ssl);</li> <li>long SSL_get_timeout(const SSL *ssl);</li> <li>int (*SSL_get_verify_callback(const SSL *ssl))(int,X509_STORE_CTX *)</li> <li>int SSL_get_verify_mode(const SSL *ssl);</li> <li>long SSL_get_verify_result(const SSL *ssl);</li> <li>char *SSL_get_version(const SSL *ssl);</li> <li>BIO *SSL_get_wbio(const SSL *ssl);</li> <li>int SSL_in_accept_init(SSL *ssl);</li> <li>int SSL_in_before(SSL *ssl);</li> <li>int SSL_in_connect_init(SSL *ssl);</li> <li>int SSL_in_init(SSL *ssl);</li> <li>int SSL_is_init_finished(SSL *ssl);</li> <li>STACK *SSL_load_client_CA_file(char *file);</li> <li>void SSL_load_error_strings(void);</li> <li>SSL *SSL_new(SSL_CTX *ctx);</li> <li>long SSL_num_renegotiations(SSL *ssl);</li> <li>int SSL_peek(SSL *ssl, void *buf, int num);</li> <li>int SSL_pending(const SSL *ssl);</li> <li>int SSL_read(SSL *ssl, void *buf, int num);</li> <li>int SSL_renegotiate(SSL *ssl);</li> <li>char *SSL_rstate_string(SSL *ssl);</li> <li>char *SSL_rstate_string_long(SSL *ssl);</li> <li>long SSL_session_reused(SSL *ssl);</li> <li>void SSL_set_accept_state(SSL *ssl);</li> <li>void SSL_set_app_data(SSL *ssl, char *arg);</li> <li>void SSL_set_bio(SSL *ssl, BIO *rbio, BIO *wbio);</li> <li>int SSL_set_cipher_list(SSL *ssl, char *str);</li> <li>void SSL_set_client_CA_list(SSL *ssl, STACK *list);</li> <li>void SSL_set_connect_state(SSL *ssl);</li> <li>int SSL_set_ex_data(SSL *ssl, int idx, char *arg);</li> <li>int SSL_set_fd(SSL *ssl, int fd);</li> <li>void SSL_set_info_callback(SSL *ssl, void (*cb);(void))</li> <li>void SSL_set_msg_callback(SSL *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg));</li> <li>void SSL_set_msg_callback_arg(SSL *ctx, void *arg);</li> <li>void SSL_set_options(SSL *ssl, unsigned long op);</li> <li>void SSL_set_quiet_shutdown(SSL *ssl, int mode);</li> <li>void SSL_set_read_ahead(SSL *ssl, int yes);</li> <li>int SSL_set_rfd(SSL *ssl, int fd);</li> <li>int SSL_set_session(SSL *ssl, SSL_SESSION *session);</li> <li>void SSL_set_shutdown(SSL *ssl, int mode);</li> <li>int SSL_set_ssl_method(SSL *ssl, const SSL_METHOD *meth);</li> <li>void SSL_set_time(SSL *ssl, long t);</li> <li>void SSL_set_timeout(SSL *ssl, long t);</li> <li>void SSL_set_verify(SSL *ssl, int mode, int (*callback);(void))</li> <li>void SSL_set_verify_result(SSL *ssl, long arg);</li> <li>int SSL_set_wfd(SSL *ssl, int fd);</li> <li>int SSL_shutdown(SSL *ssl);</li> <li>int SSL_state(const SSL *ssl);</li> <li>char *SSL_state_string(const SSL *ssl);</li> <li>char *SSL_state_string_long(const SSL *ssl);</li> <li>long SSL_total_renegotiations(SSL *ssl);</li> <li>int SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey);</li> <li>int SSL_use_PrivateKey_ASN1(int type, SSL *ssl, unsigned char *d, long len);</li> <li>int SSL_use_PrivateKey_file(SSL *ssl, char *file, int type);</li> <li>int SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa);</li> <li>int SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len);</li> <li>int SSL_use_RSAPrivateKey_file(SSL *ssl, char *file, int type);</li> <li>int SSL_use_certificate(SSL *ssl, X509 *x);</li> <li>int SSL_use_certificate_ASN1(SSL *ssl, int len, unsigned char *d);</li> <li>int SSL_use_certificate_file(SSL *ssl, char *file, int type);</li> <li>int SSL_version(const SSL *ssl);</li> <li>int SSL_want(const SSL *ssl);</li> <li>int SSL_want_nothing(const SSL *ssl);</li> <li>int SSL_want_read(const SSL *ssl);</li> <li>int SSL_want_write(const SSL *ssl);</li> <li>int SSL_want_x509_lookup(const SSL *ssl);</li> <li>int SSL_write(SSL *ssl, const void *buf, int num);</li> <li>void SSL_set_psk_client_callback(SSL *ssl, unsigned int (*callback)(SSL *ssl, const char *hint, char *identity, unsigned int max_identity_len, unsigned char *psk, unsigned int max_psk_len));</li> <li>int SSL_use_psk_identity_hint(SSL *ssl, const char *hint);</li> <li>void SSL_set_psk_server_callback(SSL *ssl, unsigned int (*callback)(SSL *ssl, const char *identity, unsigned char *psk, int max_psk_len));</li> <li>const char *SSL_get_psk_identity_hint(SSL *ssl);</li> <li>const char *SSL_get_psk_identity(SSL *ssl);</li> </ul>"},{"location":"man3/ssl/#see-also","title":"SEE ALSO","text":"<p>openssl(1), crypto(3), SSL_accept(3), SSL_clear(3), SSL_connect(3), SSL_CIPHER_get_name(3), SSL_COMP_add_compression_method(3), SSL_CTX_add_extra_chain_cert(3), SSL_CTX_add_session(3), SSL_CTX_ctrl(3), SSL_CTX_flush_sessions(3), SSL_CTX_get_ex_new_index(3), SSL_CTX_get_verify_mode(3), SSL_CTX_load_verify_locations(3) SSL_CTX_new(3), SSL_CTX_sess_number(3), SSL_CTX_sess_set_cache_size(3), SSL_CTX_sess_set_get_cb(3), SSL_CTX_sessions(3), SSL_CTX_set_cert_store(3), SSL_CTX_set_cert_verify_callback(3), SSL_CTX_set_cipher_list(3), SSL_CTX_set_client_CA_list(3), SSL_CTX_set_client_cert_cb(3), SSL_CTX_set_default_passwd_cb(3), SSL_CTX_set_generate_session_id(3), SSL_CTX_set_info_callback(3), SSL_CTX_set_max_cert_list(3), SSL_CTX_set_mode(3), SSL_CTX_set_msg_callback(3), SSL_CTX_set_options(3), SSL_CTX_set_quiet_shutdown(3), SSL_CTX_set_read_ahead(3), SSL_CTX_set_session_cache_mode(3), SSL_CTX_set_session_id_context(3), SSL_CTX_set_ssl_version(3), SSL_CTX_set_timeout(3), SSL_CTX_set_tmp_rsa_callback(3), SSL_CTX_set_tmp_dh_callback(3), SSL_CTX_set_verify(3), SSL_CTX_use_certificate(3), SSL_alert_type_string(3), SSL_do_handshake(3), SSL_get_SSL_CTX(3), SSL_get_ciphers(3), SSL_get_client_CA_list(3), SSL_get_default_timeout(3), SSL_get_error(3), SSL_get_ex_data_X509_STORE_CTX_idx(3), SSL_get_ex_new_index(3), SSL_get_fd(3), SSL_get_peer_cert_chain(3), SSL_get_rbio(3), SSL_get_session(3), SSL_get_verify_result(3), SSL_get_version(3), SSL_library_init(3), SSL_load_client_CA_file(3), SSL_new(3), SSL_pending(3), SSL_read(3), SSL_rstate_string(3), SSL_session_reused(3), SSL_set_bio(3), SSL_set_connect_state(3), SSL_set_fd(3), SSL_set_session(3), SSL_set_shutdown(3), SSL_shutdown(3), SSL_state_string(3), SSL_want(3), SSL_write(3), SSL_SESSION_free(3), SSL_SESSION_get_ex_new_index(3), SSL_SESSION_get_time(3), d2i_SSL_SESSION(3), SSL_CTX_set_psk_client_callback(3), SSL_CTX_use_psk_identity_hint(3), SSL_get_psk_identity(3)</p>"},{"location":"man3/ssl/#history","title":"HISTORY","text":"<p>The ssl(3) document appeared in OpenSSL 0.9.2</p>"},{"location":"man3/threads/","title":"threads","text":""},{"location":"man3/threads/#name","title":"NAME","text":"<p>CRYPTO_THREADID_set_callback, CRYPTO_THREADID_get_callback, CRYPTO_THREADID_current, CRYPTO_THREADID_cmp, CRYPTO_THREADID_cpy, CRYPTO_THREADID_hash, CRYPTO_set_locking_callback, CRYPTO_num_locks, CRYPTO_set_dynlock_create_callback, CRYPTO_set_dynlock_lock_callback, CRYPTO_set_dynlock_destroy_callback, CRYPTO_get_new_dynlockid, CRYPTO_destroy_dynlockid, CRYPTO_lock - OpenSSL thread support</p>"},{"location":"man3/threads/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/crypto.h&gt;\n\n/* Don't use this structure directly. */\ntypedef struct crypto_threadid_st\n        {\n        void *ptr;\n        unsigned long val;\n        } CRYPTO_THREADID;\n/* Only use CRYPTO_THREADID_set_[numeric|pointer]() within callbacks */\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val);\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr);\nint CRYPTO_THREADID_set_callback(void (*threadid_func)(CRYPTO_THREADID *));\nvoid (*CRYPTO_THREADID_get_callback(void))(CRYPTO_THREADID *);\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id);\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,\n                        const CRYPTO_THREADID *b);\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,\n                         const CRYPTO_THREADID *src);\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id);\n\nint CRYPTO_num_locks(void);\n\n/* struct CRYPTO_dynlock_value needs to be defined by the user */\nstruct CRYPTO_dynlock_value;\n\nvoid CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *\n       (*dyn_create_function)(char *file, int line));\nvoid CRYPTO_set_dynlock_lock_callback(void (*dyn_lock_function)\n       (int mode, struct CRYPTO_dynlock_value *l,\n       const char *file, int line));\nvoid CRYPTO_set_dynlock_destroy_callback(void (*dyn_destroy_function)\n       (struct CRYPTO_dynlock_value *l, const char *file, int line));\n\nint CRYPTO_get_new_dynlockid(void);\n\nvoid CRYPTO_destroy_dynlockid(int i);\n\nvoid CRYPTO_lock(int mode, int n, const char *file, int line);\n\n#define CRYPTO_w_lock(type)    \\\n       CRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)\n#define CRYPTO_w_unlock(type)  \\\n       CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)\n#define CRYPTO_r_lock(type)    \\\n       CRYPTO_lock(CRYPTO_LOCK|CRYPTO_READ,type,__FILE__,__LINE__)\n#define CRYPTO_r_unlock(type)  \\\n       CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_READ,type,__FILE__,__LINE__)\n#define CRYPTO_add(addr,amount,type)   \\\n       CRYPTO_add_lock(addr,amount,type,__FILE__,__LINE__)\n</code></pre>"},{"location":"man3/threads/#description","title":"DESCRIPTION","text":"<p>OpenSSL can generally be used safely in multi-threaded applications provided that at least two callback functions are set, the locking_function and threadid_func. Note that OpenSSL is not completely thread-safe, and unfortunately not all global resources have the necessary locks. Further, the thread-safety does not extend to things like multiple threads using the same SSL object at the same time.</p> <p>locking_function(int mode, int n, const char *file, int line) is needed to perform locking on shared data structures.  (Note that OpenSSL uses a number of global data structures that will be implicitly shared whenever multiple threads use OpenSSL.) Multi-threaded applications will crash at random if it is not set.</p> <p>locking_function() must be able to handle up to CRYPTO_num_locks() different mutex locks. It sets the n-th lock if mode &amp; CRYPTO_LOCK, and releases it otherwise.</p> <p>file and line are the file number of the function setting the lock. They can be useful for debugging.</p> <p>threadid_func(CRYPTO_THREADID *id) is needed to record the currently-executing thread's identifier into id. The implementation of this callback should not fill in id directly, but should use CRYPTO_THREADID_set_numeric() if thread IDs are numeric, or CRYPTO_THREADID_set_pointer() if they are pointer-based. If the application does not register such a callback using CRYPTO_THREADID_set_callback(), then a default implementation is used - on Windows and BeOS this uses the system's default thread identifying APIs, and on all other platforms it uses the address of errno. The latter is satisfactory for thread-safety if and only if the platform has a thread-local error number facility.</p> <p>Once threadid_func() is registered, or if the built-in default implementation is to be used;</p> <ul> <li>CRYPTO_THREADID_current() records the currently-executing thread ID into the given id object.</li> <li>CRYPTO_THREADID_cmp() compares two thread IDs (returning zero for equality, ie. the same semantics as memcmp()).</li> <li>CRYPTO_THREADID_cpy() duplicates a thread ID value,</li> <li>CRYPTO_THREADID_hash() returns a numeric value usable as a hash-table key. This is usually the exact numeric or pointer-based thread ID used internally, however this also handles the unusual case where pointers are larger than 'long' variables and the platform's thread IDs are pointer-based - in this case, mixing is done to attempt to produce a unique numeric value even though it is not as wide as the platform's true thread IDs.</li> </ul> <p>Additionally, OpenSSL supports dynamic locks, and sometimes, some parts of OpenSSL need it for better performance.  To enable this, the following is required:</p> <ul> <li>Three additional callback function, dyn_create_function, dyn_lock_function and dyn_destroy_function.</li> <li>A structure defined with the data that each lock needs to handle.</li> </ul> <p>struct CRYPTO_dynlock_value has to be defined to contain whatever structure is needed to handle locks.</p> <p>dyn_create_function(const char *file, int line) is needed to create a lock.  Multi-threaded applications might crash at random if it is not set.</p> <p>dyn_lock_function(int mode, CRYPTO_dynlock *l, const char *file, int line) is needed to perform locking off dynamic lock numbered n. Multi-threaded applications might crash at random if it is not set.</p> <p>dyn_destroy_function(CRYPTO_dynlock *l, const char *file, int line) is needed to destroy the lock l. Multi-threaded applications might crash at random if it is not set.</p> <p>CRYPTO_get_new_dynlockid() is used to create locks.  It will call dyn_create_function for the actual creation.</p> <p>CRYPTO_destroy_dynlockid() is used to destroy locks.  It will call dyn_destroy_function for the actual destruction.</p> <p>CRYPTO_lock() is used to lock and unlock the locks.  mode is a bitfield describing what should be done with the lock.  n is the number of the lock as returned from CRYPTO_get_new_dynlockid().  mode can be combined from the following values.  These values are pairwise exclusive, with undefined behaviour if misused (for example, CRYPTO_READ and CRYPTO_WRITE should not be used together):</p> <pre><code>    CRYPTO_LOCK     0x01\n    CRYPTO_UNLOCK   0x02\n    CRYPTO_READ     0x04\n    CRYPTO_WRITE    0x08\n</code></pre>"},{"location":"man3/threads/#return-values","title":"RETURN VALUES","text":"<p>CRYPTO_num_locks() returns the required number of locks.</p> <p>CRYPTO_get_new_dynlockid() returns the index to the newly created lock.</p> <p>The other functions return no values.</p>"},{"location":"man3/threads/#notes","title":"NOTES","text":"<p>You can find out if OpenSSL was configured with thread support:</p> <pre><code>#define OPENSSL_THREAD_DEFINES\n#include &lt;openssl/opensslconf.h&gt;\n#if defined(OPENSSL_THREADS)\n  // thread support enabled\n#else\n  // no thread support\n#endif\n</code></pre> <p>Also, dynamic locks are currently not used internally by OpenSSL, but may do so in the future.</p>"},{"location":"man3/threads/#examples","title":"EXAMPLES","text":"<p>crypto/threads/mttest.c shows examples of the callback functions on Solaris, Irix and Win32.</p>"},{"location":"man3/threads/#history","title":"HISTORY","text":"<p>CRYPTO_set_locking_callback() is available in all versions of SSLeay and OpenSSL. CRYPTO_num_locks() was added in OpenSSL 0.9.4. All functions dealing with dynamic locks were added in OpenSSL 0.9.5b-dev. CRYPTO_THREADID and associated functions were introduced in OpenSSL 1.0.0 to replace (actually, deprecate) the previous CRYPTO_set_id_callback(), CRYPTO_get_id_callback(), and CRYPTO_thread_id() functions which assumed thread IDs to always be represented by 'unsigned long'.</p>"},{"location":"man3/threads/#see-also","title":"SEE ALSO","text":"<p>crypto(3)</p>"},{"location":"man3/ui/","title":"ui","text":""},{"location":"man3/ui/#name","title":"NAME","text":"<p>UI_new, UI_new_method, UI_free, UI_add_input_string, UI_dup_input_string, UI_add_verify_string, UI_dup_verify_string, UI_add_input_boolean, UI_dup_input_boolean, UI_add_info_string, UI_dup_info_string, UI_add_error_string, UI_dup_error_string, UI_construct_prompt, UI_add_user_data, UI_get0_user_data, UI_get0_result, UI_process, UI_ctrl, UI_set_default_method, UI_get_default_method, UI_get_method, UI_set_method, UI_OpenSSL, ERR_load_UI_strings - New User Interface</p>"},{"location":"man3/ui/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/ui.h&gt;\n\ntypedef struct ui_st UI;\ntypedef struct ui_method_st UI_METHOD;\n\nUI *UI_new(void);\nUI *UI_new_method(const UI_METHOD *method);\nvoid UI_free(UI *ui);\n\nint UI_add_input_string(UI *ui, const char *prompt, int flags,\n       char *result_buf, int minsize, int maxsize);\nint UI_dup_input_string(UI *ui, const char *prompt, int flags,\n       char *result_buf, int minsize, int maxsize);\nint UI_add_verify_string(UI *ui, const char *prompt, int flags,\n       char *result_buf, int minsize, int maxsize, const char *test_buf);\nint UI_dup_verify_string(UI *ui, const char *prompt, int flags,\n       char *result_buf, int minsize, int maxsize, const char *test_buf);\nint UI_add_input_boolean(UI *ui, const char *prompt, const char *action_desc,\n       const char *ok_chars, const char *cancel_chars,\n       int flags, char *result_buf);\nint UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,\n       const char *ok_chars, const char *cancel_chars,\n       int flags, char *result_buf);\nint UI_add_info_string(UI *ui, const char *text);\nint UI_dup_info_string(UI *ui, const char *text);\nint UI_add_error_string(UI *ui, const char *text);\nint UI_dup_error_string(UI *ui, const char *text);\n\n/* These are the possible flags.  They can be or'ed together. */\n#define UI_INPUT_FLAG_ECHO             0x01\n#define UI_INPUT_FLAG_DEFAULT_PWD      0x02\n\nchar *UI_construct_prompt(UI *ui_method,\n       const char *object_desc, const char *object_name);\n\nvoid *UI_add_user_data(UI *ui, void *user_data);\nvoid *UI_get0_user_data(UI *ui);\n\nconst char *UI_get0_result(UI *ui, int i);\n\nint UI_process(UI *ui);\n\nint UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f)());\n#define UI_CTRL_PRINT_ERRORS           1\n#define UI_CTRL_IS_REDOABLE            2\n\nvoid UI_set_default_method(const UI_METHOD *meth);\nconst UI_METHOD *UI_get_default_method(void);\nconst UI_METHOD *UI_get_method(UI *ui);\nconst UI_METHOD *UI_set_method(UI *ui, const UI_METHOD *meth);\n\nUI_METHOD *UI_OpenSSL(void);\n</code></pre>"},{"location":"man3/ui/#description","title":"DESCRIPTION","text":"<p>UI stands for User Interface, and is general purpose set of routines to prompt the user for text-based information.  Through user-written methods (see ui_create(3)), prompting can be done in any way imaginable, be it plain text prompting, through dialog boxes or from a cell phone.</p> <p>All the functions work through a context of the type UI.  This context contains all the information needed to prompt correctly as well as a reference to a UI_METHOD, which is an ordered vector of functions that carry out the actual prompting.</p> <p>The first thing to do is to create a UI with UI_new() or UI_new_method(), then add information to it with the UI_add or UI_dup functions.  Also, user-defined random data can be passed down to the underlying method through calls to UI_add_user_data.  The default UI method doesn't care about these data, but other methods might.  Finally, use UI_process() to actually perform the prompting and UI_get0_result() to find the result to the prompt.</p> <p>A UI can contain more than one prompt, which are performed in the given sequence.  Each prompt gets an index number which is returned by the UI_add and UI_dup functions, and has to be used to get the corresponding result with UI_get0_result().</p> <p>The functions are as follows:</p> <p>UI_new() creates a new UI using the default UI method.  When done with this UI, it should be freed using UI_free().</p> <p>UI_new_method() creates a new UI using the given UI method.  When done with this UI, it should be freed using UI_free().</p> <p>UI_OpenSSL() returns the built-in UI method (note: not the default one, since the default can be changed.  See further on).  This method is the most machine/OS dependent part of OpenSSL and normally generates the most problems when porting.</p> <p>UI_free() removes a UI from memory, along with all other pieces of memory that's connected to it, like duplicated input strings, results and others.</p> <p>UI_add_input_string() and UI_add_verify_string() add a prompt to the UI, as well as flags and a result buffer and the desired minimum and maximum sizes of the result, not counting the final NUL character.  The given information is used to prompt for information, for example a password, and to verify a password (i.e. having the user enter it twice and check that the same string was entered twice).  UI_add_verify_string() takes and extra argument that should be a pointer to the result buffer of the input string that it's supposed to verify, or verification will fail.</p> <p>UI_add_input_boolean() adds a prompt to the UI that's supposed to be answered in a boolean way, with a single character for yes and a different character for no.  A set of characters that can be used to cancel the prompt is given as well.  The prompt itself is divided in two, one part being the descriptive text (given through the prompt argument) and one describing the possible answers (given through the action_desc argument).</p> <p>UI_add_info_string() and UI_add_error_string() add strings that are shown at the same time as the prompt for extra information or to show an error string. The difference between the two is only conceptual.  With the builtin method, there's no technical difference between them.  Other methods may make a difference between them, however.</p> <p>The flags currently supported are UI_INPUT_FLAG_ECHO, which is relevant for UI_add_input_string() and will have the users response be echoed (when prompting for a password, this flag should obviously not be used, and UI_INPUT_FLAG_DEFAULT_PWD, which means that a default password of some sort will be used (completely depending on the application and the UI method).</p> <p>UI_dup_input_string(), UI_dup_verify_string(), UI_dup_input_boolean(), UI_dup_info_string() and UI_dup_error_string() are basically the same as their UI_add counterparts, except that they make their own copies of all strings.</p> <p>UI_construct_prompt() is a helper function that can be used to create a prompt from two pieces of information: an description and a name. The default constructor (if there is none provided by the method used) creates a string \"Enter description for name:\".  With the description \"pass phrase\" and the file name \"foo.key\", that becomes \"Enter pass phrase for foo.key:\".  Other methods may create whatever string and may include encodings that will be processed by the other method functions.</p> <p>UI_add_user_data() adds a piece of memory for the method to use at any time.  The builtin UI method doesn't care about this info.  Note that several calls to this function doesn't add data, it replaces the previous blob with the one given as argument.</p> <p>UI_get0_user_data() retrieves the data that has last been given to the UI with UI_add_user_data().</p> <p>UI_get0_result() returns a pointer to the result buffer associated with the information indexed by i.</p> <p>UI_process() goes through the information given so far, does all the printing and prompting and returns.</p> <p>UI_ctrl() adds extra control for the application author.  For now, it understands two commands: UI_CTRL_PRINT_ERRORS, which makes UI_process() print the OpenSSL error stack as part of processing the UI, and UI_CTRL_IS_REDOABLE, which returns a flag saying if the used UI can be used again or not.</p> <p>UI_set_default_method() changes the default UI method to the one given.</p> <p>UI_get_default_method() returns a pointer to the current default UI method.</p> <p>UI_get_method() returns the UI method associated with a given UI.</p> <p>UI_set_method() changes the UI method associated with a given UI.</p>"},{"location":"man3/ui/#see-also","title":"SEE ALSO","text":"<p>ui_create(3), ui_compat(3)</p>"},{"location":"man3/ui/#history","title":"HISTORY","text":"<p>The UI section was first introduced in OpenSSL 0.9.7.</p>"},{"location":"man3/ui/#author","title":"AUTHOR","text":"<p>Richard Levitte (richard@levitte.org) for the OpenSSL project (http://www.openssl.org).</p>"},{"location":"man3/ui_compat/","title":"ui_compat","text":""},{"location":"man3/ui_compat/#name","title":"NAME","text":"<p>des_read_password, des_read_2passwords, des_read_pw_string, des_read_pw - Compatibility user interface functions</p>"},{"location":"man3/ui_compat/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/des_old.h&gt;\n\nint des_read_password(DES_cblock *key,const char *prompt,int verify);\nint des_read_2passwords(DES_cblock *key1,DES_cblock *key2,\n       const char *prompt,int verify);\n\nint des_read_pw_string(char *buf,int length,const char *prompt,int verify);\nint des_read_pw(char *buf,char *buff,int size,const char *prompt,int verify);\n</code></pre>"},{"location":"man3/ui_compat/#description","title":"DESCRIPTION","text":"<p>The DES library contained a few routines to prompt for passwords.  These aren't necessarely dependent on DES, and have therefore become part of the UI compatibility library.</p> <p>des_read_pw() writes the string specified by prompt to standard output turns echo off and reads an input string from the terminal.  The string is returned in buf, which must have spac for at least size bytes. If verify is set, the user is asked for the password twice and unless the two copies match, an error is returned.  The second password is stored in buff, which must therefore also be at least size bytes.  A return code of -1 indicates a system error, 1 failure due to use interaction, and 0 is success.  All other functions described here use des_read_pw() to do the work.</p> <p>des_read_pw_string() is a variant of des_read_pw() that provides a buffer for you if verify is set.</p> <p>des_read_password() calls des_read_pw() and converts the password to a DES key by calling DES_string_to_key(); des_read_2password() operates in the same way as des_read_password() except that it generates two keys by using the DES_string_to_2key() function.</p>"},{"location":"man3/ui_compat/#notes","title":"NOTES","text":"<p>des_read_pw_string() is available in the MIT Kerberos library as well, and is also available under the name EVP_read_pw_string().</p>"},{"location":"man3/ui_compat/#see-also","title":"SEE ALSO","text":"<p>ui(3), ui_create(3)</p>"},{"location":"man3/ui_compat/#author","title":"AUTHOR","text":"<p>Richard Levitte (richard@levitte.org) for the OpenSSL project (http://www.openssl.org).</p>"},{"location":"man3/x509/","title":"x509","text":""},{"location":"man3/x509/#name","title":"NAME","text":"<p>x509 - X.509 certificate handling</p>"},{"location":"man3/x509/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include &lt;openssl/x509.h&gt;\n</code></pre>"},{"location":"man3/x509/#description","title":"DESCRIPTION","text":"<p>A X.509 certificate is a structured grouping of information about an individual, a device, or anything one can imagine.  A X.509 CRL (certificate revocation list) is a tool to help determine if a certificate is still valid.  The exact definition of those can be found in the X.509 document from ITU-T, or in RFC3280 from PKIX. In OpenSSL, the type X509 is used to express such a certificate, and the type X509_CRL is used to express a CRL.</p> <p>A related structure is a certificate request, defined in PKCS#10 from RSA Security, Inc, also reflected in RFC2896.  In OpenSSL, the type X509_REQ is used to express such a certificate request.</p> <p>To handle some complex parts of a certificate, there are the types X509_NAME (to express a certificate name), X509_ATTRIBUTE (to express a certificate attributes), X509_EXTENSION (to express a certificate extension) and a few more.</p> <p>Finally, there's the supertype X509_INFO, which can contain a CRL, a certificate and a corresponding private key.</p> <p>X509_..., d2i_X509_... and i2d_X509_... handle X.509 certificates, with some exceptions, shown below.</p> <p>X509_CRL_..., d2i_X509_CRL_... and i2d_X509_CRL_... handle X.509 CRLs.</p> <p>X509_REQ_..., d2i_X509_REQ_... and i2d_X509_REQ_... handle PKCS#10 certificate requests.</p> <p>X509_NAME_... handle certificate names.</p> <p>X509_ATTRIBUTE_... handle certificate attributes.</p> <p>X509_EXTENSION_... handle certificate extensions.</p>"},{"location":"man3/x509/#see-also","title":"SEE ALSO","text":"<p>X509_NAME_ENTRY_get_object(3), X509_NAME_add_entry_by_txt(3), X509_NAME_add_entry_by_NID(3), X509_NAME_print_ex(3), X509_NAME_new(3), d2i_X509(3), d2i_X509_ALGOR(3), d2i_X509_CRL(3), d2i_X509_NAME(3), d2i_X509_REQ(3), d2i_X509_SIG(3), crypto(3), x509v3(3)</p>"}]}