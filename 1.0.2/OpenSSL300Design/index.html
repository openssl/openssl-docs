<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="OpenSSL Management Committee (OMC)"><link href=https://docs.openssl.org/1.0.2/OpenSSL300Design/ rel=canonical><link rel=icon href=../images/favicon.ico><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.27"><title>OpenSSL 3.0.0 Design (Draft) - OpenSSL Documentation</title><link rel=stylesheet href=../assets/stylesheets/main.6543a935.min.css><link rel=stylesheet href=../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../stylesheets/extra.css><script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script><script id=__analytics>
  function __md_analytics() {

    var script = document.createElement("script")
    script.async = true
    script.src = "https://api.transpond.io/tracker?am=MzgyOTE%3D"

    var container = document.getElementById("__analytics")
    container.insertAdjacentElement("afterEnd", script)

  }
</script><script>"undefined"!=typeof __md_analytics&&__md_analytics()</script></head><body dir=ltr data-md-color-scheme=openssl data-md-color-primary=indigo data-md-color-accent=indigo><input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off><input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off><label class=md-overlay for=__drawer></label><div data-md-component=skip><a href=#openssl-300-design-draft class=md-skip> Skip to content </a></div><div data-md-component=announce></div><div data-md-color-scheme=default data-md-component=outdated hidden></div><header class="md-header md-header--shadow md-header--lifted" data-md-component=header><nav class="md-header__inner md-grid" aria-label=Header><a href=.. title="OpenSSL Documentation" class="md-header__button md-logo" aria-label="OpenSSL Documentation" data-md-component=logo><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg></a><label class="md-header__button md-icon" for=__drawer><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg></label><div class=md-header__title data-md-component=header-title><div class=md-header__ellipsis><div class=md-header__topic><span class=md-ellipsis> OpenSSL Documentation </span></div><div class=md-header__topic data-md-component=header-topic><span class=md-ellipsis> OpenSSL 3.0.0 Design (Draft) </span></div></div></div><form class=md-header__option data-md-component=palette><input class=md-option data-md-color-media data-md-color-scheme=openssl data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to dark mode" type=radio name=__palette id=__palette_0><label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_1 hidden><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg></label><input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=black data-md-color-accent=light-blue aria-label="Switch to light mode" type=radio name=__palette id=__palette_1><label class="md-header__button md-icon" title="Switch to light mode" for=__palette_0 hidden><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg></label></form><script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script><label class="md-header__button md-icon" for=__search><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg></label><div class=md-search data-md-component=search role=dialog><label class=md-search__overlay for=__search></label><div class=md-search__inner role=search><form class=md-search__form name=search><input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required><label class="md-search__icon md-icon" for=__search><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg></label><nav class=md-search__options aria-label=Search><button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg></button></nav><div class=md-search__suggest data-md-component=search-suggest></div></form><div class=md-search__output><div class=md-search__scrollwrap tabindex=0 data-md-scrollfix><div class=md-search-result data-md-component=search-result><div class=md-search-result__meta> Initializing search </div><ol class=md-search-result__list role=presentation></ol></div></div></div></div></div><div class=md-header__source><a href=https://github.com/openssl/openssl title="Go to repository" class=md-source data-md-component=source><div class="md-source__icon md-icon"><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg></div><div class=md-source__repository> GitHub </div></a></div></nav><nav class=md-tabs aria-label=Tabs data-md-component=tabs><div class=md-grid><ul class=md-tabs__list><li class=md-tabs__item><a href=.. class=md-tabs__link> Home </a></li><li class=md-tabs__item><a href=../fips/ class=md-tabs__link> FIPS-140 </a></li><li class=md-tabs__item><a href=../man1/ class=md-tabs__link> Commands </a></li><li class=md-tabs__item><a href=../man3/ class=md-tabs__link> Libraries </a></li><li class=md-tabs__item><a href=../man5/ class=md-tabs__link> File Formats </a></li><li class=md-tabs__item><a href=../man7/ class=md-tabs__link> Overviews </a></li></ul></div></nav></header><div class=md-container data-md-component=container><main class=md-main data-md-component=main><div class="md-main__inner md-grid"><div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation hidden><div class=md-sidebar__scrollwrap><div class=md-sidebar__inner><nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0><label class=md-nav__title for=__drawer><a href=.. title="OpenSSL Documentation" class="md-nav__button md-logo" aria-label="OpenSSL Documentation" data-md-component=logo><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg></a> OpenSSL Documentation </label><div class=md-nav__source><a href=https://github.com/openssl/openssl title="Go to repository" class=md-source data-md-component=source><div class="md-source__icon md-icon"><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg></div><div class=md-source__repository> GitHub </div></a></div><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a href=.. class=md-nav__link title=Home><span class=md-ellipsis-custom> Home </span></a></li><li class=md-nav__item><a href=../fips/ class=md-nav__link title=FIPS-140><span class=md-ellipsis-custom> FIPS-140 </span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a href=../man1/ class=md-nav__link><span class=md-ellipsis-custom> Commands </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a href=../man3/ class=md-nav__link><span class=md-ellipsis-custom> Libraries </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a href=../man5/ class=md-nav__link><span class=md-ellipsis-custom> File Formats </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a href=../man7/ class=md-nav__link><span class=md-ellipsis-custom> Overviews </span><span class="md-nav__icon md-icon"></span></a></li></ul></nav></div></div></div><div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc><div class=md-sidebar__scrollwrap><div class=md-sidebar__inner><nav class="md-nav md-nav--secondary" aria-label="Table of contents"><label class=md-nav__title for=__toc><span class="md-nav__icon md-icon"></span> Table of contents </label><ul class=md-nav__list data-md-component=toc data-md-scrollfix><li class=md-nav__item><a href=#introduction class=md-nav__link><span class=md-ellipsis> Introduction </span></a></li><li class=md-nav__item><a href=#terms-used-in-this-document class=md-nav__link><span class=md-ellipsis> Terms Used in This Document </span></a></li><li class=md-nav__item><a href=#architecture class=md-nav__link><span class=md-ellipsis> Architecture </span></a><nav class=md-nav aria-label=Architecture><ul class=md-nav__list><li class=md-nav__item><a href=#conceptual-component-view class=md-nav__link><span class=md-ellipsis> Conceptual Component View </span></a></li><li class=md-nav__item><a href=#packaging-view class=md-nav__link><span class=md-ellipsis> Packaging View </span></a></li></ul></nav></li><li class=md-nav__item><a href=#core-and-provider-design class=md-nav__link><span class=md-ellipsis> Core and Provider Design </span></a><nav class=md-nav aria-label="Core and Provider Design"><ul class=md-nav__list><li class=md-nav__item><a href=#library-context class=md-nav__link><span class=md-ellipsis> Library Context </span></a></li><li class=md-nav__item><a href=#naming class=md-nav__link><span class=md-ellipsis> Naming </span></a></li><li class=md-nav__item><a href=#properties-for-algorithm-implementation-selection class=md-nav__link><span class=md-ellipsis> Properties for Algorithm Implementation Selection </span></a><nav class=md-nav aria-label="Properties for Algorithm Implementation Selection"><ul class=md-nav__list><li class=md-nav__item><a href=#property-based-algorithm-selection class=md-nav__link><span class=md-ellipsis> Property-based Algorithm Selection </span></a></li></ul></nav></li><li class=md-nav__item><a href=#parameter-definition class=md-nav__link><span class=md-ellipsis> Parameter Definition </span></a></li><li class=md-nav__item><a href=#operation-and-operation-function-definitions class=md-nav__link><span class=md-ellipsis> Operation and Operation Function Definitions </span></a></li><li class=md-nav__item><a href=#algorithm-query class=md-nav__link><span class=md-ellipsis> Algorithm Query </span></a></li><li class=md-nav__item><a href=#algorithm-query-caching class=md-nav__link><span class=md-ellipsis> Algorithm Query Caching </span></a></li><li class=md-nav__item><a href=#multilevel-queries class=md-nav__link><span class=md-ellipsis> Multilevel Queries </span></a></li><li class=md-nav__item><a href=#provider-module-loading class=md-nav__link><span class=md-ellipsis> Provider Module Loading </span></a><nav class=md-nav aria-label="Provider Module Loading"><ul class=md-nav__list><li class=md-nav__item><a href=#finding-and-loading-dynamic-provider-modules class=md-nav__link><span class=md-ellipsis> Finding and loading dynamic provider modules </span></a></li><li class=md-nav__item><a href=#provider-module-entry-point class=md-nav__link><span class=md-ellipsis> Provider Module Entry Point </span></a></li><li class=md-nav__item><a href=#provider-initialisation-and-algorithm-registration class=md-nav__link><span class=md-ellipsis> Provider Initialisation and Algorithm Registration </span></a></li></ul></nav></li><li class=md-nav__item><a href=#algorithm-selection class=md-nav__link><span class=md-ellipsis> Algorithm Selection </span></a><nav class=md-nav aria-label="Algorithm Selection"><ul class=md-nav__list><li class=md-nav__item><a href=#only-fips class=md-nav__link><span class=md-ellipsis> Only FIPS </span></a></li><li class=md-nav__item><a href=#default-to-fips-but-allow-an-override class=md-nav__link><span class=md-ellipsis> Default to FIPS but allow an override </span></a></li><li class=md-nav__item><a href=#default-to-not-caring-and-allow-override-for-fips class=md-nav__link><span class=md-ellipsis> Default to not caring and allow override for FIPS </span></a></li><li class=md-nav__item><a href=#asymmetric-algorithm-selection class=md-nav__link><span class=md-ellipsis> Asymmetric algorithm selection </span></a></li></ul></nav></li><li class=md-nav__item><a href=#example-dynamic-views-of-algorithm-selection class=md-nav__link><span class=md-ellipsis> Example dynamic views of algorithm selection </span></a></li></ul></nav></li><li class=md-nav__item><a href=#fips-module class=md-nav__link><span class=md-ellipsis> FIPS Module </span></a><nav class=md-nav aria-label="FIPS Module"><ul class=md-nav__list><li class=md-nav__item><a href=#fips-module-version-numbering class=md-nav__link><span class=md-ellipsis> FIPS Module Version Numbering </span></a></li><li class=md-nav__item><a href=#detection-of-changes-inside-the-fips-boundary class=md-nav__link><span class=md-ellipsis> Detection of Changes inside the FIPS Boundary </span></a><nav class=md-nav aria-label="Detection of Changes inside the FIPS Boundary"><ul class=md-nav__list><li class=md-nav__item><a href=#how-to-react-to-a-change-of-the-signed-checksum class=md-nav__link><span class=md-ellipsis> How to react to a change of the signed checksum </span></a></li><li class=md-nav__item><a href=#compiling class=md-nav__link><span class=md-ellipsis> Compiling </span></a></li></ul></nav></li><li class=md-nav__item><a href=#fips-mode class=md-nav__link><span class=md-ellipsis> FIPS Mode </span></a></li><li class=md-nav__item><a href=#roles-and-authentication class=md-nav__link><span class=md-ellipsis> Roles and Authentication </span></a></li><li class=md-nav__item><a href=#finite-state-model-fips-140-2-section-44 class=md-nav__link><span class=md-ellipsis> Finite State Model (FIPS 140-2 section 4.4) </span></a><nav class=md-nav aria-label="Finite State Model (FIPS 140-2 section 4.4)"><ul class=md-nav__list><li class=md-nav__item><a href=#state-machine class=md-nav__link><span class=md-ellipsis> State Machine </span></a></li></ul></nav></li><li class=md-nav__item><a href=#services class=md-nav__link><span class=md-ellipsis> Services </span></a></li><li class=md-nav__item><a href=#self-testing class=md-nav__link><span class=md-ellipsis> Self Testing </span></a><nav class=md-nav aria-label="Self Testing"><ul class=md-nav__list><li class=md-nav__item><a href=#integrity-checksum-location class=md-nav__link><span class=md-ellipsis> Integrity Checksum Location </span></a></li><li class=md-nav__item><a href=#known-answer-tests class=md-nav__link><span class=md-ellipsis> Known Answer Tests </span></a><nav class=md-nav aria-label="Known Answer Tests"><ul class=md-nav__list><li class=md-nav__item><a href=#api-access class=md-nav__link><span class=md-ellipsis> API access </span></a></li></ul></nav></li></ul></nav></li><li class=md-nav__item><a href=#security-strength class=md-nav__link><span class=md-ellipsis> Security Strength </span></a></li><li class=md-nav__item><a href=#sp800-56a-56b class=md-nav__link><span class=md-ellipsis> SP800-56A &amp; 56B </span></a><nav class=md-nav aria-label="SP800-56A & 56B"><ul class=md-nav__list><li class=md-nav__item><a href=#fips-186-4-rsa-key-generation class=md-nav__link><span class=md-ellipsis> FIPS 186-4 RSA Key Generation </span></a></li><li class=md-nav__item><a href=#dh-key-generation class=md-nav__link><span class=md-ellipsis> DH Key Generation </span></a></li><li class=md-nav__item><a href=#key-validation class=md-nav__link><span class=md-ellipsis> Key Validation </span></a></li></ul></nav></li><li class=md-nav__item><a href=#gcm-iv-generation class=md-nav__link><span class=md-ellipsis> GCM IV Generation </span></a></li><li class=md-nav__item><a href=#cspkey-zeroization class=md-nav__link><span class=md-ellipsis> CSP/Key Zeroization </span></a></li><li class=md-nav__item><a href=#drbg class=md-nav__link><span class=md-ellipsis> DRBG </span></a><nav class=md-nav aria-label=DRBG><ul class=md-nav__list><li class=md-nav__item><a href=#derivation-function class=md-nav__link><span class=md-ellipsis> Derivation Function </span></a></li><li class=md-nav__item><a href=#test-requirements class=md-nav__link><span class=md-ellipsis> Test Requirements </span></a></li><li class=md-nav__item><a href=#other-items-to-consider class=md-nav__link><span class=md-ellipsis> Other Items to Consider </span></a></li></ul></nav></li><li class=md-nav__item><a href=#entropy class=md-nav__link><span class=md-ellipsis> Entropy </span></a><nav class=md-nav aria-label=Entropy><ul class=md-nav__list><li class=md-nav__item><a href=#work-to-do-to-complete-the-entropy-solution class=md-nav__link><span class=md-ellipsis> Work to do to Complete the Entropy Solution </span></a><nav class=md-nav aria-label="Work to do to Complete the Entropy Solution"><ul class=md-nav__list><li class=md-nav__item><a href=#gcm-iv class=md-nav__link><span class=md-ellipsis> GCM IV </span></a></li></ul></nav></li></ul></nav></li><li class=md-nav__item><a href=#fips-module-boundary class=md-nav__link><span class=md-ellipsis> FIPS Module Boundary </span></a></li><li class=md-nav__item><a href=#asn1-code class=md-nav__link><span class=md-ellipsis> ASN.1 code </span></a></li></ul></nav></li><li class=md-nav__item><a href=#code-maintenance class=md-nav__link><span class=md-ellipsis> Code Maintenance </span></a><nav class=md-nav aria-label="Code Maintenance"><ul class=md-nav__list><li class=md-nav__item><a href=#source-code-structuretree-clean-up class=md-nav__link><span class=md-ellipsis> Source code structure/tree clean-up </span></a></li><li class=md-nav__item><a href=#shared-source-code class=md-nav__link><span class=md-ellipsis> Shared source code </span></a></li><li class=md-nav__item><a href=#conditional-code class=md-nav__link><span class=md-ellipsis> Conditional Code </span></a></li></ul></nav></li><li class=md-nav__item><a href=#fips-testing class=md-nav__link><span class=md-ellipsis> FIPS Testing </span></a><nav class=md-nav aria-label="FIPS Testing"><ul class=md-nav__list><li class=md-nav__item><a href=#fips-test-callbacks class=md-nav__link><span class=md-ellipsis> FIPS Test callbacks </span></a></li><li class=md-nav__item><a href=#post-failure-testing-and-logging class=md-nav__link><span class=md-ellipsis> POST Failure Testing and Logging. </span></a></li><li class=md-nav__item><a href=#cavs-testing class=md-nav__link><span class=md-ellipsis> CAVS Testing </span></a></li></ul></nav></li><li class=md-nav__item><a href=#legacy class=md-nav__link><span class=md-ellipsis> Legacy </span></a><nav class=md-nav aria-label=Legacy><ul class=md-nav__list><li class=md-nav__item><a href=#evp-to-low-level-api-bridges class=md-nav__link><span class=md-ellipsis> EVP to low level API bridges </span></a></li><li class=md-nav__item><a href=#evp-method-creators class=md-nav__link><span class=md-ellipsis> EVP method creators </span></a></li><li class=md-nav__item><a href=#associated-types class=md-nav__link><span class=md-ellipsis> Associated types </span></a></li></ul></nav></li><li class=md-nav__item><a href=#legacy-provider-module class=md-nav__link><span class=md-ellipsis> Legacy Provider Module </span></a></li><li class=md-nav__item><a href=#the-engine-api class=md-nav__link><span class=md-ellipsis> The ENGINE API </span></a></li></ul></nav></div></div></div><div class=md-content data-md-component=content><article class="md-content__inner md-typeset"><h1 id=openssl-300-design-draft>OpenSSL 3.0.0 Design (Draft)<a class=headerlink href=#openssl-300-design-draft title="Permanent link">&para;</a></h1><h2 id=introduction>Introduction<a class=headerlink href=#introduction title="Permanent link">&para;</a></h2><p>This document outlines the design of OpenSSL 3.0, the next version of OpenSSL after 1.1.1. It assumes familiarity with the document entitled <a href=../OpenSSLStrategicArchitecture/ >OpenSSL Strategic Architecture</a> and a working knowledge of OpenSSL 1.1.x.</p><p>The OpenSSL 3.0 release will have minimal impact to the vast majority of existing applications; almost all well-behaved applications will just need to be recompiled.</p><p>The majority of the changes in OpenSSL 3.0 are internal architectural restructuring to facilitate a long-term supportable cryptographic framework that enables better separation of algorithm implementations from algorithm APIs. These structural changes also support a more maintainable OpenSSL FIPS Cryptographic Module 3.0.</p><p>No currently marked deprecated APIs will be removed in OpenSSL 3.0.</p><p>Many additional low-level functions will be marked as deprecated APIs in OpenSSL 3.0.</p><p>OpenSSL 3.0 will support an application having TLS connections that are in FIPS mode (using the OpenSSL FIPS Cryptographic Module 3.0) and TLS connections that are in non-FIPS mode simultaneously.</p><h2 id=terms-used-in-this-document>Terms Used in This Document<a class=headerlink href=#terms-used-in-this-document title="Permanent link">&para;</a></h2><p>The following terms, in alphabetical order, are used in this document. A brief (summary) definition is provided.</p><ul><li><strong>Algorithm</strong>, or sometimes <strong>cryptographic algorithm</strong>, is a method to perform a set of operations (such as encryption or decryption). Our use of the term is abstract, and usually represents an algorithm by its name, such as "aes-128-cbc".</li><li><strong>Algorithm implementation</strong>, or sometimes just <strong>implementation</strong>, is a concrete implementation of an algorithm. This is mainly represented in code in the form of a set of functions.</li><li><strong>CAVS</strong> is the Cryptographic Algorithm Validation System. A tool used to test that a cryptographic implementation conforms to FIPS standards.</li><li><strong>CMVP</strong> is the Cryptographic Module Validation Program. A process that validates that cryptographic implementations conform to FIPS standards.</li><li><strong>EVP</strong> is a family of APIs implemented by libcrypto that enables applications to perform cryptographic operations. The implementation of the EVP API uses the Core and Provider components.</li><li>The <strong>Core</strong> is a component in libcrypto that enables applications to access the algorithm implementations offered by providers.</li><li><strong>CSP</strong> is Critical Security Parameters. This includes any information (e.g. private keys, passwords, pin numbers etc) that might compromise the security of a module in the event of their unauthorised disclosure or modification.</li><li><strong>Explicit Fetch</strong> is a method for finding an algorithm implementation where the application makes an explicit call to locate the implementation and supplies search criteria.</li><li><strong>FIPS</strong> is the Federal Information Processing Standards. This is a set of standards defined by the US government. In particular, FIPS standard 140-2 is applicable to cryptographic software.</li><li>A <strong>FIPS module</strong> is an implementation of cryptographic algorithms that has been validated by the CMVP as conforming to FIPS standards. In OpenSSL the FIPS module is implemented as a provider and is available in dynamically loadable module form.</li><li><strong>Implicit Fetch</strong> is a method for finding an algorithm implementation where the application does not explicitly make a call to locate the implementation and therefore default search criteria are used.</li><li>The <strong>Integrity Check</strong> is a test that is automatically run when the FIPS module is loaded. The module checksums itself and verifies that it hasn't been inadvertently altered.</li><li><strong>KAS</strong> is Key Agreement Scheme. A method by which two communicating parties can agree a shared key between them.</li><li><strong>KAT</strong>s are Known Answer Tests. A set of tests used to perform a health-check of a FIPS module.</li><li><strong>libcrypto</strong> is a shared library implemented by OpenSSL that provides applications with access to various cryptography related capabilities.</li><li><strong>libssl</strong> is a shared library implemented by OpenSSL that provides applications with the ability to create SSL/TLS connections either as a client or as a server.</li><li>A <strong>Library Context</strong> is an opaque structure that holds library "global" data.</li><li><strong>Operation</strong> is a class of functions to be performed on data, such as calculating a digest, encrypting, decrypting, etc. An algorithm may offer one or more operations. For example RSA provides asymmetric encryption, asymmetric decryption, signing, verifying, etc</li><li><strong>Parameters</strong> are an implementation agnostic set of key-value pairs that are used to communicate object data between the Core and providers. For example they could be used to transfer private key data.</li><li><strong>POST</strong> refers to the FIPS module Power-Up Self-Tests (a.k.a. Power-On Self-Tests) that are run at installation time, at power up (i.e. each time the FIPS module is loaded for an application) or on demand. These tests include the Integrity Check and the KATs. If the KATs were run successfully at installation time then they don't need to be run again at power up, however the Integrity Check is always performed.</li><li><strong>Properties</strong> are used by providers to describe the features of their algorithm implementations. They are also used in application queries to find specific implementations.</li><li><strong>Provider</strong> is a unit that provides one or more algorithm implementations.</li><li><strong>Provider module</strong> is a provider in dynamically loadable module form.</li></ul><h2 id=architecture>Architecture<a class=headerlink href=#architecture title="Permanent link">&para;</a></h2><p>The architecture shall have the following features:</p><ul><li>Common Services form the building blocks usable by applications and providers. (e.g. BIO, X509, SECMEM, ASN.1, etc).</li><li>Providers implement cryptographic algorithms and supporting services. An algorithm may consist of multiple operations (for example RSA may have "encrypt", "decrypt", "sign", "verify" etc). Similarly an operation (for example "sign") can be implemented by multiple algorithms such as RSA and ECDSA. A provider has implementations of the cryptographic primitives for an algorithm. This release will include the following providers: a. Default, which contains the current non-legacy OpenSSL cryptographic algorithms; this will be built-in (i.e., part of libcrypto) b. Legacy, with implementations of older algorithms (e.g, DES, MDC2, MD2, Blowfish, CAST) c. FIPS, which implements the OpenSSL FIPS Cryptographic Module 3.0; this can be loaded dynamically at runtime.</li><li>The Core enables access to the operations offered by providers to applications (and other providers). The Core is the mechanism via which concrete implementations of operations are located.</li><li>Protocol implementations. E.g. TLS, DTLS.</li></ul><p>This document has many references to the "EVP API." This refers to "application-level" operations, such as public-key signing, generating a digest and so on. These functions include <code>EVP_DigestSign</code>, <code>EVP_Digest</code>, <code>EVP_MAC_init</code> and the like. The EVP API also encapsulates the cryptographic objects used to perform those services, such as <code>EVP_PKEY</code>, <code>EVP_CIPHER</code>, <code>EVP_MD</code>, <code>EVP_MAC</code> and so forth. Providers implement the backend functionality for the latter set. Instances of these objects can be bound to providers implicitly or explicitly, depending on the application's needs. This is discussed in more detail in the <a href=#core-and-provider-design>Provider Design</a>, below.</p><p>The architecture has the following characteristics:</p><ul><li>The EVP layer is a thin wrapper for operations implemented in the providers. Most calls are passed straight through with little/no pre- or post-processing.</li><li>New EVP APIs will be provided to affect how the Core selects (or finds) the implementation of an operation to be used for any given EVP call.</li><li>Information will be passed between libcrypto and the providers in an implementation agnostic manner.</li><li>Legacy APIs (e.g. low level cryptographic APIs that do not go via the EVP layer) will be deprecated. Note that there are legacy APIs to non legacy algorithms (e.g. AES is not a legacy algorithm but <code>AES_encrypt</code> is a legacy API).</li><li>The OpenSSL FIPS Cryptographic Module will be implemented as a dynamically loaded provider. It will be self-contained (i.e. can only depend on system runtime libraries and services provided by the Core).</li></ul><h3 id=conceptual-component-view>Conceptual Component View<a class=headerlink href=#conceptual-component-view title="Permanent link">&para;</a></h3><p>An overview of the conceptual components in the OpenSSL architecture is as shown in the diagram below. Note that the existence of a component in the diagram does not indicate that the component is a public API or intended for end-user direct access or usage.</p><p><img alt src=../images/ToBeComponent.png></p><p>The new components (not present in the previous architecture) shown here are as follows:</p><ul><li>Core: This is a fundamental component that connects requests for an operation (such as encryption) to a provider of that operation. It provides the ability to locate an implementation of an algorithm offering specified operations given a set of properties that the implementation must fulfil. For example, properties of an encryption algorithm may include at a minimum "fips".</li><li>Default Provider: Implements a set of default algorithms.</li><li>FIPS Provider: Implements a set of algorithms that are FIPS validated and are made available via the Core. This includes the following supporting services:<ul><li>POST: Power On Self Test that perform:<ul><li>KAT: Known Answer Tests</li><li>Integrity Check</li></ul></li><li>Low Level Implementations: This is the set of components that actually implement the cryptographic primitives (to meet the FIPS-mandated self-contained requirement).</li></ul></li><li>Legacy Provider: Provides implementations of older algorithms that will be exposed via EVP-level APIs.</li><li>3rd Party Providers: Eventually, third-parties may provide their own providers. A third-party provider, like any other provider, implements a set of algorithms that will be accessible to applications and other providers via the Core.</li><li>Null Provider: A provider that does nothing. This can be useful for testing that the correct library context is used.</li><li>Base Provider: A provider for serialization of keys. The FIPS provider requires this since it does not contain methods to load keys. The Base provider is also embedded in the default provider.</li></ul><h3 id=packaging-view>Packaging View<a class=headerlink href=#packaging-view title="Permanent link">&para;</a></h3><p>The various components described in the conceptual component view above are physically packaged into:</p><ul><li>Executable application(s) for use by users</li><li>Libraries for use by application(s)</li><li>Dynamically loadable module(s) for use by the Core.</li></ul><p>There will be multiple different packaging options provided with OpenSSL 3.0 (for example a single library libcrypto containing everything except the FIPS Provider, and all providers as separate dynamically loadable modules).</p><p>Which dynamically loadable modules are registered, used, or available will be able to be configured at runtime.</p><p>The following figure describes the architecture in terms of physical packages.</p><p><img alt src=../images/ToBePackaging.png></p><p>The physical packages new to this release are:</p><ul><li><p>FIPS module. This contains the FIPS Provider that implements a set of algorithms that are FIPS validated and are available via the Core. The FIPS Provider is the OpenSSL FIPS Cryptographic Module 3.0.</p><p>We will not attempt to preclude users from making errors, however we will keep in mind the typical user usage and "safety". By default the FIPS provider will be built and installed.</p><p>We will be able to perform a safety check that detects if the user has modified the source in a FIPS-impactful manner from the release distribution and block building the FIPS provider (on best effort basis) unless an override option is provided.</p><p>We need to ensure there is a mechanism that enables the end user to determine whether or not their usage of the FIPS module is within the allowed uses under a formal validation.</p><p>Versioning of the FIPS module will be aligned with the base OpenSSL version number at the point in time of the validation. Not all OpenSSL releases will need an update to the FIPS module. Therefore when a new FIPS module version is released there may be gaps/jumps in its version number since the previous release.</p></li><li><p>Legacy module. This contains implementations of legacy algorithms.</p></li></ul><p>It was originally intended that Engines would be built with a provider shim, to allow them to work as usual for cases when an ENGINE pointer is passed to some functions, and as providers when acting as default implementations. Investigations during development, showed that this approach had problematic edge cases. The workaround for now is that there are two code paths currently when EVP calls are made. For engines support, the legacy code is used for 'legacy keys'. The long term plan is to remove engines and the legacy code paths from the code base. Anything written as an engine will need to be rewritten as a provider once engines are removed.</p><h2 id=core-and-provider-design>Core and Provider Design<a class=headerlink href=#core-and-provider-design title="Permanent link">&para;</a></h2><p>The interactions relevant for the Core and provider design are shown in the diagram below. There are four major components: User Application, EVP component, the Core, and a cryptographic Provider. (There may be multiple providers, but that is not relevant here).</p><p><img alt src=../images/300ProviderCollab.png></p><p>The Core has the following characteristics:</p><ul><li>It enables Provider discovery, loading, initialisation and unloading</li><li>It enables property-based algorithm queries</li><li>It implements caching of algorithm queries and implementation details</li><li>It operates within a library context that contains data such as global properties, search cache and dispatch tables.</li></ul><p>Providers have the following characteristics:</p><ul><li>They provide for access to specific algorithm implementations</li><li>They associate algorithm implementations with a set of well defined properties</li><li>They support parameter passing in an implementation agnostic manner</li><li>They can be loaded at any point in time</li><li>They have a well-known module entry point</li></ul><p>The subsections that follow describe the flow an application uses to load a provider, fetch an algorithm implementation, and use it. In addition, this section describes in detail how algorithms, properties, and parameters are named; how algorithm queries are handled; how algorithms are registered and initialized; and how providers are loaded.</p><p>In order for an application to be able to use an algorithm it must first "fetch" an implementation of it through an algorithm query. Our design objective is to be able to support both explicit (up front) fetching of algorithms and fetching of algorithms on use. By default we expect to do fetching on use (e.g. using <code>EVP_sha256()</code>) so that algorithms are typically fetched during an "init" function and bound to a context object (often named <code>ctx</code>). The explicit fetching option will be implemented via new API calls (e.g. <code>EVP_MD_fetch()</code>).</p><p>The diagram above shows the explicit fetch approach. The steps are as follows:</p><ol><li>Every provider needs to be loaded. This will happen implicitly (default provider or specified via configuration) and may also be explicitly requested by the application. Load encompases both dynamic shared object loading (as needed) and initialisation.<ol><li>The Core physically loads the module into memory (not required if default provider is already in memory).</li><li>The Core calls the provider's entry point for the provider to initialise itself.<ol><li>Within the entry point function, the provider initialises some provider variables using values passed in from the Core. A provider algorithm implementation query callback is returned to the Core if initialization succeeds.</li></ol></li></ol></li><li>User application requests algorithm by calling a fetch routine.<ol><li>The search by EVP will combine global properties with call-specific ones and an algorithm identity to find the corresponding algorithm implementation, and then create and return a library handle (e.g. <code>EVP_MD</code>, <code>EVP_CIPHER</code>) to the application.<ol><li>The first search of the implementation dispatch table is made in an internal cache.</li><li>Should the first search fail, a second search is made by asking the providers if they have an implementation of said algorithm with the queried properties. When this search is done, the resulting data is cached unless the provider opts out of caching, to be used in the first search (2.1.1). For example a PKCS#11 provider may opt out of caching because its algorithms may become available and unavailable over time.</li></ol></li></ol></li><li>The user application then uses the algorithm via EVP APIs (e.g., <code>EVP_DigestInit()</code>, <code>EVP_DigestUpdate()</code>, <code>EVP_DigestFinal()</code>, etc).<ol><li>The function pointer is invoked and ends up in the provider for the implementation to perform the requested cryptographic algorithm.</li></ol></li></ol><p>For the existing <code>EVP_{algorithm}()</code> functions (e.g. <code>EVP_sha256()</code>, etc) things remain mostly unchanged. In particular, the fetch call is not performed when the <code>EVP_{algorithm}()</code> call returns, but rather it happens implicitly when the context object (e.g. <code>EVP_MD_CTX</code>) is bound within the respective EVP init function. Specifically, step 2.1 happens just before step 3.1. This is known as "implicit fetch". Implicit fetch always operates within a default library context (see <a href=#library-context>Library Context</a> below).</p><p>The method dispatch table is a list of <code>&lt;function-id, function-pointer&gt;</code> pairs — where the <code>function-id</code>s are publically defined and known by OpenSSL — put together with a set of properties that can be used to identify each particular implementation. The Core can take a property query and find the corresponding dispatch table, to be used for applicable operations. This approach allows providers to flexibly pass references to functions that the OpenSSL code can use to create its method structures dynamically.</p><p>Providers can be loaded at any point in time. Unload at any point in time can be requested. It is up to the application to ensure that a provider is not currently being used or referenced when it is unloaded. If an attempt is made to use an implementation that is no longer available then an error will be returned.</p><p>The assumptions an application can currently make about the return from <code>EVP_{algorithm}()</code> and not the new fetch approach are:</p><ul><li>const pointer</li><li>does not need to be freed by the application</li><li>can safely be compared for checking algorithms are the same (i.e. specifically comparing pointers to <code>EVP_CIPHER</code>, <code>EVP_MD</code>, etc)</li></ul><p>For a direct use of explicit fetch by the application (rather than using the existing <code>EVP_{algorithm}()</code> functions) the semantics will be different:</p><ul><li>non-const pointer</li><li>needs to be freed by the application</li><li>pointers can't be safely compared with each other (more on that in the next paragraph)</li></ul><p>There will be new APIs to test the equality of objects that can be used for both explicitly fetched objects and static variant ones These APIs will enable comparison of just the algorithm identity, or of specific algorithm implementations.</p><h3 id=library-context>Library Context<a class=headerlink href=#library-context title="Permanent link">&para;</a></h3><p>A library context is an opaque structure that holds library "global" data. OpenSSL will provide such a structure, limited to the global data that the Core has to keep. Future expansion may come to include other existing global data. An application will be able to create and destroy one or more library context(s) within which all subsequent interactions with the Core operate within. If the application does not create and provide its own library context, an internal default one will be used.</p><div class=highlight><pre><span></span><code><span class=n>OPENSSL_CTX</span><span class=w> </span><span class=o>*</span><span class=nf>OPENSSL_CTX_new</span><span class=p>();</span>
<span class=kt>void</span><span class=w> </span><span class=nf>OPENSSL_CTX_free</span><span class=p>(</span><span class=n>OPENSSL_CTX</span><span class=w> </span><span class=o>*</span><span class=n>ctx</span><span class=p>);</span>
</code></pre></div><p>A library context can be passed to the explicit fetch functions. If <code>NULL</code> is passed to them, the internal default context will be used.</p><p>More than one library context may be allocated, which implies that any provider module may be initialized more than once. This permits an application to both be directly linked with libcrypto and loading providers it's interested in, as well as being linked with other libraries that use their own provider modules, independently.</p><h3 id=naming>Naming<a class=headerlink href=#naming title="Permanent link">&para;</a></h3><p>Names are required for algorithms, parameters, and properties. In order to ensure consistency and to enable external Provider implementers to define new names in a consistent way there will be a registry of recommended or used names. It will be maintained separately from the sources.</p><p>The ability to define aliases for names is required because there are contexts where there are more than one name for the same thing (e.g. EC curves with general names and NIST names for the same thing).</p><h3 id=properties-for-algorithm-implementation-selection>Properties for Algorithm Implementation Selection<a class=headerlink href=#properties-for-algorithm-implementation-selection title="Permanent link">&para;</a></h3><p>Algorithm implementations (cryptographic and non-cryptographic) will have some properties which will be used to select an implementation from amongst those available. For 3.0, two properties are defined:</p><ul><li><em>is this implementation the default implementation?</em></li><li><em>is this implementation FIPS validated</em>?</li></ul><p>The valid input and their meaning are:</p><table><thead><tr><th><strong>Property String</strong></th><th><strong>Meaning in a definition</strong></th><th><strong>Meaning in a query</strong></th></tr></thead><tbody><tr><td><code>default</code></td><td>This is the default implementation</td><td>Request the default implementation</td></tr><tr><td><code>default=yes</code></td><td>This is the default implementation</td><td>Request the default implementation</td></tr><tr><td><code>default=no</code></td><td>This is not the default implementation</td><td>Request a non-default implementation</td></tr><tr><td><code>fips</code></td><td>This implementation is FIPS validated</td><td>Request an implementation that is FIPS validated</td></tr><tr><td><code>fips=yes</code></td><td>This implementation is FIPS validated</td><td>Request an implementation that is FIPS validated</td></tr><tr><td><code>fips=no</code></td><td>This implementation is not FIPS validated</td><td>Request an implementation that is not FIPS validated</td></tr></tbody></table><p>In all cases property names will be defined as printable ASCII characters and are case insensitive. Property values may be quoted or unquoted. Unquoted values will also always be printable ASCII characters and are case insensitive. Quoted values are tested for equality on a raw byte comparison basis only.</p><p>Providers will be able to provide their own names or values. The full syntax of property definitions and queries appear in <a href=#appendix-1-property-syntax>Appendix 1 - Property Syntax</a>.</p><p>OpenSSL reserves all property names that do not have a period; vendor-provided property names must have a period in the name. It is expected (but not enforced) that the part of the property name before the first period is or relates to the provider's name, to provide some level of conflict avoidance via namespacing.</p><p>It is likely that additional properties will be defined during the development of this release. A likely candidate is <code>provider</code> being the name of the provider that is supplying the implementation. Another possibility is <code>engine</code>, meaning that this algorithm is implemented by an OpenSSL 1.1.1 dynamically loaded engine masquerading as a provider.</p><p>There will be a built in global property query string, which will be "default".</p><h4 id=property-based-algorithm-selection>Property-based Algorithm Selection<a class=headerlink href=#property-based-algorithm-selection title="Permanent link">&para;</a></h4><p>Algorithm implementation selection is based on properties.</p><p>The provider sets properties on the algorithms it offers. The application sets which properties that it wants to see used as a filter during algorithm selection - the query.</p><p>The desired properties for fetching algorithm implementations can be specified in the following places:</p><ol><li>globally, based on configuration files.</li><li>globally, based on API calls.</li><li>on a per-object basis for specific objects. E.g. SSL_CTX, SSL.</li></ol><p>Properties will be used during algorithm lookup (parameter specification of property values).</p><p>The sets of properties will be evaluated in a manner that resolves to a single value of a property for each specified property (keyword). The precedence order for keyword evaluation is:</p><ol><li>The per-object or directly specified API parameter to fetch</li><li>The global (default) properties set by API calls</li><li>The global (default) properties set in configuration files</li></ol><p>It is possible that additional property setting methods and evaluation approaches will be defined during the development of this release.</p><p>By default, OpenSSL 3.0 will load a configuration file (which contains global properties and other settings) automatically without explicit application API calls. This will occur in libcrypto. Note that in OpenSSL 1.1.1 the configuration file is automatically loaded only by the default (automatic) initialisation of libssl.</p><h3 id=parameter-definition>Parameter Definition<a class=headerlink href=#parameter-definition title="Permanent link">&para;</a></h3><p>The OpenSSL Core and providers have to exchange data while keeping OpenSSL and provider structures opaque. All composite values will be passed as an array of items, using the public data structure defined in <a href=#appendix-2-parameter-passing>Appendix 2 - OpenSSL parameter passing</a>. Parameters will be identified using their name (as a string) and each contains its own type and size information.</p><p>The Core will define an API to pass an array of parameter values or requests for values to a provider or a specific algorithm implementation, and for the latter, an associated object handled by that implementation. In the cases of the basic machine types, macros could be developed to assist in the construction and extraction of values.</p><h3 id=operation-and-operation-function-definitions>Operation and Operation Function Definitions<a class=headerlink href=#operation-and-operation-function-definitions title="Permanent link">&para;</a></h3><p>While algorithm and parameter names are essentially controlled and allocated by the providers, the operations and associated functions that are going to be called by libcrypto are essentially controlled and allocated by the Core.</p><p>For things that are only controlled by the Core, we will use macros to name them, with numbers as values to be used as indexes. Allocation will be incremental, i.e. for any new operation or function, the next number available will be picked.</p><h3 id=algorithm-query>Algorithm Query<a class=headerlink href=#algorithm-query title="Permanent link">&para;</a></h3><p>Each algorithm type (e.g. <code>EVP_MD</code>, <code>EVP_CIPHER</code> etc) with have a "fetch" function available (e.g. <code>EVP_MD_fetch()</code>, <code>EVP_CIPHER_fetch()</code>). Algorithm implementations are identified using their name and properties</p><p>Each fetch function will use services provided by the Core to find an appropriate implementation as described in the introduction of <a href=#core-and-provider-design>Core and Provider Design</a>. If an appropriate implementation has been found then it is constructed into a suitable algorithm structure (e.g. <code>EVP_MD</code>, <code>EVP_CIPHER</code>) and returned to the calling application.</p><p>If multiple implementations are equally good matches for the passed name and properties, one of these will be returned on retrieval but exactly which one is not defined. Furthermore, there is no guarantee that the same match would be returned every time.</p><h3 id=algorithm-query-caching>Algorithm Query Caching<a class=headerlink href=#algorithm-query-caching title="Permanent link">&para;</a></h3><p>Algorithm queries will be cached together with their result.</p><p>The algorithm query cache can be flushed to remove:</p><ul><li>All queries returning a specific algorithm implementation</li><li>All algorithm implementations from a specific provider</li><li>All algorithm implementations</li></ul><h3 id=multilevel-queries>Multilevel Queries<a class=headerlink href=#multilevel-queries title="Permanent link">&para;</a></h3><p>In order to handle both global properties and properties passed to specific calls (such as fetch calls), the global property query settings will be merged with the passed property settings except where there is a conflict, specifically:</p><table><thead><tr><th><strong>Global Setting</strong></th><th><strong>Passed Settings</strong></th><th><strong>Resulting Query</strong></th></tr></thead><tbody><tr><td><code>fips=yes</code></td><td><code>fips=yes</code></td><td><code>fips=yes</code></td></tr><tr><td><code>fips=yes</code></td><td><code>fips=no</code></td><td><code>fips=no</code></td></tr><tr><td><code>fips=yes</code></td><td><code>-fips</code></td><td><em>fips is not specified</em></td></tr><tr><td><code>fips=yes</code></td><td><em>fips is not specified</em></td><td><code>fips=yes</code></td></tr><tr><td><code>fips=no</code></td><td><code>fips=yes</code></td><td><code>fips=yes</code></td></tr><tr><td><code>fips=no</code></td><td><code>fips=no</code></td><td><code>fips=no</code></td></tr><tr><td><code>fips=no</code></td><td><code>-fips</code></td><td><em>fips is not specified</em></td></tr><tr><td><code>fips=no</code></td><td><em>fips is not specified</em></td><td><code>fips=no</code></td></tr><tr><td><em>fips is not specified</em></td><td><code>fips=yes</code></td><td><code>fips=yes</code></td></tr><tr><td><em>fips is not specified</em></td><td><code>fips=no</code></td><td><code>fips=no</code></td></tr><tr><td><em>fips is not specified</em></td><td><code>-fips</code></td><td><em>fips stays not specified</em></td></tr><tr><td><em>fips is not specified</em></td><td><em>fips is not specified</em></td><td><em>fips stays not specified</em></td></tr></tbody></table><h3 id=provider-module-loading>Provider Module Loading<a class=headerlink href=#provider-module-loading title="Permanent link">&para;</a></h3><p>Providers can either be built-in or dynamically loadable modules.</p><p>All algorithms are implemented by providers. The OpenSSL Core will initially have no providers loaded, and therefore will have no algorithms available. Providers will need to be discovered and loaded. The algorithm implementations contained within them can then be queried by the Core at a later time, with those queries possibly becoming cached.</p><p>If no provider has been loaded at the time of the first fetch (implicit as well as explicit), the built in default provider will be automatically loaded.</p><p>Note that a provider may be written against an older version of the Core API than the current version in libcrypto. For example, it will have to be possible for users to run a different FIPS provider module version than the main OpenSSL version. This means the Core API will have to remain stable and backwards compatible (just like any other public API).</p><p>All of the command line applications supplied as part of the OpenSSL build will gain a <code>-provider xxx</code> option which loads a provider. This option can be specified multiple times on the command line (as multiple providers can always be loaded) and it isn't an error if the provider remains unused for any specific operation (e.g. loading a provider that only supplies AES when doing a SHA256 digest).</p><h4 id=finding-and-loading-dynamic-provider-modules>Finding and loading dynamic provider modules<a class=headerlink href=#finding-and-loading-dynamic-provider-modules title="Permanent link">&para;</a></h4><p>Dynamic provider modules are <code>.so</code> files on UNIX type operating systems, or a <code>.dll</code> file on Windows type operating systems, or whatever corresponds on other operating systems. By default, they will be installed in a well known directory.</p><p>Provider module loading can occur several ways:</p><ul><li><strong>On demand</strong>, the application will have to specify exactly what provider modules should be loaded.</li><li><strong>By configuration</strong>, the set of provider modules to load would be specified in a configuration file.</li></ul><p>Some of these methods may be combined.</p><p>A provider module can be specified by full path, and can therefore be loaded even if it isn't located in the well known directory.</p><p>After the Core loads a provider module, it calls the provider module entry point.</p><h4 id=provider-module-entry-point>Provider Module Entry Point<a class=headerlink href=#provider-module-entry-point title="Permanent link">&para;</a></h4><p>A provider module <em>must</em> have the following well known entry point:</p><div class=highlight><pre><span></span><code><span class=kt>int</span><span class=w> </span><span class=nf>OSSL_provider_init</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>OSSL_PROVIDER</span><span class=w> </span><span class=o>*</span><span class=n>provider</span><span class=p>,</span>
<span class=w>                       </span><span class=k>const</span><span class=w> </span><span class=n>OSSL_DISPATCH</span><span class=w> </span><span class=o>*</span><span class=n>in</span><span class=p>,</span>
<span class=w>                       </span><span class=k>const</span><span class=w> </span><span class=n>OSSL_DISPATCH</span><span class=w> </span><span class=o>**</span><span class=n>out</span>
<span class=w>                       </span><span class=kt>void</span><span class=w> </span><span class=o>**</span><span class=n>provider_ctx</span><span class=p>);</span>
</code></pre></div><p>If the entry point does not exist in the dynamically loaded object, then it is not a valid module and loading it will fail.</p><p><code>in</code> is an array of functions that the Core passes to the provider.</p><p><code>out</code> is an array of provider functions that the provider passes back to the Core.</p><p><code>provider_ctx</code> (may be shortened to <code>provctx</code> elsewhere in this document) is an object optionally created by the provider for its own use (storing data it needs to keep around safely). This pointer will be passed back to appropriate provider functions.</p><p><code>provider</code> is a handle to a provider object belonging to the Core. This can serve as a unique provider identity which may be required in some API calls. This object will also be populated with diverse data, such as module path, NCONF configuration structure for the provider (see <a href=#conf-nconf-values-as-parameters>CONF / NCONF values as parameters</a> below for an idea on how that would be implemented), and these diverse values can then be retrieved by the provider using a params getter callback that the Core provides. The type <code>OSSL_PROVIDER</code> is opaque.</p><p><code>OSSL_DISPATCH</code> is an open structure that implements the <code>&lt; function-id, function-pointer &gt;</code> tuple mentioned in the introduction of <a href=#core-and-provider-design>Core and Provider Design</a>:</p><div class=highlight><pre><span></span><code><span class=k>typedef</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>ossl_dispatch_st</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>function_id</span><span class=p>;</span>
<span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>function</span><span class=p>)();</span>
<span class=p>}</span><span class=w> </span><span class=n>OSSL_DISPATCH</span><span class=p>;</span>
</code></pre></div><p>The <code>funcion_id</code> identifies a specific function, and <code>function</code> is the pointer to that function. An array of these is terminated with <code>function_id</code> set to zero.</p><p>The provider module may or may not be linked against libcrypto. If it is not then it will have no direct access to any libcrypto functions. All essential communication back to libcrypto will be via callback functions provided by the Core. It is important that memory allocated by specific providers is freed by the same providers. Similarly memory allocated in libcrypto should be freed by libcrypto.</p><p>The API will specify a well known set of callback function numbers. More function numbers can be added in later releases as required without breaking backwards compatibility.</p><div class=highlight><pre><span></span><code><span class=cm>/* Functions provided by the Core to the provider */</span>
<span class=cp>#define OSSL_FUNC_ERR_PUT_ERROR                        1</span>
<span class=cp>#define OSSL_FUNC_GET_PARAMS                           2</span>
<span class=cm>/* Functions provided by the provider to the Core */</span>
<span class=cp>#define OSSL_FUNC_PROVIDER_QUERY_OPERATION             3</span>
<span class=cp>#define OSSL_FUNC_PROVIDER_TEARDOWN                    4</span>
</code></pre></div><p>The Core will set up an array of the well known callback functions:</p><div class=highlight><pre><span></span><code><span class=k>static</span><span class=w> </span><span class=n>OSSL_DISPATCH</span><span class=w> </span><span class=n>core_callbacks</span><span class=p>[]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>OSSL_FUNC_ERR_PUT_ERROR</span><span class=p>,</span><span class=w> </span><span class=n>ERR_put_error</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=cm>/* int ossl_get_params(OSSL_PROVIDER *prov, OSSL_PARAM params[]); */</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>OSSL_FUNC_GET_PARAMS</span><span class=p>,</span><span class=w> </span><span class=n>ossl_get_params</span><span class=p>,</span><span class=w> </span><span class=p>}</span>
<span class=w>    </span><span class=cm>/* ... and more */</span>
<span class=p>};</span>
</code></pre></div><p>This is only a few of the functions that the Core may see fit to pass to a provider. We may also pass functions to help with logging, testing, instrumentation etc as the need comes up.</p><p>Once the module is loaded and the well known entry point located, the init entry point can be invoked by the Core:</p><div class=highlight><pre><span></span><code><span class=cm>/*</span>
<span class=cm> * NOTE: this code is meant as a simple demonstration of what could happen</span>
<span class=cm> * in the core.  This is an area where the OSSL_PROVIDER type is not opaque.</span>
<span class=cm> */</span>
<span class=n>OSSL_PROVIDER</span><span class=w> </span><span class=o>*</span><span class=n>provider</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>OSSL_PROVIDER_new</span><span class=p>();</span>
<span class=k>const</span><span class=w> </span><span class=n>OSSL_DISPATCH</span><span class=w> </span><span class=o>*</span><span class=n>provider_callbacks</span><span class=p>;</span>
<span class=cm>/*</span>
<span class=cm> * The following are diverse parameters that the provider can get the values</span>
<span class=cm> * of with ossl_get_params.</span>
<span class=cm> */</span>
<span class=cm>/* reference to the loaded module, or NULL if built in */</span>
<span class=n>provider</span><span class=o>-&gt;</span><span class=n>module</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dso</span><span class=p>;</span>
<span class=cm>/* reference to the path of the loaded module */</span>
<span class=n>provider</span><span class=o>-&gt;</span><span class=n>module_path</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dso_path</span><span class=p>;</span>
<span class=cm>/* reference to the NCONF structure used for this provider */</span>
<span class=n>provider</span><span class=o>-&gt;</span><span class=n>conf_module</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>conf_module</span><span class=p>;</span>

<span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>OSSL_provider_init</span><span class=p>(</span><span class=n>provider</span><span class=p>,</span><span class=w> </span><span class=n>core_callbacks</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>provider_callbacks</span><span class=p>))</span>
<span class=w>    </span><span class=k>goto</span><span class=w> </span><span class=n>err</span><span class=p>;</span>

<span class=cm>/* populate |provider| with functions passed by the provider */</span>
<span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>provider_callbacks</span><span class=o>-&gt;</span><span class=n>func_num</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>switch</span><span class=w> </span><span class=p>(</span><span class=n>provider_callbacks</span><span class=o>-&gt;</span><span class=n>func_num</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>case</span><span class=w> </span><span class=no>OSSL_FUNC_PROVIDER_QUERY_OPERATION</span><span class=p>:</span>
<span class=w>        </span><span class=n>provider</span><span class=o>-&gt;</span><span class=n>query_operation</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>provider_callbacks</span><span class=o>-&gt;</span><span class=n>func</span><span class=p>;</span>
<span class=w>        </span><span class=k>break</span><span class=p>;</span>
<span class=w>    </span><span class=k>case</span><span class=w> </span><span class=no>OSSL_FUNC_PROVIDER_TEARDOWN</span><span class=p>:</span>
<span class=w>        </span><span class=n>provider</span><span class=o>-&gt;</span><span class=n>teardown</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>provider_callbacks</span><span class=o>-&gt;</span><span class=n>func</span><span class=p>;</span>
<span class=w>        </span><span class=k>break</span><span class=p>;</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>    </span><span class=n>provider_callbacks</span><span class=o>++</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>The <code>OSSL_provider_init</code> entry point does not register any algorithms that will be needed, but it will return at least these two callbacks to enable this process:</p><ol><li><code>OSSL_FUNC_QUERY_OPERATION</code>, which is used to find out what implementations of an operation are available. This must return an array of <code>OSSL_ALGORITHM</code> (see further down), which maps algorithm names and property definition strings to implementation dispatch tables. This function must also be able to indicate if the resulting array may be cached by the Core or not. This is explained in further detail below.</li><li><code>OSSL_FUNC_TEARDOWN</code>, which is used when the provider is unloaded.</li></ol><p>The provider register callback can only be run after the <code>OSSL_provider_init()</code> call succeeds.</p><h4 id=provider-initialisation-and-algorithm-registration>Provider Initialisation and Algorithm Registration<a class=headerlink href=#provider-initialisation-and-algorithm-registration title="Permanent link">&para;</a></h4><p>An algorithm offers a set of operations (capabilities, features, etc). The operations are invoked via functions. For example, the RSA algorithm offers signing and encryption (two operations) which are invoked via the <em>init</em>, <em>update</em>, <em>final</em> functions for signing and <em>init</em>, <em>update</em>, _final _ functions for encryption. The set of functions is determined by the implementation of the upper-level EVP code.</p><p>Operations are identified by a unique number. For example:</p><div class=highlight><pre><span></span><code><span class=cp>#define OSSL_OP_DIGEST                     1</span>
<span class=cp>#define OSSL_OP_SYM_ENCRYPT                2</span>
<span class=cp>#define OSSL_OP_SEAL                       3</span>
<span class=cp>#define OSSL_OP_DIGEST_SIGN                4</span>
<span class=cp>#define OSSL_OP_SIGN                       5</span>
<span class=cp>#define OSSL_OP_ASYM_KEYGEN                6</span>
<span class=cp>#define OSSL_OP_ASYM_PARAMGEN              7</span>
<span class=cp>#define OSSL_OP_ASYM_ENCRYPT               8</span>
<span class=cp>#define OSSL_OP_ASYM_SIGN                  9</span>
<span class=cp>#define OSSL_OP_ASYM_DERIVE               10</span>
</code></pre></div><p>For a provider to make an algorithm usable by libcrypto, it must register an operation querying callback, which returns an array of implementation descriptors, given an operation identity:</p><div class=highlight><pre><span></span><code>&lt; algorithm name, property definition string, implementation `OSSL_DISPATCH*` &gt;
</code></pre></div><p>So for example, this query callback will return the list of all its digests if the given operation is <code>OSSL_OP_DIGEST</code>.</p><p>Algorithms are identified by a string.</p><p>The Core provides a set of services for the provider to use in the form of a function table.</p><p>A provider will also offer a service for returning information (in the form of parameters as specified in <a href=#appendix-2-parameter-passing>Appendix 2 - Parameter Passing</a>) via a callback provided by the provider, such as:</p><ul><li>version number</li><li>Build strings - as per the current OpenSSL related build information (only at the provider level)</li><li>Provider name</li></ul><p>An individual operation may require multiple function callbacks to be defined in order to implement the operation. Each function will be identified by a numeric function identity. Each of the identities are unique for the combination of operation and function, i.e. the number assigned to the init function of the digest operation cannot be reused for init functions for other operations, those will have their own unique numbers. For example, for the digest operation, these functions are required:</p><div class=highlight><pre><span></span><code><span class=cp>#define OSSL_OP_DIGEST_NEWCTX_FUNC         1</span>
<span class=cp>#define OSSL_OP_DIGEST_INIT_FUNC           2</span>
<span class=cp>#define OSSL_OP_DIGEST_UPDATE_FUNC         3</span>
<span class=cp>#define OSSL_OP_DIGEST_FINAL_FUNC          4</span>
<span class=cp>#define OSSL_OP_DIGEST_FREECTX_FUNC        5</span>
<span class=k>typedef</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>OSSL_OP_digest_newctx_fn</span><span class=p>)(</span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>provctx</span><span class=p>);</span>
<span class=k>typedef</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=n>OSSL_OP_digest_init_fn</span><span class=p>)(</span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>ctx</span><span class=p>);</span>
<span class=k>typedef</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=n>OSSL_OP_digest_update_fn</span><span class=p>)(</span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>data</span><span class=p>,</span><span class=w> </span><span class=kt>size_t</span><span class=w> </span><span class=n>len</span><span class=p>);</span>
<span class=k>typedef</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=n>OSSL_OP_digest_final_fn</span><span class=p>)(</span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>md</span><span class=p>,</span><span class=w> </span><span class=kt>size_t</span><span class=w> </span><span class=n>mdsize</span><span class=p>,</span>
<span class=w>                                       </span><span class=kt>size_t</span><span class=w> </span><span class=o>*</span><span class=n>outlen</span><span class=p>);</span>
<span class=k>typedef</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=n>OSSL_OP_digest_freectx_fn</span><span class=p>)(</span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>ctx</span><span class=p>);</span>
</code></pre></div><p>An all in one version is also advisable for devices that cannot handle multi-part operations:</p><div class=highlight><pre><span></span><code><span class=cp>#define OSSL_OP_DIGEST_FUNC                6</span>
<span class=k>typedef</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=n>OSSL_OP_digest</span><span class=p>)(</span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>provctx</span><span class=p>,</span>
<span class=w>                              </span><span class=k>const</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>data</span><span class=p>,</span><span class=w> </span><span class=kt>size_t</span><span class=w> </span><span class=n>len</span><span class=p>,</span>
<span class=w>                              </span><span class=kt>unsigned</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>*</span><span class=n>md</span><span class=p>,</span><span class=w> </span><span class=kt>size_t</span><span class=w> </span><span class=n>mdsize</span><span class=p>,</span>
<span class=w>                              </span><span class=kt>size_t</span><span class=w> </span><span class=o>*</span><span class=n>outlen</span><span class=p>);</span>
</code></pre></div><p>A provider then defines arrays containing the set of functions for each algorithm implementation and one array of algorithm descriptors for each operation. The algorithm descriptor was mentioned higher up, and would be publically defined like this:</p><div class=highlight><pre><span></span><code><span class=k>typedef</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>ossl_algorithm_st</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>*</span><span class=n>name</span><span class=p>;</span>
<span class=w>    </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>*</span><span class=n>properties</span><span class=p>;</span>
<span class=w>    </span><span class=n>OSSL_DISPATCH</span><span class=w> </span><span class=o>*</span><span class=n>impl</span><span class=p>;</span>
<span class=p>}</span><span class=w> </span><span class=n>OSSL_ALGORITHM</span><span class=p>;</span>
</code></pre></div><p>For example (and it is only an example, providers may arrange these things any way they want, the important thing is what the algorithm querying function such as <code>fips_query_operation</code> below returns) the FIPS module may define arrays like this for the SHA1 algorithm:</p><div class=highlight><pre><span></span><code><span class=k>static</span><span class=w> </span><span class=n>OSSL_DISPATCH</span><span class=w> </span><span class=n>fips_sha1_callbacks</span><span class=p>[]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>OSSL_OP_DIGEST_NEWCTX_FUNC</span><span class=p>,</span><span class=w> </span><span class=n>fips_sha1_newctx</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>OSSL_OP_DIGEST_INIT_FUNC</span><span class=p>,</span><span class=w> </span><span class=n>fips_sha1_init</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>OSSL_OP_DIGEST_UPDATE_FUNC</span><span class=p>,</span><span class=w> </span><span class=n>fips_sha1_update</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>OSSL_OP_DIGEST_FINAL_FUNC</span><span class=p>,</span><span class=w> </span><span class=n>fips_sha1_final</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>OSSL_OP_DIGEST_FUNC</span><span class=p>,</span><span class=w> </span><span class=n>fips_sha1_digest</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>OSSL_OP_DIGEST_FREECTX_FUNC</span><span class=p>,</span><span class=w> </span><span class=n>fips_sha1_freectx</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=w> </span><span class=p>}</span>
<span class=p>};</span>
<span class=k>static</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=n>prop_fips</span><span class=p>[]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&quot;fips&quot;</span><span class=p>;</span>
<span class=k>static</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>OSSL_ALGORITHM</span><span class=w> </span><span class=n>fips_digests</span><span class=p>[]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=s>&quot;sha1&quot;</span><span class=p>,</span><span class=w> </span><span class=n>prop_fips</span><span class=p>,</span><span class=w> </span><span class=n>fips_sha1_callbacks</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=s>&quot;SHA-1&quot;</span><span class=p>,</span><span class=w> </span><span class=n>prop_fips</span><span class=p>,</span><span class=w> </span><span class=n>fips_sha1_callbacks</span><span class=w> </span><span class=p>},</span><span class=w> </span><span class=cm>/* alias for &quot;sha1&quot; */</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=nb>NULL</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=w> </span><span class=p>}</span>
<span class=p>};</span>
</code></pre></div><p>The FIPS provider init module entry point function might look like this:</p><div class=highlight><pre><span></span><code><span class=k>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>fips_query_operation</span><span class=p>(</span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>provctx</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>op_id</span><span class=p>,</span>
<span class=w>                                </span><span class=k>const</span><span class=w> </span><span class=n>OSSL_ALGORITHM</span><span class=w> </span><span class=o>**</span><span class=n>map</span><span class=p>)</span>
<span class=p>{</span>
<span class=w>    </span><span class=o>*</span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>NULL</span><span class=p>;</span>
<span class=w>    </span><span class=k>switch</span><span class=w> </span><span class=p>(</span><span class=n>op_id</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>case</span><span class=w> </span><span class=no>OSSL_OP_DIGEST</span><span class=p>:</span>
<span class=w>        </span><span class=o>*</span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>fips_digests</span><span class=p>;</span>
<span class=w>        </span><span class=k>break</span><span class=p>;</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=o>*</span><span class=n>map</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nb>NULL</span><span class=p>;</span>
<span class=p>}</span>

<span class=cp>#define param_set_string(o,s) do {                                  \</span>
<span class=cp>    (o)-&gt;buffer = (s);                                              \</span>
<span class=cp>    (o)-&gt;data_type = OSSL_PARAM_UTF8_STRING_PTR;                    \</span>
<span class=cp>    if ((o)-&gt;result_size != NULL) *(o)-&gt;result_size = sizeof(s);    \</span>
<span class=cp>} while(0)</span>
<span class=k>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>fips_get_params</span><span class=p>(</span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>provctx</span><span class=p>,</span><span class=w> </span><span class=n>OSSL_PARAM</span><span class=w> </span><span class=o>*</span><span class=n>outparams</span><span class=p>)</span>
<span class=p>{</span>
<span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>outparams</span><span class=o>-&gt;</span><span class=n>key</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nb>NULL</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>outparams</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=s>&quot;provider.name&quot;</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>            </span><span class=n>param_set_string</span><span class=p>(</span><span class=n>outparams</span><span class=p>,</span><span class=w> </span><span class=s>&quot;OPENSSL_FIPS&quot;</span><span class=p>);</span>
<span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>outparams</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=s>&quot;provider.build&quot;</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>            </span><span class=n>param_set_string</span><span class=p>(</span><span class=n>outparams</span><span class=p>,</span><span class=w> </span><span class=n>OSSL_FIPS_PROV_BUILD_STRING</span><span class=p>);</span>
<span class=w>        </span><span class=p>}</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>OSSL_DISPATCH</span><span class=w> </span><span class=n>provider_dispatch</span><span class=p>[]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>OSSL_FUNC_PROVIDER_QUERY_OPERATION</span><span class=p>,</span><span class=w> </span><span class=n>fips_query_operation</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>OSSL_FUNC_PROVIDER_GET_PARAMS</span><span class=p>,</span><span class=w> </span><span class=n>fips_get_params</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>OSSL_FUNC_PROVIDER_STATUS</span><span class=p>,</span><span class=w> </span><span class=n>fips_get_status</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>OSSL_FUNC_PROVIDER_TEARDOWN</span><span class=p>,</span><span class=w> </span><span class=n>fips_teardown</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>{</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=w> </span><span class=p>}</span>
<span class=p>};</span>
<span class=k>static</span><span class=w> </span><span class=n>core_put_error_fn</span><span class=w> </span><span class=o>*</span><span class=n>core_put_error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>NULL</span><span class=p>;</span>
<span class=k>static</span><span class=w> </span><span class=n>core_get_params_fn</span><span class=w> </span><span class=o>*</span><span class=n>core_get_params</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>NULL</span><span class=p>;</span>

<span class=kt>int</span><span class=w> </span><span class=nf>OSSL_provider_init</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>OSSL_PROVIDER</span><span class=w> </span><span class=o>*</span><span class=n>provider</span><span class=p>,</span>
<span class=w>                       </span><span class=k>const</span><span class=w> </span><span class=n>OSSL_DISPATCH</span><span class=w> </span><span class=o>*</span><span class=n>in</span><span class=p>,</span>
<span class=w>                       </span><span class=k>const</span><span class=w> </span><span class=n>OSSL_DISPATCH</span><span class=w> </span><span class=o>**</span><span class=n>out</span>
<span class=w>                       </span><span class=kt>void</span><span class=w> </span><span class=o>**</span><span class=n>provider_ctx</span><span class=p>)</span>
<span class=p>{</span>
<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>ret</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>

<span class=w>    </span><span class=cm>/*</span>
<span class=cm>     * Start with collecting the functions provided by the core</span>
<span class=cm>     * (we could write it more elegantly, but ...)</span>
<span class=cm>     */</span>
<span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>in</span><span class=o>-&gt;</span><span class=n>func_num</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>        </span><span class=k>switch</span><span class=w> </span><span class=p>(</span><span class=n>in</span><span class=o>-&gt;</span><span class=n>func_num</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>        </span><span class=k>case</span><span class=w> </span><span class=no>OSSL_FUNC_ERR_PUT_ERROR</span><span class=p>:</span>
<span class=w>            </span><span class=n>core_put_error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>in</span><span class=o>-&gt;</span><span class=n>func</span><span class=p>;</span>
<span class=w>            </span><span class=k>break</span><span class=p>;</span>
<span class=w>        </span><span class=k>case</span><span class=w> </span><span class=no>OSSL_FUNC_GET_PARAMS</span><span class=p>:</span>
<span class=w>            </span><span class=n>core_get_params</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>in</span><span class=o>-&gt;</span><span class=n>func</span><span class=p>;</span>
<span class=w>            </span><span class=n>Break</span><span class=p>;</span>
<span class=w>        </span><span class=p>}</span>
<span class=w>        </span><span class=n>in</span><span class=o>++</span><span class=p>;</span>
<span class=w>    </span><span class=p>}</span>

<span class=w>    </span><span class=cm>/* Get all parameters required for self tests */</span>
<span class=w>    </span><span class=p>{</span>
<span class=w>        </span><span class=cm>/*</span>
<span class=cm>         * All these parameters come from a configuration saying this:</span>
<span class=cm>         *</span>
<span class=cm>         * [provider]</span>
<span class=cm>         * selftest_i = 4</span>
<span class=cm>         * selftest_path = &quot;foo&quot;</span>
<span class=cm>         * selftest_bool = true</span>
<span class=cm>         * selftest_name = &quot;bar&quot;</span>
<span class=cm>         */</span>
<span class=w>        </span><span class=n>OSSL_PARAM</span><span class=w> </span><span class=n>selftest_params</span><span class=p>[]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span>
<span class=w>            </span><span class=p>{</span><span class=w> </span><span class=s>&quot;provider.selftest_i&quot;</span><span class=p>,</span><span class=w> </span><span class=n>OSSL_PARAM_NUMBER</span><span class=p>,</span>
<span class=w>              </span><span class=o>&amp;</span><span class=n>selftest_i</span><span class=p>,</span><span class=w> </span><span class=k>sizeof</span><span class=p>(</span><span class=n>selftest_i</span><span class=p>),</span><span class=w> </span><span class=nb>NULL</span><span class=w> </span><span class=p>},</span>
<span class=w>            </span><span class=p>{</span><span class=w> </span><span class=s>&quot;provider.selftest_path&quot;</span><span class=p>,</span><span class=w> </span><span class=n>OSSL_PARAM_STRING</span><span class=p>,</span>
<span class=w>              </span><span class=o>&amp;</span><span class=n>selftest_path</span><span class=p>,</span><span class=w> </span><span class=k>sizeof</span><span class=p>(</span><span class=n>selftest_path</span><span class=p>),</span><span class=w> </span><span class=o>&amp;</span><span class=n>selftest_path_ln</span><span class=w> </span><span class=p>},</span>
<span class=w>            </span><span class=p>{</span><span class=w> </span><span class=s>&quot;provider.selftest_bool&quot;</span><span class=p>,</span><span class=w> </span><span class=n>OSSL_PARAM_BOOLEAN</span><span class=p>,</span>
<span class=w>              </span><span class=o>&amp;</span><span class=n>selftest_bool</span><span class=p>,</span><span class=w> </span><span class=k>sizeof</span><span class=p>(</span><span class=n>selftest_bool</span><span class=p>),</span><span class=w> </span><span class=nb>NULL</span><span class=w> </span><span class=p>},</span>
<span class=w>            </span><span class=p>{</span><span class=w> </span><span class=s>&quot;provider.selftest_name&quot;</span><span class=p>,</span><span class=w> </span><span class=n>OSSL_PARAM_STRING</span><span class=p>,</span>
<span class=w>              </span><span class=o>&amp;</span><span class=n>selftest_name</span><span class=p>,</span><span class=w> </span><span class=k>sizeof</span><span class=p>(</span><span class=n>selftest_name</span><span class=p>),</span><span class=w> </span><span class=o>&amp;</span><span class=n>selftest_name_ln</span><span class=w> </span><span class=p>},</span>
<span class=w>            </span><span class=p>{</span><span class=w> </span><span class=nb>NULL</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=w> </span><span class=p>}</span>
<span class=w>        </span><span class=p>}</span>
<span class=w>        </span><span class=n>core_get_params</span><span class=p>(</span><span class=n>provider</span><span class=p>,</span><span class=w> </span><span class=n>selftest_params</span><span class=p>);</span>
<span class=w>    </span><span class=p>}</span>

<span class=w>    </span><span class=cm>/* Perform the FIPS self test - only return params if it succeeds. */</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>OSSL_FIPS_self_test</span><span class=p>())</span><span class=w> </span><span class=p>{</span>
<span class=w>        </span><span class=o>*</span><span class=n>out</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>provider_dispatch</span><span class=p>;</span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=mi>1</span><span class=p>;</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h3 id=algorithm-selection>Algorithm Selection<a class=headerlink href=#algorithm-selection title="Permanent link">&para;</a></h3><p>Multiple providers may be available at any one time. Existing application code re-compiled for this version should continue to work. At the same time it should be possible with minor code adjustments to be able to find and use algorithms using the new property based algorithm lookup capability.</p><p>To illustrate how this might work, the code below is an example of how a simple AES-CBC-128 encryption might be done using OpenSSL 1.1.1. All error handling has been stripped out for simplicity.</p><div class=highlight><pre><span></span><code><span class=n>EVP_CIPHER_CTX</span><span class=w> </span><span class=o>*</span><span class=n>ctx</span><span class=p>;</span>
<span class=n>EVP_CIPHER</span><span class=w> </span><span class=o>*</span><span class=n>ciph</span><span class=p>;</span>

<span class=n>ctx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EVP_CIPHER_CTX_new</span><span class=p>();</span>
<span class=n>ciph</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EVP_aes_128_cbc</span><span class=p>();</span>
<span class=n>EVP_EncryptInit_ex</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ciph</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=p>,</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>iv</span><span class=p>);</span>
<span class=n>EVP_EncryptUpdate</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ciphertext</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>clen</span><span class=p>,</span><span class=w> </span><span class=n>plaintext</span><span class=p>,</span><span class=w> </span><span class=n>plen</span><span class=p>);</span>
<span class=n>EVP_EncryptFinal_ex</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ciphertext</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>clen</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>clentmp</span><span class=p>);</span>
<span class=n>clen</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>clentmp</span><span class=p>;</span>

<span class=n>EVP_CIPHER_CTX_free</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span>
</code></pre></div><p>In OpenSSL 3.0, such code would continue to work and would use algorithms from a provider (assuming nothing else has been configured, it will be the default provider). It could also be rewritten using explicit fetching as follows. Explicit fetching also enables the application to specify a non-default library context if required (<code>osslctx</code> in this example):</p><div class=highlight><pre><span></span><code><span class=n>EVP_CIPHER_CTX</span><span class=w> </span><span class=o>*</span><span class=n>ctx</span><span class=p>;</span>
<span class=n>EVP_CIPHER</span><span class=w> </span><span class=o>*</span><span class=n>ciph</span><span class=p>;</span>

<span class=n>ctx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EVP_CIPHER_CTX_new</span><span class=p>();</span>
<span class=n>ciph</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EVP_CIPHER_fetch</span><span class=p>(</span><span class=n>osslctx</span><span class=p>,</span><span class=w> </span><span class=s>&quot;aes-128-cbc&quot;</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=p>);</span><span class=w>                </span><span class=cm>/* &lt;=== */</span>
<span class=n>EVP_EncryptInit_ex</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ciph</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=p>,</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>iv</span><span class=p>);</span>
<span class=n>EVP_EncryptUpdate</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ciphertext</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>clen</span><span class=p>,</span><span class=w> </span><span class=n>plaintext</span><span class=p>,</span><span class=w> </span><span class=n>plen</span><span class=p>);</span>
<span class=n>EVP_EncryptFinal_ex</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ciphertext</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>clen</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>clentmp</span><span class=p>);</span>
<span class=n>clen</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>clentmp</span><span class=p>;</span>

<span class=n>EVP_CIPHER_CTX_free</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span>
<span class=n>EVP_CIPHER_free</span><span class=p>(</span><span class=n>ciph</span><span class=p>);</span><span class=w>                                                </span><span class=cm>/* &lt;=== */</span>
</code></pre></div><p>An application may wish to use algorithms from a different provider.</p><p>For example, consider the scenario where an application wishes to use some algorithms from the FIPS provider, but still use the default algorithms in certain cases. This could be implemented in different ways, e.g.</p><ol><li>Only use FIPS algorithms.</li><li>Default to using FIPS algorithms. Be able to override it on an "as needed" basis to get access to a non FIPS algorithm.</li><li>Default to not caring about FIPS algorithms. Be able to override it on an "as needed" basis to get a FIPS algorithm.</li></ol><h4 id=only-fips>Only FIPS<a class=headerlink href=#only-fips title="Permanent link">&para;</a></h4><p>Compared to code written for pre-3.0.0 OpenSSL, all you need to do to only get FIPS implementations is something like this:</p><div class=highlight><pre><span></span><code><span class=kt>int</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
<span class=w>    </span><span class=n>EVP_set_default_alg_properties</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span><span class=w> </span><span class=s>&quot;fips=yes&quot;</span><span class=p>);</span><span class=w>                 </span><span class=cm>/* &lt;=== */</span>
<span class=w>    </span><span class=p>...</span>
<span class=p>}</span>
</code></pre></div><p>Then the above encryption code that uses <code>EVP_aes_128_cbc()</code>would continue to work as before. The <code>EVP_EncryptInit_ex()</code> call would use those default algorithm properties, and then look it up via the Core in order to get a handle to the FIPS implementation. This implementation would then be associated with the <code>EVP_CIPHER_CTX</code> object. If there isn't a suitable algorithm implementation available then the the <code>EVP_Encrypt_init_ex()</code> call will fail.</p><p>The first parameter to <code>EVP_set_default_alg_properties</code> is the library context, NULL being the default internal one.</p><h4 id=default-to-fips-but-allow-an-override>Default to FIPS but allow an override<a class=headerlink href=#default-to-fips-but-allow-an-override title="Permanent link">&para;</a></h4><p>To default to using FIPS algorithms but override it on an <em>as needed</em> basis to non-FIPS algorithms, the application might instead do this, compared to code written for pre-3.0.0 OpenSSL:</p><div class=highlight><pre><span></span><code><span class=kt>int</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
<span class=w>    </span><span class=n>EVP_set_default_alg_properties</span><span class=p>(</span><span class=n>osslctx</span><span class=p>,</span><span class=w> </span><span class=s>&quot;fips=yes&quot;</span><span class=p>);</span><span class=w>              </span><span class=cm>/* &lt;=== */</span>
<span class=w>    </span><span class=p>...</span>
<span class=p>}</span>

<span class=n>EVP_CIPHER_CTX</span><span class=w> </span><span class=o>*</span><span class=n>ctx</span><span class=p>;</span>
<span class=n>EVP_CIPHER</span><span class=w> </span><span class=o>*</span><span class=n>ciph</span><span class=p>;</span>

<span class=n>ctx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EVP_CIPHER_CTX_new</span><span class=p>();</span>
<span class=n>ciph</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EVP_CIPHER_fetch</span><span class=p>(</span><span class=n>osslctx</span><span class=p>,</span><span class=w> </span><span class=s>&quot;aes-128-cbc&quot;</span><span class=p>,</span><span class=w> </span><span class=s>&quot;fips!=yes&quot;</span><span class=p>);</span><span class=w>         </span><span class=cm>/* &lt;=== */</span>
<span class=n>EVP_EncryptInit_ex</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ciph</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=p>,</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>iv</span><span class=p>);</span>
<span class=n>EVP_EncryptUpdate</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ciphertext</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>clen</span><span class=p>,</span><span class=w> </span><span class=n>plaintext</span><span class=p>,</span><span class=w> </span><span class=n>plen</span><span class=p>);</span>
<span class=n>EVP_EncryptFinal_ex</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ciphertext</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>clen</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>clentmp</span><span class=p>);</span>
<span class=n>clen</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>clentmp</span><span class=p>;</span>

<span class=n>EVP_CIPHER_CTX_free</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span>
<span class=n>EVP_CIPHER_free</span><span class=p>(</span><span class=n>ciph</span><span class=p>);</span><span class=w>                                                </span><span class=cm>/* &lt;=== */</span>
</code></pre></div><p>Here the <code>EVP_CIPHER_fetch()</code> call would combine properties from:</p><ol><li>The default algorithm properties</li><li>The properties passed in as a parameter (with the passed in properties taking precedence).</li></ol><p>Because the <code>EVP_CIPHER_fetch()</code> call overrides the default "fips" property it will look for an implementation of AES-CBC-128 that is not "fips".</p><p>In this example, we see a non-default library context being used. This is only possible with explicitly fetched implementations.</p><p>(note for the attentive: <code>"fips!=yes"</code> could as well be <code>"fips=no"</code>, but is provided here as an example of the "not equal to" operator)</p><h4 id=default-to-not-caring-and-allow-override-for-fips>Default to not caring and allow override for FIPS<a class=headerlink href=#default-to-not-caring-and-allow-override-for-fips title="Permanent link">&para;</a></h4><p>To default to not using FIPS algorithms but override it on an <em>as needed</em> basis to use FIPS, the application code might look like this, compared to code written for pre-3.0.0 OpenSSL:</p><div class=highlight><pre><span></span><code><span class=n>EVP_CIPHER_CTX</span><span class=w> </span><span class=o>*</span><span class=n>ctx</span><span class=p>;</span>
<span class=n>EVP_CIPHER</span><span class=w> </span><span class=o>*</span><span class=n>ciph</span><span class=p>;</span>

<span class=n>ctx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EVP_CIPHER_CTX_new</span><span class=p>();</span>
<span class=n>ciph</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EVP_CIPHER_fetch</span><span class=p>(</span><span class=n>osslctx</span><span class=p>,</span><span class=w> </span><span class=s>&quot;aes-128-cbc&quot;</span><span class=p>,</span><span class=w> </span><span class=s>&quot;fips=yes&quot;</span><span class=p>);</span><span class=w>          </span><span class=cm>/* &lt;=== */</span>
<span class=n>EVP_EncryptInit_ex</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ciph</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=p>,</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>iv</span><span class=p>);</span>
<span class=n>EVP_EncryptUpdate</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ciphertext</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>clen</span><span class=p>,</span><span class=w> </span><span class=n>plaintext</span><span class=p>,</span><span class=w> </span><span class=n>plen</span><span class=p>);</span>
<span class=n>EVP_EncryptFinal_ex</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ciphertext</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>clen</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>clentmp</span><span class=p>);</span>
<span class=n>clen</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>clentmp</span><span class=p>;</span>

<span class=n>EVP_CIPHER_CTX_free</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span>
<span class=n>EVP_CIPHER_free</span><span class=p>(</span><span class=n>ciph</span><span class=p>);</span><span class=w>                                                </span><span class=cm>/* &lt;=== */</span>
</code></pre></div><p>In this version we have not overridden the default algorithm properties in "main", and therefore you get the standard out-of-the-box defaults which are to not mandate the use of FIPS. However we've explicitly set the "fips" property at the <code>EVP_CIPHER_fetch()</code> level, and so that overrides the default. When <code>EVP_CIPHER_fetch()</code> looks up the algorithm using the Core it will get a reference to the FIPS one (or fail if no such algorithm is available).</p><h4 id=asymmetric-algorithm-selection>Asymmetric algorithm selection<a class=headerlink href=#asymmetric-algorithm-selection title="Permanent link">&para;</a></h4><p>Note that for symmetric encryption/decryption and for message digests there are existing OpenSSL objects that can be used to represent an algorithm, i.e. <code>EVP_CIPHER</code> and <code>EVP_MD</code>. For asymmetric algorithms there is no equivalent object. The algorithm in use is inferred implicitly from the type of the <code>EVP_PKEY</code>.</p><p>In order to solve this problem a new asymmetric algorithm object will be introduced. In the example below an ECDH key derivation is performed. We lookup a FIPS ECDH implementation (assuming we <em>know</em> that the given private key is an ECC one, of course) using a new algorithm object, <code>EVP_ASYM</code>:</p><div class=highlight><pre><span></span><code><span class=n>EVP_PKEY_CTX</span><span class=w> </span><span class=o>*</span><span class=n>pctx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EVP_PKEY_CTX_new</span><span class=p>(</span><span class=n>privkey</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=p>);</span>
<span class=n>EVP_ASYM</span><span class=w> </span><span class=o>*</span><span class=n>asym</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EVP_ASYM_fetch</span><span class=p>(</span><span class=n>osslctx</span><span class=p>,</span><span class=w> </span><span class=n>EVP_PKEY_EC</span><span class=p>,</span><span class=w> </span><span class=s>&quot;fips=yes&quot;</span><span class=p>);</span>
<span class=n>EVP_PKEY_CTX_set_alg</span><span class=p>(</span><span class=n>pctx</span><span class=p>,</span><span class=w> </span><span class=n>asym</span><span class=p>));</span>
<span class=n>EVP_PKEY_derive_init</span><span class=p>(</span><span class=n>pctx</span><span class=p>);</span>
<span class=n>EVP_PKEY_derive_set_peer</span><span class=p>(</span><span class=n>pctx</span><span class=p>,</span><span class=w> </span><span class=n>pubkey</span><span class=p>);</span>
<span class=n>EVP_PKEY_derive</span><span class=p>(</span><span class=n>pctx</span><span class=p>,</span><span class=w> </span><span class=n>out</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>outlen</span><span class=p>);</span>
<span class=n>EVP_PKEY_CTX_free</span><span class=p>(</span><span class=n>pctx</span><span class=p>);</span>
</code></pre></div><h3 id=example-dynamic-views-of-algorithm-selection>Example dynamic views of algorithm selection<a class=headerlink href=#example-dynamic-views-of-algorithm-selection title="Permanent link">&para;</a></h3><p>The sequence diagram below shows an example of how the SHA256 algorithm might be selected and invoked from the default provider.</p><p><img alt src=../images/DigestExplicit.png></p><p>Note that each EVP layer call is implemented by thin wrappers in the EVP layer, which invoke similarly named functions within the provider on an algorithm by algorithm basis. The specific provider functions to be used will be looked up in the Core Dispatcher tables via an explicit <code>EVP_MD_fetch()</code> call that specifies the message digest name as a string and any other relevant properties. The returned "md" object contains function pointers to the implementation of the algorithm in the selected provider.</p><p>The <code>EVP_MD_CTX</code> object is not passed through to the provider since we do not know whether any specific provider module is linked against libcrypto. Instead we simply pass through a black box handle (<code>void *</code> pointer), which the provider will associate with whatever structure it requires. This is allocated during an explicit <code>digestNewCtx()</code> call to the provider at the beginning of the operation, and freed at the end with a <code>digestFreeCtx()</code> call.</p><p>The next diagram shows a slightly more complex scenario, i.e. an <code>EVP_DigestSign*</code> operation using RSA and SHA256. This diagram is drawn from the perspective of libcrypto with algorithms being provided by the FIPS module. A later section will examine this scenario from the perspective of the FIPS module.</p><p><img alt src=../images/DigestSignFIPSExplicit.png></p><p>An <code>EVP_DigestSign*</code> operation is more complicated because it involves two algorithms: a signing algorithm, and a digest algorithm. In general those two algorithms may come from different providers or the same one. In the case of the FIPS module the algorithms must both come from the same FIPS module provider. The operation will fail if an attempt is made to do otherwise.</p><p>In spite of the added complexity of having two algorithms the same concepts apply as for the simpler <code>EVP_Digest*</code> operation shown in the earlier diagram. There are two contexts produced: an <code>EVP_MD_CTX</code> and an <code>EVP_PKEY_CTX</code>. Neither of these are passed through to the provider. Instead black box (<code>void *</code>) handles are created via explicit "newCtx" provider calls, and then those handles are passed through during subsequent "init", "update" and "final" operations.</p><p>The algorithms are looked up in the Core dispatch tables using explicit <code>EVP_MD_fetch()</code> and <code>EVP_ASYM_fetch()</code> calls in advance.</p><h2 id=fips-module>FIPS Module<a class=headerlink href=#fips-module title="Permanent link">&para;</a></h2><p>This is a <a href=https://csrc.nist.gov/publications/detail/fips/140/2/final>FIPS 140-2</a> validated cryptographic module. It is a <a href=#core-and-provider-design>provider</a> that contains FIPS validated/approved cryptographic algorithms only. Non FIPS algorithms will be supplied by the default provider (not the FIPS module).</p><p>The module is dynamically loadable - static linking is not supported.</p><p>The FIPS Module will itself not have a "FIPS mode". The OpenSSL that can use the FIPS provider will have a "mode" concept that is compatible with the FIPS Module 2.0.0.</p><h3 id=fips-module-version-numbering>FIPS Module Version Numbering<a class=headerlink href=#fips-module-version-numbering title="Permanent link">&para;</a></h3><p>The version will be FIPS module 3.0</p><p>Any subsequent revisions will be labelled in a similar manner to previous releases i.e 3.0.x.</p><p>For change letters or revalidations the version number of the FIPS Module will be updated to match the current version of the OpenSSL library.</p><h3 id=detection-of-changes-inside-the-fips-boundary>Detection of Changes inside the FIPS Boundary<a class=headerlink href=#detection-of-changes-inside-the-fips-boundary title="Permanent link">&para;</a></h3><p>For the sake of validation, we need to detect if any relevant source has changed.</p><p>This can be done with a script that tokenizes the C sources the same way a C preprocessor does, but that is also taught to ignore certain parts of the source:</p><ul><li>System <code>#include</code> directives.</li><li>Code that is conditioned away in FIPS mode (as described in <a href=#conditional-code>Conditional Code</a> below).</li></ul><p>(reminder: a C preprocessor can, but doesn't not have to, collapse all non-newline whitespace and leave a standard single space between every token, and comments are considered to be whitespace for this purpose)</p><p>The result of the tokenization process can then go through a checksum, which is stored in a file parallel to the source file and ultimately version controlled.</p><p>The process will be something like this (not exactly, this is a code example to show the overall process):</p><div class=highlight><pre><span></span><code><span class=w>    </span><span class=k>for</span><span class=w> </span>f<span class=w> </span><span class=k>in</span><span class=w> </span><span class=k>$(</span>FIPS_SOURCES<span class=k>)</span><span class=p>;</span><span class=w> </span><span class=k>do</span>
<span class=w>        </span>perl<span class=w> </span>./util/fips-tokenize<span class=w> </span><span class=nv>$f</span><span class=w> </span><span class=p>|</span><span class=w> </span>openssl<span class=w> </span>sha256<span class=w> </span>-r
<span class=w>    </span><span class=k>done</span><span class=w> </span><span class=p>|</span><span class=w> </span>openssl<span class=w> </span>sha256<span class=w> </span>-hex<span class=w> </span>-out<span class=w> </span>fips.checksum
</code></pre></div><p>There will also be some mechanism that alerts us of changes so we can take appropriate action. For example:</p><div class=highlight><pre><span></span><code><span class=w>    </span>git<span class=w> </span>diff<span class=w> </span>--quiet<span class=w> </span>fips.checksum<span class=w> </span><span class=o>||</span><span class=w> </span><span class=se>\</span>
<span class=w>        </span><span class=o>(</span>git<span class=w> </span>rev-parse<span class=w> </span>HEAD<span class=w> </span>&gt;<span class=w> </span>fips.commit<span class=p>;</span><span class=w> </span>scream<span class=o>)</span>
</code></pre></div><p>What <code>scream</code> should actually do is still to be determined.</p><p>Updating <code>fips.checksum</code> should happen as part of a normal <code>make update</code>, which is the usual method to change and check changes on files that are version controlled. OpenSSL's CIs already run this to see that nothing was forgotten, and breaks the build if something was changed by this command. Running <code>make update</code> is also part of the normal OpenSSL release process.</p><h4 id=how-to-react-to-a-change-of-the-signed-checksum>How to react to a change of the signed checksum<a class=headerlink href=#how-to-react-to-a-change-of-the-signed-checksum title="Permanent link">&para;</a></h4><p>In spite of <code>scream</code>, a changed checksum in our repo isn't very dramatic per se, it simply notifies us that we need to pay some extra attention to the FIPS source.</p><p>Two possibilities:</p><ol><li><em>When it's soon time for a release</em> and <code>fips.checksum</code> no longer contains the checksum from the last validated source, send the FIPS source to the lab and get the update validation process started.</li><li><em>At the same time as a release is made</em> <code>fips.checksum</code> no longer contains the checksum from the last validated source, send the FIPS source to the lab (including diff files and a change list) and get the appropriate update validation process started.</li></ol><p>The list of validated checksums will be listed <em>somewhere else</em> (to be specified later)</p><h4 id=compiling>Compiling<a class=headerlink href=#compiling title="Permanent link">&para;</a></h4><p>For each FIPS provider source file, we calculate that file's checksum and check it against the collected checksum in <code>fips.checksum</code>, and refuse to compile if there's a mismatch.</p><h3 id=fips-mode>FIPS Mode<a class=headerlink href=#fips-mode title="Permanent link">&para;</a></h3><p>The FIPS module only contains FIPS validated cryptographic algorithms. Any FIPS mode 'switching logic' will be outside the FIPS module boundary - this will be handled by the "fips" property.</p><p><a href=#conditional-code>Conditional code</a> related to FIPS mode is discussed in a separate section.</p><p>The following FIPS API's will continue to be available for application use (for consistency the same names present in 1.1.1 are used):</p><ul><li><p><code>int FIPS_mode_set(int on)</code></p><p>Ensures that "fips=yes" is set (for <code>on != 0</code>) or "fips" is unset (for <code>on == 0</code>) in the current global property setting. This will also attempt to fetch the <code>HMAC-SHA256</code> algorithm with the property "fips=yes" and ensure that it successfully returns.</p></li><li><p><code>int FIPS_mode(void)</code></p><p>Returns 1 if the current global property string contains the property "fips=yes" (or "fips"), 0 otherwise.</p><p>We could check if there is any provider available that offers a FIPS algorithm currently and handle this a little differently.</p></li><li><p><code>int FIPS_self_test(void)</code></p><p>If the <code>FIPS_mode()</code> returns true then this runs the KATs.</p><p>The integrity test will not be covered. That will be a separate function if we decide to provide it.</p><p>Returns 1 on success; 0 on failure or there being no OpenSSL FIPS provider.</p></li></ul><p>Note: these functions will only operate in the context of the OpenSSL FIPS provider - not in the context of any other FIPS provider. These are legacy, deprecated interfaces. The <code>EVP_set_default_alg_properties()</code> function(s) should be used for non-legacy configuration.</p><h3 id=roles-and-authentication>Roles and Authentication<a class=headerlink href=#roles-and-authentication title="Permanent link">&para;</a></h3><p>There are two implied roles - Cryptographic Officer (CO) and User. Both roles support all the same services. The only difference is that the CO installs the software. The module should not support user authentication (it is not required for level 1). This can all be explained in the security policy without any specific code.</p><h3 id=finite-state-model-fips-140-2-section-44>Finite State Model (FIPS 140-2 section 4.4)<a class=headerlink href=#finite-state-model-fips-140-2-section-44 title="Permanent link">&para;</a></h3><p>A state machine needs to be defined.</p><p>We will require the following:</p><ul><li>Self test states - initialisation, running, self test, error, shutdown, (and potentially post_triggered)</li><li><p>Error States - If a self test fails the module should return an error for that operation. It is permissible to try to clear the error and repeat the operation. If failure persists, the module should enter an error state. This can either be a hard error state where all cryptographic operations fail or a reduced functionality state where the failing components only return error when used.</p><p>Failing a self test can be triggered by:</p><ol><li>Continuous tests (key pair gen pairwise test (sign/verify) and random number compare test from entropy source to verify random number inputs into the DRBG are not the same).</li><li>DRBG health tests - this can be made to cause an error always just in the RNG (rather than setting a global error state)<sup id=fnref:1><a class=footnote-ref href=#fn:1>1</a></sup>.</li><li>POST Integrity test failure either at install, startup, or on demand.</li><li>POST KAT failure at startup, or on demand.</li></ol><p>An internal API will be supplied to set the failure state for the above cases.</p></li></ul><h4 id=state-machine>State Machine<a class=headerlink href=#state-machine title="Permanent link">&para;</a></h4><p>States which are not present in the state machine are shown dotted. The edges into and out of the error state are dashed to indicate that they are not expected to be traversed.</p><p><img alt src=../images/300FIPSStateMachine.png></p><p>The state model consists of these states:</p><ol><li><strong>Power Off</strong>: the FIPS module is not loaded into an application and the shared library is not in memory.</li><li><strong>Power On</strong>: the FIPS module has been loaded by an application and the shared library is in memory. Default Entry Point Constructors will be initiated.</li><li><strong>Initialisation</strong>: <code>OSSL_provider_init</code> is called.</li><li><p><strong>Integrity Check (POST Integrity)</strong>: the module checksums itself and verifies that it hasn't been inadvertently altered.</p><p>(This is run during the FIPS providers <code>OSSL_provider_init()</code>).</p></li><li><p><strong>Self Test (POST KAT)</strong>: the FIPS module is performing its POST during installation or the POST on demand from an API call.</p></li><li><strong>Running</strong>: the FIPS module is in its normal operating state. All APIs can be used and continuous testing is in force.</li><li><strong>Error</strong>: the FIPS module has entered an error state. All cryptographic APIs will return an error when called.</li><li><strong>Shutdown</strong>: the FIPS module is being terminated and unloaded from the using application.</li></ol><p>The edges between states are:</p><ol><li><strong>Power Off</strong> to <strong>Power On</strong>: this transition is performed by the operating system when loading the shared library into an application.</li><li><strong>Power On</strong> to <strong>Initialisation</strong>: this transition occurs when the shared library constructor is called.</li><li><strong>Power On</strong> to <strong>Shutdown</strong>: this transition is triggered if the constructor cannot be called or if it fails.</li><li><strong>Initialisation </strong>to <strong>Integrity Check</strong>: this transition occurs when the initialisation code has completed. The module integrity checksum is computed and compared to the expected value.</li><li><strong>Initialisation </strong>to <strong>Error</strong>: this transition is triggered if the initialisation code encounters an error before the self tests are initiated.</li><li><strong>Integrity Check</strong> to <strong>Running</strong>: this transition occurs for all startup where the integrity checks succeed after initial installation.</li><li><strong>Integrity Check</strong> to <strong>Self Test</strong>: this transition occurs during installation when the integrity checks succeed.</li><li><strong>Integrity Check</strong> to <strong>Error</strong>: this transition is triggered if the integrity check fails.</li><li><strong>Running </strong>to <strong>Shutdown</strong>: this transition occurs when the FIPS module is being finalised.</li><li><strong>Running </strong>to <strong>Error</strong>: this transition is triggered if one of the continuous tests fail.</li><li><strong>Running </strong>to <strong>Self Test</strong>: this transition is triggered by the application when it initiates the self tests manually. The integrity checks are not rerun.</li><li><strong>Self Test</strong> to <strong>Running</strong>: this transition occurs when the self tests pass.</li><li><strong>Self Test</strong> to <strong>Error</strong>: this transition is triggered if the self tests fail.</li><li><strong>Shutdown </strong>to <strong>Power Off</strong>: this transition occurs when the FIPS module is unloaded from the memory of the application.</li><li><strong>Error </strong>to <strong>Shutdown</strong>: this transition occurs when the FIPS module is being finalised.</li></ol><p>If possible, we should aim to have algorithms registered only in the running state. Any transition into the running state should allow registration / caching of cryptographic algorithms and any transition into the error or shutdown states should flush all cached algorithms from libcrypto. By taking this approach, we obviate the need to check the state in all the cryptographic factory functions. This avoids special case access for the self tests (when started manually) while denying access to external callers.</p><h3 id=services>Services<a class=headerlink href=#services title="Permanent link">&para;</a></h3><p>The FIPS module provides the following services.</p><ul><li>Show status. This returns 1 if the 'Running' state is active otherwise it returns 0.</li><li>Cryptographic services such as HMAC, SHS, Encryption. See <a href=#appendix-3-algorithms>Algorithms</a>.</li><li>Self Test (POST On Demand) - A public API FIPS_self_test() in libcrypto will be used to access this method. The method used must be the same one that is triggered during initialization. The Security Policy will state that this may only be accessed while no other cryptographic services are running.</li><li>Key Zeroization. See <a href=#cspkey-zeroization>CSP/Key Zeroization</a>.</li></ul><p>Services are only operational in the running state. Any attempts to access services in any other state will result in an error being returned. If the POST fails then any attempt to access any service should result in an error being returned.</p><h3 id=self-testing>Self Testing<a class=headerlink href=#self-testing title="Permanent link">&para;</a></h3><p>Self-testing consists of power-on self-tests (POST) and run-time tests (such as ensuring entropy isn't repeated as input to the RNG).</p><p>The POST consists of a module integrity check (which runs each time a FIPS-using application runs) as well as algorithm KATs (which can be run once at installation time).</p><p>The POST tests run during the call to the FIPS modules <code>OSSL_provider_init()</code> entry point.</p><p>In order to implement the Integrity Test and KAT in the proper order, the module needs access to the following data items:</p><ol><li>Path to the library;</li><li>HMAC-SHA256 of the library contents (or path to the file with that);</li><li>An indication that the library has been installed and the KAT has passed; and</li><li>HMAC-SHA256 of that indicator.</li></ol><p>These values will be part of the parameters that can be retrieved through the <code>OSSL_PROVIDER</code> object and associated <code>OSSL_PARAM</code> getter. A "safer" get-value function that doesn't expand environment variables, etc. will be used to fetch the values. In addition, functions to access and return the library contents (probably BIO-based by having the Core pass a select number of BIO functions in its dispatch table) will also have to be passed into the module so that it can generate its own digest of the library.</p><p>A new OpenSSL "fips" application will provide install (run the KAT and output data for the config file) and check (see if the values in the config file are valid) capabilities.</p><p>The module's Default Entry Point (DEP), the ".init" function in Linux libraries, will set a module variable (probably the state variable). This variable will be checked in the OSSL_provider_init() and, if set (which it always will be), will verify the values in the file. This two-step process meets the FIPS requirement of having the DEP ensure the tests are run, but allows us to implement the tests when the rest of the module is being initialized during normal operation.</p><p>As part of the build process the integrity checksum of the FIPS module must be saved to a file. This could be done as a script. It is just a HMAC_SHA256 of the entire FIPS module file with a known fixed key. If the library is signed then the checksum would have to be calculated after the signature is applied.</p><p>A fixed key of at least 112 bits will be embedded in the FIPS module for all HMAC integrity operation(s), this key will also be made available to the external build script.</p><p>For testing purposes all active POST tests run even if one or more of them fail.</p><h4 id=integrity-checksum-location>Integrity Checksum Location<a class=headerlink href=#integrity-checksum-location title="Permanent link">&para;</a></h4><p>The integrity checksum will be saved into a seperate file during installation. This file will be in the same location as the FIPS module itself by default, but may be configured to be in a different location.</p><h4 id=known-answer-tests>Known Answer Tests<a class=headerlink href=#known-answer-tests title="Permanent link">&para;</a></h4><p>The purpose of a KAT is to perform a health-check of the cryptographic module to identify catastrophic failures or alterations of the module between power cycles and not that the implementation is correct.</p><p>There are <a href=https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/fips140-2/fips1402ig.pdf>FIPS 140-2 IG</a>'s rules that specify that each supported algorithm (not each mode) need to be tested, and that if an algorithm is tested as a component of another test then it does not need separate tests. Here is the list of algorithms that 'need' to be tested.</p><ul><li>Cipher encrypt/decrypt<ul><li>AES_128_GCM<sup id=fnref:2><a class=footnote-ref href=#fn:2>2</a></sup></li><li>TDES_CBC</li></ul></li><li>Digests<ul><li>SHA1</li><li><em>SHA256 is required but tested elsewhere</em></li><li>SHA512</li><li>SHA3-256</li></ul></li><li>Sign/Verify tests<ul><li>DSA_2048</li><li>RSA_SHA256 (with PKCS #1 v1.5 padding)</li><li>ECDSA P256</li></ul></li><li>DRBG Health Tests for any supported DRBG mechanisms<ul><li>CTR (AES_128_CTR)</li><li>HASH - SHA256<sup id=fnref:3><a class=footnote-ref href=#fn:3>3</a></sup></li><li>HMAC - SHA256</li></ul></li><li>Derived Tests (Compute Z)<ul><li>ECDSA P256</li><li>ECDH</li></ul></li><li>KDF's<ul><li>KBKDF (HKDF for TLS)</li></ul></li></ul><p>Note: HMAC-SHA-256 is used by the integrity test, so there is no need for a seperate HMAC test.</p><h5 id=api-access>API access<a class=headerlink href=#api-access title="Permanent link">&para;</a></h5><p>In order to easily modify and change the self tests that are run - the self tests should be data driven. The POST tests are run before any methods are registered but the method tables can still be used indirectly. Lower level API's will still be required to set up keys (params, public/private) - the key loading code should be isolated in a separate function.</p><p>An init method that sets up any required dependencies for the high level functions will be required i.e. <code>set_cpuid</code> may need to be called before doing primitive calls.</p><p>API's for different types of self tests should be provided for digests, ciphers, signatures, DRBGs, KDFs, HMACs.</p><p>The parameter passed into each of these tests is KAT data.</p><h3 id=security-strength>Security Strength<a class=headerlink href=#security-strength title="Permanent link">&para;</a></h3><p><a href=https://csrc.nist.gov/publications/detail/sp/800-131a/rev-2/draft>SP 800-131A rev2</a> disallows certain algorithms and key lengths after certain dates. Security strengths are associated with these items.</p><p>Algorithms with at least 112 bits of security strength are allowed.</p><p>For signature verification, security strengths of at least 80 and below 112 are allowed for legacy purposes.</p><p>These two values could be defined and enforced in the FIPS module for keys, or it can be handled more simply in the Security Policy Document.</p><p>They could be defined by public API's that allow setting of these minimum values.</p><p>A concept of target security strength should also be added, this value would be used during key generation algorithms, which have an input target security strength parameter specified by their standards.</p><h3 id=sp800-56a-56b>SP800-56A &amp; 56B<a class=headerlink href=#sp800-56a-56b title="Permanent link">&para;</a></h3><p>These standards contain Key Agreement protocols. In order to test the protocols the following low level primitives would need to be in the cryptographic module.</p><ul><li>Compute key methods - These already exist. (e.g <code>DH_compute_key()</code>).</li><li>Key Generation - (RSA <a href=https://csrc.nist.gov/publications/detail/fips/186/4/final>FIPS 186-4</a> Keygen is currently missing).</li><li>Key Validation - (Mostly implemented).</li></ul><h4 id=fips-186-4-rsa-key-generation>FIPS 186-4 RSA Key Generation<a class=headerlink href=#fips-186-4-rsa-key-generation title="Permanent link">&para;</a></h4><ul><li><p>Initial Code for RSA key generation has been written (<a href=https://github.com/openssl/openssl/pull/6652>https://github.com/openssl/openssl/pull/6652</a>)</p><p>Outstanding work is to plumb this into the FIPS module. The OpenSSL FIPs provider will have the logic that enforces the key size limits. * A pairwise consistency test (Conditional Self Test) is required for RSA, DSA &amp; ECDSA key pair generation. As the purpose of keys is not known during key generation, <a href=https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/fips140-2/fips1402ig.pdf>FIPS 140-2 IG</a> states that the same pairwise tests can be used for both modes i.e Signatures and Encryption. * 1024 bit keys are not allowed for RSA key generation. * The Key generation algorithms have the concept of a target_security_strength. i.e- the code in key generation needs the following check for RSA for example</p><div class=highlight><pre><span></span><code><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>target_strength</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>112</span>
<span class=w>    </span><span class=o>||</span><span class=w> </span><span class=n>target_strength</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>256</span>
<span class=w>    </span><span class=o>||</span><span class=w> </span><span class=n>BN_security_bits</span><span class=p>(</span><span class=n>nbits</span><span class=p>)</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>target_strength</span><span class=p>)</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
</code></pre></div></li></ul><h4 id=dh-key-generation>DH Key Generation<a class=headerlink href=#dh-key-generation title="Permanent link">&para;</a></h4><ul><li>DH Key generation - This could possibly be broken up so that it matches the standard steps. It is currently a fairly complex monolithic function that is also used for validation.</li></ul><h4 id=key-validation>Key Validation<a class=headerlink href=#key-validation title="Permanent link">&para;</a></h4><ul><li>RSA <a href=https://csrc.nist.gov/publications/detail/sp/800-56b/rev-1/final>SP 800-56B</a> Key validation - public key, private key and key-pair checks that conform to the standard have been added to <a href=https://github.com/openssl/openssl/pull/6652>PR #6652</a>.</li><li>DH key validation checks need to be checked that they match the standard.</li><li>EC key validation matches the standards checks.</li><li>AES-XTS mode requires a tweak key check.</li></ul><p>For KAS DH Params - two types are supported:</p><ol><li><p>Approved Safe Prime groups given by the following:</p><p>(where g=2, q=(p-1)/2, priv=[1, q-1], pub=[2, p-2])</p><p>TLS: (ffdhe2048, ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192)</p><p>IKE: (modp-2048, modp-3072, modp-4096, modp-6144, modp-8192)</p><p>Only the above safe primes can be validated - any others should fail.</p><p>Safe primes can be used for security strengths of at least 112 bits. FIPS specific checks to validate the group may be required.</p></li><li><p><a href=https://csrc.nist.gov/publications/detail/fips/186/4/final>FIPS 186-4</a> param sets can be used for backwards compatibility with security strength of 112 bits only. The groups are</p><p>FB (2048, 224) &amp;</p><p>FC (2048, 256).</p><p>This requires the seed and counter to be saved for validation purposes.</p></li></ol><p>If both types need to be supported then different key validation code will be required.</p><p>The existing <code>DH_Check()</code> will require FIPS specific checks for the approved types.</p><p>Keygen is the same for both (the security strength and max bitlen of private key are inputs).</p><p>DSA = 'FFC' in <a href=https://csrc.nist.gov/publications/detail/fips/186/4/final>FIPS 186-4</a>. The DSA key generation/key validation could be reworked so that it matches the standard steps better. The key validation would benefit from this and can possibly be reused for the DH case if required.</p><h3 id=gcm-iv-generation>GCM IV Generation<a class=headerlink href=#gcm-iv-generation title="Permanent link">&para;</a></h3><p>For the FIPS module AES GCM has requirements related to unique key/IV pairs i.e.</p><ul><li>Key/IV pair's must be unique for encryption.</li><li>The IV's must be generated inside the FIPS boundary.</li><li>For TLS the counter portion of the IV must be set by the module. The module must ensure that when the counter is exhausted an error is returned.</li><li>For a given key (for any IV length) the total number of invocations of the authenticated encryption function must be less than 2^32^.</li><li>A loss of power to the module should not cause the repetition of IVs.</li></ul><p>The Random Construction method for IV generation (from <a href=https://csrc.nist.gov/publications/detail/sp/800-38d/final>SP 800-38D</a>) will be used (except for TLS which will behave the same way it currently does). The Random Construction consists of a free field (which will be NULL) and a random field which will use a DRBG that can return at least 96 bits of entropy strength. This DRBG needs to be seeded by the module.</p><p>The existing code needs to be modified so that an IV is generated if it is not set during the init() phase. The do_cipher() method can then be used to generate an iv if required..</p><div class=highlight><pre><span></span><code><span class=kt>int</span><span class=w> </span><span class=nf>aes_gcm_cipher</span><span class=p>()</span>
<span class=p>{</span>
<span class=w>    </span><span class=p>....</span>
<span class=w>    </span><span class=cm>/* old code just returned -1 if iv_set was zero */</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>gctx</span><span class=o>-&gt;</span><span class=n>iv_set</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>ctx</span><span class=o>-&gt;</span><span class=n>encrypt</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>           </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>aes_gcm_iv_generate</span><span class=p>(</span><span class=n>gctx</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>))</span>
<span class=w>               </span><span class=k>return</span><span class=w> </span><span class=mi>-1</span><span class=p>;</span>
<span class=w>           </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span>
<span class=w>               </span><span class=k>return</span><span class=w> </span><span class=mi>-1</span><span class=p>;</span>
<span class=w>           </span><span class=p>}</span>
<span class=w>        </span><span class=p>}</span>
<span class=w>    </span><span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>The generate code would look like the following:</p><div class=highlight><pre><span></span><code><span class=cp>#define AES_GCM_IV_GENERATE(gctx, offset)                   \</span>
<span class=cp>    if (!gctx-&gt;iv_set) {                                    \</span>
<span class=cp>        int sz = gctx-&gt;ivlen - offset;                      \</span>
<span class=cp>        if (sz &lt;= 0)                                        \</span>
<span class=cp>            return -1;                                      \</span>
<span class=cp>        </span><span class=cm>/* Must be at least 96 bits */</span><span class=cp>                      \</span>
<span class=cp>        if (gctx-&gt;ivlen &lt; 12)                               \</span>
<span class=cp>            return -1;                                      \</span>
<span class=cp>        </span><span class=cm>/* Use DRBG to generate random iv */</span><span class=cp>                \</span>
<span class=cp>        if (RAND_bytes(gctx-&gt;iv + offset, sz) &lt;= 0)         \</span>
<span class=cp>            return -1;                                      \</span>
<span class=cp>        gctx-&gt;iv_set = 1;                                   \</span>
<span class=cp>    }</span>
</code></pre></div><p>The generated IV can be retrieved via <code>EVP_CIPHER_CTX_iv()</code> so a ctrl id should not be needed.</p><p>Ideally in FIPS mode trying to set the GCM IV parameter would result in an error. In practice there may be some applications that still require setting of the IV, so it is recommended that this is specified as a security policy item.</p><p>The security policy would also need to state the following: (See <a href=https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/fips140-2/fips1402ig.pdf>FIPS 140-2 IG</a> A.5)</p><ul><li>When the power is lost and then restored, a new key for use with AES GCM encryption shall be established.</li><li>The total number of invocations using the same key must be less than 2^32^.</li><li>Scenario 1: IV gen is in compliance with the TLS protocol.</li><li>Scenario 2: IV gen using <a href=https://csrc.nist.gov/publications/detail/sp/800-38d/final>NIST SP 800-38D</a> (Section 8.2.2).</li></ul><h3 id=cspkey-zeroization>CSP/Key Zeroization<a class=headerlink href=#cspkey-zeroization title="Permanent link">&para;</a></h3><p>We must set all Critical Security Parameters (CSPs) to zero when they are no longer needed. This might happen at different times dependent on the context:</p><ul><li>Temporary copies of CSPs may be stack or heap allocated, and will be zeroized within the relevant function for the scope within which they are used.</li><li>Some CSPs will have a lifetime associated with an OpenSSL object such as an <code>EVP_PKEY</code>, or an <code>EVP_CIPHER_CTX</code>. In this case the CSPs will be zeroized at the point that these objects are freed. In some cases objects may be reused (e.g. an <code>EVP_CIPHER_CTX</code> can be reused for multiple encryption operations), in which case any CSPs still present in the object will be zeroized at the point that it is reinitialized for the new operation.</li><li>Some CSPs (e.g. internal DRBG state) may live for the entire time that the OpenSSL FIPS Module is loaded. In this case the state will be encapsulated within OpenSSL objects. All OpenSSL Providers (including the FIPS Module Provider) will have the ability to register an "unload" function which is to be called when OpenSSL is closed down (or the module is unloaded for any other reason). The objects containing CSPs will be freed (and hence zeroized) by this unload function.</li><li>According to <a href=https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/fips140-2/fips1402ig.pdf>FIPS 140-2 IG</a> 4.7: Cryptographic keys used by a cryptographic module ONLY to perform <a href=https://csrc.nist.gov/publications/detail/fips/140/2/final>FIPS 140-2</a> Section 4.9.1 Power-Up Tests are not considered CSPs and therefore do not need to meet the <a href=https://csrc.nist.gov/publications/detail/fips/140/2/final>FIPS 140-2</a> Section 4.7.6 zeroization requirements.</li></ul><p>The OpenSSL FIPS Module will contain its own copy of the standard <code>OPENSSL_cleanse()</code> function to perform the zeroization. This is implemented using platform specific assembler.</p><h3 id=drbg>DRBG<a class=headerlink href=#drbg title="Permanent link">&para;</a></h3><p>The following API's existed in the old FIPS module and may need to be re-added:</p><ul><li><strong>FIPS_drbg_health_check</strong>: runs the DRBG KAT tests on demand. We will need this available.</li><li><strong>FIPS_drbg_set_check_interval</strong>: sets the interval (number of generate calls) between running the DRBG KATs. This doesn't seem like it is necessary, these tests are run at power up but are not required to be run later, however this call is useful for failure testing.</li></ul><h4 id=derivation-function>Derivation Function<a class=headerlink href=#derivation-function title="Permanent link">&para;</a></h4><p>As per #2 in <a href=https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/fips140-2/fips1402ig.pdf>FIPS 140-2 IG 14.5</a>, CTR DRBG will need to support the derivation function unconditionally. With the derivation function disabled, the current code has issues reseeding. Moreover, without a derivation function, additional justification is required from the lab.</p><h4 id=test-requirements>Test Requirements<a class=headerlink href=#test-requirements title="Permanent link">&para;</a></h4><ul><li>The <code>uninstantiate()</code> needs to demonstrate that the internal state has been zeroized.</li><li>Failure testing requires a function for DRBG's to always produce the same output.</li></ul><h4 id=other-items-to-consider>Other Items to Consider<a class=headerlink href=#other-items-to-consider title="Permanent link">&para;</a></h4><p>In addition to entropy, described below, the following items need to be considered:</p><ul><li>The entropy expansion in <a href=https://csrc.nist.gov/publications/detail/sp/800-90c/draft>NIST SP 800-90C</a> 10.1.2 should be considered for implementation.</li><li>A better DRBG selection mechanism to choose between the available DRBGs.</li><li>Support for prediction resistance. I.e. attempt to collect more entropy from our sources when requested.</li><li>We need to figure out what the DRBG layer is going to look like. A fair portion of the code will need to sit inside the FIPS module. This code currently accesses EVP functionality which might not be exposed inside the module. e.g. <code>drbg_ctr_init()</code> resolves the <code>EVP_CIPHER</code> from a NID, and then sets up an <code>EVP_CIPHER_CTX</code>.</li></ul><h3 id=entropy>Entropy<a class=headerlink href=#entropy title="Permanent link">&para;</a></h3><p>For all platforms, the operating system will provide entropy. For some platforms, built in hardware random number generators can also be used, although this introduces additional justification needs.</p><p>For UNIX-like systems, one of the system calls <code>getrandom</code> or <code>getentropy</code> or the random device, <code>/dev/random</code>, will be used as entropy sources. Preference to be given to the system calls. Other strong random devices that can be used instead of <code>/dev/random</code> include: <code>/dev/srandom</code> and <code>/dev/hwrng</code>. Note, <code>/dev/urandom</code>, <code>/dev/prandom</code>, <code>/dev/wrandom</code> and <code>/dev/arandom</code> are not useable for FIPS operations without additional justification.</p><p>On Windows, <code>BCryptGenRandom</code> or <code>CryptGenRandom</code> will be used as entropy sources.</p><p>On VMS, various pieces of system status information will be used as entropy sources. Note, this will require justification and analysis to attest to the quality of the sources.</p><p>For iOS, <a href=https://developer.apple.com/documentation/security/1399291-secrandomcopybytes>SecRandomCopyBytes</a> which produces <a href=https://developer.apple.com/documentation/security/secrandomref>cryptographically secure random bytes</a>.</p><p>FIPS only allows one entropy source to be credited so the FIPS module will rely solely on the aforementioned operating system sources. Other sources, e.g. egd, hardware devices and the like, will not be used.</p><h4 id=work-to-do-to-complete-the-entropy-solution>Work to do to Complete the Entropy Solution<a class=headerlink href=#work-to-do-to-complete-the-entropy-solution title="Permanent link">&para;</a></h4><p>The DRBG health tests need to be added to the random framework so that the seed material being fed into the DRBGs is checked. The check is for no two sequential blocks of seed material being identical. The check is made after all entropy sources are coalesced together and if it fails, reseeding the DRBGs fails forever more. We get to define the block size used: 64 bits. This is a balance between the probability of accidentally receiving a duplicate block (2^-64^) and grabbing too much entropy from the operating system (since the first block is discarded). Other obvious block sizes that could be used are 128 and 256 bits.</p><p>The initial block of data must be zeroed and discarded after it is used.</p><h5 id=gcm-iv>GCM IV<a class=headerlink href=#gcm-iv title="Permanent link">&para;</a></h5><p>A recent update to <a href=https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/fips140-2/fips1402ig.pdf>FIPS 140-2 IG</a> A.5 states that justification is required if the module claims to generate a random IV for GCM. We would need to substantiate that the module can obtain the required 96 bits of entropy from the operating system. This should not be an insurmountable problem if the blocking calls to the operating system's randomness source are used and at least this amount is used as seed material for the DRBGs.</p><h3 id=fips-module-boundary>FIPS Module Boundary<a class=headerlink href=#fips-module-boundary title="Permanent link">&para;</a></h3><p>Once in a FIPS module provided algorithm, we must remain within the FIPS module for any other cryptographic operations. It would be allowed by the FIPS rules for one FIPS module to use another FIPS module. However, for the purposes of the 3.0 design we are making the simplifying assumption that we will not allow this. For example an <code>EVP_DigestSign*</code> implementation uses both a signing algorithm and digest algorithm. We will not allow one of those algorithms to come from the FIPS module, and one to come from some other provider.</p><p>All providers are assigned a unique <code>OSSL_PROVIDER</code> object when they are initialised. When the FIPS module is asked to use an algorithm it will verify that the implementation <code>OSSL_PROVIDER</code> object for that algorithm is the same as its own <code>OSSL_PROVIDER</code> object (i.e. the one that was passed to <code>OSSL_provider_init</code>). For example consider the case of an <code>EVP_DigestSign*</code> using RSA and SHA256. Both algorithms will be looked up externally to the FIPS module using the Core. The RSA signing algorithm is the first entry point and the "init" call will be passed references to the SHA256 algorithm to be used. The FIPS module implementation will check that the <code>OSSL_PROVIDER</code> object associated that the SHA256 implementation that it has been asked to use is also within the FIPS module boundary. If it is not then the "init" operation will fail. This is illustrated in the diagram below, which shows this operation from the perspective of the FIPS module.</p><p><img alt src=../images/DigestSignFIPSModulePerspective.png></p><p>Note that within the FIPS module we are using EVP concepts (EVP_MD_CTX, EVP_PKEY_CTX, etc) in order to implement this. These are <strong>copies</strong> of the EVP implementation found in libcrypto. The FIPS module is <strong>not</strong> linked against libcrypto. This is to ensure that the complete operation stays within the boundary of the FIPS module without calling code that is external to it.</p><h3 id=asn1-code>ASN.1 code<a class=headerlink href=#asn1-code title="Permanent link">&para;</a></h3><p>ASN.1 DER (distinguished encoding rules) is used to:</p><ul><li>serialize <strong>keys </strong>and <strong>parameters</strong></li><li>serialize <strong>DSA and ECDSA signatures</strong>, which consist of two values, r and s</li><li>encode the signature digest OBJECT IDENTIFIER (OID) that is placed in <strong>RSA PKCS #1 padding</strong></li><li>serialize X.509 certificates and CRLs</li><li>other PDUs, such as PKCS #7/CMS, OCSP, PKCS #12, etc.</li></ul><p>The FIPS module will not have a copy of the ASN.1 DER encoder/parser and there will be no requirement for any provider to perform ASN.1 serialization/deserialization for algorithms implemented by OpenSSL.</p><p>All ASN.1 serialization/deserialization will be performed in libcrypto, with composite-value <strong>key, parameter and signature</strong> structures crossing the Core/provider boundary as an array of items, using the public data structure defined in <a href=#appendix-2-parameter-passing>Appendix 2 - OpenSSL parameter passing</a>.</p><p>The encoded digest OIDs used for <strong>RSA PKCS #1 padding</strong> will either be pre-generated (as was done in the old FIPS module using the SHA_DATA macro) or generated on demand using a simple function that only generates encoded OIDs for the small set of digests supported by PKCS #1 padding. These digest OIDs occur in the "OID tree" under a common node. Verifying the padding will include getting the encoded OID for the expected digest and comparing the bytes with what occurs in the padding; no DER parsing/decoding is required.</p><h2 id=code-maintenance>Code Maintenance<a class=headerlink href=#code-maintenance title="Permanent link">&para;</a></h2><h3 id=source-code-structuretree-clean-up>Source code structure/tree clean-up<a class=headerlink href=#source-code-structuretree-clean-up title="Permanent link">&para;</a></h3><p>Cryptographic implementations (<code>crypto/evp/e_*.c</code> and most of <code>crypto/evp/m_*.c</code>; essentially any code that defines an <code>EVP_CIPHER</code>, <code>EVP_MD</code>, <code>EVP_PKEY_METHOD</code>, <code>EVP_MAC</code>, or <code>EVP_KDF</code>) must move out of the evp directory. They will all end up being part of one or two providers, so they should end up in a provider specific sub-tree.</p><p>There will be a new directory <code>providers/</code>, where provider specific code is moved. <code>providers/build.info</code> defines exactly what source is used in what provider module(s).</p><h3 id=shared-source-code>Shared source code<a class=headerlink href=#shared-source-code title="Permanent link">&para;</a></h3><p>The FIPS provider module and the default provider will share the same source, under different conditions, such as different include paths or different macros being defined (the latter requires added support in the build system). An example <code>build.info</code> that does this:</p><div class=highlight><pre><span></span><code>PROVIDERS=p_fips p_default

SOURCE[p_fips]=foo.c
INCLUDE[p_fips]=include/fips

SOURCE[p_default]=foo.c
INCLUDE[p_default]=include/default
</code></pre></div><p>Or, using macros:</p><div class=highlight><pre><span></span><code>PROVIDERS=p_fips p_default

SOURCE[p_fips]=foo.c
DEFINE[p_fips]=FIPS_MODE

SOURCE[p_default]=foo.c
</code></pre></div><p>Note: some keywords aren't yet part of the <code>build.info</code> language.</p><h3 id=conditional-code>Conditional Code<a class=headerlink href=#conditional-code title="Permanent link">&para;</a></h3><p>We need a consistent approach to the compile-time inclusion of FIPS-specific code, and in some cases the exclusion of code that FIPS does not permit.</p><p>Compile-time controls will be done via <code>#ifdef FIPS_MODE</code>. This ensures that all relevant files are compiled explicitly for non-FIPS or for use within the FIPS module. Since every file will be compiled twice (in the default provider, and in the FIPS module), once with each setting, there is no benefit to using a run-time if statement with constant value. (Further, a runtime setting will not always work (such as when expanding macros like BLOCK_CIPHER_custom, which create a global variable of function pointers.)</p><p>The build system will support this by building FIPS provider object files with <code>-DFIPS_MODE</code> and default provider object files, which come from the same source, without the command line define.</p><p>For runtime checks, a test for a TLS connection being in FIPS mode will be required. This can be done in a generic way by checking the property query string that is associated with a specific <code>SSL_CTX</code> or <code>SSL</code> object, to see if the "fips" property was set.</p><h2 id=fips-testing>FIPS Testing<a class=headerlink href=#fips-testing title="Permanent link">&para;</a></h2><p>The following types of tests are required:</p><ul><li>CAVS testing for CMVP validated algorithms</li><li>FIPS Test Suite that can run all FIPS module algorithms.</li><li>POST failure testing.</li></ul><p>Acumen will write applications that use libcrypto to gain access to the FIPS provider via the EVP layer.</p><p>Any special case code needed to return intermediate values (say for CAVS key generation), to display info (self test states), or change the normal flow of FIPS module code (e.g - self test failure or failing a keygen loop that supplies fixed rand values) will be controlled by embedding callbacks into the FIPS module code.</p><p>It is recommended that this callback code would be conditionally compiled into the module, since some of the values should not be returned (e.g- intermediate values in keygen are not supposed to be output by the FIPS module).</p><p>rand_bytes() will be overridden for tests that require fixed rand_bytes to be used.</p><h3 id=fips-test-callbacks>FIPS Test callbacks<a class=headerlink href=#fips-test-callbacks title="Permanent link">&para;</a></h3><p>The application can optionally supply a single callback function that can be used to process values received from the FIPS module. (Multiple callbacks could be registered if this is required).</p><p>The optional application callback would be of the form:</p><div class=highlight><pre><span></span><code><span class=k>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>fips_test_callback</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>*</span><span class=n>type</span><span class=p>,</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>arg</span><span class=p>)</span>
<span class=p>{</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>The return value can be used to control flow in special cases inside the FIPS module code.</p><p>The type is passed in from the FIPS module hook. Each different hook in the FIPS module should have a unique type. The type determines what the arg param contains (either a struct (e.g- intermediate values), a name, or int.</p><p>The callback in the FIPS module will be of the form</p><div class=highlight><pre><span></span><code><span class=n>MY_STRUCT</span><span class=w>  </span><span class=n>data</span><span class=p>;</span><span class=w>   </span><span class=cm>/* values that need to be returned to the application */</span>
<span class=n>data</span><span class=p>.</span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span>
<span class=p>.....</span>
<span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>FIPS_test_cb</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nb>NULL</span><span class=p>)</span>
<span class=w>    </span><span class=n>FIPS_test_cb</span><span class=p>(</span><span class=n>FIPS_TEST_CB_RSA_KEYGEN_GET</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>data</span><span class=p>);</span>
</code></pre></div><h3 id=post-failure-testing-and-logging>POST Failure Testing and Logging.<a class=headerlink href=#post-failure-testing-and-logging title="Permanent link">&para;</a></h3><p>In order to support the failure of multiple tests all tests will always be run without early exiting (the failure is just flagged). A failure status will be returned after all the tests have completed.</p><p>For logging or failure, the args would be:</p><div class=highlight><pre><span></span><code><span class=k>struct</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>*</span><span class=n>desc</span><span class=p>;</span>
<span class=w>    </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>*</span><span class=n>state</span><span class=p>;</span>
<span class=w>    </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>*</span><span class=n>fail_reason</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><p>Where:</p><ul><li>type is one of "post_integrity", "post_cipher", "post_digest", "post_signature", "post_drbg", ..</li><li>desc is the identifying name: e.g AES_128_CBC</li><li>state is one of</li><li>"start" - indicates the test is starting</li><li>"corrupt" - if this returns 0 then the test will fail</li><li>"pass" - indicates the test passed</li><li>"fail" - indicates the test failed</li><li>fail_reason - is the specific reason for failure (e.g- unable to read the integrity module file, or integrity checksum file.)</li></ul><h3 id=cavs-testing>CAVS Testing<a class=headerlink href=#cavs-testing title="Permanent link">&para;</a></h3><p>CAVS testing will be performed by the lab.</p><p>However each CAVS tests file could also be sampled and added to the unit tests. This would mean converting the file data of a single test into binary data inside a unit test.</p><p>(DRBG_ctr is an example that does this already).</p><p>This will ensure the following:</p><ul><li>The required interfaces will be available to the CAVS tests (some CAVS tests require access to internals, that are not normally needed).</li><li>That the algorithm works.</li><li>Coverage.</li></ul><p>We could skip doing this if there is good communication with the lab, but there may be some extra callback hooks required in the code if the labs finds missing accessors for internals.</p><h2 id=legacy>Legacy<a class=headerlink href=#legacy title="Permanent link">&para;</a></h2><h3 id=evp-to-low-level-api-bridges>EVP to low level API bridges<a class=headerlink href=#evp-to-low-level-api-bridges title="Permanent link">&para;</a></h3><p>There are places where low level API structures are assigned to an <code>EVP_PKEY</code> object. The impact on the public <code>EVP_PKEY</code> is that it will have to keep a pointer to a possible low level structure and the type of that low level structure must be known internally in <code>libcrypto</code>. Any time the <code>EVP_PKEY</code> with such a pointer is used for any computation, it must check if the low level structure has changed and convert its data to parameters that can be used with the new providers.</p><p>The exact mechanism to check if the contents of a low level structure has changed is to be determined. One possibility would be to have a dirty counter in the low level structure and a copy in the <code>EVP_PKEY</code> structure. The dirty counter gets incremented any time the low level structure is changed (functions such as <code>RSA_set0_key</code> would have to do the increment), and any time the <code>EVP_PKEY</code> is used for computations, its copy of the counter get checked against the low level dirty counter, and if they differ, the <code>EVP_PKEY</code> provider parameters get modified with data from the low level structure.</p><p>(yet another idea is to have a callback function placed in the <code>EVP_PKEY</code> by the legacy functions, which does the update of parameters if it detects that low level changes have been made)</p><h3 id=evp-method-creators>EVP method creators<a class=headerlink href=#evp-method-creators title="Permanent link">&para;</a></h3><p>There is functionality to create diverse EVP method structures in OpenSSL 1.1.x, easily found like this:</p><div class=highlight><pre><span></span><code>grep<span class=w> </span>EVP_CIPHER_meth<span class=w> </span>util/libcrypto.num
grep<span class=w> </span>EVP_MD_meth<span class=w> </span>util/libcrypto.num
grep<span class=w> </span>EVP_PKEY_meth<span class=w> </span>util/libcrypto.num
</code></pre></div><h3 id=associated-types>Associated types<a class=headerlink href=#associated-types title="Permanent link">&para;</a></h3><p>The low level APIs are fairly standalone, so all low level API types will remain unchanged apart from an added dirty flag in some of the types. Associated <code>EVP_CIPHER</code>, <code>EVP_MD</code>, <code>EVP_PKEY_METHOD</code>, <code>EVP_MAC</code>, or <code>EVP_KDF</code> instances are handled separately through the implementation of dispatch tables in the Legacy provider module (see below).</p><h2 id=legacy-provider-module>Legacy Provider Module<a class=headerlink href=#legacy-provider-module title="Permanent link">&para;</a></h2><p>Some algorithms that are considered "legacy" (an example could be IDEA) and that have current <code>EVP_CIPHER</code>, <code>EVP_MD</code>, <code>EVP_PKEY_METHOD</code>, <code>EVP_MAC</code>, or <code>EVP_KDF</code> implementations will move to a Legacy provider module rather than our default provider module.</p><p>The methods for the following algorithms will become dispatch tables in the Legacy provider module:</p><ol><li>Blowfish</li><li>CAST</li><li>DES (but not 3DES)</li><li>DSA</li><li>IDEA</li><li>MD2</li><li>MD4</li><li>MDC2</li><li>RC2</li><li>RC4</li><li>RC5</li><li>RIPEMD160</li><li>SEED</li><li>Whirlpool</li></ol><p>(note: this is not meant to be an exhaustive list, even though fairly complete <em>for the moment</em>)</p><h2 id=the-engine-api>The ENGINE API<a class=headerlink href=#the-engine-api title="Permanent link">&para;</a></h2><p>The whole ENGINE API will be deprecated and removed in the major release after this one. By then, people will have to have learned how to create provider modules instead. In the meantime, it will be transformed into a tool to help implementers to transition from an ENGINE module implementation to a provider module implementation.</p><p>Because algorithm constructors will be changed to construct dispatch tables, the ENGINE type will change into a collection of dispatch tables, and the ENGINE constructor functionality will change to collect the dispatch tables they get into the given ENGINE.</p><p>Dispatch tables registered this way will get the added property <em>engine</em> with the ENGINE identity as provider name property. That will make it possible for <code>ENGINE_by_id</code> and similar functionality to find the correct provider.</p><p>The ENGINE module entry point <code>bind_engine</code> will be replaced with the provider module entry point, and the macro <code>IMPLEMENT_DYNAMIC_BIND_FN</code> will be changed to construct such an entry point. This entry point will create a provider style ENGINE structure, call the binding function which will fill it up with dispatch tables using the same method creation functions it has always used, then register all those dispatch tables collected in the ENGINE structure just like any provider module would, using the same method setting functions as before.</p><p>As with the rest of this release, our goal is source-level compatibility.</p><p>With OpenSSL 1.1.x and older, it's possible to hook in ENGINE provided methods to be used instead of the functions built into <code>libcrypto</code>, using functions like <code>ENGINE_get_default_RSA</code> and <code>ENGINE_get_RSA</code>. The first of the two needs no modification, while the latter will be changed to create the old-style methods (such as <code>RSA_METHOD</code>) from the corresponding dispatch table attached to the engine.</p><h1 id=appendix-1-property-syntax>Appendix 1 - Property Syntax<a class=headerlink href=#appendix-1-property-syntax title="Permanent link">&para;</a></h1><p>Property definitions and queries have a well defined syntax. This section presents this in both eBNF and as railroad diagrams. Okay, almost eBNF but using regular expression extensions in places.</p><p><strong>Definition</strong></p><p><img alt src=../images/300PropDefinition.png></p><div class=highlight><pre><span></span><code>Definition
      ::= SingleDefinition ( &#39;,&#39; SingleDefinition )*

SingleDefinition
      ::= PropertyName ( &#39;=&#39; Value )?
</code></pre></div><hr><p><strong>Query</strong></p><p><img alt src=../images/300PropQuery.png></p><div class=highlight><pre><span></span><code>Query ::= SingleQuery ( &#39;,&#39; SingleQuery )*

SingleQuery
      ::= &#39;-&#39;? PropertyName
        | PropertyName ( &#39;=&#39; | &#39;!=&#39; ) Value )
</code></pre></div><hr><p><strong>Value</strong></p><p><img alt src=../images/300PropValue.png></p><div class=highlight><pre><span></span><code>Value ::= NumberLiteral
        | StringLiteral
</code></pre></div><hr><p><strong>StringLiteral</strong></p><p><img alt src=../images/300PropStringLiteral.png></p><div class=highlight><pre><span></span><code>StringLiteral
      ::= QuotedString
        | UnquotedString
</code></pre></div><hr><p><strong>QuotedString</strong><sup id=fnref:4><a class=footnote-ref href=#fn:4>4</a></sup></p><p><img alt src=../images/300PropQuotedString.png></p><div class=highlight><pre><span></span><code>QuotedString
      ::= &#39;&quot;&#39; [^&quot;]* &#39;&quot;&#39;
        | &quot;&#39;&quot; [^&#39;]* &quot;&#39;&quot;
</code></pre></div><hr><p><strong>UnquotedString</strong><sup id=fnref:5><a class=footnote-ref href=#fn:5>5</a></sup></p><p><img alt src=../images/300PropUnquotedString.png></p><div class=highlight><pre><span></span><code>UnquotedString
      ::= [^{space},]+
</code></pre></div><hr><p><strong>NumberLiteral</strong></p><p><img alt src=../images/300PropNumberLiteral.png></p><div class=highlight><pre><span></span><code>NumberLiteral
      ::= &#39;0&#39; ( [0-7]+ | &#39;x&#39; [0-9A-Fa-f]+ )
        | &#39;-&#39;? [1-9] [0-9]+
</code></pre></div><hr><p><strong>PropertyName</strong><sup id=fnref:6><a class=footnote-ref href=#fn:6>6</a></sup></p><p><img alt src=../images/300PropPropertyName.png></p><div class=highlight><pre><span></span><code>PropertyName
      ::= [A-Z] [A-Z0-9_]* ( &#39;.&#39; [A-Z] [A-Z0-9_]* )*
</code></pre></div><h1 id=appendix-2-parameter-passing>Appendix 2 - Parameter Passing<a class=headerlink href=#appendix-2-parameter-passing title="Permanent link">&para;</a></h1><p>Core or provider objects are supposed to be opaque to everything outside, and yet, we will need to be able to get parameters from them, or to pass parameters to them in a uniform way. We therefore need an intermediary non-opaque structure to support this.</p><p>The types of data passed need to remain simple:</p><ul><li>Numbers (integers of arbitrary size)</li><li>Character strings (assume UTF-8 encoding)</li><li>Octet strings (byte arrays of arbitrary size)</li></ul><p>Any parameter that's passing values to a module will need the following items:</p><ul><li>An identifier, to indicate what parameter is being passed</li><li>The type of the value (from the list above)</li><li>The size of the value</li><li>The value itself</li></ul><p>Any parameters that are used to request values <em>from</em> a module will need the following items:</p><ul><li>An identifier to indicate what is being requested</li><li>The type of the value (from the list above)</li><li>The size of the buffer</li><li>A buffer where the values get filled in</li><li>The resultant output size, to be filled in by the function we ask for parameters from</li></ul><p>These two structure are similar enough to be expressed as one and the same:</p><div class=highlight><pre><span></span><code><span class=k>typedef</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>ossl_param_st</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>*</span><span class=n>key</span><span class=p>;</span>
<span class=w>    </span><span class=kt>unsigned</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=n>data_type</span><span class=p>;</span><span class=w>    </span><span class=cm>/* declare what kind of content is sent or</span>
<span class=cm>                                   expected */</span>
<span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=o>*</span><span class=n>buffer</span><span class=p>;</span><span class=w>               </span><span class=cm>/* value being passed in</span>
<span class=cm>                                   or out */</span>
<span class=w>    </span><span class=kt>size_t</span><span class=w> </span><span class=n>buffer_size</span><span class=p>;</span><span class=w>         </span><span class=cm>/* buffer size */</span>
<span class=w>    </span><span class=kt>size_t</span><span class=w> </span><span class=o>*</span><span class=n>return_size</span><span class=p>;</span><span class=w>        </span><span class=cm>/* OPTIONAL: address to</span>
<span class=cm>                                   content size */</span>
<span class=p>}</span><span class=w> </span><span class=n>OSSL_PARAM</span><span class=p>;</span>
</code></pre></div><p>Usage examples:</p><div class=highlight><pre><span></span><code><span class=w>    </span><span class=cm>/* passing parameters to a module */</span>
<span class=w>    </span><span class=kt>unsigned</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>*</span><span class=n>rsa_n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=cm>/* memory allocation */</span>
<span class=cp>#if __BYTE_ORDER == __LITTLE_ENDIAN</span>
<span class=w>    </span><span class=kt>size_t</span><span class=w> </span><span class=n>rsa_n_size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BN_bn2lebinpad</span><span class=p>(</span><span class=n>N</span><span class=p>,</span><span class=w> </span><span class=n>rsa_n</span><span class=p>,</span><span class=w> </span><span class=n>BN_num_bytes</span><span class=p>(</span><span class=n>rsa_n</span><span class=p>));</span>
<span class=cp>#else</span>
<span class=w>    </span><span class=kt>size_t</span><span class=w> </span><span class=n>rsa_n_size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BN_bn2bin</span><span class=p>(</span><span class=n>N</span><span class=p>,</span><span class=w> </span><span class=n>rsa_n</span><span class=p>);</span>
<span class=cp>#endif</span>
<span class=w>    </span><span class=k>struct</span><span class=w> </span><span class=nc>OSSL_PARAM</span><span class=w> </span><span class=n>rsa_params</span><span class=p>[]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span>
<span class=w>        </span><span class=p>{</span><span class=w> </span><span class=n>RSA_N</span><span class=p>,</span><span class=w> </span><span class=n>OSSL_PARAM_INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>rsa_n</span><span class=p>,</span><span class=w> </span><span class=n>rsa_n_size</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=w> </span><span class=p>},</span>
<span class=w>        </span><span class=p>{</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>};</span>

<span class=w>    </span><span class=n>EVP_set_params</span><span class=p>(</span><span class=n>pkey</span><span class=p>,</span><span class=w> </span><span class=n>rsa_params</span><span class=p>);</span>

<span class=w>    </span><span class=cm>/* requesting parameters from a module */</span>
<span class=w>    </span><span class=kt>size_t</span><span class=w> </span><span class=n>rsa_n_buffer_size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BITS</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>8</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>;</span>
<span class=w>    </span><span class=kt>unsigned</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>*</span><span class=n>rsa_n_buffer</span><span class=w> </span><span class=o>=</span>
<span class=w>       </span><span class=n>OPENSSL_malloc</span><span class=p>(</span><span class=n>rsa_n_size</span><span class=p>);</span>
<span class=w>    </span><span class=kt>size_t</span><span class=w> </span><span class=n>rsa_n_size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>    </span><span class=n>OSSL_PARAM</span><span class=w> </span><span class=n>rsa_params</span><span class=p>[]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span>
<span class=w>        </span><span class=p>{</span><span class=w> </span><span class=n>RSA_N</span><span class=p>,</span><span class=w> </span><span class=n>OSSL_PARAM_INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>rsa_n_buffer</span><span class=p>,</span><span class=w> </span><span class=n>rsa_n_buffer_size</span><span class=p>,</span>
<span class=w>          </span><span class=o>&amp;</span><span class=n>rsa_n_size</span><span class=w> </span><span class=p>},</span>
<span class=w>        </span><span class=p>{</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>},</span>
<span class=w>    </span><span class=p>};</span>

<span class=w>    </span><span class=n>EVP_get_params</span><span class=p>(</span><span class=n>pkey</span><span class=p>,</span><span class=w> </span><span class=n>rsa_params</span><span class=p>);</span>

<span class=w>    </span><span class=cm>/*</span>
<span class=cm>     * Note: we could also have a ctrl functionality:</span>
<span class=cm>     * EVP_ctrl(pkey, EVP_CTRL_SET_PARAMS, rsa_params);</span>
<span class=cm>     * EVP_ctrl(pkey, EVP_CTRL_GET_PARAMS, rsa_params);</span>
<span class=cm>     *</span>
<span class=cm>     * This would allow other controls using the same API.</span>
<span class=cm>     * For added flexibility, the signature could be something like:</span>
<span class=cm>     *</span>
<span class=cm>     * int EVP_ctrl(EVP_CTX *ctx, int cmd, ...);</span>
<span class=cm>     */</span>
</code></pre></div><h2 id=data-types>Data types<a class=headerlink href=#data-types title="Permanent link">&para;</a></h2><p>This specification supports the following parameter types:</p><ul><li><code>INTEGER</code></li><li><code>UNSIGNED_INTEGER</code><ul><li>These are arbitrary length and may therefore require an arbitrarily sized buffer.</li><li>The number is stored in native form, i.e. MSB first on big endian systems and LSB first on little endian systems. This means that arbitrary native integers can be stored in the buffer, just make sure that the buffer size is correct and properly aligned.</li></ul></li><li><code>REAL</code><ul><li>These store C binary floating point values in their native format and alignment.</li></ul></li><li><code>UTF8_STRING</code><ul><li>This type of string is expected to be printable as is.</li></ul></li><li><code>OCTET_STRING</code><ul><li>When printed, this is expected to become a hexdump.</li></ul></li></ul><p>We also support pointer variants of the same types (which means that the <code>OSSL_PARAM</code> <code>buffer</code> only has to have space for a <code>void *</code>). This use is <em>fragile</em> unless the pointed at values are constant over time.</p><p>We have macros to declare the type of content in <code>data_type</code>:</p><div class=highlight><pre><span></span><code><span class=cp>#define OSSL_PARAM_INTEGER              1</span>
<span class=cp>#define OSSL_PARAM_UNSIGNED_INTEGER     2</span>
<span class=cp>#define OSSL_PARAM_UTF8_STRING          3</span>
<span class=cp>#define OSSL_PARAM_OCTET_STRING         4</span>
<span class=cm>/*</span>
<span class=cm> * This one is combined with one of the above, i.e. to get a string pointer:</span>
<span class=cm> * OSSL_PARAM_POINTER | OSSL_PARAM_UTF8_STRING</span>
<span class=cm> */</span>
<span class=cp>#define OSSL_PARAM_POINTER           0x80</span>
</code></pre></div><h2 id=implementation-details>Implementation details<a class=headerlink href=#implementation-details title="Permanent link">&para;</a></h2><h3 id=determining-the-size-of-the-buffer>Determining the size of the buffer<a class=headerlink href=#determining-the-size-of-the-buffer title="Permanent link">&para;</a></h3><p>When requesting parameter values, the caller may choose to assign <code>NULL</code> to <code>buffer</code> in one or more parameter structures. The called getter should answer such a request by filling in the size pointed at by <code>return_size</code> and return, at which point the caller can allocate appropriately sized buffers and make a second call, at which point the getter can fill in the buffer with no problem.</p><p>If the programmer wants, <code>return_size</code> could be made to point at <code>buffer_size</code> in the same <code>OSSL_PARAM</code>.</p><h2 id=uses-beyond-the-immediately-obvious>Uses beyond the immediately obvious<a class=headerlink href=#uses-beyond-the-immediately-obvious title="Permanent link">&para;</a></h2><h3 id=conf-nconf-values-as-parameters>CONF / NCONF values as parameters<a class=headerlink href=#conf-nconf-values-as-parameters title="Permanent link">&para;</a></h3><p>Configuration values are interesting to providers! And yet, just passing a CONF pointer between the Core and the provider may not be feasible, even though it's <em>currently</em> a non-opaque structure.</p><p>Another method could be to make the CONF / NCONF values into parameters, with a bit of inspiration from git config value names.</p><p>Let's start with imagining a provider configuration along the same lines as the what the current ENGINE configuration module supports:</p><div class=highlight><pre><span></span><code><span class=k>[provider_section]</span>
<span class=c1># Configure provider named &quot;foo&quot;</span>
<span class=na>foo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>foo_section</span>
<span class=c1># Configure provider named &quot;bar&quot;</span>
<span class=na>bar</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>bar_section</span>

<span class=k>[foo_section]</span>
<span class=na>provider_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>myfoo</span>
<span class=na>module_path</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>/usr/lib/openssl/providers/foo.so</span>
<span class=na>selftests</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>foo_selftest_section</span>
<span class=na>algorithms</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>RSA, DSA, DH</span>

<span class=k>[foo_selftest_section]</span>
<span class=na>doodah</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>1</span>
<span class=na>cookie</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>0</span>
</code></pre></div><p>The Core side provider structure for the provider "foo" could then answer to these requested parameter keys:</p><ul><li><code>"provider_id"</code> (value is <code>"myfoo"</code>)</li><li><code>"module_path"</code> (value is <code>"/usr/lib/openssl/providers/foo.so"</code>)</li><li><code>"selftests.doodah"</code> (value is <code>1</code>)</li><li><code>"selftests.cookie"</code> (value is <code>0</code>)</li><li><code>"algorithms"</code> (value is <code>"RSA, DSA, DH"</code>)</li></ul><p>Note that the section names themselves never appear in the parameter key, but that the key that lead to the section does instead. This is suggested because OpenSSL allows arbitrarily named section names.</p><h2 id=the-tooth-of-time>The tooth of time<a class=headerlink href=#the-tooth-of-time title="Permanent link">&para;</a></h2><p>The parameter structure defined above isn't something that's been invented on the spot. It's highly inspired from OpenVMS programming paradigms that have proven stable over time. The actual inspiring structure is called "item_list_3", which is documented here: <a href="https://support.hpe.com/hpsc/doc/public/display?docId=emr_na-c04621447">OpenVMS Programming Concepts Manual, Volume I</a></p><h1 id=appendix-3-algorithms>Appendix 3 - Algorithms<a class=headerlink href=#appendix-3-algorithms title="Permanent link">&para;</a></h1><p>The algorithms which are to be included in the FIPS module are:</p><table><tr><th colspan=2><strong>Requirement</strong></th><th><strong>Standard</strong></th><th><strong>Notes</strong></th></tr><tr><td>TDES</td><td>CBC</td><td><a href=https://csrc.nist.gov/publications/detail/fips/81/archive/1980-12-02>FIPS 81</a></td><td> Refer also to <a href=https://csrc.nist.gov/publications/detail/sp/800-67/rev-2/final>SP 800-67rev2</a>. TDES support being decryption only (from 2020) and banned (from 2025). </td></tr><tr><td></td><td>ECB</td><td><a href=https://csrc.nist.gov/publications/detail/fips/81/archive/1980-12-02>FIPS 81</a></td><td> Limits to data length imposed. Security Policy statement regarding the <a href=https://csrc.nist.gov/publications/detail/sp/800-67/rev-1/archive/2012-01-23>SP 800-67rev1</a> transition and limitations will be required. </td></tr><tr><td>AES</td><td>CBC</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-38a/final>SP 800-38A</a></td><td>All AES cipher modes supporting 128, 192 and 256 bits.</td></tr><tr><td></td><td>CBC CTS</td><td></td><td></td></tr><tr><td></td><td>CCM</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-38c/final>SP 800-38C</a></td><td></td></tr><tr><td></td><td>CFB</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-38a/final>SP 800-38A</a></td><td></td></tr><tr><td></td><td>CTR</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-38a/final>SP 800-38A</a></td><td></td></tr><tr><td></td><td>ECB</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-38a/final>SP 800-38A</a></td><td></td></tr><tr><td></td><td>GCM</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-38d/final>SP 800-38D</a></td><td></td></tr><tr><td></td><td>GMAC</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-38d/final>SP 800-38D</a></td><td></td></tr><tr><td></td><td>OFB</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-38a/final>SP 800-38A</a></td><td></td></tr><tr><td></td><td>XTS</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-38e/final>SP 800-38E</a> </td><td> See <a href=https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Module-Validation-Program/documents/fips140-2/FIPS1402IG.pdf>FIPS 140-2 I.G.</a> A.9. Needs key check added. This mode does not support 192 bits. Check added by <a href=https://github.com/openssl/openssl/pull/7120>#7120</a>. </td></tr><tr><td></td><td>KW</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-38f/final>SP 800-38F</a></td><td rowspan=2>Differences from standard but within it.</td></tr><tr><td></td><td>KWP</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-38f/final>SP 800-38F</a></td></tr><tr><td>Hash</td><td>SHA-1</td><td><a href=http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf>FIPS 180-4</a></td><td></td></tr><tr><td></td><td>SHA-2</td><td><a href=http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf>FIPS 180-4</a></td><td>224, 256, 384, 512, 512/224, 512/256.</td></tr><tr><td></td><td>SHA-3</td><td><a href=https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf>FIPS 202</a></td><td>224, 256, 384, 512.</td></tr><tr><td>HMAC</td><td>SHA-1</td><td><a href="https://www.nist.gov/publications/keyed-hash-message-authentication-code-hmac-0?pub_id=901614">FIPS 198-1</a></td><td></td></tr><tr><td></td><td>SHA-2</td><td><a href="https://www.nist.gov/publications/keyed-hash-message-authentication-code-hmac-0?pub_id=901614">FIPS 198-1</a></td><td>224, 256, 384, 512.</td></tr><tr><td></td><td>SHA-3</td><td><a href="https://www.nist.gov/publications/keyed-hash-message-authentication-code-hmac-0?pub_id=901614">FIPS 198-1</a></td><td></td></tr><tr><td>CMAC</td><td></td><td></td><td></td></tr><tr><td>GMAC</td><td></td><td></td><td></td></tr><tr><td>KMAC</td><td></td><td></td><td></td></tr><tr><td>DRBG</td><td>AES CTR</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-90a/rev-1/final>SP 800-90A</a></td><td rowspan=3> Issues with <a href=https://csrc.nist.gov/publications/detail/sp/800-90c/draft>SP 800-90C</a>. All comply with <a href=https://csrc.nist.gov/publications/detail/sp/800-90a/rev-1/final>SP 800-90A</a>. </td></tr><tr><td></td><td>Hash</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-90a/rev-1/final>SP 800-90A</a></td></tr><tr><td></td><td>HMAC</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-90a/rev-1/final>SP 800-90A</a></td></tr><tr><td>RSA</td><td></td><td><a href=https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf>FIPS 186-4</a></td><td> Refer also to <a href=https://csrc.nist.gov/publications/detail/sp/800-56b/rev-2/draft>SP 800-56B</a>. PKCS#1.5, PSS, Key pair generation. Modulus size changes. </td></tr><tr><td></td><td>Key wrap (transport)</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-56b/rev-2/draft>SP 800-56B</a></td><td>OAEP. Update to <a href=https://csrc.nist.gov/publications/detail/sp/800-56b/rev-2/draft>SP 800-56B rev-1</a> standard.</td></tr><tr><td>DH</td><td>KAS</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-56a/rev-3/final>SP 800-56A</a></td><td>Update to <a href=https://csrc.nist.gov/publications/detail/sp/800-56a/rev-3/final>SP 800-56A rev-3</a> standard.</td></tr><tr><td></td><td>KAS</td><td><a href=https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-Validation-Program/documents/keymgmt/KASVS.pdf>KASVS</a></td><td>Additional testing to meet ZZonly. CVL/KAS.</td></tr><tr><td>DSA</td><td></td><td><a href=https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf>FIPS 186-4</a></td><td>PQG generation & verification, signature generation & verification, key pair generation.</td></tr><tr><td>ECDSA</td><td></td><td><a href=https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf>FIPS 186-4</a></td><td>Key pair generation, public key generation, signature generation & verification.</td></tr><tr><td>ECC</td><td>KAS</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-56a/rev-3/final>SP 800-56A</a></td><td> B-233, 283, 409, 571; K-233, 283, 409, 571; P-224, 256, 384, 521. Update to <a href=https://csrc.nist.gov/publications/detail/sp/800-56a/rev-3/final>SP 800-56A rev-3</a> standard. </td></tr><tr><td></td><td>KAS</td><td><a href=https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-Validation-Program/documents/keymgmt/KASVS.pdf>KASVS</a></td><td>Additional testing to meet ZZonly. CVL/KAS.</td></tr><tr><td>KDF</td><td>PBKDF2</td><td><a href=https://csrc.nist.gov/publications/detail/sp/800-132/final>SP 800-132</a></td><td>Verify conformance with standards. See <a href=https://github.com/openssl/openssl/pull/6674>#6674</a>.</td></tr><tr><td></td><td>HKDF</td><td></td><td></td></tr><tr><td></td><td>SSKDF</td><td></td><td></td></tr><tr><td></td><td>SSHKDF</td><td></td><td></td></tr><tr><td></td><td>X9.42 KDF</td><td></td><td></td></tr><tr><td></td><td>X9.63 KDF</td><td></td><td></td></tr><tr><td></td><td>KBKDF</td><td></td><td></td></tr><tr><td></td><td>TLS PRF</td><td></td><td></td></tr><tr><td>TLS</td><td>PRF</td><td></td><td>For TLS 1.2 and 1.3.</td></tr></table><h1 id=notes>Notes<a class=headerlink href=#notes title="Permanent link">&para;</a></h1><div class=footnote><hr><ol><li id=fn:1><p>The output of the DRBGs are not required to be tested because of <a href=https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/fips140-2/fips1402ig.pdf>FIPS 140-2 IG</a> 9.8. However, the seed material being fed into the master DRBG still requires the RCT or stuck bit testing.&#160;<a class=footnote-backref href=#fnref:1 title="Jump back to footnote 1 in the text">&#8617;</a></p></li><li id=fn:2><p>The draft guidance has changed. The alternatives are: AES_GMAC, AES_128_CCM, AES_256_GCM and AES_256_CCM. GMAC is arguably the simplest of the three and thus might be preferable.&#160;<a class=footnote-backref href=#fnref:2 title="Jump back to footnote 2 in the text">&#8617;</a></p></li><li id=fn:3><p>Using a different digest algorithm for HASH and HMAC DRBGs would obviate the need to test the digest independently.&#160;<a class=footnote-backref href=#fnref:3 title="Jump back to footnote 3 in the text">&#8617;</a></p></li><li id=fn:4><p>Quoted strings can contain UTF-8 characters.&#160;<a class=footnote-backref href=#fnref:4 title="Jump back to footnote 4 in the text">&#8617;</a></p></li><li id=fn:5><p>Unquoted strings are passed through a lower case conversion and can only contain ASCII characters.&#160;<a class=footnote-backref href=#fnref:5 title="Jump back to footnote 5 in the text">&#8617;</a></p></li><li id=fn:6><p>Property names are case insensitive even though only upper case is depicted here.&#160;<a class=footnote-backref href=#fnref:6 title="Jump back to footnote 6 in the text">&#8617;</a></p></li></ol></div></article></div><script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script></div></main><footer class=md-footer><div class="md-footer-meta md-typeset"><div class="md-footer-meta__inner md-grid"><div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a></div></div></div></footer></div><div class=md-dialog data-md-component=dialog><div class="md-dialog__inner md-typeset"></div></div><script id=__config type=application/json>{"base": "..", "features": ["navigation.indexes", "navigation.instant", "navigation.path", "navigation.prune", "navigation.tabs", "navigation.tabs.sticky", "navigation.tracking", "search.suggest", "toc.follow"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"default": "master", "provider": "mike"}}</script><script src=../assets/javascripts/bundle.ad660dcc.min.js></script></body></html>